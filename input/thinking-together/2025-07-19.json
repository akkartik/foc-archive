[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1752950826.835019",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1753005563.000000"
        },
        "client_msg_id": "dfa12d46-5837-4809-a2c3-54061e0e0c4f",
        "text": "Watching <https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1752783700147739?thread_ts=1752395773.053399&cid=C5U3SEW6A|this> (again). I find myself wondering if this can be related to Morrison's FBP (<https:\/\/jpaulm.github.io\/fbp\/|flow based programming>), especially his \"conveyor belt\" model. It, also, underlines my feeling that there should be a strong separation between the expression of programs in human-oriented terms, vs. some kind of automatic mapping from that human-readable domain to something production engineered to run on hardware CPUs. Currently, popular programming languages try to do both at once, usually leaning on humans to express code in ways that can be optimized for hardware (based on old-fashioned 1960s biases). I think that there should be two distinct languages and some automagic tooling that transforms from one to the other. A simple example is Prolog. Someone wrote a Prolog \"engine\" in machine code (or assembler, or an ancestor of assembler, like Lisp\/Python\/Haskell\/C\/etc). Prolog code allows humans to express \"relational logic\", then maps that logic onto operations for the engine (e.g. WAM).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1752950826.835019",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1753103884.266669",
        "reply_users": [
            "UGWUJUZHT"
        ],
        "replies": [
            {
                "user": "UGWUJUZHT",
                "ts": "1753103884.266669"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "from_url": "https:\/\/www.youtube.com\/watch?v=wo84LFzx5nI",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/wo84LFzx5nI\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/wo84LFzx5nI?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen title=\"Casey Muratori – The Big OOPs: Anatomy of a Thirty-five-year Mistake – BSC 2025\"><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "id": 1,
                "original_url": "https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1752783700147739?thread_ts=1752395773.053399&amp;cid=C5U3SEW6A",
                "fallback": "YouTube Video: Casey Muratori – The Big OOPs: Anatomy of a Thirty-five-year Mistake – BSC 2025",
                "title": "Casey Muratori – The Big OOPs: Anatomy of a Thirty-five-year Mistake – BSC 2025",
                "title_link": "https:\/\/www.youtube.com\/watch?v=wo84LFzx5nI",
                "author_name": "Better Software Conference",
                "author_link": "https:\/\/www.youtube.com\/@BetterSoftwareConference",
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Xt8Y3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Watching "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1752783700147739?thread_ts=1752395773.053399&cid=C5U3SEW6A",
                                "text": "this"
                            },
                            {
                                "type": "text",
                                "text": " (again). I find myself wondering if this can be related to Morrison's FBP ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/jpaulm.github.io\/fbp\/",
                                "text": "flow based programming"
                            },
                            {
                                "type": "text",
                                "text": "), especially his \"conveyor belt\" model. It, also, underlines my feeling that there should be a strong separation between the expression of programs in human-oriented terms, vs. some kind of automatic mapping from that human-readable domain to something production engineered to run on hardware CPUs. Currently, popular programming languages try to do both at once, usually leaning on humans to express code in ways that can be optimized for hardware (based on old-fashioned 1960s biases). I think that there should be two distinct languages and some automagic tooling that transforms from one to the other. A simple example is Prolog. Someone wrote a Prolog \"engine\" in machine code (or assembler, or an ancestor of assembler, like Lisp\/Python\/Haskell\/C\/etc). Prolog code allows humans to express \"relational logic\", then maps that logic onto operations for the engine (e.g. WAM)."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]