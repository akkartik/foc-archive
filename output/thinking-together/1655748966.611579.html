<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1655748966.611579.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Personal Dynamic Media</b>
<span style="margin:2em; color:#606060">2022-06-20 11:16</span><br/>
Is it possible that in our efforts to find alternatives to imperative programming, we have failed to promulgate knowledge about how to program imperatively?<br/><br/>Back in the day, folks like Dijkstra, Hoare, Wirth, Knuth, and Naur did a lot of work on figuring out how to write imperative programs that did what they were intended to do.<br/><br/>However, nowadays, I get the impression that much of the energy being spent on making programs better is focused on alternative ways to structure programs, like object oriented design, distributed and/or parallel and/or concurrent, event driven, reactive, etc. However, most of these design disciplines still involve executing chunks of imperative code, they just involve new and different ways of deciding which imperative code runs when.<br/><br/>This may be a dull and boring idea, but is it possible that part of what we need in order to improve software is wider distribution and study of the old ways of writing correct imperative programs, so that more of the little chunks of imperative code that get executed during an object oriented or event driven program will do what they are supposed to do?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1655749902.653779"></a>
      <img src="https://avatars.slack-edge.com/2022-04-29/3447576657367_f58a6508f11105e0d0be_72.png" style="float:left"/>
      <a href="../thinking-together/1655748966.611579.html#1655749902.653779" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alex Cruise</b>
<span style="margin:2em; color:#606060">2022-06-20 11:31</span><br/>
&gt; the old ways of writing correct imperative programs<br/>Not sure how well this ever worked :wink:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1655760552.235979"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1655748966.611579.html#1655760552.235979" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-06-20 14:29</span><br/>
I notice you didn't mention functional in your list. Was that deliberate? :slightly_smiling_face: I don't think it involves chunks of imperative code, or orchestration of when each step runs.<br/><br/>Dijkstra's <em>A Discipline of Programming</em> is one of the top 10 books on my bookshelf, and highly recommended no matter what paradigm you program in.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1655760872.401939"></a>
      <img src="https://secure.gravatar.com/avatar/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1655748966.611579.html#1655760872.401939" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Personal Dynamic Media</b>
<span style="margin:2em; color:#606060">2022-06-20 14:34</span><br/>
Yes, I left out purely functional programming and logic programming on purpose, both because they are not especially popular and because it requires some twisted thinking to fit them into the viewpoint I am taking.<br/><br/>However, I would argue that mostly functional programming, like in Scheme, ML, or Clojure would still fit into this worldview of programs still containing small chunks of imperative code that need to be written correctly.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1655772886.863429"></a>
      <img src="https://avatars.slack-edge.com/2022-05-12/3510607958037_8ed439042059d9927ccd_72.jpg" style="float:left"/>
      <a href="../thinking-together/1655748966.611579.html#1655772886.863429" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ryo Hirayama</b>
<span style="margin:2em; color:#606060">2022-06-20 17:54</span><br/>
Rust does the things. To write imperative programming correctly today, we will need Rust or better.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1655790781.802479"></a>
      <img src="https://secure.gravatar.com/avatar/df13e3ce9dfc39e2f387bd3d6e87b952.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0016-72.png" style="float:left"/>
      <a href="../thinking-together/1655748966.611579.html#1655790781.802479" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jan Ruzicka</b>
<span style="margin:2em; color:#606060">2022-06-20 22:53</span><br/>
I’m not sure I agree with that bits of imperative code always get run (I mean: obviously it does; but is this a good viewpoint?).<br/><br/>However, what certainly happens in all paradigms (even functional and logic) is that inbetween “cybernetical parts” (parts that do stuff: function applications, rules, statements, message sends, …) you get to play with lexical variables containing state. These aren’t easily analyzed, even when the state is “immutable” (immutability doesn’t imply discoverability or predictability).<br/><br/>So what is needed, in my view, is better handling of lexical variables (what they contain w.r.t. cybernetic elements of the program) and their evolution through control flow (imperative control flow, but also repeated message receives / function applications). One can imagine that a better understanding of imperative programs might lead to this handling of variables and control flow, since both are present in almost all paradigms in the form they had in imperative languages (an exception I can think of is constraint-solving).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1655852114.844389"></a>
      <img src="https://secure.gravatar.com/avatar/b4cbb729a8a92d30e9e6849fc514fc4a.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1655748966.611579.html#1655852114.844389" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Yusuke Shinyama</b>
<span style="margin:2em; color:#606060">2022-06-21 15:55</span><br/>
I don't think imperative style is necessarily inherent or ideal for computer programs. It was rather born out of the limitation of early computer architectures (single ALU, single memory bus, everything has to be synchronized, etc.) When multiple operations are happening in multiple places, imperative programming will no longer be suitable. Another thing to consider is that modern software needs to take care of thousands of different conditions (hardware configurations, user preferences, access controls, GUI events, network inputs and concurrency!). In a purely imperative style, it will blow up if-thens. We somehow needed to "abstract away" those conditionals. Programming styles don't evolve in vacuum. It's constantly reacting to ever changing needs from external forces like these.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1655959279.484379"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1655748966.611579.html#1655959279.484379" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2022-06-22 21:41</span><br/>
Think about it this way.  Though an imperative, interactive, step-by-step process may be the domain of a program, it doesn't mean a language with imperative semantics is going to be a good fit for the domain.  Often the process semantics and the imperative semantics have a big mismatch, take event driven UIs as an example.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
