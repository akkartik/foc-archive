<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/0cc9260f41ff521633069f4d94782cc7.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0005-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Josh Marinacci</b>
<span style="margin:2em; color:#606060">2019-07-22 09:59</span><br/>
i get the feeling there aren’t strict separation between declarative and imperative. it’s a spectrum and real world languages fall somewhere on the spectrum
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563816121.069600"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563816121.069600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-07-22 10:22</span><br/>
It seems to me that at the conceptual level there is a clear, grammatical distinction. It’s easy to detect in code with the following test: does execution order of a series of expressions matter? If so, it’s imperative. But it also appears to me that there is a kind of “coinherence” between knowledge and imperative knowledge (to borrow the term from theology) - knowledge of what and how seem inextricably embedded in each other, though definitely distinct. I don’t know if this coinherence has any manifestation in formal logic, but wouldn’t be at all surprised to find it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563818869.075900"></a>
      <a href="../thinking-together/1563814799.068500.html#1563818869.075900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2019-07-22 11:07</span><br/>
<span style="background-color:#ccf">@Daniel Hines</span> Isn't that the distinction we already have with pure functions / side effects?<br/><br/>And anyway pure functions are abstractions too :slightly_smiling_face: You just decide to ignore the side-effects (for very good reasons).<br/><br/>We like to categorize things but in the end I think it's just about whether you work at the right level of abstraction or not.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563820318.076400"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563820318.076400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-07-22 11:31</span><br/>
Not exactly. composing map after fold and fold after map produce two very different results.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563820339.076600"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563820339.076600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-07-22 11:32</span><br/>
But in a purely declarative language, the order of expressions really doesn’t matter.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563820353.076800"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563820353.076800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-07-22 11:32</span><br/>
(Nor does the order of execution)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563820462.077000"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563820462.077000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-07-22 11:34</span><br/>
I may be wrong about order of expressions. But, most definitely, the order of execution never affects declarative languages.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563825975.077700"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563825975.077700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-07-22 13:06</span><br/>
The order in which you call map and fold "matters" not because of order of execution, but because of the dependency graph or structure. It's the same difference between an array of dictionaries and a dictionary of arrays
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563827841.078300"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563827841.078300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-07-22 13:37</span><br/>
Pure declarative languages only really exist in mathematics. In math, you have the luxury of abstracting away everything that isn't relevant to the description of some mathematical object. The order of subexpressions in a declarative sentence only matters iff you are describing a mathematical object with ordered elements. Eg, you might be describing a sequence of events that occur over time.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563827968.078700"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563827968.078700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-07-22 13:39</span><br/>
Once you take a declarative language and make it executable, then it becomes a leaky abstraction. Once you have to worry about memory consumption and execution time, once you start changing a declarative description in order to optimize performance in the underlying execution engine, then the description is no longer purely declarative.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563828087.078900"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563828087.078900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-07-22 13:41</span><br/>
&gt; you might be describing a sequence of events that occur over time<br/>You articulated precisely what I had a vague feeling about, that order may be an important language construct for efficiently communicating the idea, even if it doesn’t affect the final outcome.<br/>I’d like to point to Answer Set Programming as a pretty darn good counter example to the assertion that there are no declarative languages. The tech is still young, so some problems do require the optimization you’re describing, but many problems can be encoded completely naively, and termination is always guaranteed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563828377.079100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563828377.079100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-07-22 13:46</span><br/>
Music notation is an example of a declarative language that uses ordering of subexpressions to describe a time ordered series of events.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563828896.079500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563828896.079500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-07-22 13:54</span><br/>
Regular expressions are a very successful example of a declarative language. Regular expressons are far simpler and more abstract than the equivalent imperative program working on an array of characters. In their original "pure" form, regular expressions were used in mathematics to describe sets of strings. Perl and Unix regular expressions are less declarative than their mathematical predecessors, because you need to understand how the execution engine works, you need to execute the regex in your head, in order to understand what substring will be captured by a \(...\) subexpression, for example.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563839796.079800"></a>
      <img src="https://secure.gravatar.com/avatar/c5602bab02fb00f0c9a052ee6c220513.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563839796.079800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alan Johnson</b>
<span style="margin:2em; color:#606060">2019-07-22 16:56</span><br/>
Is there a connection between scope and imperativeness? The whole concept of introducing bindings into a scope that are accessible in subsequent statements, whether or not mutation or effects are allowed?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563839885.080000"></a>
      <img src="https://secure.gravatar.com/avatar/c5602bab02fb00f0c9a052ee6c220513.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563839885.080000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alan Johnson</b>
<span style="margin:2em; color:#606060">2019-07-22 16:58</span><br/>
Or I guess you could say outcome or validity depending on lexical order?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563839941.080200"></a>
      <img src="https://secure.gravatar.com/avatar/c5602bab02fb00f0c9a052ee6c220513.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563839941.080200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alan Johnson</b>
<span style="margin:2em; color:#606060">2019-07-22 16:59</span><br/>
If so, then musical notation is imperative for sure. Things like key signatures and dynamics could be said to be stored in scope as the piece is played
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563840284.080400"></a>
      <img src="https://secure.gravatar.com/avatar/c5602bab02fb00f0c9a052ee6c220513.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563840284.080400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alan Johnson</b>
<span style="margin:2em; color:#606060">2019-07-22 17:04</span><br/>
In a pure functional language without shadowing of identifiers, order is arguably a convention. You <em>could</em> choose to infer execution order. Shadowing is just syntactic sugar for choosing a new name.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563842307.080800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563842307.080800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-07-22 17:38</span><br/>
<span style="background-color:#ccf">@Alan Johnson</span> In Haskell, the list expression [a,b,c] produces a different result than [c,b,a], because a list is an ordered sequence of values. So the outcome depends on lexical order. This doesn't make Haskell an imperative language. But Haskell has lazy evaluation, and the order in which the subexpressions a, b and c are evaluated depends upon context, unlike in an imperative language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563842784.081000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563842784.081000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-07-22 17:46</span><br/>
The essence of imperative programming is: Mutable variables that can be modified by assignment statements; Algorithms expressed by executing statements, which have side effects, in some order, using sequential, conditional and iterative control structures.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563844907.081200"></a>
      <img src="https://secure.gravatar.com/avatar/c5602bab02fb00f0c9a052ee6c220513.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563844907.081200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alan Johnson</b>
<span style="margin:2em; color:#606060">2019-07-22 18:21</span><br/>
I guess I should specify that I mean the outcome of the elemental "sentences" of the language, not that it can define data structures with inherent order
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563845606.081500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563845606.081500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-07-22 18:33</span><br/>
<span style="background-color:#ccf">@Alan Johnson</span> said "Is there a connection between scope and imperativeness? The whole concept of introducing bindings into a scope that are accessible in subsequent statements, whether or not mutation or effects are allowed?" Scoped variables are a feature of every non-esoteric high level programming language. Even the lambda calculus has this. I would say no, you need mutable state in order to quality as an imperative language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563845701.081700"></a>
      <img src="https://secure.gravatar.com/avatar/c5602bab02fb00f0c9a052ee6c220513.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563845701.081700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alan Johnson</b>
<span style="margin:2em; color:#606060">2019-07-22 18:35</span><br/>
Prolog doesn't really have them, and I wouldn't say it's esoteric
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563845855.081900"></a>
      <img src="https://secure.gravatar.com/avatar/c5602bab02fb00f0c9a052ee6c220513.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563845855.081900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alan Johnson</b>
<span style="margin:2em; color:#606060">2019-07-22 18:37</span><br/>
For some reason, I think of the (simple) lambda calculus a bit differently from having scope, in the sense I'm thinking of. Maybe that's because it doesn't natively have statements
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563846488.082100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563846488.082100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-07-22 18:48</span><br/>
Prolog does have scoped variables, by my way of thinking. In this program:<br/><br/>  mother_child(trude, sally).<br/>  father_child(tom, sally).<br/>  father_child(tom, erica).<br/>  father_child(mike, tom).<br/>  sibling(X, Y) :- parent_child(Z, X), parent_child(Z, Y).<br/>  parent_child(X, Y) :- father_child(X, Y).<br/>  parent_child(X, Y) :- mother_child(X, Y).<br/><br/>the X, Y and Z variables have local scope in each rule they occur in, analogous to function parameters in a functional language or in the lambda calculus. Lower cased variables like tom and sally have global scope.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563848639.082400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563848639.082400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-07-22 19:23</span><br/>
<span style="background-color:#ccf">@Alan Johnson</span> The meaning of the word "variable" is different for imperative and functional programmers. I have a functional and declarative programming mindset, so for me, a variable is an immutable association between a name and a value, defined over some scope. I use the term "mutable variable" to refer to imperative variables. If I'm thinking formally, from the perspective of denotational semantics, then I think of an imperative variable as an immutable association between a name and the address of a mutable memory location. I've participated in forum threads where imperative programmers prefer to call functional variables "constants", and I notice that the Swift language documentation uses this terminology. (I think that's wrong: a constant is an expression which always has the same value, in every execution of a program. 42 is a constant.) So there is a cultural divide, where the two cultures use the same words differently. It appears we may have a different understanding of the word "scope", so maybe that's related?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563911602.276500"></a>
      <img src="https://secure.gravatar.com/avatar/c5602bab02fb00f0c9a052ee6c220513.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563911602.276500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alan Johnson</b>
<span style="margin:2em; color:#606060">2019-07-23 12:53</span><br/>
yeah, i'm not counting parameters as scope. i think there needs to be some form of abstract reference to do anything interesting at all in a programming language
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1563967626.286000"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1563967626.286000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-07-24 04:27</span><br/>
I’ve had a major paradigm shift in the last month or so. Before, I didn’t consider parameters as scope, nor closure as mutation. Now I’m starting to see that when a function rebinds its parameters, it’s modifying its environment - it’s mutating things. That’s why it’s possible to simulate mutable state with recursive functions. If you’re trying to avoid the complexity caused by mutable state, I think  any parameter bound more than once needs to be considered mutation.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564206260.346700"></a>
      <img src="https://secure.gravatar.com/avatar/c5602bab02fb00f0c9a052ee6c220513.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1563814799.068500.html#1564206260.346700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alan Johnson</b>
<span style="margin:2em; color:#606060">2019-07-26 22:44</span><br/>
i think that's true in the sense that it's more complex than when there is no rebinding, it's still significantly less complex than allowing mutation that is visible through other copies of the reference
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
