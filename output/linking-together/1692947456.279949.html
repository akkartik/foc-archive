<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1692947456.279949.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2023-08-25 00:10</span><br/>
A nice essay on programming languages, but with a message that is much more general: <a href="https://journal.infinitenegativeutility.com/leaving-haskell-behind">https://journal.infinitenegativeutility.com/leaving-haskell-behind</a><br/><br/>It's about the tension between "make better technology", "use start-of-the-art technology", and "use boring (but stable and well understood) technology". Different goals, different tools.<br/><br/>Another example I have experienced a lot: mathematics and physics. Mathematicians work on new mathematics, mathematical physicists introduce state-of-the-art mathematics into physics, and all other physicists use 100-year-old mathematics from textbooks. And each group complains about the attitude of the two others.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1693025682.673339"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../linking-together/1692947456.279949.html#1693025682.673339" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2023-08-25 21:54</span><br/>
Some excellent quotes:<br/>&gt; I would describe good Haskell code as “brittle”, and I mean that as a compliment. People tend to casually use “brittle” to mean “prone to breakage”, but in materials science what “brittle” means is that something breaks without bending: when a brittle material reaches the limits of its strength, it fractures instead of deforming. Haskell is a language where abstractions do not “bend” (or permit invalid programs) but rather “break” (fail to compile) in the face of problems.<br/>And another:<br/>&gt; I once heard it said that Haskell lets you work with functions the way Perl lets you work with strings. Lots of Haskell idioms, like monads, are perfectly expressible in other languages: Haskell just makes them feel natural, while writing a monad in many other languages feels like you have to do lots of busy-work.<br/>I wish the critique of Haskell was as good as the love expressed for it.<br/><br/>For my part, I just find that most attempts write Haskell programs ends up down theoretical rabbit holes.<br/><br/>Here's a tiny, silly example.  For illustration purposes, I wanted to write <tt>take 25 (map (^2) [0..])</tt> as:<br/><pre style="white-space:pre-wrap">do<br/>  i &lt;- [0..]<br/>  let ii = i * i<br/>  guard (i &lt; 25)<br/>  return ii</pre><br/>This is, of course, bad because it loops after producing the 25 squares.  You keep pulling off <tt>i</tt>s and keep fining that they are not longer less than 25.  It would be "neat" if we could replace <tt>guard</tt> with some sort of <tt>until</tt>.  But what sort?  Could get lost for hours.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1693073043.323009"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1692947456.279949.html#1693073043.323009" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2023-08-26 11:04</span><br/>
Haskell is the formal systems lover's dream (unless they have already moved on to something more sophisticated, such as dependent types). All code defines a formal system, but Haskell programmers love to make formal systems that are <em>about</em> the code (types etc.) Formal systems are very precise, which is great when you can certain that they match your problem. If they don't match, or if you don't know, they are an endless source of frustration. Which means that Haskell is great language if and only if your problem has already been formlized, e.g. in mathematics.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
