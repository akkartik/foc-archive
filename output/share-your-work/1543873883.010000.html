<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-03 13:51</span><br/>
Looking for comments, opinions on an idea I've been thinking about, described here : <a href="http://sdi.thoughtstorms.info/?p=1344">http://sdi.thoughtstorms.info/?p=1344</a><br/><br/>Something we could call "Assemblage Programming"<br/><br/>Does this make sense? Can anyone see anything wrong with this idea? Is there a language out there that actually works like this?<br/><br/>Finally, I'd like to build a prototype of this. But what would people recommend as the compile target? I'd quite like a very simple, prototype-based OO virtual machine. Maybe that is just Javascript. Or maybe something else. Anyone know of a good, high-level overview of what a Smalltalk or minimal OO VM architecture looks like?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543992703.030900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1543992703.030900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-12-04 22:51</span><br/>
Hi Phil - welcome and thanks for posting!<br/><br/>I find the 'network of objects' idea very useful to comprehend or design a system. One thing that comes to mind is whether this network topology is a static or dynamic structure? Also what do you think makes a pattern/assembly different from a class. Presumably you can can construct and pass all the inner objects to the class constructor. In general, I think there are some good ideas here worth exploring.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544009885.031100"></a>
      <img src="https://secure.gravatar.com/avatar/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544009885.031100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Antranig Basman</b>
<span style="margin:2em; color:#606060">2018-12-05 03:38</span><br/>
Cheers <span style="background-color:#ccf">@Phil Jones</span> I think your observation "No OO language has such an explicit concept of network or assemblage. They all stop at the level of class." is quite right and important. You could say that our system, Infusion, represents a form of "Assemblage Programming" in that it indeed allows the topology of an arbitrary-sized patch of the runtime and its connectivity to be described in a single gesture. There some docs here <a href="https://docs.fluidproject.org/infusion/development/SubcomponentDeclaration.html">https://docs.fluidproject.org/infusion/development/SubcomponentDeclaration.html</a> and a moderately chunky real-world example here - <a href="https://github.com/GPII/gpii-app/blob/master/src/main/app.js#L62">https://github.com/GPII/gpii-app/blob/master/src/main/app.js#L62</a> - would be interested to hear if this is the kind of thing you are imagining or impressions of any areas it seems to fall short. Whilst this example is mostly tree-like, we can also describe some DAGs through injection.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544013807.031300"></a>
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544013807.031300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-05 04:43</span><br/>
<span style="background-color:#ccf">@Antranig Basman</span> Yes. If I understand it, Infusion is doing something like this. In fact everyone recognises the need to talk about assemblages of objects. That's not controversial. There are dozens of "business process modelling" tools and UML tools and all kinds of similar higher-level descriptions. And, like Infusion (if I understand), there are frameworks too.<br/><br/>My issue is that there is always major friction and extra hassle when trying to depend on an external tool, or even on a framework, for good ideas that could (and I think, in this case, should) be built into the language and treated as "standard".<br/><br/>When it's in a framework, it's always an "optional" extra, it's not in the initial installer of the language, it's not taught to beginners, it's not the de-facto way that everything is done, there's no syntactic support to make it elegant so it always ends up looking clunky ... etc.<br/><br/>That's the mystery to me ... we have 40 + years of "builder" tools and frameworks to help understand and work on assemblages of objects. But almost no language designer sees how useful it would be to build into the language itself.<br/><br/>Also, I grokked this through learning Clojure and starting to work with EDN. I see that algebraic data in Haskell is even prettier. But you shouldn't have to give up OO just to get this. Some people like OO. And with Smalltalk-like OO you have something every bit as elegant and principled as the best FP languages today. BUT ... missing this capactity to talk easily about assemblages. In Smalltalk it's particularly egregious because the Class Browser, one of the wonderful elegant tools, forces you into it ... everything is about the Class and the Class hierarchy.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544014390.031600"></a>
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544014390.031600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-05 04:53</span><br/>
<span style="background-color:#ccf">@Shalabh</span> The representation I'm thinking of is designed to be static rather than dynamic. The data-structures are explicitly declared in source code rather than the result of computation.<br/><br/>That's obviously less flexible, but I'm willing to make that trade off because<br/><br/>a) I like immutability by default anyway, so I think mutability should be rare and explicit. With encouragement not to use it.<br/><br/>b) the fact we have an OR in the grammar (ie. we can say "this component of the other objects can be like this or like that) already gives us more flexibility than you'd think. The data-structure doesn't mutate at runtime but it does have several different shapes it can take.<br/><br/>c) I'm quite interested in Jonathan Edwards' "social data-types" Where data mutation IS required, I'd quite like to see higher-level declarative ways of talking about it. Eg. to be able to say in the declaration of an assemblage : "the values of this part are automatically synced with an isomorphic structure in the cloud"<br/><br/>Rather than having programmers faff around doing low level mutation, I'd like to see languages support higher level strategies of mutation.<br/><br/>In terms of constructing. You construct the entire assemblage at once. The description of the assemblage can be used to define some kind of parser of an EDN-like serialization (like in the Pong example in the blog post).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544015622.032100"></a>
      <img src="https://secure.gravatar.com/avatar/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544015622.032100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Antranig Basman</b>
<span style="margin:2em; color:#606060">2018-12-05 05:13</span><br/>
Yes, I agree that such facilities need to be parts of "languages", but the economics of development prohibit people from building such things and getting them adopted. A more favorable roadmap is to develop such systems as frameworks, gradually expand their capabilities, and progressively impoverish the host language so that it can eventually be thrown away. It's impractical to design such a scheme as a language and expect to get all of its design details correct without having access to a living community continually validating (or invalidating) its results on real problems. So whilst Infusion's current status as a framework is uncontroversial (meaning it can be adopted!), its roadmap might be less so. In terms of your static/dynamic distinction, and preference for immutability, I think we are on the same page - where it is idiomatic, we already store such definitions in static files rather than "compute" them. +1 to constructing the entire assemblage at once. Where we disagree is where you say "This isn’t meant to be changing the semantics of a running OO system" - a key goal is to collapse the distinction between run-time, design-time and compile-time.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544049553.032400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544049553.032400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-12-05 14:39</span><br/>
<span style="background-color:#ccf">@Phil Jones</span> - I see. It would be useful for me to see the contrast in the assembly idea and the class idea using the use case you picked. I completely agree that the 'wider schema gets lost'. But for the car example, I can see a Java class definition looking exactly like the pattern you have - the Car class would contain members attributes where the types define what they are and even allow alternatives via things like interfaces. The definition is scattered across files, but is it simply a matter of chasing those links down vs seeing the schema in one place? Do you think the following is the key distinction in this system:<br/>&gt; I’ve long thought that it would be useful for a language to have an explicit distinction between slots containing objects that are components “internal” to an object, and slots containing other external objects that are lent to it, or that represent things outside itself.<br/><br/>Perhaps assemblies describe how the are wired up wrt their external relationships only? There seems to be some overlap with dependency injection.  Also how does this relate to encapsulation? Can you reach an Engine if you have a Car, without the Car mediating the access?<br/><br/>I agree the low level ad hoc mutation doesn't seem to scale well and some form of managed mutation is better. Overall I feel there are few different ideas here and it would help to break these apart.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544049657.032600"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544049657.032600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-12-05 14:40</span><br/>
<span style="background-color:#ccf">@Antranig Basman</span><br/>&gt; collapse the distinction between run-time, design-time and compile-time.<br/><br/>Agree 100%. Do you think Smalltalk achieves this? This aspect seems to be orthogonal to OO semantics.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544055122.032900"></a>
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544055122.032900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-05 16:12</span><br/>
<span style="background-color:#ccf">@Shalabh</span> Yes. Imagine this was a Java-like language. Even a JVM language.<br/><br/>The end result in the "assemblage language" and in Java would be exactly the same : 10 objects of 10 different types (or classes) wired together in a particular way. The difference is just that in Java, the knowledge of how they are wired together is scattered through 10 different constructors in ten different source-files and it's a pain to keep running around and keeping track of that in your head.<br/><br/>In the assemblage language, the knowledge of how the objects are wired together is in 10 consecutive lines of code in the same place, where it's easy for the programmer to get a good overview. Or to make changes.<br/><br/>This itself is what I think is the key distinction of an assemblage language from every other OO language I've seen. (Whether Java, Smalltalk, Ruby or Python)<br/><br/>And that's what I think would be the biggest win. Just putting that schema overview in a single place and expressive form.<br/><br/>Having an explicit distinction between "internal component" and other kinds of references you're holding is a separate issue. I think it's ALSO a good idea. And I think it's extremely compatible with an assemblage language. And it's convenient to represent this distinction with sigils in the schema.<br/><br/>But it's an idea that could ALSO be implemented in a more traditional object oriented language.<br/><br/>In fact you get some of these capabilities with inner-classes and "friends" or whatever they're called in Java  and C++ etc. Not to mention public and private qualifiers. But these are too "low level". Instead of mechanisms expressing what the real world is like (eg. this is a permanent component of that, this is a temporary occupant of that, this is a context of that) you have to implement it yourself.<br/><br/>BTW : this is hardly an original idea. Literally the first new thing that the UML brings to structure modelling is two different arrows to distinguish aggregation from usage.<br/><br/>My thinking on encapsulation is that there doesn't need to be much within the assemblage. The assemblage consists of a number of classes that work well together, whose roles are defined in terms of each other, and which don't make much sense outside the assemblage. So you don't need to hide the details of one from another. If the assemblage language enforces encapsulation, the right border is between one assemblage and another. (I mention that here : <a href="http://sdi.thoughtstorms.info/?p=1351">http://sdi.thoughtstorms.info/?p=1351</a> )<br/><br/>Can you reach the engine in a car without having the car involved? In the real world, not really. There are two situations ... one is you're talking about a real engine in a real car. The other is maybe you're talking about an engine in an engine factory that hasn't been put into a car yet.<br/><br/>I think your program is going to have to know which of these two situations it's really modelling.<br/><br/>The fact you're using an Assemblage language rather than a "normal" OO language doesn't commit you one way or another.<br/><br/>In an ordinary OO language you might require that an Engine has a reference back to the Car that contains it. And, yes, you'll need a Dependency Injection strategy to make sure that happens. Or the Engine might not need a reference back to the Car that contains it. And you won't.<br/><br/>The assemblage language would be the same. Perhaps it would be a good idea to make that, itself, explicit. We might need as well as a "Component of" relationship, to be able to specify "Component of that can't exist outside the context of" relationship.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544057166.033100"></a>
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544057166.033100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-05 16:46</span><br/>
<span style="background-color:#ccf">@Antranig Basman</span> I'm not going to say you're wrong about costs, but I'd like to flag up the counter-argument : that once something moves into the language, you just get one version of it, so you don't have rival competing implementations, the way you do with frameworks. The functionality is tied into the language, so you don't get problems where the language changes and the framework is incompatible with it. Beginners learn the idea from the beginning because it's part of the language. And you don't get two groups of users of the language who have trouble with each others' code because they are used to two rival frameworks.<br/><br/>Sure I agree that frameworks managed independently of the language core give more scope for trying out new ideas without being held back by the language designers etc. But I think there's an argument that overall, when a good idea moves into the language itself, that reduces costs for everyone.<br/><br/>Think of something like garbage collection. You can do it in C++ via a library. But it's never hassle-free. Or cost-free. Whereas in Java you can basically forget about it.<br/><br/>But I'm not dissing the framework approach. And I certainly didn't intend this as a criticism of Infusion. If I wanted to get this functionality into, say, Javascript, I'd certainly do it as a library or a pre-processor, not waste my time trying to convince some committee to put it into the core.<br/><br/>I'm approaching this as someone interested in inventing new languages, so that's where I obviously see it.<br/><br/>When I said not change the underlying semantics, what I mean is that I can see that it would be possible to create an assemblage language that was like Java (ie. statically typed, very definite "compile time", etc.)<br/><br/>And I can also imagine an assemblage language in a very dynamic, live, late-bound world like Smalltalk.<br/><br/>The idea can be fitted into both.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544108136.033400"></a>
      <img src="https://secure.gravatar.com/avatar/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544108136.033400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Antranig Basman</b>
<span style="margin:2em; color:#606060">2018-12-06 06:55</span><br/>
<span style="background-color:#ccf">@Phil Jones</span> - I think we agree in practice. We both think that a language-level feature would be the ideal end - but I argue that we have insufficient knowledge about how such a language-level feature should be structured in order to justify the implementation and community costs of building it that way up front. This will be a multi-decade project and I think we can't support the costs for the community with whom the feature is being co-designed being split off from mainstream improvements/changes in VMs, tooling and general idiom for all of those decades. I don't see this as a relatively well-characterised and self-contained facility like garbage collection for which the engineering tradeoffs can be quite well described and variant implementations slotted in without disturbing the semantics of the host language too much. However, you may be interested in Stephen Kell's conception of an "Integration Domain" which perhaps promises a cross-language notion of assemblages along the lines you are considering - <a href="https://www.cs.kent.ac.uk/people/staff/srk21/research/papers/kell09mythical.pdf">https://www.cs.kent.ac.uk/people/staff/srk21/research/papers/kell09mythical.pdf</a> - he describes his "linking language" named Cake which I believe would be a good substrate for this.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544112367.033600"></a>
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544112367.033600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-06 08:06</span><br/>
<span style="background-color:#ccf">@Antranig Basman</span> We're basically in violent agreement on 90% of it. And I guess if I think it's cheap and easy enough to do, the onus is on me, not to argue, but to get on and build it :slightly_smiling_face:<br/><br/>Thanks for the link ... looks good, I'll go read it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544134503.033800"></a>
      <img src="https://secure.gravatar.com/avatar/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544134503.033800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Antranig Basman</b>
<span style="margin:2em; color:#606060">2018-12-06 14:15</span><br/>
<span style="background-color:#ccf">@Phil Jones</span> - it's possible I'm casting your "feature" as something more grandiose than you were intending - but assuming we had an "assemblage language" that could i) be superimposed on top of the semantics of existing languages, ii) function mostly as a first-class language in its own right, wouldn't we then expect that it could, as Kell is imagining, act as a runtime broker between the object models of any collection of runtimes expressed in heterogeneous languages? As you said in an earlier post, we have seen these kinds of mostly static assemblage frameworks in the previous decade in the guise of DI systems like Spring, and their "fire and forget" model, that takes no interest in the dynamic, so-called "runtime" structure of the system is largely uninteresting.<br/>Actually Kell is more grandiose about this than I can see as realistic but his implementation capability is vastly greater than mine. When I say to him, "How to you plan to 'abstract' over the fact that one of your cooperating runtimes has just thrown a bus error as a result of being asked to dereference something that the memory model of one of the others insisted was deterministically deallocated?", he just waves the question away as though it were a fly.. "that will be no problem!". For my part, I can't see that we can get to this point until we actually do away with all the languages and their runtimes entirely. The point at which Infusion, or something like it, finally casts off its host language entirely, will be the point at which such languages become largely irrelevant for general purpose developers/users and we instead "code" primarily against integration domains. There we go, two modest, easily achievable views of the future of programming :slightly_smiling_face:<br/>Interested to see anything you end up building, cheap and easy or not - cheers!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544144879.034100"></a>
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544144879.034100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-06 17:07</span><br/>
OK ... with the proviso that I haven't read Kell yet, just skimmed the first page or so, it seems to me we've always had a secondary level of management of programs, from <a href="https://en.wikipedia.org/wiki/Job_Control_Language">https://en.wikipedia.org/wiki/Job_Control_Language</a> through to all the ways we orchestrate microservices within container platforms like Kubernetes etc.<br/><br/>I certainly don't want to claim that we can or should collapse this layer down into our ordinary programming language. Or that my "assemblage language" could scale to that grandiose level.<br/><br/>I accept that there's a valid role for separate language or tool for orchestration of microservices in containers and you only want to talk about those things as black-boxes with some kind of wire-protocol and message-queue architecture between them.<br/><br/>Now I have some opinions about how those languages for higher-level orchestration or even defining continuous integration pipelines and provisioning etc. should be. I think they should be more like Prolog, based on rules rather than imperative scripts copying files around and launching / closing down nodes.<br/><br/>And being rule based they should certainly be "dynamic" eg. able to adapt and compensate when the configuration / architecture changes.<br/><br/>But they aren't the same as the object oriented languages I imagine being extended with assemblage programming.<br/><br/>Assemblages are still much closer to the kind of OO code we know and love / hate today. They're just one or two scales "up".  Instead of having a system with 1000 separate class files leading to 100000 objects of 1000 types, you now have a system of 100 separate assemblage files, leaving to 100000 objects of 1000 types.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544270148.037200"></a>
      <img src="https://secure.gravatar.com/avatar/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544270148.037200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Antranig Basman</b>
<span style="margin:2em; color:#606060">2018-12-08 03:55</span><br/>
<span style="background-color:#ccf">@Phil Jones</span> Yeah, bringing in JCL and orchestration languages is a great reference point for the discussion. +1 for Prolog-like languages based on rules rather than imperative scripts - and in fact you'll notice that this is an important part of Kell's roadmap for an integration domain expressed in sections 4.2 and 4.3 of his paper. An  integration domain is about "relations, not scripts".<br/>Whilst I share your scepticism that we can collapse this layer down into our programming language, I feel that we can't refuse to make the attempt, otherwise our discipline is a failure. Our mission is to "put the complete resources of the system at the disposal of the user", which includes all those of the orchestration layer as well as the endless integration layers beneath. But it is interesting how modern orchestration platforms such as Kubernetes are already more declaratively structured than their predecessors such as JCL, and long line of other system languages such as REXX, etc. We do note in our "Revolution" paper that the infrastructure arc of the ownability story looks like it is closing much more quickly than that of our programming languages, which hasn't even started to curve back yet.<br/>When you say, "being rule based they should certainly be 'dynamic', e.g. able to adapt and compensate when the configuration / architecture changes" I argue that this exactly the kind of admirable property we need all the way down our stack. It has huge benefits, for example, at the level of user interaction which is required to be fluid in the face of the unexpected arrival or disappearance of interaction devices or idioms.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544288729.037400"></a>
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1543873883.010000.html#1544288729.037400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-08 09:05</span><br/>
Yes. <br/><br/>100% agreed
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
