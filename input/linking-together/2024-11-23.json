[
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1732353889.440059",
        "client_msg_id": "027fd79f-ee16-4878-a9a1-33c70d9e30b4",
        "text": "Ceptre is described as a logic programming language (I didn't look into the details). Nova is a multiset rewriting system. So the two have very different foundations, even if the target application areas overlap.\n\nWryl argues that rewriting is easier to get into for newcomers (no programming experience at all) than the more popular PL paradigms, and that's the main argument for Nova in the talk. This affirmation sounds credible to me but not obviously true.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1732269124.417799",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4WNR1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ceptre is described as a logic programming language (I didn't look into the details). Nova is a multiset rewriting system. So the two have very different foundations, even if the target application areas overlap.\n\nWryl argues that rewriting is easier to get into for newcomers (no programming experience at all) than the more popular PL paradigms, and that's the main argument for Nova in the talk. This affirmation sounds credible to me but not obviously true."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1732354238.419759",
        "client_msg_id": "17d80be3-4144-4601-82b0-a707ac962c9e",
        "text": "Right, found it. But... let me rant a bit: I _hate_ this \"everyone picks their pronoun\" business. Not that I have political or philosophical objections, it sounds just fine. But in practice: how am I supposed to figure out someone's preferred pronouns? Some put them on their home page, others in their Mastodon profile, etc. In a conversation, am I supposed to stop, take out my phone, and do five minutes of search before I continue my sentence?\nLanguage is a collective property of its speaker community, so pronoun choice needs to follow agreed-on rules in that community. For nothing other than pragmatic reasons.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1732273539.863409",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MFBqI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Right, found it. But... let me rant a bit: I "
                            },
                            {
                                "type": "text",
                                "text": "hate",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " this \"everyone picks their pronoun\" business. Not that I have political or philosophical objections, it sounds just fine. But in practice: how am I supposed to figure out someone's preferred pronouns? Some put them on their home page, others in their Mastodon profile, etc. In a conversation, am I supposed to stop, take out my phone, and do five minutes of search before I continue my sentence?\nLanguage is a collective property of its speaker community, so pronoun choice needs to follow agreed-on rules in that community. For nothing other than pragmatic reasons."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1732360145.566009",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1732381103.000000"
        },
        "client_msg_id": "bb0357dc-c693-49c3-9592-eef6e92af042",
        "text": "<@UJBAJNFLK> I got interested in Ceptre for other reasons. If I strip away the haughty words, I see no technical difference between Ceptre and the technology that Wryl describes. Basically: Factbase that allows the existence of duplicate facts. A way to pattern match against the factbase. Rules that rewrite the factbase based on the results of the matches (including removal of matched facts and insertion of new facts). Looks trivial to implement in Lisp, or Prolog, or ???.  Actually, the big win is the use of a declarative syntax. Don't code actions, relegate all action-oriented details into the engine. Prolog does this. Ceptre does this. Nova does this. Martens' github contains numerous examples of games implemented this way. If interested, I can dig out some references from my notes...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1732269124.417799",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SS5Xp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " I got interested in Ceptre for other reasons. If I strip away the haughty words, I see no technical difference between Ceptre and the technology that Wryl describes. Basically: Factbase that allows the existence of duplicate facts. A way to pattern match against the factbase. Rules that rewrite the factbase based on the results of the matches (including removal of matched facts and insertion of new facts). Looks trivial to implement in Lisp, or Prolog, or ???.  Actually, the big win is the use of a declarative syntax. Don't code actions, relegate all action-oriented details into the engine. Prolog does this. Ceptre does this. Nova does this. Martens' github contains numerous examples of games implemented this way. If interested, I can dig out some references from my notes..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1732372247.529439",
        "client_msg_id": "5e138967-19f4-48e6-9a41-18796e19cfab",
        "text": "I didn't mean to police, was just offering information. In this case I actually made the same mistake a couple of months and got corrected. Hmm, I did get corrected in private, though. That was thoughtless of me, sorry..\n\nI think of it as simple courtesy. Calling people as they would like to be called. Like, I've known two Andrews in my life who hated being called 'Andy'. But yes it's hard in this decentered world of ours to keep track of this stuff. I try to do my best and otherwise not think about it too much when I make a mistake..",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1732273539.863409",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+Gmnv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I didn't mean to police, was just offering information. In this case I actually made the same mistake a couple of months and got corrected. Hmm, I did get corrected in private, though. That was thoughtless of me, sorry..\n\nI think of it as simple courtesy. Calling people as they would like to be called. Like, I've known two Andrews in my life who hated being called 'Andy'. But yes it's hard in this decentered world of ours to keep track of this stuff. I try to do my best and otherwise not think about it too much when I make a mistake.."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UMQ6LR9NZ",
        "type": "message",
        "ts": "1732373351.998639",
        "client_msg_id": "e3dac0de-600e-45d5-abb1-100287c394e9",
        "text": "<https:\/\/www.coa.edu\/human-resources\/careers\/|A potentially future of coding shaped CS prof. role is available at COA up on MDI in Maine>\n\nI can talk to what the school is like and make intros if anyone is interested.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf70d12f2630",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f70d12f2630b6c2a0854e3bef118e73c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "Eli",
            "real_name": "Eli Mellen",
            "display_name": "Eli",
            "team": "T5TCAFTA9",
            "name": "eli.mellen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W2b4t",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/www.coa.edu\/human-resources\/careers\/",
                                "text": "A potentially future of coding shaped CS prof. role is available at COA up on MDI in Maine"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI can talk to what the school is like and make intros if anyone is interested."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "fire",
                "users": [
                    "U05UK5T7LPP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1732389799.214399",
        "client_msg_id": "a6861641-43f3-44f1-bb47-ff6be435b6e7",
        "text": "When I see \"logic programming\", I expect an inference engine as in Prolog. A rewriting system doesn't have that, it simply evolves the factbase over time until it reaches a stable state. And yes, rewriting is easy to implement and has a nice declarative syntax. Good reasons to adopt it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1732269124.417799",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "G829v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When I see \"logic programming\", I expect an inference engine as in Prolog. A rewriting system doesn't have that, it simply evolves the factbase over time until it reaches a stable state. And yes, rewriting is easy to implement and has a nice declarative syntax. Good reasons to adopt it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1732390122.799589",
        "client_msg_id": "b9667eba-fcd6-4cf7-882b-14fdf590306c",
        "text": "I am also happy to call people as they would like to be called, but I can manage that only for a small number of people I am in contact with regularly. And pronouns are worse (from a memorization point of view) than names, because names are relatively unique, whereas for pronouns, everyone picks one of a small number of combinations.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1732273539.863409",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n7REp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am also happy to call people as they would like to be called, but I can manage that only for a small number of people I am in contact with regularly. And pronouns are worse (from a memorization point of view) than names, because names are relatively unique, whereas for pronouns, everyone picks one of a small number of combinations."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1732421999.780399",
        "client_msg_id": "dce7e21e-82a4-4358-bbe7-3315de6f7220",
        "text": "I think that Nova and Ceptre work in 2 stages. (1) search, (2) do something with the matched stuff (i.e. mutate the factbase). In my mind, the _basic_ function of Prolog is to do \"exhaustive search\". In function-based languages, exhaustive search would be written as nested loops. Both, Nova and Ceptre need to do exhaustive search in step (1), hence, they both need the basic exhaustive-search-function of Prolog (or bug-inviting nested loops). In step (2) they, both, need to do only very simple things - retract facts from the factbase, insert facts into the factbase.\n\nAt 2:05:26, Wryl shows syntax with dark-background text and grey-background text. I see the dark text as \"constants\" and the grey stuff as \"holes\". Prolog syntax uses lower-case for constants and Upper case for holes. Ceptre uses the same syntax and adds the \"lolli\" operator (\"o-\" in ASCII) to separate step (1) from step (2). And, Ceptre uses a circle-X (\"*\" in ASCII) to separate pattern matching clauses (in Prolog that would be \",\").  Off the cuff, I think Wryl's example is:\n\n```image(Name,X,Y,R,G,B)\npalette(Color,R,G,B) \n---&gt;\nimage(Name, X, Y, Color)```\nand, would be written in Prolog as:\n\n```image(Name,X,Y,R,G,B) ,\npalette(Color,R,G,B) ,\nretract(image(Name,X,Y,R,G,B)),\nretract(image(Name,X,Y,Color)),\nassert(image(Name, X, Y, Color)).```\nAnd, in Ceptre it might be written as\n\n```image(Name,X,Y,R,G,B) * palette(Color,R,G,B) o- image(Name, X, Y, Color).```\n[My knee-jerk reaction would be to use t2t or OhmJS to rewrite the Ceptre syntax into Prolog syntax, then to run SWIPL on the result. Then, I would write yet another t2t program that would allow extending the Prolog-ish syntax by adding JS externals, then, spit that out as a \/bin\/bash pipeline (example syntax from an unrelated experiment `<https:\/\/github.com\/guitarvydas\/das\/blob\/main\/das2f\/layerboundingbox.md>`)]. [Some months ago, I dissected the Ceptre dungeon crawler example and hand-mapped it to DPL syntax: `<https:\/\/guitarvydas.github.io\/2024\/01\/19\/Ceptre-Dungeon-Crawler-Example-Walk-Through.html>`]",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1732269124.417799",
        "parent_user_id": "UJBAJNFLK",
        "attachments": [
            {
                "from_url": "https:\/\/guitarvydas.github.io\/2024\/01\/19\/Ceptre-Dungeon-Crawler-Example-Walk-Through.html",
                "ts": 1705622400,
                "id": 1,
                "original_url": "https:\/\/guitarvydas.github.io\/2024\/01\/19\/Ceptre-Dungeon-Crawler-Example-Walk-Through.html",
                "fallback": "Computing Simplicity: Ceptre dungeon crawler example walk Through",
                "text": "Oops! Your browser doesn't support PDFs! Download Instead",
                "title": "Ceptre dungeon crawler example walk Through",
                "title_link": "https:\/\/guitarvydas.github.io\/2024\/01\/19\/Ceptre-Dungeon-Crawler-Example-Walk-Through.html",
                "service_name": "Computing Simplicity"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WanAZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think that Nova and Ceptre work in 2 stages. (1) search, (2) do something with the matched stuff (i.e. mutate the factbase). In my mind, the "
                            },
                            {
                                "type": "text",
                                "text": "basic",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " function of Prolog is to do \"exhaustive search\". In function-based languages, exhaustive search would be written as nested loops. Both, Nova and Ceptre need to do exhaustive search in step (1), hence, they both need the basic exhaustive-search-function of Prolog (or bug-inviting nested loops). In step (2) they, both, need to do only very simple things - retract facts from the factbase, insert facts into the factbase.\n\nAt 2:05:26, Wryl shows syntax with dark-background text and grey-background text. I see the dark text as \"constants\" and the grey stuff as \"holes\". Prolog syntax uses lower-case for constants and Upper case for holes. Ceptre uses the same syntax and adds the \"lolli\" operator (\"o-\" in ASCII) to separate step (1) from step (2). And, Ceptre uses a circle-X (\"*\" in ASCII) to separate pattern matching clauses (in Prolog that would be \",\").  Off the cuff, I think Wryl's example is:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "image(Name,X,Y,R,G,B)\npalette(Color,R,G,B) \n--->\nimage(Name, X, Y, Color)"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nand, would be written in Prolog as:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "image(Name,X,Y,R,G,B) ,\npalette(Color,R,G,B) ,\nretract(image(Name,X,Y,R,G,B)),\nretract(image(Name,X,Y,Color)),\nassert(image(Name, X, Y, Color))."
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAnd, in Ceptre it might be written as\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "image(Name,X,Y,R,G,B) * palette(Color,R,G,B) o- image(Name, X, Y, Color)."
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n[My knee-jerk reaction would be to use t2t or OhmJS to rewrite the Ceptre syntax into Prolog syntax, then to run SWIPL on the result. Then, I would write yet another t2t program that would allow extending the Prolog-ish syntax by adding JS externals, then, spit that out as a \/bin\/bash pipeline (example syntax from an unrelated experiment "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/guitarvydas\/das\/blob\/main\/das2f\/layerboundingbox.md",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ")]. [Some months ago, I dissected the Ceptre dungeon crawler example and hand-mapped it to DPL syntax: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/guitarvydas.github.io\/2024\/01\/19\/Ceptre-Dungeon-Crawler-Example-Walk-Through.html",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "]"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJBAJNFLK",
                    "U05UK5T7LPP"
                ],
                "count": 2
            }
        ]
    }
]