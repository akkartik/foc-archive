[
    {
        "user": "U0296ACR13M",
        "type": "message",
        "ts": "1686208034.870459",
        "client_msg_id": "e022cca9-36e1-42ea-b19e-576e1cbeec17",
        "text": "One approach to the text file round tripping could be to have the contents always follow strict formatting rules. Then the parser wouldn't need to care about formatting and the unparser would always just write according to those rules.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "59de929720a2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-09-08\/4075674207584_59de929720a2fe0a13d8_72.jpg",
            "first_name": "",
            "real_name": "Jarno Montonen",
            "display_name": "Jarno Montonen",
            "team": "T5TCAFTA9",
            "name": "jarno.montonen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686169579.523179",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vTh+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One approach to the text file round tripping could be to have the contents always follow strict formatting rules. Then the parser wouldn't need to care about formatting and the unparser would always just write according to those rules."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U02U0AS3J49"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1686234437.438929",
        "client_msg_id": "a42b6486-9d7d-461c-b420-31651996ef1d",
        "text": "The use case for CNL is to make the (usually domain-specific) code readable, but writing it has been hard, because there was no way to stop people from typing invalid syntax, and the CNL syntax was so similar to natural language that it was difficult to  remember what you can and cannot say. Block-based languages solve the problem by not allowing you to type. You must drag and drop valid syntax nodes and combine them. That's good, but the interface is unfamiliar for some people. Oracle Policy Automation allows you to type anything you want (in MS Word), and offers a search bar you can use to find valid syntax if you get messed up. It's more familiar, but very easy to make syntax errors. A structure aware XML editor would look and feel more like Word, giving non-programmers a familiar environment, but only allow you to type things that were syntactically correct. I'm imagining a sort of strict autocomplete. My particular use case is knowledge representation of statute and regulation, so my users are used to those things being expressed as documents.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686205425.866679",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FV2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The use case for CNL is to make the (usually domain-specific) code readable, but writing it has been hard, because there was no way to stop people from typing invalid syntax, and the CNL syntax was so similar to natural language that it was difficult to  remember what you can and cannot say. Block-based languages solve the problem by not allowing you to type. You must drag and drop valid syntax nodes and combine them. That's good, but the interface is unfamiliar for some people. Oracle Policy Automation allows you to type anything you want (in MS Word), and offers a search bar you can use to find valid syntax if you get messed up. It's more familiar, but very easy to make syntax errors. A structure aware XML editor would look and feel more like Word, giving non-programmers a familiar environment, but only allow you to type things that were syntactically correct. I'm imagining a sort of strict autocomplete. My particular use case is knowledge representation of statute and regulation, so my users are used to those things being expressed as documents."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1686282325.403339",
        "client_msg_id": "56728bd1-58c5-475f-a8fd-396443b5d735",
        "text": "I've gotten as far as concluding that each projection, text or VPL or whatever, needs to have format-specific metadata associated with each abstract AST (that is, each individual document). eg the text projection will remember whitespace, the VPL projection might remember position constraints, color, etc. You need to handle defaults for the first time you project into a particular format, e.g. initial whitespacing. Probably there are also other hideous edge cases, the absolute worst intersection of naming things and cache invalidation; I'm sure the off-by-one errors are just waiting for their chance too. (I'm also thinking of this in the context of, say, bidirectional sync of documents in different formats).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686169579.523179",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jvQF3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've gotten as far as concluding that each projection, text or VPL or whatever, needs to have format-specific metadata associated with each abstract AST (that is, each individual document). eg the text projection will remember whitespace, the VPL projection might remember position constraints, color, etc. You need to handle defaults for the first time you project into a particular format, e.g. initial whitespacing. Probably there are also other hideous edge cases, the absolute worst intersection of naming things and cache invalidation; I'm sure the off-by-one errors are just waiting for their chance too. (I'm also thinking of this in the context of, say, bidirectional sync of documents in different formats)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1686282568.830969",
        "client_msg_id": "a1f5b0b4-6c7c-40ec-a584-875ca2a4340d",
        "text": "I haven't tried this, but maybe writing to postgrest wrapping a postgres db, with Grafana providing the graphs? Postgrest is a smidge intimidating, especially the auth situation, but maybe still easier than handrolling something. Otoh, a very small single-endpoint web server that writes to postgres, which is read from grafana, might be a good compromise... (Thinking out loud at this point)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686164858.059869",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dPa8g",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I haven't tried this, but maybe writing to postgrest wrapping a postgres db, with Grafana providing the graphs? Postgrest is a smidge intimidating, especially the auth situation, but maybe still easier than handrolling something. Otoh, a very small single-endpoint web server that writes to postgres, which is read from grafana, might be a good compromise... (Thinking out loud at this point)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFS53UWE5",
        "type": "message",
        "ts": "1686282635.285699",
        "client_msg_id": "29aef815-85ef-4bef-989f-855c7d3570b1",
        "text": "I ended up trying a *lot* of stuff. But ended with hosted InfluxDB + Grafana. Works well enough. Influx has a POST Rest API, and it's all pretty easy to query in Grafana.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a88832bbbfe7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-12\/1359700849458_a88832bbbfe7c26df530_72.jpg",
            "first_name": "John",
            "real_name": "John Austin",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "kleptine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686164858.059869",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "etuPz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I ended up trying a "
                            },
                            {
                                "type": "text",
                                "text": "lot",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of stuff. But ended with hosted InfluxDB + Grafana. Works well enough. Influx has a POST Rest API, and it's all pretty easy to query in Grafana."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U016VUZGUUQ"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UFS53UWE5",
        "type": "message",
        "ts": "1686282649.287129",
        "client_msg_id": "96630d5f-230c-4715-b474-e602f8b06ca6",
        "text": "Luckily Influx has a pay-as-you-go permanent storage option, too.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a88832bbbfe7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-12\/1359700849458_a88832bbbfe7c26df530_72.jpg",
            "first_name": "John",
            "real_name": "John Austin",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "kleptine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686164858.059869",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+rg7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Luckily Influx has a pay-as-you-go permanent storage option, too."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFS53UWE5",
        "type": "message",
        "ts": "1686282674.169299",
        "client_msg_id": "ce1d361b-c87d-4df1-bdcd-995ad0c77ec4",
        "text": "Hadn't tried postgrest, though! I considered TimescaleDB which is on Postgres, but it requires you to map out the schemas in advance.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a88832bbbfe7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-12\/1359700849458_a88832bbbfe7c26df530_72.jpg",
            "first_name": "John",
            "real_name": "John Austin",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "kleptine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686164858.059869",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LhkA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hadn't tried postgrest, though! I considered TimescaleDB which is on Postgres, but it requires you to map out the schemas in advance."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFS53UWE5",
        "type": "message",
        "ts": "1686282694.153149",
        "client_msg_id": "fb7bde8a-3333-410f-b0b9-71c0c1f988b1",
        "text": "The other contender was Graphite, which is essentially built just for this purpose, but it's pretty old and kludgy.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a88832bbbfe7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-12\/1359700849458_a88832bbbfe7c26df530_72.jpg",
            "first_name": "John",
            "real_name": "John Austin",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "kleptine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686164858.059869",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OWdKx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The other contender was Graphite, which is essentially built just for this purpose, but it's pretty old and kludgy."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0296ACR13M",
        "type": "message",
        "ts": "1686290811.448749",
        "client_msg_id": "1af07c20-5fc7-483a-b52e-524e76e1a7d3",
        "text": "I see. I think the viability of using XML editor for CNL depends on the details of the language and how structure aware the editor is. Some XML schema definition might be enough for simple language, but more complex languages are likely to require context sensitive syntax rules and even semantic understanding from the editor. I feel like you'll run into a hard ceiling at some point trying to define and enforce the structure with a schema. A language workbench able to produce textual projectional editor would probably be a safer bet.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "59de929720a2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-09-08\/4075674207584_59de929720a2fe0a13d8_72.jpg",
            "first_name": "",
            "real_name": "Jarno Montonen",
            "display_name": "Jarno Montonen",
            "team": "T5TCAFTA9",
            "name": "jarno.montonen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686205425.866679",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f0Ehq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I see. I think the viability of using XML editor for CNL depends on the details of the language and how structure aware the editor is. Some XML schema definition might be enough for simple language, but more complex languages are likely to require context sensitive syntax rules and even semantic understanding from the editor. I feel like you'll run into a hard ceiling at some point trying to define and enforce the structure with a schema. A language workbench able to produce textual projectional editor would probably be a safer bet."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1::skin-tone-2",
                "users": [
                    "U02U0AS3J49"
                ],
                "count": 1
            }
        ]
    }
]