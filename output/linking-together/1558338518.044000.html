<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../linking-together/1558338518.044000.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-05-20 00:48</span><br/>
To achieve maximum productivity, being able to execute the spec means you just saved an implementation phase that could easily deviate from the spec. So eliminating this step means a whole category of errors that can't happen. Also, it means you don't partially program the system in the spec phase then throw that work away. If such a thing can be done, it is a big win.  In Modula-2  for example, each module consisted of 2 files, one was the DEFINITION part, which contained all externally visible (exported) items, which might be constants, types, functions, etc. and the IMPLEMENTATION module had the actual code for the definition. Thus it was possible by merely sending the tiny compiled DEFINITION file to another programmer, and they could build a system without a) seeing the implementation, or b) caring about the internals. The linker used a series of tricks to guarantee that the version you built against was up to date. This is decades ago, and still C++ doesn't have anything this elegant or simple, and the JS module system is a mediocre partial implementation of Modula-2's module system.<br/><br/>In reality an executable spec is a slightly more detailed than ordinary spec, as one is combining what traditionally was done in two phases (and two separate documents) into one document. Still a big win, as a project development cycle would start with a concept, proceed to napkin spec, to data structure/algorithm design, to executable specification, and then alpha testing, beta testing, shipping. Also means that over time the changes to the product are kept synchronized with the spec. Who hasn't in their career faced the situation where the spec disagrees with the running product?, and in that situation, it is often unclear which should change. It is a well known fact that if you have sensors in a spacecraft, you better have an odd number, so you know by majority rule which one will be the source of truth. Reducing it to a single document IMHO is a really big win, and is the focus of my particular research.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
