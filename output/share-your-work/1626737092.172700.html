<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2025-02-28/8529753983250_8f365fd896e9c8f573b5_72.jpg" style="float:left"/>
      <a href="../share-your-work/1626737092.172700.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>xyzzy</b>
<span style="margin:2em; color:#606060">2021-07-19 16:24</span><br/>
Hi all,  this is my first post here.  Ever since I saw <a href="https://www.youtube.com/watch?v=Av0PQDVTP4A">this literate programming talk </a>I have been messing with existing literate programming tools. After trying multiple tools, I ended up writing my own tool using python + sphinx + cog + markdown. I am calling it wheel.<br/><br/>Because of cog - I believe literate programming can enable many interesting things like arbitrary preprocessing and code generation instead of just mangle and tangle. In plannr I have experimented with adding some syntax to hylang, a dialect of lisp. I think literate programming is criss-cross programming :slightly_smiling_face: and enables <em>feature driven development</em>. I have documented my findings here <a href="https://xyzzyapps.link/wheel/why.html">https://xyzzyapps.link/wheel/why.html</a><br/><br/>Would love to hear you guys think!<br/><br/><b>Links</b><br/><br/>1. <a href="https://xyzzyapps.link/wheel">Wheel</a> - a literate programming tool with python + sphinx + cog + markdown.<br/>2. My main app <a href="https://plannr.xyzzyapps.link/">Plannr (currently beta)</a> and the <a href="https://plannr.xyzzyapps.link/docs/index.html">literate documentation</a> for it. <a href="https://plannr.xyzzyapps.link/docs/plannr.html">Source code</a> inside the documentation.<br/>3. My music making app <a href="https://bitrhythm.xyzzyapps.link/">Bitrhythm</a> and its <a href="https://bitrhythm.xyzzyapps.link/docs/index.html">documentation</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1626777101.174100"></a>
      <img src="https://avatars.slack-edge.com/2021-05-26/2104531310403_4d4f0ee36615313d19e3_72.jpg" style="float:left"/>
      <a href="../share-your-work/1626737092.172700.html#1626777101.174100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Florian Schulz</b>
<span style="margin:2em; color:#606060">2021-07-20 03:31</span><br/>
I find my self nodding a lot reading through it: <a href="https://xyzzyapps.link/wheel/why.html">https://xyzzyapps.link/wheel/why.html</a><br/><br/>I briefly looked through the “Code Walkthrough” of Plannr to get a better understanding. I wonder how you can get different perspectives on code besides chapters and pages.<br/><br/>Thinking in books: I understand that there is a table of contents and a linear flow through the book. There are also links. Is there also some sort of Appendix, Glossary or other forms of organization possible? For example, I found a couple of code snippets called “Websocket Reply Handlers” that contained message types and handlers. I could imagine an index of all those that link to their implementation. Would that be possible / how would you set this up?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1626786361.174300"></a>
      <img src="https://avatars.slack-edge.com/2025-02-28/8529753983250_8f365fd896e9c8f573b5_72.jpg" style="float:left"/>
      <a href="../share-your-work/1626737092.172700.html#1626786361.174300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>xyzzy</b>
<span style="margin:2em; color:#606060">2021-07-20 06:06</span><br/>
In the original implementation cweb extensive cross referencing capabilities are provided but yes there could be other perspectives on chapters. You can get cross references with  <a href="https://github.com/zyedidia/Literate">this tool</a>.  My current notion is 1 chapter = 1 use case or 1 complete feature with backend, frontend and tests.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1626861188.181300"></a>
      <img src="https://avatars.slack-edge.com/2021-05-26/2104531310403_4d4f0ee36615313d19e3_72.jpg" style="float:left"/>
      <a href="../share-your-work/1626737092.172700.html#1626861188.181300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Florian Schulz</b>
<span style="margin:2em; color:#606060">2021-07-21 02:53</span><br/>
Thanks! I really find this whole idea super interesting. I’ve been keeping a written log of my programming progress with notes about features, implementations and screenshots. But linking that with actual code would be interesting. I believe a lot of challenges from coding comes from the lack of Organisation and verbalisation. And as described here, files/folders aren’t enough and seem to be rather hacks. I like that in Processing (.org), you can create “tabs” when a single code file gets too long. You create a tab inside the IDE but that tab isn’t a new file that you need to import. It is just a new “snippet” that will be appended together with the other tabs. I wonder: is Observable another example of literate programming? <a href="https://observablehq.com">https://observablehq.com</a> — I do have to say that your examples are better, because they have a table of contents! :slightly_smiling_face: In general I think that lists, maps, and other designed forms of access to code are really needed in contrast to just files, folders and naming conventions.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1626865196.182500"></a>
      <img src="https://avatars.slack-edge.com/2025-02-28/8529753983250_8f365fd896e9c8f573b5_72.jpg" style="float:left"/>
      <a href="../share-your-work/1626737092.172700.html#1626865196.182500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>xyzzy</b>
<span style="margin:2em; color:#606060">2021-07-21 03:59</span><br/>
I haven’t used observable but I have used python notebooks. I think <a href="https://github.com/fastai/nbdev">nbdev</a> comes close to literate programming. The difference lies in the flexibility of organisation and arbitrary reordering.  In literate programming you define chunks that can be reused wherever you want, whether in docs or code. If observable provides a named block that can be referenced and embedded anywhere then it gets close. I would emphasise that this is production code, not just examples which blogs and notebooks are typically used for!  Personally I find literate programming for noting down 1. todo’s 2. bugs 3. bookmarks 4, design decisions and history 5. build commands 6. tests
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
