[
    {
        "subtype": "thread_broadcast",
        "user": "UCUSW7WVD",
        "thread_ts": "1661835473.383259",
        "root": {
            "text": "An impromptu demo of some recent features in my note-taking system: search and hyperlinks.",
            "files": [
                {
                    "id": "F0408E13L58",
                    "mode": "hidden_by_limit"
                }
            ],
            "upload": false,
            "user": "UCUSW7WVD",
            "display_as_bot": false,
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "nzmM",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "An impromptu demo of some recent features in my note-taking system: search and hyperlinks."
                                }
                            ]
                        }
                    ]
                }
            ],
            "type": "message",
            "ts": "1661835473.383259",
            "client_msg_id": "bb806b4e-a3ed-494d-be3c-3742d04e7ae8",
            "thread_ts": "1661835473.383259",
            "reply_count": 11,
            "reply_users_count": 3,
            "latest_reply": "1669743203.175719",
            "reply_users": [
                "UCUSW7WVD",
                "UA14TGLTC",
                "U013ZLJARC7"
            ],
            "replies": [
                {
                    "user": "UCUSW7WVD",
                    "ts": "1668202655.743929"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1669247205.071759"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1669247284.264359"
                },
                {
                    "user": "UA14TGLTC",
                    "ts": "1669273083.259989"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1669274401.812309"
                },
                {
                    "user": "U013ZLJARC7",
                    "ts": "1669711087.096809"
                },
                {
                    "user": "U013ZLJARC7",
                    "ts": "1669711163.096799"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1669712331.483739"
                },
                {
                    "user": "U013ZLJARC7",
                    "ts": "1669718202.205249"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1669733667.335219"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1669743203.175719"
                }
            ],
            "is_locked": false,
            "subscribed": false
        },
        "type": "message",
        "ts": "1669247205.071759",
        "client_msg_id": "7533196b-e059-4877-a6f0-4eee7b206b12",
        "text": "One problem I've been having with my note-taking app is that it grows sluggish over time. This is an unavoidable tension: simple programs tend to be inefficient, and optimizations tend to make programs less approachable. Meditating on <https:\/\/www.youtube.com\/watch?v=rX0ItVEVjHc> helped me speed things up significantly -- by reading data redundantly from disk. In the process I realized that garbage collection is missold as \"automatic memory management\". All memory management is manual. There's no substitute for thinking about your program's memory footprint. More details in :thread:",
        "attachments": [
            {
                "from_url": "https:\/\/www.youtube.com\/watch?v=rX0ItVEVjHc",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/rX0ItVEVjHc\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/rX0ItVEVjHc?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen title=\"CppCon 2014: Mike Acton &quot;Data-Oriented Design and C++&quot;\"><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=rX0ItVEVjHc",
                "fallback": "YouTube Video: CppCon 2014: Mike Acton \"Data-Oriented Design and C++\"",
                "title": "CppCon 2014: Mike Acton \"Data-Oriented Design and C++\"",
                "title_link": "https:\/\/www.youtube.com\/watch?v=rX0ItVEVjHc",
                "author_name": "CppCon",
                "author_link": "https:\/\/www.youtube.com\/@CppCon",
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Duf26",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One problem I've been having with my note-taking app is that it grows sluggish over time. This is an unavoidable tension: simple programs tend to be inefficient, and optimizations tend to make programs less approachable. Meditating on "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=rX0ItVEVjHc"
                            },
                            {
                                "type": "text",
                                "text": " helped me speed things up significantly -- by reading data redundantly from disk. In the process I realized that garbage collection is missold as \"automatic memory management\". All memory management is manual. There's no substitute for thinking about your program's memory footprint. More details in "
                            },
                            {
                                "type": "emoji",
                                "name": "thread",
                                "unicode": "1f9f5"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1669247284.264359",
        "client_msg_id": "ee8654e7-a762-4a8c-8c4f-8622e64048e5",
        "text": "My note-taking app consists of multiple text-editor widgets arranged on a 2D surface. I tend to add notes to the surface but leave them lying around. Over a month or so of use things would get sluggish and I'd have to start closing notes.\n\nWatching the Mike Acton talk got me to focus on this, and on ways to improve its memory footprint without complicating things too much. Lua doesn't have very good profiling tools, so I can't easily see where the bottleneck is. But I eventually hit upon a plan that worked very well: when a text editor widget goes out of view, just blow away the data backing it. When it comes back into view, read it from file. That's it!\n\nIt took me a while to convince myself that this would be a net win. I'm replacing reads from memory with reads from disk. The key realization: it's a trickle of reads to disk replacing an unbounded amount of stuff that's just always hanging around in memory.\n\nI think this is a data-oriented solution in the footsteps of Mike Acton even though it didn't delete any fields from structs, or switch to struct of arrays or anything like that. Lua doesn't really give me control over how cache lines are packed or avoiding pointer indirection, but I was following the key principle Mike Acton articulated: you always have to manage your caches. Emphasis on the \"you\". No tool can do this.\n\nThis experience has changed how I think of garbage collection. I no longer think of it as \"automated memory management\". In my new worldview memory management is always manual. GC merely allows you to reduce the ceremony of deallocation. Where in C++ I had to maintain a bunch of destructors and explictly call delete, with a GC I can just assign a variable to nil to blow away everything inside it. This seems like a powerful insight. GC isn't magic. It's still the programmer's responsibility to point out what can be reclaimed.\n\nThis experience shouldn't be so surprising. I've been around enough to know the theory. I've heard the war stories about how Google ran successive generations of its search frontend off disk, then memory, then disk again. I think the surprise stems from seeing this dynamic in action in a tiny program with a memory footprint of 10-20MB. There's still plenty of room to trash your processor's cache (0.5MB in level 1, 8MB in level 3)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1661835473.383259",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+M\/vd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My note-taking app consists of multiple text-editor widgets arranged on a 2D surface. I tend to add notes to the surface but leave them lying around. Over a month or so of use things would get sluggish and I'd have to start closing notes.\n\nWatching the Mike Acton talk got me to focus on this, and on ways to improve its memory footprint without complicating things too much. Lua doesn't have very good profiling tools, so I can't easily see where the bottleneck is. But I eventually hit upon a plan that worked very well: when a text editor widget goes out of view, just blow away the data backing it. When it comes back into view, read it from file. That's it!\n\nIt took me a while to convince myself that this would be a net win. I'm replacing reads from memory with reads from disk. The key realization: it's a trickle of reads to disk replacing an unbounded amount of stuff that's just always hanging around in memory.\n\nI think this is a data-oriented solution in the footsteps of Mike Acton even though it didn't delete any fields from structs, or switch to struct of arrays or anything like that. Lua doesn't really give me control over how cache lines are packed or avoiding pointer indirection, but I was following the key principle Mike Acton articulated: you always have to manage your caches. Emphasis on the \"you\". No tool can do this.\n\nThis experience has changed how I think of garbage collection. I no longer think of it as \"automated memory management\". In my new worldview memory management is always manual. GC merely allows you to reduce the ceremony of deallocation. Where in C++ I had to maintain a bunch of destructors and explictly call delete, with a GC I can just assign a variable to nil to blow away everything inside it. This seems like a powerful insight. GC isn't magic. It's still the programmer's responsibility to point out what can be reclaimed.\n\nThis experience shouldn't be so surprising. I've been around enough to know the theory. I've heard the war stories about how Google ran successive generations of its search frontend off disk, then memory, then disk again. I think the surprise stems from seeing this dynamic in action in a tiny program with a memory footprint of 10-20MB. There's still plenty of room to trash your processor's cache (0.5MB in level 1, 8MB in level 3)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1669273083.259989",
        "client_msg_id": "1ff58b31-945e-4670-a718-f7dc1802e2e6",
        "text": "&gt; The key realization: it's a trickle of reads to disk replacing an unbounded amount of stuff that's just always hanging around in memory.\nSo you were doing some unhelpful work?  Disk reads to refresh data that wasn't actively being used?\n\nIn a way GC issues seem to be a symptom of the general problem that certain program aspects, like performance, are pretty opaque.\n\n&gt; GC merely allows you to reduce the ceremony of deallocation.\nA good way to put it.  A problem with deallocation and naive GC is that the concern is too fine-grained.  Things like stack allocation and garbage generations can help.  I recall Lua handles it's closures relatively cleverly using \"upvalues.\"  The gist, if I remember, being that (1) you don't even need to make closure if a function stays within its the lexical scope of its creation, and (2) when you do close you only keep references to necessary variables around other things, the rest of the lexical environment of the function definition can go away.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1661835473.383259",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mBy",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The key realization: it's a trickle of reads to disk replacing an unbounded amount of stuff that's just always hanging around in memory."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So you were doing some unhelpful work?  Disk reads to refresh data that wasn't actively being used?\n\nIn a way GC issues seem to be a symptom of the general problem that certain program aspects, like performance, are pretty opaque.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "GC merely allows you to reduce the ceremony of deallocation."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A good way to put it.  A problem with deallocation and naive GC is that the concern is too fine-grained.  Things like stack allocation and garbage generations can help.  I recall Lua handles it's closures relatively cleverly using \"upvalues.\"  The gist, if I remember, being that (1) you don't even need to make closure if a function stays within its the lexical scope of its creation, and (2) when you do close you only keep references to necessary variables around other things, the rest of the lexical environment of the function definition can go away."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "text": "&gt; So you were doing some unhelpful work? Disk reads to refresh data that wasn't actively being used?\nThe key commit is <https:\/\/git.sr.ht\/~akkartik\/pensieve.love\/commit\/af7fba3263fbbdd1168ce7c941f9c6f79fca63d8>\n\nI have around 9GB of notes on disk (including all my mail for over a decade, chat logs, stuff like that). But only a tiny sliver of them are on the surface at any time. Currently around 120 columns. Far less than 50 notes\/files per column, average file size per note is probably less than 5KB. Before this change, I was loading everything on the surface at startup and holding it until I closed notes\/columns from the surface. With this strategy, the heap footprint according to `collectgarbage('count')` (<https:\/\/www.lua.org\/manual\/5.1\/manual.html#pdf-collectgarbage>) was between 10 and 20MB. Initial load seemed instantaneous.\n\nThe commit above eagerly throws away file data that isn't in notes showing on screen right now. When the viewport moves, I load any newly visible files, and throw away any files that are no longer visible.\n\nI continue to retain all metadata. It's just the raw strings that take up a lot of space.\n\nNow my footprint is halved. But the key metric is how often I find myself distracted by what I'm doing to fix my note-taking system. Today I didn't perceive any sluggishness where earlier things would slow down any time I was editing a note with more than a couple of sentences. I think the full GC might be a lot less frequent now. (I'm still seeing some signs of collection every second or so; see screenshot.)",
        "files": [
            {
                "id": "F04CDK67B1A",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "UCUSW7WVD",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bq\/X",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So you were doing some unhelpful work? Disk reads to refresh data that wasn't actively being used?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe key commit is "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/git.sr.ht\/~akkartik\/pensieve.love\/commit\/af7fba3263fbbdd1168ce7c941f9c6f79fca63d8"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI have around 9GB of notes on disk (including all my mail for over a decade, chat logs, stuff like that). But only a tiny sliver of them are on the surface at any time. Currently around 120 columns. Far less than 50 notes\/files per column, average file size per note is probably less than 5KB. Before this change, I was loading everything on the surface at startup and holding it until I closed notes\/columns from the surface. With this strategy, the heap footprint according to "
                            },
                            {
                                "type": "text",
                                "text": "collectgarbage('count')",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.lua.org\/manual\/5.1\/manual.html#pdf-collectgarbage"
                            },
                            {
                                "type": "text",
                                "text": ") was between 10 and 20MB. Initial load seemed instantaneous.\n\nThe commit above eagerly throws away file data that isn't in notes showing on screen right now. When the viewport moves, I load any newly visible files, and throw away any files that are no longer visible.\n\nI continue to retain all metadata. It's just the raw strings that take up a lot of space.\n\nNow my footprint is halved. But the key metric is how often I find myself distracted by what I'm doing to fix my note-taking system. Today I didn't perceive any sluggishness where earlier things would slow down any time I was editing a note with more than a couple of sentences. I think the full GC might be a lot less frequent now. (I'm still seeing some signs of collection every second or so; see screenshot.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1669274401.812309",
        "client_msg_id": "3320909a-f8b9-436b-91b5-17b257b05b81",
        "thread_ts": "1661835473.383259",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    }
]