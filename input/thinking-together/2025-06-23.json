[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1750683897.654829",
        "client_msg_id": "a5437482-584e-490b-bcbe-9499e4055932",
        "text": "Something that <@U013ZLJARC7> said in his <https:\/\/futureofcoding.slack.com\/archives\/CCL5VVBAN\/p1750405943880479|talk> made me think of this thread. Here is another attempt at explaining why I think that <https:\/\/programmingsimplicity.substack.com\/p\/lisp-source-code?r=1egdky|Lisp code> is tree-oriented.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "attachments": [
            {
                "from_url": "https:\/\/futureofcoding.slack.com\/archives\/CCL5VVBAN\/p1750405943880479",
                "ts": "1750405943.880479",
                "author_id": "U013ZLJARC7",
                "channel_id": "CCL5VVBAN",
                "channel_team": "T5TCAFTA9",
                "is_msg_unfurl": true,
                "is_thread_root_unfurl": true,
                "message_blocks": [
                    {
                        "team": "T5TCAFTA9",
                        "channel": "CCL5VVBAN",
                        "ts": "1750405943.880479",
                        "message": {
                            "blocks": [
                                {
                                    "type": "rich_text",
                                    "block_id": "ma1E0",
                                    "elements": [
                                        {
                                            "type": "rich_text_section",
                                            "elements": [
                                                {
                                                    "type": "text",
                                                    "text": "My latest talk, given at Craft Conf in Budapest. There were some technical difficulties, but it should hopefully serve as a reasonable introduction to the virtues of interactive development in Clojure.\n\n"
                                                },
                                                {
                                                    "type": "link",
                                                    "url": "https:\/\/m.youtube.com\/watch?v=i_dUvhEIGBQ",
                                                    "text": "https:\/\/m.youtube.com\/watch?v=i_dUvhEIGBQ"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ],
                "id": 1,
                "original_url": "https:\/\/futureofcoding.slack.com\/archives\/CCL5VVBAN\/p1750405943880479",
                "fallback": "[June 20th, 2025 12:52 AM] jack529: My latest talk, given at Craft Conf in Budapest. There were some technical difficulties, but it should hopefully serve as a reasonable introduction to the virtues of interactive development in Clojure.\n\n<https:\/\/m.youtube.com\/watch?v=i_dUvhEIGBQ|https:\/\/m.youtube.com\/watch?v=i_dUvhEIGBQ>",
                "text": "My latest talk, given at Craft Conf in Budapest. There were some technical difficulties, but it should hopefully serve as a reasonable introduction to the virtues of interactive development in Clojure.\n\n<https:\/\/m.youtube.com\/watch?v=i_dUvhEIGBQ|https:\/\/m.youtube.com\/watch?v=i_dUvhEIGBQ>",
                "author_name": "Jack Rusher",
                "author_link": "https:\/\/futureofcoding.slack.com\/team\/U013ZLJARC7",
                "author_icon": "https:\/\/avatars.slack-edge.com\/2023-10-13\/6057269405632_8ea58fc41bd6baa7dda6_48.png",
                "author_subname": "Jack Rusher",
                "mrkdwn_in": [
                    "text"
                ],
                "footer": "Thread in Slack Conversation"
            },
            {
                "image_url": "https:\/\/substackcdn.com\/image\/fetch\/$s_!52yL!,w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto\/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Feb7a8cf6-f8bf-4c2f-80bd-cf0f909274d4_701x361.heic",
                "image_width": 701,
                "image_height": 361,
                "image_bytes": 12606,
                "from_url": "https:\/\/programmingsimplicity.substack.com\/p\/lisp-source-code?r=1egdky",
                "service_icon": "https:\/\/substackcdn.com\/image\/fetch\/%24s_!9I6g!,f_auto,q_auto:good,fl_progressive:steep\/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9bf28261-3dbc-4931-99f3-57bb47beeb02%2Fapple-touch-icon-57x57.png",
                "id": 2,
                "original_url": "https:\/\/programmingsimplicity.substack.com\/p\/lisp-source-code?r=1egdky",
                "fallback": "Lisp Source Code",
                "text": "2025-06-22",
                "title": "Lisp Source Code",
                "title_link": "https:\/\/programmingsimplicity.substack.com\/p\/lisp-source-code?r=1egdky",
                "service_name": "programmingsimplicity.substack.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jXItK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Something that "
                            },
                            {
                                "type": "user",
                                "user_id": "U013ZLJARC7"
                            },
                            {
                                "type": "text",
                                "text": " said in his "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/CCL5VVBAN\/p1750405943880479",
                                "text": "talk"
                            },
                            {
                                "type": "text",
                                "text": " made me think of this thread. Here is another attempt at explaining why I think that "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/programmingsimplicity.substack.com\/p\/lisp-source-code?r=1egdky",
                                "text": "Lisp code"
                            },
                            {
                                "type": "text",
                                "text": " is tree-oriented."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1750701464.079179",
        "client_msg_id": "2f05cb84-e5b5-4c67-91b7-d8dbbe19632a",
        "text": "so, as soon as I implement read(str) in java, which would return a bunch of ArrayLists, Integers, Strings, Booleans and java.util.Maps – java code becomes tree-oriented? Is this *the* distinction?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0343f70ca57",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-07-04\/7377091009748_d0343f70ca57c18eeb41_72.png",
            "first_name": "misha",
            "real_name": "misha",
            "display_name": "misha",
            "team": "T5TCAFTA9",
            "name": "misha.akovantsev",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uQQbm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "so, as soon as I implement read(str) in java, which would return a bunch of ArrayLists, Integers, Strings, Booleans and java.util.Maps – java code becomes tree-oriented? Is this "
                            },
                            {
                                "type": "text",
                                "text": "the",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " distinction?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1750703297.261809",
        "client_msg_id": "69aa7c85-3a80-4450-88f4-2d49e93154d6",
        "text": "The Lisp reader is different from read(str). The Lisp reader does extra work and parses the str and conses up a list. The lisp reader produces something like the diagram above, containing list (yellow) and atom (gray) cells. Other languages' read(str) doesn't do all of that extra work - in those cases read(str) simply returns a string.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3vcl3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The Lisp reader is different from read(str). The Lisp reader does extra work and parses the str and conses up a list. The lisp reader produces something like the diagram above, containing list (yellow) and atom (gray) cells. Other languages' read(str) doesn't do all of that extra work - in those cases read(str) simply returns a string."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1750704755.291639",
        "client_msg_id": "b146040b-8882-43d9-8b33-d173afab3b1c",
        "text": "I wrote \"would return bunch of\" (did not write \"nested\", but meant \"nested\").\nYou are talking about some \"out the box\" read() fns, which *already* \"do not do\" extra work, as if there is no way to write such fn at any time.\nBut writing fn to convert string to a bunch of nested data structures is easy.\n\n+ all the code-manipulations in the talk were done in the editor which is a separate system from lisp, which makes lisp having such read function out the box - irrelevant, because replace emacs with a text input on a website with a js fn which knows how to turn str into nested structure and you get tree-orientation too, right? regardless of which PL str it was: python, js, common lisp, java, etc.\n\nIf that is all it takes to be tree-oriented... how is lisp special in this regard?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0343f70ca57",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-07-04\/7377091009748_d0343f70ca57c18eeb41_72.png",
            "first_name": "misha",
            "real_name": "misha",
            "display_name": "misha",
            "team": "T5TCAFTA9",
            "name": "misha.akovantsev",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ftrTk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wrote \"would return bunch of\" (did not write \"nested\", but meant \"nested\").\nYou are talking about some \"out the box\" read() fns, which "
                            },
                            {
                                "type": "text",
                                "text": "already",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " \"do not do\" extra work, as if there is no way to write such fn at any time.\nBut writing fn to convert string to a bunch of nested data structures is easy.\n\n+ all the code-manipulations in the talk were done in the editor which is a separate system from lisp, which makes lisp having such read function out the box - irrelevant, because replace emacs with a text input on a website with a js fn which knows how to turn str into nested structure and you get tree-orientation too, right? regardless of which PL str it was: python, js, common lisp, java, etc.\n\nIf that is all it takes to be tree-oriented... how is lisp special in this regard?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U013ZLJARC7",
        "type": "message",
        "ts": "1750711895.804049",
        "client_msg_id": "CEEE861C-C433-4136-ADE8-0C52E9A33C70",
        "text": "Programming language ASTs are tree shaped in general, which is not by itself an interesting observation. Lisp syntax happens to be a good representation of those trees. Also, `(read)` is great, but things get much better when you also have `(print foo)`.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8ea58fc41bd6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-10-13\/6057269405632_8ea58fc41bd6baa7dda6_72.png",
            "first_name": "",
            "real_name": "Jack Rusher",
            "display_name": "Jack Rusher",
            "team": "T5TCAFTA9",
            "name": "jack529",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZAV\/n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Programming language ASTs are tree shaped in general"
                            },
                            {
                                "type": "text",
                                "text": ","
                            },
                            {
                                "type": "text",
                                "text": " which is not by itself an interesting observation"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " Lisp syntax happens to be a good representation of those trees. Also, "
                            },
                            {
                                "type": "text",
                                "text": "(read)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is great, but things get much better when you also have "
                            },
                            {
                                "type": "text",
                                "text": "(print foo)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1750732985.567609",
        "client_msg_id": "9f0ea8bb-a9e7-4b3c-8944-12b682379f1c",
        "text": "These are very good points. I watch Rusher's demo and I know from personal experience that much (~10x) better productivity can be had. You point out that it is possible to break the technical aspects down into tiny pieces using just about any language. I argue that it is \"not enough\" to work \/only\/ on pieces that can be easily identified. It's like trying to explain to a frequency-only oriented technical person why vinyl sounds better than CDs (and MP3s, digital, etc.). It is my opinion that developer productivity tanked when the strong-typing \/ FP craze took over. Lisp, Forth, Smalltalk, Rebol, etc., etc. all have that \"something\" that got lost in the type-checking frenzy. As you point out, that \"something\" ain't a piece of tech. So, what is that \"something\"? Why do non-programmers like spreadsheets, yet pro programmers would never consider using spreadsheets for real programming?\n\nTo say that emacs is not related to lisp is incorrect, in my experience. In fact, emacs is strongly related to pre-Common-Lisp lisp. For \"some reason\" (i.e. better productivity), emacs has led the way into creation and early adoption of a plethora of features, many of which have been Greenspuned into current editors and IDEs. Attempts to cut emacs over to Common Lisp have not borne fruit in terms of advancement of productivity and have mostly fallen to the wayside. Aside: note, too, that the concept of \"macros\" was invented in pre-Common-Lisp which used verboten technologies like FEXPRs. The concept of \"macros\" was later wrangled-over and tightened up in Scheme, but, the concept was not invented in Scheme.\n\nI said that the lisp reader is essentially a \"scanner\", but I failed to state and only implied that lisp doesn't bother to break compilation off and put it somewhere else in the workflow. Edicts like \"don't use eval()\" have harmed developer productivity (compilation == eval). Rusher points out that even Python's REPL ain't as good for productivity as lisp's, and, he proceeds to show why and comments on the relationship of \/normalization\/ of data representation and code representation. Poking at Rusher might be a good idea - we should extract from him more insights on what this means and how it helps productivity.\n\nNote that Rusher quotes \"it's better to have 100 functions that operate on one data structure than 10 that operate on 10 data structures\", but doesn't take it to the extreme conclusion that providing user-defined data structures ('structs', 'records') is a bad idea.\n\nNow that we're 50+ years down the road, I think that we should step back, take a deep breath, and observe what we've discovered about programming PtGP (Programming: the Good Parts). I've started to do this over on the \"programming simplicity\" discord and am looking for a better name (than the current \"SCP\") before proceeding much further. We need to recognize that just about everything they did in 1960 is old-fashioned and based on the erroneous presumption that computers are just mathematics machines that must be based on Gutenberg type-setting.\n\nIn conclusion: lisp was tree-oriented from the start. The normalized data format - lists - used for data and for code and various seemingly-irrelevant design decisions (e.g. lisp scanner\/parser\/compiler built into the language). Today, we can duplicate this tree-orientedness using just about any programming language, but, we haven't managed to duplicate lisp's \"productivity\" for designing software (which is not the same as productivity for optimizing software). Rusher, Girba, Hinsen, Clojure+emacs, etc. are poking at design productivity instead of hard-core optimization. I see there being two different fields of programming - Engineering and Production Engineering (Design and Optimization). You can't schmoo both sets of goals into a single programming language, like we tried to do in 1960. Today, with better hardware and newly developed ideas about software, we can afford to build different tools aimed at different goals.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3S1cf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "These are very good points. I watch Rusher's demo and I know from personal experience that much (~10x) better productivity can be had. You point out that it is possible to break the technical aspects down into tiny pieces using just about any language. I argue that it is \"not enough\" to work \/only\/ on pieces that can be easily identified. It's like trying to explain to a frequency-only oriented technical person why vinyl sounds better than CDs (and MP3s, digital, etc.). It is my opinion that developer productivity tanked when the strong-typing \/ FP craze took over. Lisp, Forth, Smalltalk, Rebol, etc., etc. all have that \"something\" that got lost in the type-checking frenzy. As you point out, that \"something\" ain't a piece of tech. So, what is that \"something\"? Why do non-programmers like spreadsheets, yet pro programmers would never consider using spreadsheets for real programming?\n\nTo say that emacs is not related to lisp is incorrect, in my experience. In fact, emacs is strongly related to pre-Common-Lisp lisp. For \"some reason\" (i.e. better productivity), emacs has led the way into creation and early adoption of a plethora of features, many of which have been Greenspuned into current editors and IDEs. Attempts to cut emacs over to Common Lisp have not borne fruit in terms of advancement of productivity and have mostly fallen to the wayside. Aside: note, too, that the concept of \"macros\" was invented in pre-Common-Lisp which used verboten technologies like FEXPRs. The concept of \"macros\" was later wrangled-over and tightened up in Scheme, but, the concept was not invented in Scheme.\n\nI said that the lisp reader is essentially a \"scanner\", but I failed to state and only implied that lisp doesn't bother to break compilation off and put it somewhere else in the workflow. Edicts like \"don't use eval()\" have harmed developer productivity (compilation == eval). Rusher points out that even Python's REPL ain't as good for productivity as lisp's, and, he proceeds to show why and comments on the relationship of \/normalization\/ of data representation and code representation. Poking at Rusher might be a good idea - we should extract from him more insights on what this means and how it helps productivity.\n\nNote that Rusher quotes \"it's better to have 100 functions that operate on one data structure than 10 that operate on 10 data structures\", but doesn't take it to the extreme conclusion that providing user-defined data structures ('structs', 'records') is a bad idea.\n\nNow that we're 50+ years down the road, I think that we should step back, take a deep breath, and observe what we've discovered about programming PtGP (Programming: the Good Parts). I've started to do this over on the \"programming simplicity\" discord and am looking for a better name (than the current \"SCP\") before proceeding much further. We need to recognize that just about everything they did in 1960 is old-fashioned and based on the erroneous presumption that computers are just mathematics machines that must be based on Gutenberg type-setting.\n\nIn conclusion: lisp was tree-oriented from the start. The normalized data format - lists - used for data and for code and various seemingly-irrelevant design decisions (e.g. lisp scanner\/parser\/compiler built into the language). Today, we can duplicate this tree-orientedness using just about any programming language, but, we haven't managed to duplicate lisp's \"productivity\" for designing software (which is not the same as productivity for optimizing software). Rusher, Girba, Hinsen, Clojure+emacs, etc. are poking at design productivity instead of hard-core optimization. I see there being two different fields of programming - Engineering and Production Engineering (Design and Optimization). You can't schmoo both sets of goals into a single programming language, like we tried to do in 1960. Today, with better hardware and newly developed ideas about software, we can afford to build different tools aimed at different goals."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1750746307.919489",
        "client_msg_id": "41e0e9c3-d8a5-4f4e-b063-23f7af8da1a3",
        "text": "I am trying to pinpoint what tree-oriented actually is:\nIs it just a handful of functions, which happen to be in the std-lib of lisp, but not in other langs, but can be straightforwardly retrofit with a library to any lang.\nOr is it such combination of design and implementation decisions that only lisps have it, no matter how hard you try to put a lipstick on a python.\n\"rename variable\" and \"extract as function\" are tree-oriented features available for all languages in one IDE or another after all, so could it be that quacking like tree-orientation is enough to be tree-orientation? If so, then distinction would be not between languages but between IDEs\/editors:\n• vim with this plugin for python is tree oriented, and this notepad.exe for lisp is not\n• default git diff tool is not tree oriented for anything, but difftastic is t-o for lisps\n• etc.\nre \"would be nice to have print()\":\nsame argument: could it be retrofit onto js\/etc? is it enough? Not every list is a valid code in lisp, not any tree is a valid clojure code, not every  printed string would be valid js, but some would be, and there is an eval() in js...\n\nre \"emacs+lisp\": what I meant by \"separate system\" is emacs sends strings-of-code to repl (cider or nrepl etc), not pointer to the root of the tree emacs parsed code into, hence, conceptually, is not any different from html input with <http:\/\/js.xhr.post|js.xhr.post>(code-as-str) of string to repl socket.\n\nre \"python shell is not a repl\": is the only difference – python's shell is not your running project's process, but a separate one? so you can't overwrite some fn definition live.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0343f70ca57",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-07-04\/7377091009748_d0343f70ca57c18eeb41_72.png",
            "first_name": "misha",
            "real_name": "misha",
            "display_name": "misha",
            "team": "T5TCAFTA9",
            "name": "misha.akovantsev",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7Brr1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am trying to pinpoint what tree-oriented actually is:\nIs it just a handful of functions, which happen to be in the std-lib of lisp, but not in other langs, but can be straightforwardly retrofit with a library to any lang.\nOr is it such combination of design and implementation decisions that only lisps have it, no matter how hard you try to put a lipstick on a python.\n\"rename variable\" and \"extract as function\" are tree-oriented features available for all languages in one IDE or another after all, so could it be that quacking like tree-orientation is enough to be tree-orientation? If so, then distinction would be not between languages but between IDEs\/editors:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "vim with this plugin for python is tree oriented, and this notepad.exe for lisp is not"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "default git diff tool is not tree oriented for anything, but difftastic is t-o for lisps"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "etc."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nre \"would be nice to have print()\":\nsame argument: could it be retrofit onto js\/etc? is it enough? Not every list is a valid code in lisp, not any tree is a valid clojure code, not every  printed string would be valid js, but some would be, and there is an eval() in js...\n\nre \"emacs+lisp\": what I meant by \"separate system\" is emacs sends strings-of-code to repl (cider or nrepl etc), not pointer to the root of the tree emacs parsed code into, hence, conceptually, is not any different from html input with js.xhr.post(code-as-str) of string to repl socket.\n\nre \"python shell is not a repl\": is the only difference – python's shell is not your running project's process, but a separate one? so you can't overwrite some fn definition live."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]