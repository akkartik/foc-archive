<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2018-07-13/399377633206_43873346f949174e340e_72.jpg" style="float:left"/>
      <a href="../thinking-together/1552336253.276400.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Felix Kohlgrüber</b>
<span style="margin:2em; color:#606060">2019-03-11 13:30</span><br/>
I discovered Michael L. Van De Vanter and his work today. He's been working on advanced code editors already when I was born and recognized several problems with structure editors a long time ago. I read the following papers [1, 2] and can only recommend them. Especially the idea of using only lexical information for structured editing [2] sounds very interesting. His website [3] lists more publications that might be interesting for this community as well.<br/>[1]: <a href="http://vandevanter.net/mlvdv/publications/the_documentary_structure_o.html">http://vandevanter.net/mlvdv/publications/the_documentary_structure_o.html</a><br/>[2]: <a href="http://vandevanter.net/mlvdv/publications/displaying_and_editing_sour.html">http://vandevanter.net/mlvdv/publications/displaying_and_editing_sour.html</a><br/>[3]: <a href="http://vandevanter.net/mlvdv/publications/">http://vandevanter.net/mlvdv/publications/</a><br/><br/>PS: This demo video shows cool things like proportional fonts, managed whitespace and IDE features that still aren't widely used nowadays. And it's from 1994 :astonished:: <a href="http://vandevanter.net/mlvdv/publications/the-clarity-code-processor.html">http://vandevanter.net/mlvdv/publications/the-clarity-code-processor.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552337425.276700"></a>
      <img src="https://avatars.slack-edge.com/2018-07-13/399377633206_43873346f949174e340e_72.jpg" style="float:left"/>
      <a href="../thinking-together/1552336253.276400.html#1552337425.276700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Felix Kohlgrüber</b>
<span style="margin:2em; color:#606060">2019-03-11 13:50</span><br/>
It's really unfortunate that there aren't more details / demos / code available for the CodeProcessor described in [2]...
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552340432.277400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-03/565459439473_7af440990a8e3cbe92ff_72.jpg" style="float:left"/>
      <a href="../thinking-together/1552336253.276400.html#1552340432.277400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jake Brownson</b>
<span style="margin:2em; color:#606060">2019-03-11 14:40</span><br/>
Thanks for sharing
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552377632.296700"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1552336253.276400.html#1552377632.296700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-03-12 01:00</span><br/>
One of the problems with Van De Vanters work, which was excellent, is that it was based on C, and C is such a low-level language, really a replacement for Assembler, that it would be hard to build something great on top of that language. Its too bad that he didn't pick a more robust language like Modula-2 to base his work, because a strongly typed language like Modula-2 would have allowed for a lot more help from the IDE editor, because the strong naming and type conventions catch a lot of errors and thus the IDE doesn't have to be so smart. This is also the reason JS cannot have a great IDE, because the language itself is so flabby (hence all the preprocessors like TypeScript and CoffeeScript).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552406933.298200"></a>
      <img src="https://avatars.slack-edge.com/2018-07-13/399377633206_43873346f949174e340e_72.jpg" style="float:left"/>
      <a href="../thinking-together/1552336253.276400.html#1552406933.298200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Felix Kohlgrüber</b>
<span style="margin:2em; color:#606060">2019-03-12 09:08</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> That's right, the choice of language has a big impact on how easy it is to build great tools. What I find most interesting in [2] is that his solution works on lexical data (tokens). On that level, the difference between different programming languages shouldn't be that large, right?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552459336.301800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1552336253.276400.html#1552459336.301800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-03-12 23:42</span><br/>
Interesting.. thanks for sharing. You might also like The Cornell Program Synthesizer (from ~79): <a href="https://core.ac.uk/download/pdf/21750999.pdf">https://core.ac.uk/download/pdf/21750999.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552462605.302000"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1552336253.276400.html#1552462605.302000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-03-13 00:36</span><br/>
When i compare the same program written in two different languages, i count the number of words, which is an approximation to the number of tokens, which is a very strong measurement of the effort to originate the program. Whether the tokens are shorter or longer words doesn't matter that much in complexity; APL showed that you could cause the reader to crawl as you deciphered the symbols, and LISP with all the parentheses indicating order of calculation was also extremely difficult to read. Unfortunately tokens are inevitably parsed into a tree, and thus don't read linearly. Our eyes are trained to read words in sequence, so there has always been an interesting tug of war between syntaxes that are easier to read vs. more densely packed.  But back to Felix's question, it is quite surprising that my recent tests have shown with my progression of programs that go from 150 to 1500 words (clock, wristwatch, snake, tictactoe, minesweeper, chess) that as the program size gets to 1500, the different languages start to diverge greatly, and that once you reach that stage they no resemble each other. If the program is very short, then all the programs look almost alike. There are extremely subtle progressive non-linear effects. For example, if you have a complexity coefficient of  1.02 versus 1.10 to the 50th power, one is around 3, and the other is 117, a huge difference. Programs are not linear, there are exponential processes involved, and what appears to be a small advantage of one language over another when applied to a sufficiently large problem., becomes a huge difference in size and complexity. This is my beef with Java, what i refer to as the COBOL of our time. A language which inevitably leads to ponderous, complex monstrosities.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552510862.310000"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1552336253.276400.html#1552510862.310000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-03-13 14:01</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> interesting insights... have you published the results of writing those set of programs in different languages and details of how exactly they start to look different? It definitely seems true that small programs can look somewhat similar in many different languages but large ones have emergent shapes that can differ quite a bit. Substrate determines structure. I assume it's not just the language but the frameworks and libraries in use.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553210747.414100"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1552336253.276400.html#1553210747.414100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-03-21 16:25</span><br/>
I have published on my blog the specifications and ingredients for various small reference programs, starting with a clock (150 words) , then a wristwatch simulation, then snake, tic-tac-toe, minesweeper and ending with chess (no AI, just two player). That project set spans from 150 to 1500 words of code, and have given these challenges to some of the various next gen language teams like Red, Luna, etc. You can also compare them to the various GitHub examples that have been done in longstanding languages like JS, Java, etc.  One thing you immediately have to deal with is the graphical subsystem that the language uses; that is a major factor, and in a lot of older environments they predate the explosion of target devices, and one cannot actually make a resolution-reactive product in these older frameworks without great difficult. Another issue you see immediately when looking at existing toolchains like Objective-C/Swift from Apple is the gigantic number of system API calls you have to learn to do almost anything. You have a dozen major library subsystems to learn, must to make a sound effect, respond to a click, and draw an image. So one of the biggest problems i see is the total number of pages you have to read in order to accomplish these simple functions. Thats what makes a little game maker tool like fancade so outstanding; it manages to boil down the verbs and nouns to a small enough set you can program on a cellphone.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
