[
    {
        "user": "U098P4V8Y6R",
        "type": "message",
        "ts": "1754752241.623379",
        "client_msg_id": "197e9f7f-a924-490b-89f9-ac3ab8c8caf1",
        "text": "Sorry to take so long replying. My minor excuse is a very busy work week. My major excuse is that I had to do some re-reading! Some of Dijkstra's writing is very \"dense\" (in information), so I had to go back and review to get context in my head.\n\nA couple of background thoughts come to mind:\n1. Repetition in imperative programming seems frequently to be taught (and practiced) either in terms of explicit counting or in terms of iterating over some structure (array elements, linked nodes, file lines, etc.) In such cases, the argument for termination is fairly trivial. The bound on remaining work to be done seems \"obvious\".",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gc3ae6a1b8d7",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/c3ae6a1b8d708b79b6b85ecc365266a4.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "Joel",
            "real_name": "Joel Neely",
            "display_name": "Joel Neely",
            "team": "T5TCAFTA9",
            "name": "joel.neely",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1754118705.092259",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OUduo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sorry to take so long replying. My minor excuse is a very busy work week. My major excuse is that I had to do some re-reading! Some of Dijkstra's writing is very \"dense\" (in information), so I had to go back and review to get context in my head.\n\nA couple of background thoughts come to mind:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Repetition in imperative programming seems frequently to be taught (and practiced) either in terms of explicit counting or in terms of iterating over some structure (array elements, linked nodes, file lines, etc.) In such cases, the argument for termination is fairly trivial. The bound on remaining work to be done seems \"obvious\"."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U098P4V8Y6R",
        "type": "message",
        "ts": "1754752415.308649",
        "client_msg_id": "9fcba80a-de69-43e1-b1f4-abef013fb67e",
        "text": "2. In later discussions, Dijkstra went past _a priori_ limits on number of iterations remaining by considering the notion of a \"well-founded set\" (a set with an ordering such that there are no infinite descending chains). That's a rabbit-trail to the side, but makes interesting context for going back and seeing the state of his thinking in 1976.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gc3ae6a1b8d7",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/c3ae6a1b8d708b79b6b85ecc365266a4.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "Joel",
            "real_name": "Joel Neely",
            "display_name": "Joel Neely",
            "team": "T5TCAFTA9",
            "name": "joel.neely",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1754118705.092259",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AXqhM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "2. In later discussions, Dijkstra went past "
                            },
                            {
                                "type": "text",
                                "text": "a priori",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " limits on number of iterations remaining by considering the notion of a \"well-founded set\" (a set with an ordering such that there are no infinite descending chains). That's a rabbit-trail to the side, but makes interesting context for going back and seeing the state of his thinking in 1976."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U098P4V8Y6R",
        "type": "message",
        "ts": "1754753476.322389",
        "client_msg_id": "fc60ce57-5617-42a7-ad4f-f94a4b9c2b83",
        "text": "With all that said, I interpreted Dijkstra's introduction of _tmin_ as a way to grapple with repetition when the reduction of \"work remaining\" doesn't happen by simply counting down, and even may be affected differently based on which guarded statement list is activated (when more than one has a true guard).\n\nEuclid's GCD algorithm makes a nice lab rat for that kind of thinking (especially when one introduces the remainder-based optimization). It makes an interesting exercise to code GCD based on Dijkstra's thought process and decorate the code with output that shows the changing value of the work-remaining metric as it runs.\n\nMy recollection of my experience with the book is that of a very zig-zag journey. Sometimes a subsequent chapter or section would cause an \"Aha!\" that motivating going back to reconsider what I had previously read. I think that the fourth example on page 61 in chapter 8 can play that role relative to chapter 6 (especially after slogging through the detailed discussion of the third example!)\n\nAnd Dijkstra's note at the end of that fourth example illustrates that he sometimes throws in passing comments that actually require very deep thought on the distinction between correctness and performance!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gc3ae6a1b8d7",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/c3ae6a1b8d708b79b6b85ecc365266a4.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "Joel",
            "real_name": "Joel Neely",
            "display_name": "Joel Neely",
            "team": "T5TCAFTA9",
            "name": "joel.neely",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1754118705.092259",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lm5Lh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "With all that said, I interpreted Dijkstra's introduction of "
                            },
                            {
                                "type": "text",
                                "text": "tmin",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as a way to grapple with repetition when the reduction of \"work remaining\" doesn't happen by simply counting down, and even may be affected differently based on which guarded statement list is activated (when more than one has a true guard).\n\nEuclid's GCD algorithm makes a nice lab rat for that kind of thinking (especially when one introduces the remainder-based optimization). It makes an interesting exercise to code GCD based on Dijkstra's thought process and decorate the code with output that shows the changing value of the work-remaining metric as it runs.\n\nMy recollection of my experience with the book is that of a very zig-zag journey. Sometimes a subsequent chapter or section would cause an \"Aha!\" that motivating going back to reconsider what I had previously read. I think that the fourth example on page 61 in chapter 8 can play that role relative to chapter 6 (especially after slogging through the detailed discussion of the third example!)\n\nAnd Dijkstra's note at the end of that fourth example illustrates that he sometimes throws in passing comments that actually require very deep thought on the distinction between correctness and performance!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "subtype": "thread_broadcast",
        "user": "U098P4V8Y6R",
        "thread_ts": "1754118705.092259",
        "root": {
            "user": "UCUSW7WVD",
            "type": "message",
            "ts": "1754118705.092259",
            "client_msg_id": "671ccd73-2157-4ed2-a8e1-8df9f5503a7f",
            "text": "This might be premature, but I think I _finally_ understand Dijkstra's approach to deriving programs from post-conditions in \"A Discipline of Programming\". I've had this book on my bookshelf for almost 20 years, never understood it but also never quite worked up the will to toss it out. (For context, I only own like a dozen books over the long term.)\n\nConcretely, I've made it to the end of Chapter 7. I feel like I understand every bit up until this point.\n\nParts of Chapter 6 and 7 feel very sloppily written! And this is Dijkstra! So either my leaps of interpretation are only leaps because I'm missing something, or my sense of understanding is an illusion :sweat_smile:\n\nHas anyone here made it this far and feel like they understood it? I'd love to talk to you.\n\nIncidentally: I wouldn't have made it in even this my probably 4th attempt, if it wasn't for LLMs. They're better than a rubber duck for talking things over with! It's amazing that they can all converse intelligently about the Dijkstra method, and all I need to do is mention `wp` or `wdec`. Or I know nothing and am incapable of judging anything about this book.",
            "team": "T5TCAFTA9",
            "thread_ts": "1754118705.092259",
            "reply_count": 14,
            "reply_users_count": 3,
            "latest_reply": "1755466818.330469",
            "reply_users": [
                "U098P4V8Y6R",
                "UCUSW7WVD",
                "U05UK5T7LPP"
            ],
            "replies": [
                {
                    "user": "U098P4V8Y6R",
                    "ts": "1754259771.285849"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1754268721.461379"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1754269037.411419"
                },
                {
                    "user": "U05UK5T7LPP",
                    "ts": "1754326775.411869"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1754327682.610629"
                },
                {
                    "user": "U098P4V8Y6R",
                    "ts": "1754752241.623379"
                },
                {
                    "user": "U098P4V8Y6R",
                    "ts": "1754752415.308649"
                },
                {
                    "user": "U098P4V8Y6R",
                    "ts": "1754753476.322389"
                },
                {
                    "user": "U098P4V8Y6R",
                    "ts": "1754777681.018069"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1754780801.287359"
                },
                {
                    "user": "U098P4V8Y6R",
                    "ts": "1755436797.026409"
                },
                {
                    "user": "U098P4V8Y6R",
                    "ts": "1755436888.504089"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1755443502.811449"
                },
                {
                    "user": "U098P4V8Y6R",
                    "ts": "1755466818.330469"
                }
            ],
            "is_locked": false,
            "subscribed": false,
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "vX\/r1",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "This might be premature, but I think I "
                                },
                                {
                                    "type": "text",
                                    "text": "finally",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " understand Dijkstra's approach to deriving programs from post-conditions in \"A Discipline of Programming\". I've had this book on my bookshelf for almost 20 years, never understood it but also never quite worked up the will to toss it out. (For context, I only own like a dozen books over the long term.)\n\nConcretely, I've made it to the end of Chapter 7. I feel like I understand every bit up until this point.\n\nParts of Chapter 6 and 7 feel very sloppily written! And this is Dijkstra! So either my leaps of interpretation are only leaps because I'm missing something, or my sense of understanding is an illusion "
                                },
                                {
                                    "type": "emoji",
                                    "name": "sweat_smile",
                                    "unicode": "1f605"
                                },
                                {
                                    "type": "text",
                                    "text": "\n\nHas anyone here made it this far and feel like they understood it? I'd love to talk to you.\n\nIncidentally: I wouldn't have made it in even this my probably 4th attempt, if it wasn't for LLMs. They're better than a rubber duck for talking things over with! It's amazing that they can all converse intelligently about the Dijkstra method, and all I need to do is mention "
                                },
                                {
                                    "type": "text",
                                    "text": "wp",
                                    "style": {
                                        "code": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " or "
                                },
                                {
                                    "type": "text",
                                    "text": "wdec",
                                    "style": {
                                        "code": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": ". Or I know nothing and am incapable of judging anything about this book."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        "type": "message",
        "ts": "1754777681.018069",
        "client_msg_id": "ac5ad225-0154-4349-a524-9612e55a2fcd",
        "text": "I hadn’t thought about your before-and-after interpretation in quite that way. I’ll have to ponder a bit.\nRegarding your reference to determinism, only some constructions in EWD’s wp-based notation are deterministic! While some cases (e.g. `x := x-y`) are, EWD’s reasoning makes some kinds of determinism a not-very-interesting special case. The “Aha!” moment for me was his solution for `max` in `c := a max b`.\n```if\n   a &gt;= b -&gt; c := a\n[]\n   b &gt;= a -&gt; c :- b\nfi```\nIn the (again, uninteresting) special case that `a = b`,  both guards are true it is perfectly valid to “perform” either of the two guarded commands.",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rX6G5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I hadn’t thought about your before-and-after interpretation in quite that way. I’ll have to ponder a bit.\nRegarding your reference to determinism, only some constructions in EWD’s wp-based notation are deterministic! While some cases (e.g."
                            },
                            {
                                "type": "text",
                                "text": " x := x-y",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ") are, EWD’s reasoning makes some kinds of determinism a not-very-interesting special case. The “Aha!” moment for me was his solution for "
                            },
                            {
                                "type": "text",
                                "text": "max",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in "
                            },
                            {
                                "type": "text",
                                "text": "c := a max b",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "if\n   a >= b -> c := a\n[]\n   b >= a -> c :- b\nfi"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the (again, uninteresting) special case that "
                            },
                            {
                                "type": "text",
                                "text": "a = b",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ",  both guards are true it is perfectly valid to “perform” either of the two guarded commands."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1754780801.287359",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1754781272.000000"
        },
        "client_msg_id": "b7a9a45c-3c80-4808-84aa-e6306d92f7b5",
        "text": "Yeah, after my original commented it occurred to me that Dijkstra is building a framework that includes even compound statements, even if the initial examples consider only simple ones. Supremum probably makes more sense if S is a loop. I'll keep going until I find examples like that.\n\nThe key insight for me is that tmin is only in the context of a single iteration. It's not saying anything about the entire execution of the (containing) loop.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1754118705.092259",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IUMDX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, after my original commented it occurred to me that Dijkstra is building a framework that includes even compound statements, even if the initial examples consider only simple ones. Supremum probably makes more sense if S is a loop. I'll keep going until I find examples like that.\n\nThe key insight for me is that tmin is only in the context of a single iteration. It's not saying anything about the entire execution of the (containing) loop."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]