<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1558776997.044500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-05-25 02:36</span><br/>
Most programming languages seem to be created to satisfy some specific practical need, and aren't explicitly designed to satisfy the Principle of Abstraction. But programmers want to create abstractions, so over time, your language will evolve over time to support an increasingly greater ability to abstract over various kinds of AST nodes. This kind of language evolution can be messy and result in a lot of language complexity.<br/><br/>Gilad Bracha wrote a blog post, "Shadow Domains", that gives a name to the kind of language complexity that arises. This is where the fundamental abstraction mechanisms (the ability to bind language entities to names, the ability to pass language entities as function arguments and return them as results) are re-invented multiple times within the same language, but within different domains.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
