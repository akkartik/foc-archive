[
    {
        "user": "U08294YLWJH",
        "type": "message",
        "ts": "1739265428.437309",
        "client_msg_id": "28f8623d-b1c0-4229-86b9-fca463c46f4b",
        "text": "What if we use GPU \/ NPU \/ TPU to run Prolog several magnitudes faster?\nUsing technique of encoding words into numbers as LLM does?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "54bdcc3cea79",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-11-25\/8077168843205_54bdcc3cea79c3cee9ab_72.jpg",
            "first_name": "Oleksandr",
            "real_name": "Oleksandr Kryvonos",
            "display_name": "Oleksandr Kryvonos",
            "team": "T5TCAFTA9",
            "name": "oleksandr.kryvonos.od",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "reply_count": 14,
        "reply_users_count": 7,
        "latest_reply": "1739804674.223649",
        "reply_users": [
            "U01AD80KMLK",
            "UJBAJNFLK",
            "U08294YLWJH",
            "UGWUJUZHT",
            "U02U0AS3J49",
            "U013ZLJARC7",
            "U040R67M66L"
        ],
        "replies": [
            {
                "user": "U01AD80KMLK",
                "ts": "1739265941.527339"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1739266366.210969"
            },
            {
                "user": "U08294YLWJH",
                "ts": "1739266578.906919"
            },
            {
                "user": "U08294YLWJH",
                "ts": "1739266853.746639"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1739271364.107169"
            },
            {
                "user": "U08294YLWJH",
                "ts": "1739275342.031709"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1739285249.464699"
            },
            {
                "user": "U08294YLWJH",
                "ts": "1739285753.230129"
            },
            {
                "user": "U02U0AS3J49",
                "ts": "1739302576.253349"
            },
            {
                "user": "U02U0AS3J49",
                "ts": "1739302940.906649"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1739392338.707089"
            },
            {
                "user": "U08294YLWJH",
                "ts": "1739396573.834199"
            },
            {
                "user": "U040R67M66L",
                "ts": "1739749743.310879"
            },
            {
                "user": "U08294YLWJH",
                "ts": "1739804674.223649"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TLXPt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What if we use GPU \/ NPU \/ TPU to run Prolog several magnitudes faster?\nUsing technique of encoding words into numbers as LLM does?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1739265941.527339",
        "client_msg_id": "dc15351e-8cef-4d8d-8160-04d8caaf9baf",
        "text": "then prolog programs would be faster",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a07cdcb6d037",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-09\/1376906509376_a07cdcb6d037bf7b6a5e_72.jpg",
            "first_name": "",
            "real_name": "Denny Vrandečić",
            "display_name": "Denny Vrandečić",
            "team": "T5TCAFTA9",
            "name": "dvrandecic",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tuEju",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "then prolog programs would be faster"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "laughing",
                "users": [
                    "UC2A2ARPT",
                    "U013ZLJARC7",
                    "UE1JQM9HQ",
                    "U02N3QJC405",
                    "U06131CATV3",
                    "U0887QU9G2V"
                ],
                "count": 6
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1739266366.210969",
        "client_msg_id": "526217d7-b819-42ff-ac8b-cb29df5bfd60",
        "text": "If I understand correctly what you have in mind, the result would no longer be Prolog.\n\nProlog is a formal language, like every other programming language. In a formal language, symbols mean nothing. They are just convenient labels for human readers, inside the formal system symbols are just equal or not equal. So if you want to replace symbols by numbers, you can just enumerate them by order of occurrence.\n\nWord embeddings as used by LLMs are an interface between formal systems (the stuff running on the GPUs) and informal human language. Combining that with Prolog could lead to interesting results, but it's not faster Prolog.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UKetL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If I understand correctly what you have in mind, the result would no longer be Prolog.\n\nProlog is a formal language, like every other programming language. In a formal language, symbols mean nothing. They are just convenient labels for human readers, inside the formal system symbols are just equal or not equal. So if you want to replace symbols by numbers, you can just enumerate them by order of occurrence.\n\nWord embeddings as used by LLMs are an interface between formal systems (the stuff running on the GPUs) and informal human language. Combining that with Prolog could lead to interesting results, but it's not faster Prolog."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U08294YLWJH",
        "type": "message",
        "ts": "1739266578.906919",
        "client_msg_id": "515ca224-7522-4630-877b-ad08beefe970",
        "text": "yeah, I do not want the actual Prolog, but something similar to it to run 1000x faster",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "54bdcc3cea79",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-11-25\/8077168843205_54bdcc3cea79c3cee9ab_72.jpg",
            "first_name": "Oleksandr",
            "real_name": "Oleksandr Kryvonos",
            "display_name": "Oleksandr Kryvonos",
            "team": "T5TCAFTA9",
            "name": "oleksandr.kryvonos.od",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rZW1l",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yeah, I do not want the actual Prolog, but something similar to it to run 1000x faster"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U08294YLWJH",
        "type": "message",
        "ts": "1739266853.746639",
        "client_msg_id": "b267de60-d582-40b6-b76a-cc8f35a9350d",
        "text": "napkin math here,\nLLM have 1billion parameters, they run at acceptable inference rate on Apple M1,\nif the same compute power can be leveraged for logical inference even redundant\nfor example run 1 million branches of inference with 30% of them potentially beeing same for 1 second\nand see where it gets you",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "54bdcc3cea79",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-11-25\/8077168843205_54bdcc3cea79c3cee9ab_72.jpg",
            "first_name": "Oleksandr",
            "real_name": "Oleksandr Kryvonos",
            "display_name": "Oleksandr Kryvonos",
            "team": "T5TCAFTA9",
            "name": "oleksandr.kryvonos.od",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1hJZA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "napkin math here,\nLLM have 1billion parameters, they run at acceptable inference rate on Apple M1,\nif the same compute power can be leveraged for logical inference even redundant\nfor example run 1 million branches of inference with 30% of them potentially beeing same for 1 second\nand see where it gets you"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1739267834.143229",
        "client_msg_id": "7cfa75cc-b675-4aa2-86ce-d9f966242f0f",
        "text": "FYI: the <http:\/\/draw.io|draw.io> app can be downloaded and run on a local machine.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739223157.101739",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HdhQ+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FYI: the "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/draw.io",
                                "text": "draw.io"
                            },
                            {
                                "type": "text",
                                "text": " app can be downloaded and run on a local machine."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1739271364.107169",
        "client_msg_id": "bb2df7bc-eb40-450a-8b32-5236958d1f25",
        "text": "FWIW: From a hardware\/implementation perspective, the main feature of Prolog is that it performs exhaustive search, and, gives the programmer a way to specify such searches in a declarative - less buggy - way. Loops within loops do this, also, but provide more opportunities for inserting bugs. Prolog does this by generalizing and using backtracking - a technique essentially frowned upon in the early days of computing (due to hardware limitations) (now possible once again). <http:\/\/minikanren.org|MiniKanren> also does exhaustive search, but doesn't use backtracking, trading off memory usage instead. The canonical \"assembler\" for Prolog is WAM - the Warren Abstract Machine - which is used by GNU Prolog (iiuc, GNU Prolog implements Prolog in Prolog (it can be told to show the resulting WAM, which was useful to me when I was trying to write a WAM in Lisp)). A write-up of WAM principles can be found in <https:\/\/github.com\/a-yiorgos\/wambook|Kaci's>. Various lisp-based implementations are documented in <https:\/\/www.google.ca\/books\/edition\/Paradigms_of_Artificial_Intelligence_Pro\/eH6jBQAAQBAJ?hl=en&amp;gbpv=1&amp;printsec=frontcover|PAIP> and <https:\/\/paulgraham.com\/onlisptext.html|On Lisp> and others. IMO, the most understandable implementation of Prolog is <https:\/\/news.ycombinator.com\/item?id=20591771|Nils Holm's Prolog Control in 6 Slides> (the <http:\/\/tx3.org|tx3.org> website is 404'ing on me at this moment). The Holm version is written in Scheme. I found Holm's version so understandable that I even managed to hand-port it to <https:\/\/github.com\/guitarvydas\/cl-holm-prolog|Common Lisp> and to mechanically port it to <https:\/\/guitarvydas.github.io\/2020\/12\/09\/OhmInSmallSteps.html|Javascript> (the main thrust of this was to explore OhmJS, not particularly Prolog, but, it appears to work). I think that the way to speed up a Prolog program, is to remove all generalizations from a specific program, i.e. take a given (working) program and to pre-compile it into a bunch of nested loops written in assembler (and, for extra oomph, remove all need for context-switching). The product of any programming language is to create assembler code for use on a CPU. Some compilers do this by emitting only assembler, some do it by emitting assembler that leans on an engine. I think that Prolog fits into the 'engine' category. Many popular languages fall into the 'engine' category where the engine happens to be a lump of code that implements context-switching (often called \"operating systems\", which usually burn a lot of CPU cycles (something like 7,000-11,000 cycles per context switch, according to Claude 3.5)). Or to find ways to parallelize it (noting that LLMs operate on the principles of massive parallelization, but end up lying to you on occasion (i.e. LLMs in their current state, can't be trusted and they ain't Engineering)). Sequential programming techniques and languages, essentially oppose the existence of massive parallelization, requiring one to think hard to achieve it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "attachments": [
            {
                "from_url": "https:\/\/www.google.ca\/books\/edition\/Paradigms_of_Artificial_Intelligence_Pro\/eH6jBQAAQBAJ?hl=en&gbpv=1&printsec=frontcover",
                "thumb_url": "https:\/\/books.google.com\/books\/publisher\/content?id=eH6jBQAAQBAJ&printsec=frontcover&img=1&zoom=1&edge=curl&imgtk=AFLRE70pSJ3sgq5C61y6VQBM_uQ2o4uCLoMXowIF6e-8M9oSxEQzqEMn5wAXNglX3Eo4K4gfEPWR0v3CTuRhI3RBGjN6rKQ1WpnsC1HWXfv1Q_TyBWcHKw4RcqPMB6UxTr0HtlLthp78",
                "thumb_width": 128,
                "thumb_height": 157,
                "service_icon": "https:\/\/books.google.com\/favicon.ico",
                "id": 1,
                "original_url": "https:\/\/www.google.ca\/books\/edition\/Paradigms_of_Artificial_Intelligence_Pro\/eH6jBQAAQBAJ?hl=en&amp;gbpv=1&amp;printsec=frontcover",
                "fallback": "Google Books: Paradigms of Artificial Intelligence Programming",
                "text": "Paradigms of AI Programming is the first text to teach advanced Common Lisp techniques in the context of building major AI systems. By reconstructing authentic, complex AI programs using state-of-the-art Common Lisp, the book teaches students and professionals how to build and debug robust practical programs, while demonstrating superior programming style and important AI concepts. The author strongly emphasizes the practical performance issues involved in writing real working programs of significant size. Chapters on troubleshooting and efficiency are included, along with a discussion of the fundamentals of object-oriented programming and a description of the main CLOS functions. This volume is an excellent text for a course on AI programming, a useful supplement for general AI courses and an indispensable reference for the professional programmer.",
                "title": "Paradigms of Artificial Intelligence Programming",
                "title_link": "https:\/\/www.google.ca\/books\/edition\/Paradigms_of_Artificial_Intelligence_Pro\/eH6jBQAAQBAJ?hl=en&gbpv=1&printsec=frontcover",
                "service_name": "Google Books"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x0Xvh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FWIW: From a hardware\/implementation perspective, the main feature of Prolog is that it performs exhaustive search, and, gives the programmer a way to specify such searches in a declarative - less buggy - way. Loops within loops do this, also, but provide more opportunities for inserting bugs. Prolog does this by generalizing and using backtracking - a technique essentially frowned upon in the early days of computing (due to hardware limitations) (now possible once again). "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/minikanren.org",
                                "text": "MiniKanren"
                            },
                            {
                                "type": "text",
                                "text": " also does exhaustive search, but doesn't use backtracking, trading off memory usage instead. The canonical \"assembler\" for Prolog is WAM - the Warren Abstract Machine - which is used by GNU Prolog (iiuc, GNU Prolog implements Prolog in Prolog (it can be told to show the resulting WAM, which was useful to me when I was trying to write a WAM in Lisp)). A write-up of WAM principles can be found in "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/a-yiorgos\/wambook",
                                "text": "Kaci's"
                            },
                            {
                                "type": "text",
                                "text": ". Various lisp-based implementations are documented in "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.google.ca\/books\/edition\/Paradigms_of_Artificial_Intelligence_Pro\/eH6jBQAAQBAJ?hl=en&gbpv=1&printsec=frontcover",
                                "text": "PAIP"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/paulgraham.com\/onlisptext.html",
                                "text": "On Lisp"
                            },
                            {
                                "type": "text",
                                "text": " and others. IMO, the most understandable implementation of Prolog is "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/news.ycombinator.com\/item?id=20591771",
                                "text": "Nils Holm's Prolog Control in 6 Slides"
                            },
                            {
                                "type": "text",
                                "text": " (the "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/tx3.org",
                                "text": "tx3.org"
                            },
                            {
                                "type": "text",
                                "text": " website is 404'ing on me at this moment). The Holm version is written in Scheme. I found Holm's version so understandable that I even managed to hand-port it to "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/guitarvydas\/cl-holm-prolog",
                                "text": "Common Lisp"
                            },
                            {
                                "type": "text",
                                "text": " and to mechanically port it to "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/guitarvydas.github.io\/2020\/12\/09\/OhmInSmallSteps.html",
                                "text": "Javascript"
                            },
                            {
                                "type": "text",
                                "text": " (the main thrust of this was to explore OhmJS, not particularly Prolog, but, it appears to work). I think that the way to speed up a Prolog program, is to remove all generalizations from a specific program, i.e. take a given (working) program and to pre-compile it into a bunch of nested loops written in assembler (and, for extra oomph, remove all need for context-switching). The product of any programming language is to create assembler code for use on a CPU. Some compilers do this by emitting only assembler, some do it by emitting assembler that leans on an engine. I think that Prolog fits into the 'engine' category. Many popular languages fall into the 'engine' category where the engine happens to be a lump of code that implements context-switching (often called \"operating systems\", which usually burn a lot of CPU cycles (something like 7,000-11,000 cycles per context switch, according to Claude 3.5)). Or to find ways to parallelize it (noting that LLMs operate on the principles of massive parallelization, but end up lying to you on occasion (i.e. LLMs in their current state, can't be trusted and they ain't Engineering)). Sequential programming techniques and languages, essentially oppose the existence of massive parallelization, requiring one to think hard to achieve it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U08294YLWJH",
        "type": "message",
        "ts": "1739275342.031709",
        "client_msg_id": "019e7dcb-2d23-4dd1-9694-a810be43461d",
        "text": "Yes, I will try to achieve massive parallelization on GPU\/ NPU,\nIt does not necessary mean that I will achieve this, but I will try.\nThanks for all the links.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "54bdcc3cea79",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-11-25\/8077168843205_54bdcc3cea79c3cee9ab_72.jpg",
            "first_name": "Oleksandr",
            "real_name": "Oleksandr Kryvonos",
            "display_name": "Oleksandr Kryvonos",
            "team": "T5TCAFTA9",
            "name": "oleksandr.kryvonos.od",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lmxX9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, I will try to achieve massive parallelization on GPU\/ NPU,\nIt does not necessary mean that I will achieve this, but I will try.\nThanks for all the links."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1739285249.464699",
        "client_msg_id": "919502b7-2ebf-42e0-8689-7b56ba282c05",
        "text": "&gt; I do not want the actual Prolog, but something similar to it\nFrom my perspective, formal and informal reasoning systems are fundamentally different. And that means that what you are envisaging is not similar to Prolog, even if its user interface looks similar.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "biqNm",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I do not want the actual Prolog, but something similar to it"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFrom my perspective, formal and informal reasoning systems are fundamentally different. And that means that what you are envisaging is not similar to Prolog, even if its user interface looks similar."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "fire",
                "users": [
                    "U08294YLWJH"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1739285335.435389",
        "client_msg_id": "8d5d0b8a-d2cf-432a-9831-95cdbadac813",
        "text": "Then you can package it for Guix as well and have a self-sufficient software assembly for local use. Sounds good!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739223157.101739",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/57qC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Then you can package it for Guix as well and have a self-sufficient software assembly for local use. Sounds good!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U08294YLWJH",
        "type": "message",
        "ts": "1739285753.230129",
        "client_msg_id": "38b99a79-863a-40f4-95db-67b1e83601d9",
        "text": "&gt; From my perspective, formal and informal reasoning systems are fundamentally different. And that means that what you are envisaging is not similar to Prolog, even if its user interface looks similar.\nthank you for clarification, as I told, this is more like napkin idea, we shall see if I can bring this to reality",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "54bdcc3cea79",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-11-25\/8077168843205_54bdcc3cea79c3cee9ab_72.jpg",
            "first_name": "Oleksandr",
            "real_name": "Oleksandr Kryvonos",
            "display_name": "Oleksandr Kryvonos",
            "team": "T5TCAFTA9",
            "name": "oleksandr.kryvonos.od",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JcIQk",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "From my perspective, formal and informal reasoning systems are fundamentally different. And that means that what you are envisaging is not similar to Prolog, even if its user interface looks similar."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "thank you for clarification, as I told, this is more like napkin idea, we shall see if I can bring this to reality"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1739302576.253349",
        "client_msg_id": "ebf33ab2-c4c6-4d0d-914f-47cf9bb22976",
        "text": "If there was some way to use GPUs to do resolution faster, that would be great. I think people in the Prolog development community would be all over it, though, and I don't see any signs of that. I would check in with people like Jan Wielemaker on the SWI-Prolog forums and ask for his thoughts on where there is unexplored potential.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HZzjn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If there was some way to use GPUs to do resolution faster, that would be great. I think people in the Prolog development community would be all over it, though, and I don't see any signs of that. I would check in with people like Jan Wielemaker on the SWI-Prolog forums and ask for his thoughts on where there is unexplored potential."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1739302940.906649",
        "client_msg_id": "11efe09c-366c-4ef6-89f6-538a2b625219",
        "text": "I've been working on a logical knowledge base search that uses unification but is based on subgraph isomorphism. It's designed to facilitate different kinds of searches from resolution, and is probably much slower except in those use cases. But it's an interesting space to play in, often because there is no one else trying things. :sweat_smile:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739265428.437309",
        "parent_user_id": "U08294YLWJH",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WEXgP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been working on a logical knowledge base search that uses unification but is based on subgraph isomorphism. It's designed to facilitate different kinds of searches from resolution, and is probably much slower except in those use cases. But it's an interesting space to play in, often because there is no one else trying things. "
                            },
                            {
                                "type": "emoji",
                                "name": "sweat_smile",
                                "unicode": "1f605"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]