<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-01-15 22:33</span><br/>
<b>Perhaps all programming is distributed programming?</b><br/><br/>This little thread is melting my mind: <a href="https://queer.af/@erincandescent/105562630364133151">https://queer.af/@erincandescent/105562630364133151</a><br/><br/>My mindset for the past 5 years has been that UX = gradual teaching on demand = never lying to the end-user, which implies never telling big lies, only little white lies that are easy to push aside to learn more. But at the heart of everything I did is the big lie that I'm programming "a" single unitary computer.<br/><br/>I've always known about many little controllers in our computers, but my mind treated them as exceptions. I think society has this consensual hallucination that software runs "on top of" hardware. The past six months (starting from my old realizations about BIOS: <a href="../two-minute-week/1599112907.014300.html">../two-minute-week/1599112907.014300.html</a>) have been a slow, painful journey to come to grips with this fact.<br/><br/>Bat signal to <span style="background-color:#ccf">@Charlie</span>; this is fodder for your old thread from May 2019 that most software is built across collections of computers. <span style="background-color:#ccf">@Ian Bicking</span> too had a post around the same time that messaging and communication are all, that decomposition is trivial, that focusing on "programming" is often a modernist approach. If we started from the assumption that "coding" is about orchestrating groups of computers, what would we do differently? What does the UX for programming look like if you also have to specify where computations happen? It seems to make Bret Victor's problem much harder. But following Alan Kay, perhaps we don't yet have the "hardest and most profound thing to then build every easier thing out of".<br/><br/>I'm also thinking about Dave Ackley's <a href="https://movablefeastmachine.org">https://movablefeastmachine.org</a>. He started out in security, so he likely knew all this when he started out on his project. You can't secure your computing substrate if you aren't thinking about 90% of the computers in it.<br/><br/>Anyways, likely the fever dream will break in a day or two and I'll go back to ~lying to myself~ programming my little computer. But I thought I'd throw this out while it's fresh.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610781197.014800"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610781197.014800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2021-01-15 23:13</span><br/>
I'm definitely of the opinion that distribution should be built into the semantics of every programming language (actors etc.), rather than exposed as a library. That suggestion probably isn't too controversial within this community :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610800535.017600"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610800535.017600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2021-01-16 04:35</span><br/>
There are all the little systems inside our computers that are somewhat hidden from us, because we usually — even as developers — don't get to access them directly. The system takes care of that for us, and we get to benefit from faster image (de)compression or video de-/encoding or disk encryption etc. with API calls that look just like any other API call, but hook into these other processing units offloading some work from the CPU.<br/><br/>But that's just half the picture. We also more and more program different processors explicitly, with completely different paradigms: CPUs, GPUs, TPUs, … If your OS lights up pixels on a screen, but doesn't utilize the dedicated graphics processing capabilities of your hardware, you are not using your system "correctly". Or at least as effectively and likely also efficiently as you could (should?).<br/><br/>And it's only going to get worse, because this complexity is not going to go away. Now with Intel under extreme pressure the times of standardization are over. Sure, everybody will have SoCs soon, and it looks like a form of simplification. But market forces push everyone to differentiate, which will only lead to more complexity on that level. There might be a swing back to the opposite in the far future, when the landscape is much more fragmented than it is today and the commercial benefits of diversification have been used up so that consolidation can kick in again. Until then, it's going to be messy for a while.<br/><br/>I wonder if projects with the goal of simplifying the stack are better off building against a virtualization layer instead of trying to keep up with the further diversifying landscape of hardware architectures. Basically, bring your own (virtual) machine (and perhaps even instruction set), and let the virtualization/emulation figure out translation to actual hardware instructions. You'll likely do exactly that for testing already anyway.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610829657.017900"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610829657.017900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-16 12:40</span><br/>
&gt; What does the UX for programming look like if you also have to specify where computations happen?<br/>I love this question. I think this was one of <a href="https://youtu.be/gCWtkvDQ2ZI?t=2158">the fundamental questions</a> that drove the creation of the <a href="https://www.unisonweb.org">Unison Language</a> iirc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610830386.018300"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610830386.018300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-16 12:53</span><br/>
In another life, when the first generation of Nvidia GPU's that supported CUDA were released, I was working under a National Science Foundation grant to port some algorithms related to GIS (among other things) to run on GPUs. The biggest problem was getting data from the CPU to the GPU and back. GPU's had relatively small onboard memory at the time, and it was very easy to saturate the PCI bus when trying to move the data back and forth. It proved to be a huge bottleneck, and really broke any illusions of "a single machine."
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610851829.020900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610851829.020900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2021-01-16 18:50</span><br/>
&gt; <b>Perhaps all programming is distributed programming?</b><br/>Yes, yes, yes!<br/><br/>Its just that we have established models and tools to create a "single computer" abstraction out of <em>certain kinds</em> of smaller computers, e.g. the "PC" bundle.<br/><br/>One way I look at this is to see a bundle as having observable, consistent states and "inner bundles". Consider this statement in a C like language:<br/><tt>i = j + 1</tt><br/>This "C-system" (language + runtime) executes the above statement - you have values for i and j, then after the step, you have a new value for i. To simplify you have the "state before" and "state after". But if we look at the same system as a collection of "inner-systems", the transition consists of various nested states such as moving bits from memory to a register, an operation on the register, then moving it back to anther place in memory. Now the question is: if the first MOV has happened, but addition has not, what is the state <em>in terms of the C-computer?</em> It's not inconsistent, maybe it's in transition? Certainly it is on its way to being consistent and visible in outer system. We can go deeper than MOV - a register isn't a single physical array of memory in the CPU (neither is a "location in memory") - theres caches and other kinds of <em>inner-systems</em> all the way. One observable transition in the outer system contains many transitions in the inner systems.<br/><br/>&gt; What does the UX for programming look like if you also have to specify where computations happen?<br/>This has been on my mind too and I think for certain parts of programs, we specifically don't want to specify where the computation happens. This is what I sometimes call <em>topology</em> _independent_ programs. Note that location presumes a addressing space. Above, in the C-system, there is no location (the C-system is whole world) and when we zoom into it, we see locations such as cpu, ram, AX, BX or whatever. The compiler made that mapping for us - it organized the inner systems to appear as if its one outer system. (But we could have too, and there are many alternative locations and ways to map that would have all worked out just fine). However if we zoom out from the C-system to a distributed database (or whatever it is part of), the single C-system is now one location in a larger address space, but the database-system will have location independent concepts like a <em>table</em>. I think to specify <em>where</em> computation happens, we need to build this idea of mapping the outer-system meaning to the inner-system meaning and distinct address spaces. To do this in a general way would mean we can always scale out to the next level using the same mapping ideas as we did at the previous step out.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610854517.027100"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610854517.027100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2021-01-16 19:35</span><br/>
this is a great thread and i’m mostly commenting to get notified, but the one thing i’d like to point out is that for whatever reason, it’s pretty <em>easy</em> to forget (or never learn) that all these chips are working together. it’s pretty rare that just the microcontroller for your ram stick needs to be restarted, and it’s even rarer that a failing stick corrupts your word documents. are there any system design lessons we can learn from that? why is it easier to make these smaller and cheaper components reliable than it is to make servers reliable?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610874234.027400"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610874234.027400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-01-17 01:03</span><br/>
The single-process serial computation (aka "Turing machine") is a useful abstraction. It corresponds nicely to how people perform symbolic manipulations by hand. It's also much easier to reason about than distributed computing models.<br/><br/>Given that the Turing Machine abstraction won't (and shouldn't) go away, let me rephrase the topic of this thread: should it be the dominant abstraction for developing software system? Certainly not. Perhaps the mistake is to consider it a more fundamental abstraction than distributed models, and try to implement the latter in terms of the former. Perhaps it should be the other way round: implement the Turing Machine as a high-level abstraction on top of a more powerful one, as a useful simplification to use when appropriate.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610910164.027700"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610910164.027700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-01-17 11:02</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> Does Erlang (aka Actor Model) feel like a more powerful model?<br/><br/>There's also the Smalltalk model of an internet of computers.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610956904.029300"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610956904.029300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-01-18 00:01</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> I have next to no real-life experience with distributed computing, so I'll leave such questions to others. Everything I have personally used sucks (that's mostly MPI for parallel scientific computing).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610979942.029900"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610979942.029900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2021-01-18 06:25</span><br/>
+1 with <span style="background-color:#ccf">@Konrad Hinsen</span> on the terribleness of MPI. I like Actors and pi calculus, but for networked things you really need to build for both component failure and network partition. Erlang is the best thought out thing in production that I've seen in this regard.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610986878.030300"></a>
      <img src="https://secure.gravatar.com/avatar/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610986878.030300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Naveen Michaud-Agrawal</b>
<span style="margin:2em; color:#606060">2021-01-18 08:21</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> I think Smalltalk's original model (going back to Kay's 1-page description of Smalltalk) is that each object in the system represents a mini-computer (or better a computational process). I recall him writing somewhere that even by the late 70s he felt Smalltalk could be done better, and the official Smalltalks had reified too much of the interesting bits to be able to evolve.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610987256.030600"></a>
      <img src="https://secure.gravatar.com/avatar/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610987256.030600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Naveen Michaud-Agrawal</b>
<span style="margin:2em; color:#606060">2021-01-18 08:27</span><br/>
To <span style="background-color:#ccf">@Stefan Lesser</span>'s point, if more SOCs exposed the microcode of the system, it would be possible to defer 'reification' of software to hardware until the last minute, providing a lot more flexibility. So you could imagine a VM that could customize the processor it was running on to optimize the way it ran, ie instead of JIT'ing the running of the VM, you reify the operations the VM needs to run efficiently down to the hardware level. From Kay:  "Another example: all the Parc personal computers of various kinds were microcoded, and in the latter 70s you could sit down to any of them to e.g. run Smalltalk, whose image would be sent from a server, and the machine type would select the special microcode for the Smalltalk VM on that machine."
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610987328.030900"></a>
      <img src="https://secure.gravatar.com/avatar/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610987328.030900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Naveen Michaud-Agrawal</b>
<span style="margin:2em; color:#606060">2021-01-18 08:28</span><br/>
That quote was from a comment to one of his answers on quora starting with "We need to note that the plan": <tt> <a href="https://www.quora.com/How-old-is-cloud-computing/answer/Alan-Kay-11?comment_id=179237241&amp;comment_type=2">https://www.quora.com/How-old-is-cloud-computing/answer/Alan&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610987366.031200"></a>
      <img src="https://secure.gravatar.com/avatar/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610987366.031200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Naveen Michaud-Agrawal</b>
<span style="margin:2em; color:#606060">2021-01-18 08:29</span><br/>
I think Alan made a comment that's stuck with me for a long time - hardware is just reified software
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610987504.031400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610987504.031400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-01-18 08:31</span><br/>
I actually sent him my OP -- and he responded among other things with that exact quote :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610987526.031600"></a>
      <img src="https://secure.gravatar.com/avatar/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610987526.031600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Naveen Michaud-Agrawal</b>
<span style="margin:2em; color:#606060">2021-01-18 08:32</span><br/>
ah would love to see his response, if it doesn't feel intrusive to share
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610987576.031800"></a>
      <img src="https://secure.gravatar.com/avatar/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610987576.031800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Naveen Michaud-Agrawal</b>
<span style="margin:2em; color:#606060">2021-01-18 08:32</span><br/>
i have a bot that checks his quora feed, i've been devouring his answers and follow-on comments. Always feels like I'm getting a small peak into the blue plane. I wish that he could one day release a book or even a set of his collected writings in one place.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610987588.032000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610987588.032000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-01-18 08:33</span><br/>
Actually it was only one other thing: <a href="https://www.youtube.com/watch?v=AnrlSqtpOkw&amp;t=135s">https://www.youtube.com/watch?v=AnrlSqtpOkw&amp;t=135s</a><br/><br/>Which was interesting to rewatch in this context.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610987839.032500"></a>
      <img src="https://secure.gravatar.com/avatar/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610987839.032500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Naveen Michaud-Agrawal</b>
<span style="margin:2em; color:#606060">2021-01-18 08:37</span><br/>
Yep, I love that version of Smalltalk. I've been trying to see if I could get it running baremetal on a raspberrypi and give it to my kids and see what they can do with it
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610988149.032700"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1610988149.032700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-01-18 08:42</span><br/>
I'd love to hear if you do.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611050680.037000"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611050680.037000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-01-19 02:04</span><br/>
That video is depressing, considering that what we have today in terms of "personal dynamic media" is at the same time more complicated and more limited. As far as I can see, even today's Smalltalks (Squeak, Pharo) don't support this.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611079635.037300"></a>
      <img src="https://secure.gravatar.com/avatar/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611079635.037300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Naveen Michaud-Agrawal</b>
<span style="margin:2em; color:#606060">2021-01-19 10:07</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> sure, will post here when I get it working. I'm using <a href="https://github.com/michaelengel/crosstalk">https://github.com/michaelengel/crosstalk</a> as a base, with modifications to support the smalltalk version used above
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611081030.037700"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611081030.037700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 10:30</span><br/>
I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions (especially something as high level as an actor model) because the constraints and failure cases tend to be wildly different
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611081432.037900"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611081432.037900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 10:37</span><br/>
I don't know of any consumer hardware that will continue to run if say, its GPU just dies
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611081494.038100"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611081494.038100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 10:38</span><br/>
but in a true distributed system (you usually) care about robustness for potentially many machines that have much different uptime requirements than a consumer device
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611094589.038500"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611094589.038500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 14:16</span><br/>
<span style="background-color:#ccf">@Scott Anderson</span> I'm going to play devils advocate here :smiling_imp:<br/>&gt; I don't know of any consumer hardware that will continue to run if say, its GPU just dies<br/>I have a direct counter example:<br/>I have two GPU's in my laptop, the one bundled with my CPU, and an "external" Nvidia card. The Nvidia card regularly has driver failures and my laptop falls back to the on die graphics card.<br/><br/>This is almost seamless, and very much a distributed system. OS kernels handle these kind of driver failures all the time, and they are conceptually very similar to a distributed database that experiences a network partition.<br/><br/>Some more extreme examples are Plan9 "everything is a file" and EMACS TRAMP. Both are examples of abstractions that cross both file system and network boundaries with similar semantics and error cases.<br/><br/>referring back to my earlier story about my National Science Foundation work, there was one group of grad students working on GPU's, and another group working on distributed graph algorithms on AWS. We were part of the same umbrella project, and regularly exchanged ideas about how to solve problems.<br/><br/>The constraints and failure cases are not wildly different at all imo.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611095229.038800"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611095229.038800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 14:27</span><br/>
Sure, and there are ways in modern graphics APIs to explicitly manage that there are multiple GPUs. The thing is it's very rare that they have symmetrical capabilities, so if you have a work load that actually needs that Nvidia hardware and you switch to intel integrated graphics, you'll have a worse experience. A language with an actor model that abstracts heterogeneous hardware and treats it as a homogeneous distributed system won't really solve that
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611095638.039000"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611095638.039000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 14:33</span><br/>
And making the cases where it doesn't matter easier doesn't really help anyone I guess? I mean potentially there is an interesting abstraction of a "command buffer" (a circular ring buffer that could look a little bit like messages in actor model systems) and an actor could be an explicit piece of defined hardware that has specific capabilities (both fixed function and code) but programming models and capabilities of different hardware are different enough that I'm not sure how useful it would be
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611095963.039200"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611095963.039200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 14:39</span><br/>
Maybe there is a interesting use case where you can use local or remote compute for the same task and its entirely invisible (don't have a GPU and it automatically uses a cloud GPU)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611096758.039400"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611096758.039400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 14:52</span><br/>
Also device hang\device lost due to a driver crash is not the same as an actual hardware failure.  The OS will recover from that, and as a system wide resource it doesn't practically make sense for applications to handle that.  In some cases  (most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer.  Laptops switch regularly but desktops will by default have embedded GPUs turned off, and don't have the same switching capabilities.  Consoles and smartphone generally have one GPU as part of an SOC, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611097179.039600"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611097179.039600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 14:59</span><br/>
The reason I bring up command buffer as an abstraction is because new consoles have custom I/O hardware that uses a GPU style command buffer model for I/O requests, with the assumption that modern games will be making I/O requests at a similar rate they make draw calls.  Game engines also generally use command buffers to send commands to a render thread (running on another core on the CPU) to drive rendering on the GPU.  It works great when you are mostly pushing data/commands to another device, not so great for frequent two way communication though, because this pattern tends to be used in systems with high-throughput and high latency (relatively speaking, high latency for a GPU is still really low compared to an HTTP request)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611097341.039800"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611097341.039800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 15:02</span><br/>
&gt; I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions<br/>Using the same abstraction does not mean requiring the same constraints.<br/>And continuing with graphics as an example, things like feature flags for OpenGL are used all the time to provide different feature sets depending on hardware capability.<br/>Similarly, Erlang and most actor models have ways to query the available resources for a particular process. Smalltalk has this as well.<br/><br/>&gt; In some cases (most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer.<br/>It is a matter of opinion about what is interesting...<br/>The fact that I can still use my laptop if one of the GPU's fails seems pretty damn useful to me personally, even if the experience is degraded.<br/>In the network case, variable bitrate video is also extremely interesting. If my network is suddenly over saturated or degraded, I used to not be able to play a video on Youtube at all, or my video call would be disconnected.<br/>With variable bitrate streaming, the quality is simply lowered.... Same abstraction, that has built in semantics for heterogenous capabilities (dynamically changing capability btw)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611098365.040000"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611098365.040000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 15:19</span><br/>
Not all applications can gracefully downgrade, and a ton of effort goes into supporting that.  For example, Cyberpunk 2077 got delisted because it actually wasn't playable on last generation console hardware.  If your discrete GPU dies and you're playing the game on PC it will be unplayable (either functionally or actually due to lack of capabilities).  You could apply the same logic to machine learning training and other GPU tasks that require high compute.  Also its great that your laptop keeps running, but I'm not sure how a distributed systems approach in a user land application programming language fixes that?  Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611099503.040200"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611099503.040200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 15:38</span><br/>
Not all distributed databases are usable if the network failure is bad enough, That doesn't mean the abstraction is wrong.<br/>There are always failure cases that cannot be recovered from. It does not mean using an abstraction of heterogenous and distributed computing is a bad model (your original point iiuc).<br/><br/>&gt; Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?<br/>This is exactly what things like micro-kernels and Docker do. IPC is a form of distributed abstraction.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611099909.040500"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611099909.040500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 15:45</span><br/>
&gt; I'm not sure how a distributed systems approach in a user land application programming language fixes that?<br/>The point of exposing these to the user application level is that the application can have a say in how the failure is handled. Cyberpunk 2077 maybe can't run if the GPU fails, but Microsoft Word still can. You want to allow both options.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611100075.040700"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611100075.040700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 15:47</span><br/>
I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?  What features of distributed programming are generally not necessary for local hardware? GPU programmers do have to handle device removed (<a href="https://docs.microsoft.com/en-us/windows/uwp/gaming/handling-device-lost-scenarios">https://docs.microsoft.com/en-us/windows/uwp/gaming/handling&hellip;</a>), which could mean try to reinitialize and reload, and that could mean using a different device, but it also could mean crash or quit.  I'm focused on GPUs because I'm a graphics programmer, but I imagine you could apply this to any specific hardware (storage, audio, etc.) Maybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611100088.041000"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611100088.041000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 15:48</span><br/>
Similarly for security models. In docker or CGroups situation, you may or may not have access to a system resource depending on the security policy. Your application can decide how to handle that. Your database may try to set up a database on a certain file system, but if it doesn't have access, maybe it falls back to a memory backed store.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611100154.041200"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611100154.041200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 15:49</span><br/>
&gt; I'm focused on GPUs because I'm a graphics programmer<br/>I'm a database programmer, so this is fun to compare perspectives :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611100637.041500"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611100637.041500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 15:57</span><br/>
&gt; I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?<br/>&gt; Maybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?<br/>Microkernels are the best practical example I can think of that try to do exactly this: <a href="http://www.microkernel.info">http://www.microkernel.info</a><br/><br/>It's more about security and reliability. It does have a performance cost. (Which I'm sure sounds like pure pain to a GPU programmer lol)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611100790.041700"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611100790.041700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 15:59</span><br/>
Your example about cloud GPU is already here as well, That's basically what Google Stadia is.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611100992.041900"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611100992.041900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-01-19 16:03</span><br/>
When I started the thread I was thinking about all the ways in which non-programmable processors (built out of programmable components!) hide inside our computers. It's a place for bugs and especially security issues to hide. It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them. I said "distributed computing" just because it was the closest term I could think of, but it did pull in unintended connotations that it's been interesting to see explored :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611101248.042100"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611101248.042100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 16:07</span><br/>
&gt; It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them.<br/>This sounds like the idea of a microkernel taken to the level of firmware / BIOS / UEFI. Sounds like an awesome research project to explore :star-struck:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611101846.042300"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611101846.042300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 16:17</span><br/>
I'm also reminded of a podcast I listened to a while ago: <a href="https://oxide.computer/podcast/on-the-metal-3-ron-minnich/">https://oxide.computer/podcast/on-the-metal-3-ron-minnich/</a><br/>Google does some of this kind of thing on their servers, and also on chrome-books with U-root. (Trusting trust type stuff at the firmware level.)<br/>It's frustratingly difficult because the hardware vendors do not want this. It has taken companies like Google, Facebook, and Amazon to strong arm them into opening up their firmware more....
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611102388.042700"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611102388.042700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-01-19 16:26</span><br/>
Also, Alan Kay's quote as mentioned by <span style="background-color:#ccf">@Naveen Michaud-Agrawal</span><br/>&gt; "Another example: all the Parc personal computers of various kinds were microcoded, and in the latter 70s you could sit down to any of them to e.g. run Smalltalk, whose image would be sent from a server, and the machine type would select the special microcode for the Smalltalk VM on that machine."<br/>I remember talking to <span style="background-color:#ccf">@Kartik Agaram</span> about this exact quote a while ago.<br/>The closest modern equivalent we have is probably FPGAs.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1611107643.043300"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1610778816.014400.html#1611107643.043300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2021-01-19 17:54</span><br/>
Yeah I was probably being way too specific about what the definition of distributed system is now that we're explicitly talking about distributed systems <b>within</b> hardware. Back to the original post, what I know of FPGA architecture, it's laid out in a similar way as MFM
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
