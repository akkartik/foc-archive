[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1756996489.307289",
        "client_msg_id": "972a9481-19f2-4395-b955-26c7257e8b62",
        "text": "Pond'ring aloud:\nWe know that \"loop\" is recursion, but recursion is often expressed in too-academic a manner.\nWe know that recursion consists of 2 parts:\n1. termination case\n2. recursion case.\nI'm thinking about what might be a less-inhumane syntax for expressing a recursive solution. Suitable for non-programmers and LLMs?\n\n[aside: the goal is not \"efficiency\" at the machine level, but expressiveness and human (non-programmer) understandability]\n\n\n```humane syntax???:\n----------------\n\nbreak down member (x, list) -&gt; ([#found | #not-found], value) {\n    finish when list is empty { ^ #not-found, ɸ }\n    finish when x in list     { ^ #found, list }\n    decompose list' &lt;- rest (list) {\n\t    ^ again (x, list')\n\t}\n}\n\nbreak down append (x, list) -&gt; value {\n    finish when list is empty { ^ x }\n    decompose «item» &lt;- first (list), «list'» &lt;- rest (list) {\n        ^ prepend «item» onto again (x, «list'»))\n    }\n}```\n\n```inhumane syntax:\n----------------\n\n(defun my_member (x lis)\n  (cond ((null lis) (values nil nil))\n        ((eq x (car lis)) (values t lis))\n\t(t (my_member x (cdr lis)))))\n\n\n(defun my_append (lis x)\n  (cond ((null lis) x)\n        (t (cons (car lis) (my_append (cdr lis) x)))))```\n\n[aside: \"send ...\" sends something forward asynchronously instead of returning it synchronously to the caller and unblocking the caller]\n```less-inhumane syntax involving async ports:\n-------------------------------------------\n\nbreak down member (x, list) output ports: { success: [#found | #not-found], value: object } {\n    finish when list is empty { send success: #not-found, send value: ɸ }\n    finish when x in list     { send success: #found, send value: list }\n    decompose list' &lt;- rest (list) {\n\t    ^again (x, list')\n\t}\n}\n\nbreak down append (x, list) output port: { value: object } {\n    finish when list is empty { send value: x }\n    decompose «item» &lt;- first (list), «list'» &lt;- rest (list) {\n        send value: prepend «item» onto ^again (x, «list'»))\n    }\n}```\nsuggestions \/ comments?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1756996489.307289",
        "reply_count": 8,
        "reply_users_count": 4,
        "latest_reply": "1757156851.606799",
        "reply_users": [
            "UCUSW7WVD",
            "U08DYF4SEAE",
            "UGWUJUZHT",
            "U07BD7U4S4R"
        ],
        "replies": [
            {
                "user": "UCUSW7WVD",
                "ts": "1757006561.532639"
            },
            {
                "user": "U08DYF4SEAE",
                "ts": "1757006766.902639"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1757010833.882319"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1757012739.547489"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1757013530.496009"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1757015228.541209"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1757015384.150139"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1757156851.606799"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8yMvX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Pond'ring aloud:\nWe know that \"loop\" is recursion, but recursion is often expressed in too-academic a manner.\nWe know that recursion consists of 2 parts:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "termination case"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "recursion case."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI'm thinking about what might be a less-inhumane syntax for expressing a recursive solution. Suitable for non-programmers and LLMs?\n\n[aside: the goal is not \"efficiency\" at the machine level, but expressiveness and human (non-programmer) understandability]\n\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "humane syntax???:\n----------------\n\nbreak down member (x, list) -> ([#found | #not-found], value) {\n    finish when list is empty { ^ #not-found, ɸ }\n    finish when x in list     { ^ #found, list }\n    decompose list' <- rest (list) {\n\t    ^ again (x, list')\n\t}\n}\n\nbreak down append (x, list) -> value {\n    finish when list is empty { ^ x }\n    decompose «item» <- first (list), «list'» <- rest (list) {\n        ^ prepend «item» onto again (x, «list'»))\n    }\n}"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "inhumane syntax:\n----------------\n\n(defun my_member (x lis)\n  (cond ((null lis) (values nil nil))\n        ((eq x (car lis)) (values t lis))\n\t(t (my_member x (cdr lis)))))\n\n\n(defun my_append (lis x)\n  (cond ((null lis) x)\n        (t (cons (car lis) (my_append (cdr lis) x)))))"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\n[aside: \"send ...\" sends something forward asynchronously instead of returning it synchronously to the caller and unblocking the caller]\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "less-inhumane syntax involving async ports:\n-------------------------------------------\n\nbreak down member (x, list) output ports: { success: [#found | #not-found], value: object } {\n    finish when list is empty { send success: #not-found, send value: ɸ }\n    finish when x in list     { send success: #found, send value: list }\n    decompose list' <- rest (list) {\n\t    ^again (x, list')\n\t}\n}\n\nbreak down append (x, list) output port: { value: object } {\n    finish when list is empty { send value: x }\n    decompose «item» <- first (list), «list'» <- rest (list) {\n        send value: prepend «item» onto ^again (x, «list'»))\n    }\n}"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "suggestions \/ comments?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1757006561.532639",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1757006859.000000"
        },
        "client_msg_id": "b35a8e63-0646-4a1e-98e1-72ac3a6b5b41",
        "text": "I don't really have a sense for what about the first syntax make it seem more \"humane\" to you. But FWIW, here's how Dijkstra (likely also \"too-academic\") would implement `member` and `append`, respectively:\n\n```i := list.lob;\ndo\n  i <= list.hib and list(i) != x -> i := i+1\nod\n{i now describes where to find x, if valid}```\n```list:hiext(x)```\n(At least as of 1977, Dijkstra doesn't seem to think about function boundaries at all.)\n\n(Dijkstra recommended designing data structures out of arrays, in the way Lisp designs them out of cons pairs.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1756996489.307289",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Wr6P2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't really have a sense for what about the first syntax make it seem more \"humane\" to you. But FWIW, here's how Dijkstra (likely also \"too-academic\") would implement "
                            },
                            {
                                "type": "text",
                                "text": "member",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "append",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", respectively:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "i := list.lob;\ndo\n  i <= list.hib and list(i) != x -> i := i+1\nod\n{i now describes where to find x, if valid}"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "list:hiext(x)"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n(At least as of 1977, Dijkstra doesn't seem to think about function boundaries at all.)\n\n(Dijkstra recommended designing data structures out of arrays, in the way Lisp designs them out of cons pairs.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U08DYF4SEAE",
        "type": "message",
        "ts": "1757006766.902639",
        "client_msg_id": "6aab8d01-d2fe-47bf-a259-c12d3f52a1f0",
        "text": "So in your language, would it be illegal to make a recursive call? Requiring the use of this special syntax?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "af3f4f3c0604",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-02-18\/8487018839873_af3f4f3c0604a679e817_72.jpg",
            "first_name": "When",
            "real_name": "When Leggett",
            "display_name": "When Leggett",
            "team": "T5TCAFTA9",
            "name": "russ",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1756996489.307289",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "88CN8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So in your language, would it be illegal to make a recursive call? Requiring the use of this special syntax?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1757010833.882319",
        "client_msg_id": "468b61d1-6859-494d-ab2a-d79140f07cfa",
        "text": "This isn't an attempt to banish recursion, only to capture its essence and give it a different (better?) syntax.\n\nI am tinkering and brainstorming with ideas. I don't necessarily believe in this particular syntax, but, I do know that trying _something_, then critiquing it tends to move ideas forward...\n\nIMO, the essence of recursion is: divide and conquer.\n\nI am trying to do something that I thought would be simple, but am finding that it requires way more detail than I would expect anyone but a programmer would have the patience for. I have been trying to explain to an LLM (Claude 4.0) what I want, but, it keeps making blunders (due to my fault in not supplying enough niggly details, it gets really, really close, but always leaves out some important detailed edge-case).\n\nSyntax-wise, I know that Loop is too low-level and leaves too many foot-guns lying around. Recursion is better, but too weird-looking. I'm wondering if there is a way to express the essence of divide-and-conquer in a less inhumane way. Maybe this needs multiple syntaxes? Or, maybe it just can't be expressed any better. We do see lots of attempts to define and improve on low-level loop, for, while, etc. syntaxes.\n\nThe Dijkstra thing smacks of too much low-levelness, esp. to someone who thinks that an array is just a list with its CDRs optimized away.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1756996489.307289",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "j+I53",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This isn't an attempt to banish recursion, only to capture its essence and give it a different (better?) syntax.\n\nI am tinkering and brainstorming with ideas. I don't necessarily believe in this particular syntax, but, I do know that trying "
                            },
                            {
                                "type": "text",
                                "text": "something",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", then critiquing it tends to move ideas forward...\n\nIMO, the essence of recursion is: divide and conquer.\n\nI am trying to do something that I thought would be simple, but am finding that it requires way more detail than I would expect anyone but a programmer would have the patience for. I have been trying to explain to an LLM (Claude 4.0) what I want, but, it keeps making blunders (due to my fault in not supplying enough niggly details, it gets really, really close, but always leaves out some important detailed edge-case).\n\nSyntax-wise, I know that Loop is too low-level and leaves too many foot-guns lying around. Recursion is better, but too weird-looking. I'm wondering if there is a way to express the essence of divide-and-conquer in a less inhumane way. Maybe this needs multiple syntaxes? Or, maybe it just can't be expressed any better. We do see lots of attempts to define and improve on low-level loop, for, while, etc. syntaxes.\n\nThe Dijkstra thing smacks of too much low-levelness, esp. to someone who thinks that an array is just a list with its CDRs optimized away."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1757012739.547489",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1757012747.000000"
        },
        "client_msg_id": "b64e574a-3d79-4253-8762-92d6cc097a0b",
        "text": "Programming is like a Necker cube. Each of us has a slightly different perspective on what is good and what is bad. The interesting question for me lately is: at what point should one give up on finding an axis of good-bad that everyone will get on board with, and instead focus on other aspects that seem more well-posed.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1756996489.307289",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yZ+DD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Programming is like a Necker cube. Each of us has a slightly different perspective on what is good and what is bad. The interesting question for me lately is: at what point should one give up on finding an axis of good-bad that everyone will get on board with, and instead focus on other aspects that seem more well-posed."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1757013530.496009",
        "client_msg_id": "667f236a-f465-49c6-a173-a4bd497eb2d8",
        "text": "I agree, with the nuance that there are multiple possible syntaxes \/ perspectives. There's what academic-analysts think is useful, there's what programmers think is useful, there's what non-programmers think is useful, etc. LLMs seem to come close to providing syntax for non-programmers, but, in this case, the LLM couldn't infer sufficient detail from my prompt. In other cases, I asked for smaller snippets and was very satisfied. I wonder what the \"grain\" size is for getting reliable results?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1756996489.307289",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7uoGK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree, with the nuance that there are multiple possible syntaxes \/ perspectives. There's what academic-analysts think is useful, there's what programmers think is useful, there's what non-programmers think is useful, etc. LLMs seem to come close to providing syntax for non-programmers, but, in this case, the LLM couldn't infer sufficient detail from my prompt. In other cases, I asked for smaller snippets and was very satisfied. I wonder what the \"grain\" size is for getting reliable results?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1757015228.541209",
        "client_msg_id": "02ea8344-2206-4d95-88de-10515cbe4bb5",
        "text": "Absolutely, multiple perspectives. That's what I was getting at with the Necker cube analogy. None of them more right than the others. \n\nBut you often strike me as too attached to one perspective and ignoring the others. With any tool you're only going to get out what you put in.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1756996489.307289",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bRHan",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Absolutely, multiple perspectives. That's what I was getting at with the Necker cube analogy. None of them more right than the others. \n\nBut you often strike me as too attached to one perspective and ignoring the others. With any tool you're only going to get out what you put in."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1757015384.150139",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1757015488.000000"
        },
        "client_msg_id": "c5336210-116b-42c4-ac08-2a05d4642f4c",
        "text": "Where I am: Recursion or iteration? Necker cube. Low level or high level? Necker cube. Academics or builders? Necker cube. Natural language or formal language? Necker cube. Correctness or friendliness? Necker cube. Companies or people? People, people, people.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1756996489.307289",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NtL4d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Where I am: Recursion or iteration? Necker cube. Low level or high level? Necker cube. Academics or builders? Necker cube. Natural language or formal language? Necker cube. Correctness or friendliness? Necker cube. Companies or people? People, people, people."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "clap",
                "users": [
                    "U08DYF4SEAE"
                ],
                "count": 1
            }
        ]
    }
]