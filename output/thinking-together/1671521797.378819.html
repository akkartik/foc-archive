<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2022-09-08/4075674207584_59de929720a2fe0a13d8_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jarno Montonen</b>
<span style="margin:2em; color:#606060">2022-12-19 23:36</span><br/>
Any opinions on should <em>the editors in which you edit a structure (AST) rather than text</em> be called Structure Editors, Structured Editors, Structural Editors (just saw <span style="background-color:#ccf">@Peter Saxton</span> use this term in his post), or Projectional Editors? Are all of these synonyms or are they just related in specific ways?<br/><br/>Personally I like Structure Editor the best, as opposed to Text Editor. Although Structured and Structural sound correct, I feel like they refer to the editor UI. Similar to how the terms graphical and visual are used. But a Structure editor could be either visual or textual, so having Structure Editor as the 'base term' would allow being more specific by saying Graphical Structure Editor or Textual Structure Editor. Also, even if technically a structure editor would always use a projection of the structure, I feel like it would be best to reserve the term Projectional Editor to editors that explicitly support multiple projections of the said structure.  However, Projection(al) might be a bit foreign term to people not familiar with the topic, so I would rather just use Structure Editor 99% of the time. I feel like one of the barriers for more widespread usage of structure editors is that you have to explain people what they even are and it would certainly be easier to change this if the developer field could agree on the terminology :slightly_smiling_face:.<br/><br/>Any thoughts?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671522340.337339"></a>
      <img src="https://avatars.slack-edge.com/2022-08-26/3992499177765_78c476adad42ab6cfe32_72.png" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671522340.337339" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Lu Wilson</b>
<span style="margin:2em; color:#606060">2022-12-19 23:45</span><br/>
My vote is for Structure Editor :hand:<br/>"With a text editor, you edit some text that represents your code. With a structure editor, you edit a structure that represents your code." ?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671522542.584069"></a>
      <img src="https://avatars.slack-edge.com/2022-08-26/3992499177765_78c476adad42ab6cfe32_72.png" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671522542.584069" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Lu Wilson</b>
<span style="margin:2em; color:#606060">2022-12-19 23:49</span><br/>
on the other hand, it doesn't roll off the tongue so well, so scrap that
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671522561.744529"></a>
      <img src="https://avatars.slack-edge.com/2022-09-08/4075674207584_59de929720a2fe0a13d8_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671522561.744529" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jarno Montonen</b>
<span style="margin:2em; color:#606060">2022-12-19 23:49</span><br/>
Good choice! :slightly_smiling_face: Although I don't think the thing 'represented' needs to necessary be code.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671522599.037089"></a>
      <img src="https://avatars.slack-edge.com/2022-09-08/4075674207584_59de929720a2fe0a13d8_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671522599.037089" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jarno Montonen</b>
<span style="margin:2em; color:#606060">2022-12-19 23:49</span><br/>
roll off as opposed to Structured or Structural?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671522787.099499"></a>
      <img src="https://avatars.slack-edge.com/2022-08-26/3992499177765_78c476adad42ab6cfe32_72.png" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671522787.099499" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Lu Wilson</b>
<span style="margin:2em; color:#606060">2022-12-19 23:53</span><br/>
I guess swap out 'code' for 'X' depending on the context. <br/>And yes, but that's possibly just an accent thing. Not sure whether to put a glottal stop in between the two words or not :)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671522983.555769"></a>
      <img src="https://avatars.slack-edge.com/2022-09-08/4075674207584_59de929720a2fe0a13d8_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671522983.555769" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jarno Montonen</b>
<span style="margin:2em; color:#606060">2022-12-19 23:56</span><br/>
I feel like for a finn Projectional would be easiest, but out of the other three Structure
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671527182.877669"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671527182.877669" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2022-12-20 01:06</span><br/>
all variations of structur* occur in the literature, but I also prefer "Structure Editor" :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671527232.517079"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671527232.517079" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2022-12-20 01:07</span><br/>
("Projectional editor" means an editor that can project the same underlying structure in multiple ways, so it connotes a sort of meta structure editor.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671541383.577169"></a>
      <img src="https://avatars.slack-edge.com/2022-05-27/3589814658547_fd3b904fdc456648ecb2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671541383.577169" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Václav Blažej</b>
<span style="margin:2em; color:#606060">2022-12-20 05:03</span><br/>
'Structure editor' seems like a good general term, but a software that directly explores and edits AST may be called ... 'AST Editor'?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671556992.672599"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671556992.672599" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-20 09:23</span><br/>
I would call it “Lisp” or a “tree editor”.<br/><br/>Features of the underlying syntax:<br/>very regular syntax, limited choices<br/>recursive definition<br/>machine-readable, machine-writable.<br/><br/>The different views (“projections”) might be called “skins”.  They are micro-syntaxes that make the machine-readable stuff more palatable to humans, i.e. mappings from human-readable -&gt; machine-readable.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671641685.971529"></a>
      <img src="https://avatars.slack-edge.com/2022-09-08/4075674207584_59de929720a2fe0a13d8_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671641685.971529" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jarno Montonen</b>
<span style="margin:2em; color:#606060">2022-12-21 08:54</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> why "Lisp" ?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671650532.079039"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671650532.079039" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-21 11:22</span><br/>
<span style="background-color:#ccf">@Jarno Montonen</span> Squinting:<br/>Lisp source code is: hand-written ASTs<br/>e.g. in a ficticious high level language: <tt>a := b + c</tt><br/>In ficticious Lisp: <tt>(assign a (plus b c))</tt><br/>In real Common Lisp: <tt>(setf a (+ b c))</tt><br/>Lisp’s main operations are tree manipulation operators - CAR, CDR, CONS.  The rest are nice-to-have noise operations that deal with with the contents of tree nodes and/or convenience functions.<br/>Any AST editor boils down to Lisp operations.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671700672.656719"></a>
      <img src="https://avatars.slack-edge.com/2022-06-23/3708469439522_ea29e26e919bc202feb6_72.png" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671700672.656719" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Peter Saxton</b>
<span style="margin:2em; color:#606060">2022-12-22 01:17</span><br/>
What are the list operations for dealing with tagged structures. i.e records and unions. I see how lisp matches to lambda reductions but I've been adding unions/records/effects all based of row types and am unsure what there native manipulations would be
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671713931.376959"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671713931.376959" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-22 04:58</span><br/>
short answer: functions<br/>x.y is really y(x) and is written in Lisp as (y x)<br/>method call self.y(z) is really y(self,z) and is written in Lisp as (y self z)<br/><br/>longer answer: all you get is ASTs (things and lists of things)<br/>Yes, that is very low-level.<br/>McCarthy decided to drape meaning over ASTs, i.e the root node of an AST is a always considered to be a function.<br/>In the past, if you wanted to create more syntactic sugar draped over your ASTs, you would lock yourself away in a room for years and invent a “new language”.<br/>Or, if you were a Lisper, you would create functions called “macros”, but, the resulting syntax always looked like more ASTs (lists).<br/>Character-based syntax was reserved for compiler gurus who knew how to use parser tools.<br/>Today, though: Ohm-JS provides a way to drape character-based syntax over ASTs in an afternoon (it even comes with a REPL for helping you design/debug a syntax - “Ohm-Editor”).  All you need is a toolbag of functionality plus Ohm-JS. (i.e. Common Lisp + Ohm-JS, or, JavaScript + Ohm-JS, or …).  PEG-based parsers (like Ohm) can do things that CFG parsers can’t.  As a result, quickie grammars can be incredibly short (i.e a couple of lines, slightly longer than a REGEX, but way shorter than most YACC-based parsers).<br/>Back to your question: If you want to see other people’s ideas on how to structure data, or if you don’t want to roll your own, see “CLOS”  and “DEFCLASS” and “DEFSTRUCT”.  CLOS method dispatch is different and better and more flexible than the usual OO stuff.<br/><br/>[The learning curve is probably steep.  Lispers are usually glad to help.  There are &gt;1 Lispers here].
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671716960.985979"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671716960.985979" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-12-22 05:49</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> Your reference to "Common Lisp + Ohm-JS" suggests that parsers written in Ohm-JS can be used with languages outside of the JS ecosystem. That's not my impression from looking at the Ohm-JS Web site, which only mentions TypeScript as an alternative target to JavaScript. Is there something I overlooked?<br/>Background: Ohm-JS looks very interesting for some ideas I'd like to play with, but I have investment into JS or Web programming in general.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671775304.698739"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671775304.698739" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-22 22:01</span><br/>
[hmm long answer, I wish it were shorter...]<br/><br/>Correct, the parser technology is built in JavaScript and runs in a browser and in node.js.<br/><br/>I was getting at something else. It’s my fault that the idea wasn’t made clear.  Let’s try again:<br/>1) I generate compilers using Ohm-JS that transpile from syntax I invent to other languages like Common Lisp, Python and JS (I believe that I could do more languages, but I haven’t needed to do so (FYI, I have a P.O.C. WASM generator, but more work is needed (this was my first encounter with WASM and more learning curve is needed))).<br/>2) Then, I run those generated compilers to compile code written in the new languages.<br/>3) Then, I run the generated code on the command line, and, sometimes, in the browser.<br/><br/>Ohm-JS, based on PEG, is the game changer in the way I now look at problems.  CFGs (LR(k), YACC, etc.), REGEX, and, hand-written recursive descent parsers are just too cumbersome to use in the same way that I use Ohm-JS.<br/><br/>As an aside, one of the first things I wrote was a compiler that produced code that could be bolted into an Ohm-JS project, with the result that, in many use-cases, I don’t have to write any JavaScript code at all.  I can write the grammar in Ohm’s grammar syntax and I can write the transform in my own FABrication syntax, which is more succinct than JS.<br/><br/>Further aside: the first thing I did with Ohm-JS was to write a Scheme-subset-to-JS transpiler and used it to convert Nils Holm’s PROLOG in Scheme to JavaScript.<br/><br/>Example: I am deeply interested in true concurrency.  My code uses messages that look like:<br/>⟨a b c d⟩<br/>and I use Ohm-JS to transpile this nano-syntax into something like:<br/>⟨Message a b c d⟩<br/>using 2 specifications:<br/>1. ‛⟪«p» «d» «s» «m»⟫’<br/>2. ‛⟨Message «p» «d» «s» «m»⟩’<br/>N.B. the whole spec for the pattern matching is 1 line long, and, the whole spec for transforming is 1 line long.<br/>This specific example could be done with a Python script (or sed with Unicode support), but there are other details that I’m trying to skip over for this example, e.g. messages might contain other messages recursively, for which it helps to have a parser that can express matching brackets.<br/><br/>The input to Ohm-JS is a JS String.  The output of my FABricator compiler is a JS String.  All of the above steps can be done in one fell-swoop in a JavaScript program that feeds strings to Ohm-JS and calls Ohm-JS twice.  At one point, I need to compile a generated String to executable code.  JavaScript’s “eval()” does this. (A “compiler” is “eval()“)<br/><br/>Example: here’s a contrived example of something that I would never do with YACC, but would do with Ohm-JS:<br/>Contrived Problem: scan this big JavaScript program and list every name of every top-level function.  Using YACC, you need to write a full spec (“grammar”) for JavaScript, with PEG (Ohm-JS), you can say something more obvious and succint: a function is <tt>function id (...) { ... }</tt> where the ‘...’ stuff is anything including recursively bracketed bits.  The point here is not whether I wrote a correct pattern match, but, the difference between “omg, I have to write a grammar for every nook and cranny in JavaScript” vs. writing a grammar with “I don’t care about this part”.  This contrived example can probably be done with a REGEX, but if the problem is expanded to be something like “list every function with the name of each parameter” then REGEX works less-well than a parser.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671785800.274309"></a>
      <a href="../thinking-together/1671521797.378819.html#1671785800.274309" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-12-23 00:56</span><br/>
Thanks <span style="background-color:#ccf">@Paul Tarvydas</span>, that's a very good answer (better long than cryptic!). I was aware of the advantages of PEG, and of the exceptional tooling support in Ohm-JS for PEG. So my summary of your explanation is "Rather than using a PEG library for language X, use Ohm-JS to generate something that you can process in/with language X." You gain better tooling, at the price of build system complexity if your ecosystem is not already JS.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1671979233.520089"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1671979233.520089" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-25 06:40</span><br/>
Addendum: There is “lightweight” pattern matching and “heavyweight” pattern matching.<br/><br/>REGEX falls into the lightweight category, while CFG-based parser generators fall into the heavyweight category.<br/><br/>The terms “lightweight” and “heavyweight” refer to Economy of Expression.<br/><br/>Ohm-JS’s big win is that it fills the gap between REGEX and CFG technologies, enabling a new niche for thought.<br/><br/>Ohm-JS falls into the lightweight category.  Ohm-JS can do things that REGEX can’t do, like recursive matching and matching of balanced constructs.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1673817394.927199"></a>
      <img src="https://secure.gravatar.com/avatar/24ac39488e9c4f2833d087a1343707dc.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1673817394.927199" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Yair Chuchem</b>
<span style="margin:2em; color:#606060">2023-01-15 13:16</span><br/>
To me it seems a question of what you wish to emphasize. You could have a textual structure editor which still in the end saves the code in text files, while projectional editor more clearly communicates that the code is stored as a data structure. Though I agree that the connotation for multiple projections is not helpful.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1674241975.654179"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1671521797.378819.html#1674241975.654179" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2023-01-20 11:12</span><br/>
Among those options, "Structure Editor" seems to me to most clearly convey the intended meaning.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
