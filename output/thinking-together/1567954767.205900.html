<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-08 07:59</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> That’s how I feel about FP. Though no one should take either of our statements of opinion as an argument.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568345450.297000"></a>
      <a href="../thinking-together/1567954767.205900.html#1568345450.297000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-12 20:30</span><br/>
<span style="background-color:#ccf">@Steve Dekorte</span> can you elaborate? We've seen defenses here of OOP (usually taking the form that Java and C++ are not OOP) but never an attack of FP.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568364655.297600"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568364655.297600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-09-13 01:50</span><br/>
Since you've started this, I'm going to jump in instead of getting :popcorn: .. :smile:<br/>I think we can learn from both OO and FP, but being purist is always a mistake.<br/>There.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568387468.307600"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568387468.307600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-13 08:11</span><br/>
One minor point: FP isn't even remotely similar to what the low level execution model of the hardware is. (I'm thinking mostly of the CPU, since you could make an argument that GPU parallel cores are slightly more FP-ish.) This difference means we need to translate our FP code to the CPU execution model, and translate feedback back. The FP translation is generally more lossy and incidentally complex than other language models. For instance, how will you know whether you're optimally using the branch predictor? In C and assembly, you know because you wrote every branch. In higher level procedural / OO languages, it's more likely that your branching constructs map to predictable low-level code. In FP, it's that much harder to know. In something like Prolog, all bets are off.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568393872.308300"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568393872.308300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-09-13 09:57</span><br/>
Yeah, I don't lie awake worrying about that.. :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568394961.310200"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568394961.310200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2019-09-13 10:16</span><br/>
at the very least i support the idea that monads (and other category theoretic concepts) are much easier to understand in a dynamic OOP model, where you add interfaces to a datatype that enforce constraints 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568394980.310900"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568394980.310900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2019-09-13 10:16</span><br/>
so much so that you end up using them without knowing it
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568397296.311400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568397296.311400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-13 10:54</span><br/>
The term "FP" is only loosely defined, so it's better to be more precise when attacking/defending it (or exploring relative strengths/weaknesses, for the less combative).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568397783.311600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568397783.311600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-13 11:03</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> "FP isn't even remotely similar to what the low level execution model of the hardware is." That's certainly true for lazy evaluation in Haskell. Most functional languages use strict evaluation, though. Curv is a referentially transparent, pure functional language, and one reason I chose that is to make it easier to generate code for the GPU. However, Curv also has mutable local variables, assignments and a <tt>while</tt> statement. I include those things to simplify the programming model for imperative programmers, and so that I can transliterate GLSL into Curv without converting loops to tail recursion, etc. So Ivan's statement isn't really true of Curv.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568398152.311800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568398152.311800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-13 11:09</span><br/>
How is Curv referentially transparent and pure in the presence of mutable local variables and assignment?<br/><br/>That fact that you're finding it useful to include imperative constructs suggests exactly the opposite, that <span style="background-color:#ccf">@Ivan Reese</span>'s statement <em>is</em> true of Curv.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568398366.312100"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568398366.312100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-13 11:12</span><br/>
How does Curv do with CPU cache lines? Are you able to control data usage patterns to make sure you're keeping stuff in L1 as much as possible?<br/><br/>My point isn't that FP (as a philosophy) is "bad", or even that common functional language implementations have poor performance. Rather, it's that FP languages like Haskell, Clojure, and Scala, and other non-imperative / high-level / managed languages like Prolog, Smalltalk, Java, JavaScript, etc., tend to make it a <em>primary</em> design goal to abstract away low-level hardware details. They regard that as incidental complexity, or as a security risk, or as a source of error and confusion. I have trouble with that, because I write very (very) performance-sensitive code. So for me, one of the primary goals of FP / declarative / managed languages (broadly) is diametrically opposed to one of my primary concerns.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568398671.312300"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568398671.312300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-13 11:17</span><br/>
I recognize that FP (as a philosophy) has a long list of concrete benefits compared to other paradigms. What's missing is the caveat — those benefits apply iff the things that FP language designers regard as incidental complexities are actually incidental. In games, they often aren't. That's why you see folks like John Carmack praising Racket and immutability (or as C++ people call it, "const correctness" ugh) and pure functions. They're useful ideas. But those same folks continue to write C++, or C. They borrow the good parts of FP philosophy, but don't bother with true FP languages because those languages <em>by necessity</em> put a big wedge between the programmer and the CPU.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568398869.312500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568398869.312500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-13 11:21</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> My main focus is to abstract away from the hardware and make programming easier, so I agree with you. Some theoretician probably has a way to write efficient device drivers in an FP language, but it's not something I'm aware of.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568399198.312700"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568399198.312700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-13 11:26</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> Curv has immutable values, and all functions are pure. It has a referentially transparent expression language, in which the order of evaluation can't be exposed by side effects, and it has a statement language that is imperative. I don't know what paradigm this language belongs to. I call it a pure functional language, but FP culture rejects imperative style programming, so people may argue that it can't be FP, even though it has all the properties I listed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568399320.312900"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568399320.312900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-13 11:28</span><br/>
That sounds a bit like how people categorize Scala — multi-paradigm, where one of those paradigms is functional.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568403386.313700"></a>
      <img src="https://avatars.slack-edge.com/2019-10-07/786673147216_cad501b70b26e7666ed0_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568403386.313700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tim Babb</b>
<span style="margin:2em; color:#606060">2019-09-13 12:36</span><br/>
I don't think that FP tends to be less performant is a particularly strong argument against it. Razor's-edge performance isn't a requirement in order for a language to be useful to people— look at Python, which is ~200 times slower than C, but wildly popular, and IMO a joy to use.<br/><br/>I don't think it's a positive thing if a system makes you think about its internal details in order to use it; that makes it less easy to wield, and just generally it's poor encapsulation. Yes, there are performance critical applications where you do need to micromanage every instruction, and those demand very low level languages/systems. But I'd argue those cases are quite rare, and lie in a problem space that is just about perfectly disjoint from the kind of system we could call a "bicycle for the mind".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568403548.314000"></a>
      <img src="https://avatars.slack-edge.com/2019-10-07/786673147216_cad501b70b26e7666ed0_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568403548.314000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tim Babb</b>
<span style="margin:2em; color:#606060">2019-09-13 12:39</span><br/>
I see the "FoP problem" as needing to push in the direction of "a computer is a magic box that automatically does what you ask it", and "but what are my cache lines doing?!" is very nearly the opposite direction :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568409608.314700"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568409608.314700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-13 14:20</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> I have no formal arguments (and can’t recall ever hearing any for either side). My experience and intuition (for what they’re worth) suggest that immutable objects are useful in some places (like strings &amp; number arguments, immutable proxies to protect ownership, pass by copy for distributed objects, etc), but counter productive in most cases (particularly when trying to enforce these policies on the whole system). By counter productive, I mean people will take longer to produce working code and will produce worse (less understandable, maintainable, scalable, flexible) code when they are required to update all references to an object to change it, at least outside of the realm of some narrow math focused components.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568411668.315300"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568411668.315300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-13 14:54</span><br/>
<span style="background-color:#ccf">@Tim Babb</span> I'm not making a Python. I make FoC tools for people who make detailed, highly-interactive games that run on the web. I also make FoC tools that, themselves, are more like games than text documents. So <em>for me and the users of my tools</em> performance is paramount, and every iota counts. I borrow the ideas of FP where they benefit my needs and don't impose a cost, but in general they're directly opposed to one of my primary concerns.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568411773.315600"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568411773.315600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-13 14:56</span><br/>
Gang — the goal of this thread, as established by <span style="background-color:#ccf">@Kartik Agaram</span>, is to lay out an <em>attack</em> on FP. We're a community of people that, broadly speaking, are all so intimately familiar with FP that we all know the myriad benefits it offers compared to OO, procedural, etc. In present company, FP doesn't need defending.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568411821.315800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568411821.315800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-13 14:57</span><br/>
We <em>should</em> also be the best people to know which skeletons are in the FP closet. Let's have fun pulling them out and dusting them off! Let's not take such an attack personally, and defend the fact that we're (broadly speaking) making good use of FP in our own work. Nobody here needs to be "converted".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568412085.316500"></a>
      <img src="https://avatars.slack-edge.com/2019-10-07/786673147216_cad501b70b26e7666ed0_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568412085.316500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tim Babb</b>
<span style="margin:2em; color:#606060">2019-09-13 15:01</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> True. In the domain of high-perf applications, I completely agree with you. :slightly_smiling_face:<br/><br/>To the point of "FP's biggest skeletons", I think <span style="background-color:#ccf">@Steve Dekorte</span> hits the nail on the head— some problems are best naturally expressed with mutability, and when you give that up, things get messy. That really does feel like a usability/ergonomics problem to me, and I think it's hard to fix.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568412947.316900"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568412947.316900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-13 15:15</span><br/>
It seems like there’s a strong parallel between the immutability vs mutability debate and the static vs dynamic types debate. Most people seem to feel everything must be one or the other, instead of the ideal being to use each where useful. I think they’re all useful in different situations. My beef with “FP” is only with the focus on immutability absolutism.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568413955.317300"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568413955.317300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-13 15:32</span><br/>
For general purpose programming in a pure FP language, that typically requires garbage collection. This has a performance cost that the C/C++/Rust communities consider unacceptable. (GC is not an <b>absolute</b> requirement. Curv uses reference counting, at a cost in expressiveness: there's no way in the language to create cyclic data structures.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568414454.318500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568414454.318500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-13 15:40</span><br/>
Haskell is the only well known functional language that requires immutability. Older functional languages, and current members of the functional family, like O'Caml and F#, support mutable objects. So, in terms of "skeletons", I think it's better to ask what are the limitations of programming in a pure functional style, without using mutable objects. (As a language designer, I also want to ask if there are missing features that would make pure functional programming easier or more widely applicable.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568414751.318900"></a>
      <img src="https://avatars.slack-edge.com/2019-10-07/786673147216_cad501b70b26e7666ed0_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568414751.318900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tim Babb</b>
<span style="margin:2em; color:#606060">2019-09-13 15:45</span><br/>
<span style="background-color:#ccf">@Steve Dekorte</span> I share your distaste for absolutism. When it makes sense, I think languages should not impose a particular style of code-organization on the programmer; that's a design choice for them to make. Classic example: Java saying "OOP is hot, thou shalt make every single part of thine program into OOP"— yuck, even though OOP can be an excellent way to organize some (parts of) programs.<br/><br/>My own project is a pure FP node-and-wire tool, and I wish "FP vs imperative" was a choice to be selected by the programmer, not imposed. But the moment nodes have side-effects, the entire system becomes impossible to reason about (data dependencies appear that are not visible as wires; execution order is determined only by wire-dependency, so the behavior would collapse to non-determinism), so the choice to allow side effects is disastrous for usability. I do offer some niceties like an "imperative loop" node, which contains a network which transforms the previous loop iteration state to the next one. It's still side-effect free, but is less mind-bendy than recursion. Overall I think it is a necessary evil to make a system with simple, limited parts that are easy to reason about.<br/><br/><span style="background-color:#ccf">@Doug Moen</span> Does "immutable" not imply "acyclic"?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568421827.000600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568421827.000600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-13 17:43</span><br/>
Shared mutable state imposes a global complexity tax on all of the code in a program. This "tax" makes programs harder to reason about, and inhibits compiler optimizations. Not all language features impose a tax on code that doesn't use it. That's why some people are "absolutist" about this feature.  At the PWL conference yesterday, there was a beautiful and insightful presentation about how to reason formally about these kinds of issues in programming language design, so that it's not just a matter of taste or opinion. I can't reproduce all the arguments here. <a href="https://pwlconf.org/2019/shriram-krishnamurthi/">https://pwlconf.org/2019/shriram-krishnamurthi/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568422282.000900"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568422282.000900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-13 17:51</span><br/>
<span style="background-color:#ccf">@Tim Babb</span> Haskell supports cyclic immutable data structures, which are constructed using recursive definitions.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568423376.004800"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568423376.004800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-13 18:09</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> “makes programs harder to reason about” for whom? I can tell you that I don’t find it easier to program that way. Am I wrong about myself? 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568424860.010000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568424860.010000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-13 18:34</span><br/>
I like imperative programming too, so <em>touché</em>!<br/><br/>But this thread actually started about OO vs FP rather than any absolutism. I tend to find FP ideas more useful than OO ones, and I find my programs are better when I try to limit mutation. So I don't think OO vs FP is like static vs dynamic typing at all. FP ideas seem strictly superior to OO.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568425107.010200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568425107.010200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-13 18:38</span><br/>
The best parts of OO feel complementary to FP. In the large, OO provides some guidance on how to organize code, while FP provides constraints. The best object-based designs use lots of stateless objects, I think. So the two feel like positive vs negative space, not necessarily in opposition.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568444713.011600"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568444713.011600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-14 00:05</span><br/>
I think what is desired via mutability is the notion of identity. This is quite easily and directly represented in objects. This can and is simulated in FP as well, but the primary ideas bring up a sense of disembodied values floating around and getting transformed. That is my main criticism of FP.. it doesn't start with a stateful substrate or strong notion of identity.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568445112.011800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568445112.011800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-14 00:11</span><br/>
Thus far, we've conjured the following interesting angles of attack:<br/><br/>• [the benefits of FP] apply iff the things that FP language designers regard as incidental complexities are actually incidental<br/>• some problems are best naturally expressed with mutability<br/>• For general purpose programming in a pure FP language, that typically requires garbage collection. This has a performance cost<br/>• [FP] doesn't start with a stateful substrate or strong notion of identity.<br/><br/>What other things do you find lacking about FP? Where does FP have room to grow? At the risk of over-anthropomorphizing: what parts of OO should FP envy? <em>We all know</em> that shared mutable state is a double-edged sword — so what parts of FP are surprisingly dull?<br/><br/>If we can't come up with some <em>really</em> good ones, on par with our total smackdown arguments against OO, what's the more likely reason — that FP is utterly without such shortcomings, or that we just aren't properly seeing them?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568445210.012000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568445210.012000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-14 00:13</span><br/>
<span style="background-color:#ccf">@Shalabh</span> Hmm, at the risk of getting into angels and pinheads, I actually think of FP as providing a stronger sense of identity. Mutation introduces ship-of-theseus effects. Should it be considered the same thing once I've modified it?<br/><br/>Concrete implications:<br/><li> We all know not to modify keys in a hash table.<br/><li> Interning string literals is an abstraction leak you only run into if you ever modify them.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568446369.012300"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568446369.012300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-14 00:32</span><br/>
I heard a good one the other day. Can't remember the source. Here's my bastardized paraphrase:<br/><br/>&gt; Google Search, from the perspective of the web searcher, isn't a pure function — every time you do a Google search for the same term, you get a different result. You could try to model it as a pure function, but that'd require some contortions that are easy to describe ("Just take the current index as an additional hidden / curried argument") but that fall apart upon further reflection. Google search is actually a <em>process</em>, not a function, and rather than trying to model it using the ill-fitting formalisms of math, we can more naturally model it using the formalisms of systems theory.<br/><br/>OO embodies some elements of process / systems theory very elegantly. Erlang is probably a great touchstone here. Compare with Milner's π-calculus, a mathematical formalism that encodes some parts of process / systems theory, which I find to be not nearly as simple or elegant as the <em>very OO</em> process model in Erlang.<br/><br/>(Hedging against expected counterarguments: Of course, that doesn't mean there <em>can't</em> be a way to encode process / systems theory in mathematics that is simple and elegant. But I think it's fair to say that this is a case where <em>currently</em> OO does better than FP.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568470135.017700"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568470135.017700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2019-09-14 07:08</span><br/>
all of my feelings are about ergonomics. i don’t have very many feelings about mutability or immutability (i think it’s kind of pushing on the problem of seeing data move through your system without quite addressing it directly). but one example is the degree to which pipe operators end up being used in functional code: it’s really useful to start with data, and then apply operations to it.... almost like asking the data to transform itself
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568470342.018500"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568470342.018500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2019-09-14 07:12</span><br/>
<a href="https://youtu.be/dkZFtimgAcM">https://youtu.be/dkZFtimgAcM</a> monads are better presented as objects argument at timestamp 13:53
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568470602.020000"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568470602.020000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2019-09-14 07:16</span><br/>
incidentally as i slowly heat up my Hot Take Machine i think javascript proxies are strictly more useful and understandable/direct than 90% of category theory
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568475761.020300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568475761.020300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-14 08:42</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> We're using very different meanings of 'identity'. For me 'identity' is that very aspect which is preserved while the thing itself changes. <em>The tree grows</em> - is it the same tree tomorrow? There's definitely an aspect of identifying the tree that we wish to preserve even though there are new leaves present.<br/><br/>When I drive the car around and the gasoline, temperature and location fluctuate, does it remain the same car every moment or are there monads involved?<br/><br/>This notion of identity is so deeply ingrained in our interactions that it is almost invisible. Virtual things in computers have identity too. I may regenerate <em>the file</em>, move around <em>the paddle</em> to hit <em>the moving ball</em>. Even looking at a function pipeline that operates on data, I might track <b>this data</b> as it moves through the functions. I'm arguing that everything that is presented to us and all our interaction with computers involve identities of these virtual artifacts. Identities are tracked in FP by various patterns like attaching ids to data, logging, maybe STM and so on. In Excel, for example, I think of location as identity (<em>this</em> cell). By contrast OO tends to lack the 'consistent snapshot' notions represented easily in FP. I don't think there's any dichotomy here btw. I just think it's better to have an OO substrate and then incorporate the notions consistent snapshots and pure transforms.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568484172.021300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568484172.021300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-14 11:02</span><br/>
Can you give an example of a situation where the sameness obviously outweighs the differences? I tend to find that this is one area where bits are not like atoms, and our intuitions about the notion of identity don't really translate. You can't rely on analogies here.<br/><br/>Just this past week I had an incident at work where a pipeline somewhere got wedged and refused to make forward progress. Turned out a user somewhere had changed the name of a record. Then 10 minutes later they changed their mind, reverted the old record, created a new record with the new name. But in the meantime the pipeline had run and the new name was saved downstream. Further updates failed; you couldn't create a new record with the new name because the name already existed.<br/><br/>The pipeline assumed that only the id of the record decided identity, but the uniqueness constraint meant that the name was also effectively part of the identity of a record. These sorts of subtle bugs are very common, I'm sure you've encountered them. Asking when two values are snapshots of 'the same record' is often intractable. The insight of FP is to encourage architectures that sidestep the question altogether. And if we could resolve the performance problems we'd use this idea exclusively. Mutation should be merely a hack for performance.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568495046.023300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568495046.023300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-14 14:04</span><br/>
It's not the bits themselves but what they mean to us. Identity in part of our conceptual system. If "a user had changed the name of a record" - what is the system implementing here if not the mutation of an entity with identity? If it wasn't for the 'sameness' across those different scattered bits, this wouldn't be a bug, would it? :wink: So I think identity should be core in our expressions. Anyway, I think we're talking past each other.<br/>&gt;  Mutation should be merely a hack for performance<br/>If you say at the machine level bits shouldn't be mutated in place except as an optimization, I fully agree. I'm thinking more in terms of higher level processes that we describe - identity and mutation should be part of the language as well as snapshots and consistency..
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568499274.023700"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568499274.023700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-14 15:14</span><br/>
&gt; I'm thinking more in terms of higher level processes that we describe - identity and mutation should be part of the language as well as snapshots and consistency..<br/><br/>That's definitely a level-up on the rhetoric I've heard so far in favor of state! Great thread.<br/><br/>&gt; If it wasn't for the 'sameness' across those different scattered bits, this wouldn't be a bug, would it? :wink:<br/><br/>The bug was just that the pipeline was wedged. It really didn't matter whether name <tt>X</tt> got assigned row <tt>m</tt> or <tt>n</tt>. I think that's extremely common. Deep in the guts of our computers, software is often just arcane book-keeping without any meaningful mapping to the real world. And this has been true of bureaucracies long before software existed. Was it a Kafka short story where the guy's record says he's dead and he can't convince the bureaucrat that he's alive? I think focusing on 'identity' risks confusing map for territory.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568499613.024100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568499613.024100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-14 15:20</span><br/>
To connect up with an old thread (<a href="1557860308.364300.html">1557860308.364300.html</a>), I think emphasis on identity is pretty modernist (maybe even AHM: <a href="https://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility">https://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility</a>). The post-modernist insight is that the concept is so fuzzy that it'll mislead you just when you need it most. Better to just not rely on it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568507646.028500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568507646.028500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-14 17:34</span><br/>
Haha perhaps. Is static typing authoritarian high-modernism? I'm tweeting that it is :stuck_out_tongue_winking_eye: Thanks for the links - great to re-read those. BTW I realize I'm quite an ad-hoc modernist - want order in some aspects, chaos for others..
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568508425.031800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568508425.031800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-14 17:47</span><br/>
Following up on <span style="background-color:#ccf">@Ivan Reese</span>’s question about OOP 'envy', I want to propose FP really envies that the computation model inside the OO program is very compatible with the model outside it. In OOP, how do you send a message to another process? Well we've been sending messages to other objects all along so 'very much the same way'.  The models of pure functional code and 'sending a message' are incompatible enough to require a fair bit of algebraic gymnastics. What do you think? Legit criticism?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568509375.042600"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568509375.042600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-14 18:02</span><br/>
On static vs dynamic types and immutable vs mutable data, I’m reminded of a recent podcast on tight and loose cultures: <a href="https://podcasts.apple.com/us/podcast/sean-carrolls-mindscape-science-society-philosophy/id1406534739?i=1000448378141">https://podcasts.apple.com/us/podcast/sean-carrolls-mindscap&hellip;</a> which makes connections to excessive and insufficient synchrony in mental disorders. The TLDR is that an excess of either produces failure states and some balance of the two is optimal. Could programming cultures unconsciously be dividing themselves on similar biases? 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568512252.068600"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568512252.068600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-09-14 18:50</span><br/>
Let me add my intuitions here. I tried to create a coherent argument but I failed. Please help me finding these out:)<br/><br/>So these are related to the OO substates and mutability vs immutabilty mentioned above, but I'd like just to give some high level thoughts.<br/><br/>1. 0 or 1 ref to a piece of data is no problem for sure, things go crazy above 2+ references to the same piece of data.<br/>2. A. Multiple (sub)states enable different rate of (state) change in different parts of the system, meaning loose(r) coupling.<br/>2. B. Multiple (sub)states introduce a syncronization problem/requirement on a higher level: between the subsystems using the (sub)states.<br/>3. Using a mutable variable by the reference feels like an implicit subscription / an implicit syncronization pattern.<br/>4. There is too much ideas around time (syncronization and subscription): maybe the idea of state is just too low level to be useful and a state should be viewed as a snapshot in a "stateStream" to be even able to reason about?<br/>5. Immutable data encourages creating new pieces of data (+swapping references) so we end up managing (and syncig) multiple pieces of data like in OO (sub)states.<br/>6. Virtually everything can be solved purely with mutable/immutable data with some extra code, so it seems they just have different "defaults" in their meaning, requiring different extra pieces of code to mimic the others behaviour.<br/>7. Immutability and local state feel like a bit like "locks". Wat.<br/>+1: Wtf am I talking about? I mean I can't express these better but it feels really odd.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568512393.069000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568512393.069000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-14 18:53</span><br/>
&gt; In OOP, how do you send a message to another process? Well we've been sending messages to other objects all along so 'very much the same way'. The models of pure functional code and 'sending a message' are incompatible enough to require a fair bit of algebraic gymnastics.<br/><br/>In modern languages, "OOP" is just classes and inheritance, and "sending a message" is just overwrought terminology for indirect function call. Even in Smalltalk, message sends have synchronous function call semantics. Functional languages also have function calls. O'Caml is a pedigreed functional language with OOP (as in: classes and inheritance), so there's no conflict between FP and class based OOP. When you talk about "sending a message to another process", it sounds like you are talking about the Actor model. The only Actor language I know is Erlang, which is considered a functional language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568513064.073500"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568513064.073500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-09-14 19:04</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> Erlang it is considered an FP lang, but there are opinions that it is the "most OO" lang considering the "original" OO term used by Alan Kay. I coud not find any direct Alan Kay opinion on Erlang. But ofc "modern OO" is not even close to either of them.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568513152.074000"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568513152.074000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-14 19:05</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> Doesn’t Erlang have mutable state within a process and doesn’t it send messages between processes? So at least on the process level, Erlang is about mutable message sending objects?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568516968.074900"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568516968.074900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-14 20:09</span><br/>
<span style="background-color:#ccf">@Steve Dekorte</span><br/>&gt; Doesn’t Erlang have mutable state within a process and doesn’t it send messages between processes? So at least on the process level, Erlang is about mutable message sending objects?<br/><br/>Haskell supports this as well. Every general purpose language has threads and concurrency, and threads are useless unless they can change state in response to messages (or whatever the IPC mechanism is). Haskell has several IPC mechanisms: if you use the Control.Concurrent.Actors library, you can even use the Actor model.<br/><br/>What makes Erlang functional is that data structures are immutable values and variables are immutable: they cannot be reassigned once they are bound to a value.<br/><br/>An Erlang process manages its mutable state using a tail recursive function F that is passed the current process state as an argument. Each time F is called, it receives a message, processes it, then calls itself with its updated state as an argument. This is a functional style, not an OOP style of programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568524131.075200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568524131.075200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-14 22:08</span><br/>
<span style="background-color:#ccf">@Pezo - Zoltan Peto</span> believe it or not what you're saying makes sense to me. What you call stateStream, I call identity. In typical OO an object is always pointing to the latest version of everything else - even if the latest version is only half done for some objects (this is the pitfall of OO). Ideally you want to move your references to the latest version in some organized way. And you never want to be pointing a half-done state of anything. FP typically doesn't have widespread stateStreams (well there's Clojure refs..) and you may have to build these streams yourself if you need from the immutable substrates. I think a more approachable option may to keep the OO model but introduce <em>deep versioning</em> of objects so they can manage their evolution through their stateStream.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568532397.075600"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568532397.075600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-15 00:26</span><br/>
I find both OOP, FP, and Actor model to be lousy paradigms. They each have their own problems, and the more purely that philosophy was pursued the lousier the language. Smalltalk, absolute garbage. Try doing a bitmap rotation in it, crazy hard. Java, the COBOL of our time, and i don't use Haskell but i find it abhorrent. We are about to add 100 million more programmers in the next 5 years, and surely they will not want to work with any of the prior languages.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568532454.075800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568532454.075800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-15 00:27</span><br/>
Whatever the next popular language is going to be, it will have to be simpler, and in totality, require less learning, and be 10x faster and easier to debug, because that part of programming for a newbie is a real turn-off.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568537753.085900"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568537753.085900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-09-15 01:55</span><br/>
<span style="background-color:#ccf">@Shalabh</span> I am glad it made sense to someone! :) So I think what you are talking about is basically the thing the "syncronization problem". <br/><br/>What is interesting about that to me is we dont even have to bring in concurrency, we can still mess up the "syncronicity" and end up in an invalid/inconsistent state.<br/><br/>Having multiple refs to the same mutable state might solve that sometimes out of the box (if they have the same identity as you say?) which seems interesting, but other times it is just like "accidental" temporal similarity of two things which might refer to DIFFERENT aspects of something - and this similarity makes us call them often by the same name at different parts if the system.<br/><br/>Funny observation: maybe if that is the case what we have (at least partially) is a kind of "naming problem" as well. :)<br/><br/>I am just dumping my thoughs, however I am glad to hear any response, because that feels important.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568539311.104100"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568539311.104100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-09-15 02:21</span><br/>
I also found a related not I wrote a couple weeks ago: <br/><br/>- Observer (pattern) feels an abstraction which does the syncronization "on (virtually) every event" (which make the value change).<br/>- But because (as said above) we sometimes need to alter references to states in different &amp; multiple steps (as business logic / consistency requirement) : the syncronization/consistency of our  system is at risk.<br/>Note that 2 different references pointing to 2 different piece of data might refer to the "same thing", but because of the differrent rate of change we often have to copy data to use.<br/>But what "different rate of change" virtually means from the Observation pattern view is like: we shall have a mechanism which does NOT syncronization on "on virtually (every) event" (which make the value change) =&gt; <br/><br/>to sum up: We need something like a syncronization abstraction specifying the events / conditions when we want to synchronize.<br/><br/>Identity/Model = State + the Events it changes on.<br/>&lt;&lt; is there anything known about that?<br/>That feels similar to a "Lifecycle". But "Lifecycle" feels similar to a "Process".<br/><br/>And I think this is what we as programmers have to fight a lot these days, but it feels partially accidental complexity, but if not at least it seems we (or at least I) lack of the correct viewpoint to think about these.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568540070.114100"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568540070.114100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-09-15 02:34</span><br/>
One more related note I found:<br/><br/>Observer pattern has the same problem in some regard as imperative programming: there is too much "temporal dependency" going on which are not "tamed". <br/><br/>In both cases it is not just valid assumption to have as a programmer "things change out there" but a requirement - and we have no initial awareness of the problem of syncronization/consistency problems this involved. To me both approch/school say (if they were a person): "oh, for sure, the programmer has to take care of these, but I don't have anything to do with that. I am not even aware of that being so hard and important aspect of the work to help the programmer at any level".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568540161.116000"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568540161.116000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-09-15 02:36</span><br/>
Let me add also: maybe unfortunately there is no accidental complexity there, but still I feel I lack of a level of understanding.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568570057.131600"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568570057.131600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-15 10:54</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> “Smalltalk, absolute garbage. Try doing a bitmap rotation in it, crazy hard. ” Isn’t that a function of the libraries and not the paradigm? e.g. it’s easy to do in Objective-C using AppKit.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568570286.132300"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568570286.132300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-15 10:58</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> “What makes Erlang functional is that data structures are immutable values and variables are immutable: they cannot be reassigned once they are bound to a value.” I think you’ve missed my point, which was that while it looks like an FP if viewed from within a process, it is an OOP (messages and objects w mutable state) if viewed at a higher scale of  what one sees happening between processes. Does that make sense?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568570965.139200"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568570965.139200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-15 11:09</span><br/>
It'd be interesting to see a well-done stratification showing how the paradigms sit with respect to one another, in terms of how "in the small" / "in the large" they are. For instance, you'd probably have FP (pure functions, immutable values) and procedural (mutable, side effects, place-oriented) at the small end, OO (classes, methods/messages) and modules/mixins and Gang of Four-style design patterns in the middle, and then things like CSP/Actor/process calculi/dataflow/MapReduce and HPC stuff in the large. It'd probably be useful to reference this when having "my dad can beat up your dad" debates, to avoid saying sort of useless things like "my dad can beat up your great grandpa" because, like, duh.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568571092.139600"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568571092.139600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-09-15 11:11</span><br/>
For example: of course the feeling of complexity from OOP is different than the feeling of complexity from FP — they're for solving problems of different magnitude. Instead, you might be better off contrasting FP and procedural programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568571573.140500"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568571573.140500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-15 11:19</span><br/>
In the original Smalltalk 80 book by Goldberg, which i eventually threw out (now a collector's item), because it wasn't worth carrying from apartment to apartment ( a true sign of a bad language when your $50 hardbound book is tossed), there was code to do a bitmap rotation that used recursion to subdivide the image into 4 sub-squares over and over, truly mind boggling, so tricky. Smalltalk may be bad, but the Pharo IDE for Smalltak is arguably the most refined and clever IDE extant for any language. Just goes to show how lots of elapsed time can polish something very well.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568571928.140900"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568571928.140900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-15 11:25</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> I don’t see what that has to do with either the paradigm or language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568573879.141700"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568573879.141700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-15 11:57</span><br/>
There are some purists who claim that Smalltalk is the only true OOP language. Languages like Java which are considered OOP by the vast majority of people is really a blended language, containing many ALGOL aspects which is procedural in style. Very few languages are pure; most throw in aspects and features from other paradigms and languages. Today it's more common to see kitchen sink languages like Swift and Rust.  This is why i discourage use of categorizations which are approximate at best. All languages eventually map to a registers+RAM+mutable data underlying form during execution on the hardware. The only thing that notation affects is ease of initial coding, ease of debugging, and ease of transferring to other people the code base. The inventor of FP John Backus was striving to create a world of interchangeable parts. I would argue that current FP languages have near zero interchangeable parts results. I think the high water for prior art in interchangeable parts was VB6, which was ages ago. A lot of the people pushing FP are members of the programming priesthood who have discovered how to lay a nice thick blanket of obfuscation over programming. Nothing like gnarly terms like functors and monoids to befuddle the newbies. We are going to see 100 million programmers added in the next 5 years, and the people in the field today are a bit insecure about the number of people coming onboard, and are erecting natural defenses. The demystification of programming is inevitable however. This next batch is less inclined to put up with arbitrary complexity.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568577654.143400"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568577654.143400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-15 13:00</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> I agree with most of that. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568578745.147000"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568578745.147000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-09-15 13:19</span><br/>
&gt; We are going to see 100 million programmers added in the next 5 years
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568578751.147200"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568578751.147200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-09-15 13:19</span><br/>
how do you know that?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568579160.153300"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568579160.153300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-15 13:26</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> I’d also like to see a chart of these features but I feel the conventional terms like FP and OOP combine too many ideas to be useful here. For example, one can have a well encapsulated message sending OO language with immutable objects, as the original actor languages did.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568579497.153800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568579497.153800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-15 13:31</span><br/>
In general, bundling is a huge problem in software. Our entire discourse suffers from speaking in terms of Erlang and Zookeeper rather than referential transparency and Paxos.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568582056.154500"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568582056.154500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-15 14:14</span><br/>
The 100  million number is just repeating the estimate of Bob Martin. He did a recent interesting talk at Oxford where he estimates the current base of programmers (including VBA programmers from Excel), and extrapolates the growth rate. Pretty reasonable estimates. Martin does take a long time to get to talking about the future, but his honoring of Alan Turing is a worthy detour as he was a super genius. So sad they didn't treat him better.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568585732.154700"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568585732.154700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-15 15:15</span><br/>
That link didn't work but I did find this: <a href="https://www.youtube.com/watch?v=BHnMItX2hEQ">https://www.youtube.com/watch?v=BHnMItX2hEQ</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568623648.155900"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1568623648.155900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-16 01:47</span><br/>
Yep that's the talk.  He has written a lot of books about Agile, and C++, but like most programming book authors has not built very many large projects. I don't expect him to, but Fred Brook's Mythical Man Month book is a bit more authoritative because Brooks managed 2000 programmers. Who gets to do that? To me a dozen is a big team.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569332007.452100"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569332007.452100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-09-24 06:33</span><br/>
<span style="background-color:#ccf">@Shalabh</span> <span style="background-color:#ccf">@Kartik Agaram</span> I think I could connect some dots thanks to this thread.<br/><br/>1. When I started programming I thought the “smart”/“hacky” solutions are nice.<br/>2. Later when I realized it might lead to dead-end code which I am unable the refactor I dumped this. I started to overcomplicate code as an anti-thesis.<br/>3. Later, I recognised features/ideas die, so I will have to get rid of some parts of my code no matter what. The “synthesis” is trying to write as little code as possible and focus, cutting and getting rid of (“overlapping”) features as much as possible. (I also realized writing code which is easy to change is a feature itself!)<br/>However as focusing on that I tend to write “hackier” code again, at least I am always questioning myself why I don’t just keep it simple instead going too abstract - is it really worth it? But being “simple” also adds a quite hard limit what I can or can’t do. This is what leads me again to be “(mutable-)hacky”, which extends the possibilites on that “hard limit” - so what I try to do is push “standalone” hacky solutions into Units so the whole system might just be ok.<br/><br/>I suspect this “valueable hackyness” has to do something with “identity” / “problems naturally expressed with mutability”. With preserved identity and mutability it is OFTEN MUCH EASIER to add some “clever” code to add a <b>limited</b> set features. Even the Unit tests are simpler and the code has smaller “surface” to test.<br/><br/>I am aware things can blow off any time that way, but the conclusion I have today is its easier to rewrite “easy” parts than going accidentally too abstract (which is kind of having the wrong abstractions for the domain which is a kind of technical debt itself).<br/><br/>I am curious what do you think about the relation of simplicity, “clever/hacky” solutions, mutability, identity, FP. - Is it something you also feel? Do you feel similar pressure?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569429296.456500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569429296.456500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-25 09:34</span><br/>
I hadn't connected the clever/hackiness ideas with mutability, FP etc. Maybe there is something there. I definitely feel the pressure between 'simple but weak' and 'complex (uses abstractions) but powerful'. BTW, what does 'hacky' mean exactly? Sounds like something that is super good in one aspect (quick to implement) but worse in another aspect (hard to maintain or understand / error prone / inconsistent with the rest of the design). It's a specific trade-off that we make - but we make trade-offs all the time. So some trade-offs are classified as hacks?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569429937.456700"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569429937.456700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-25 09:45</span><br/>
<span style="background-color:#ccf">@Pezo - Zoltan Peto</span> an example would help.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569431910.471200"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569431910.471200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-09-25 10:18</span><br/>
For example: I know some part of code can be reached theoretically multiple ways which should be handled on the proper layer of abstraction. But I also know via other constraints (eg.: knowing the navigation options in a menu), that some events might just happen in a given order. <br/><br/>Theoretically I could write up beautiful invariants on that to express these constraints, but the menu itself can change so in that case I had to prove the same thing over an over again and it is not obvious how to do that if not using a dependent typed language. Even with that, often I "just know" which ordering of events are possible and which are not. Of course it is really easy to forget about a case, but via hand-crafted tests we all assume we enumerate "all the important" cases and that might be a problem.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569432802.488600"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569432802.488600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-09-25 10:33</span><br/>
<span style="background-color:#ccf">@Shalabh</span> Thats a nice question: what is hacky? <br/><br/>To me it seems to be a piece of code which does not respect "the layers" of codebase and uses a shortcut.<br/><br/>With that we can "skip" the "full, proper" implemententation of the 2 layers we are connecting - or all/any intermediate layers.<br/><br/>Sometimes a hack means: the existing implementation and abstractions are out of date, but without a rewrite, without respecting the higher abstractness of the problem (and without the possibility of introducing a much broader set of problems harder to reason about and implement): we can cheat and the existing rules and abstractions here and there.<br/><br/>Maybe this is a little bit too small example but the "for" of "procedural" is hacky compared to "functional"s "map", but it has the 2 magic keywords: break; and continue "map" itself lacks of and must be mimiced on a higher level.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569433361.489900"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569433361.489900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2019-09-25 10:42</span><br/>
you could always wild out in function-land and use callbags or transducers to get some of those keywords back :wink:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569441714.492900"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569441714.492900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-25 13:01</span><br/>
When people use the term functional programming, do they usually mean the heavy use of immutable data structures, or the organizational convention of separating data and functions?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569442178.493100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569442178.493100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-25 13:09</span><br/>
For me it's the former. Particularly <a href="https://en.wikipedia.org/wiki/Referential_transparency">https://en.wikipedia.org/wiki/Referential_transparency</a><br/><br/>Separating functions and data feels pretty foundational to pretty much all paradigms (except maybe Prolog and SQL?)<br/><br/>There used to also be a connotation of using higher order functions with function values. But it too seems to be pervading all languages and being taken for granted.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569442300.493400"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569442300.493400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-09-25 13:11</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> “Separating functions and data feels pretty foundational to pretty much all paradigms” Do you mean besides the paradigm of OOP?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569443256.493700"></a>
      <img src="https://avatars.slack-edge.com/2019-10-07/786673147216_cad501b70b26e7666ed0_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569443256.493700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tim Babb</b>
<span style="margin:2em; color:#606060">2019-09-25 13:27</span><br/>
To me, the defining feature of "functional programming" is "dynamic function composition"; that is to say that procedures are data, and they can be stored, moved, invoked, and composed based on runtime decisions.<br/><br/>Referential transparency is another important concept which I see as closely tied to functional programming (though not strictly the same thing); specifically it's closely associated with the "pure" subset of functional programming. FWIW, it's the need for referential transparency that forced me to adopt pure functional programming in my own project's design.<br/><br/>Consider closures in non-pure languages like python or JS, though— you can have a function which is not referentially transparent, by nature of referring to a mutable variable in an outer function scope (including the global one). I would still call the use of such closures "functional programming", though.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569444220.494000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569444220.494000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-25 13:43</span><br/>
This is an interesting disconnect. We're all saying very different things, about a subject I used to think a consensus existed on, if not on what terms mean, at least in the 2 things a term <em>could</em> mean.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569445606.494300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569445606.494300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-25 14:06</span><br/>
Me:<br/>&gt; &gt; Separating functions and data feels pretty foundational to pretty much all paradigms.<br/><span style="background-color:#ccf">@Steve Dekorte</span>:<br/>&gt; Do you mean besides the paradigm of OOP?<br/><br/>I see, I misunderstood what you meant by "separating functions and data".<br/><br/>The term 'functional programming' existed long before OOP:<br/><br/>• The 1978 Turing Award lecture, "Can programming be liberated from the von Neumann style?" makes no mention of OOP or Simula (1962) or Smalltalk (1972).<br/>• The famous 1990 paper "Why Functional Programming matters" makes no mention of OOP or C++ (which first came out in 1985).<br/><br/>I mostly get my sense of the term from those sources. While I usually don't care to argue semantics of terms, 'FP' seems still relatively crisp in meaning and so worth defending.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569445741.494500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1567954767.205900.html#1569445741.494500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-25 14:09</span><br/>
Ah, <span style="background-color:#ccf">@Tim Babb</span>, I had to read your comment a few times to realize it was the same as the third connotation I mentioned. Yes, that connotation has a long history. I tend to distinguish between referential transparency and first-class functions using the terms "pure FP" and "FP" when necessary.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
