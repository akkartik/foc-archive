[
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1689427049.380399",
        "client_msg_id": "9874156b-b1b4-4d9e-8e05-ffbeef04b047",
        "text": "<@U013WBS1B1C> Making context explicit is indeed one way to handle this problem, and if Red is working towards that goal, that's a reason for me to take a closer look. There is some tradition of this kind in Lisp\/Scheme, but it's a bit fringe.\n\nPrompt-based development is perhaps a solution at the IDE-level, but not at the language level. The IDE must store the developer's answers in some way that makes the code usable without prompts later and elsewhere. That some way would then have to be part of the language.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "17ZY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U013WBS1B1C"
                            },
                            {
                                "type": "text",
                                "text": " Making context explicit is indeed one way to handle this problem, and if Red is working towards that goal, that's a reason for me to take a closer look. There is some tradition of this kind in Lisp\/Scheme, but it's a bit fringe.\n\nPrompt-based development is perhaps a solution at the IDE-level, but not at the language level. The IDE must store the developer's answers in some way that makes the code usable without prompts later and elsewhere. That some way would then have to be part of the language."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05GSC0B4A0",
        "type": "message",
        "ts": "1689428904.650439",
        "edited": {
            "user": "U05GSC0B4A0",
            "ts": "1689428928.000000"
        },
        "client_msg_id": "060c8152-1624-4449-89fa-f81226483b00",
        "text": "Yeah, so they're using it as a natural language router which is super interesting in itself - that \"update my name\" could also be the output of another LLM (ex - as a result of a user action in a UI...user fills in a \"name\" field and clicks the \"save\" button, router POSTs that message to the API).\n\nYou can take that further on it's own - can you have an LLM route messages in a smalltalk\/ruby\/objective-c message-passing style language?\n\nBut where my head went is - given a specific context in a prompt, we can encode a bunch of information (in binary, hex?, emoji?) and enable new patterns that give us cost\/speed benefits from LLMs while also not having to explicitly write as much code. I need to do a bigger experiment, but in my screenshots, I'm showing it actually being able to encode and decode the information, at least from a simple binary encoding.\n\nA while back I followed a tutorial for building a chess engine in C, and they used a similar technique but with U64s and a lot of bitwise operations, bit masks, etc and I'm thinking there's a way to take inspiration from those techniques and use it with an LLM...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g6366d8630c4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6366d8630c4e2394142efb0a9358fcc6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0016-72.png",
            "first_name": "Scott",
            "real_name": "Scott",
            "display_name": "Scott",
            "team": "T5TCAFTA9",
            "name": "scott099",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689369045.712599",
        "parent_user_id": "U05GSC0B4A0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zW5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, so they're using it as a natural language router which is super interesting in itself - that \"update my name\" could also be the output of another LLM (ex - as a result of a user action in a UI...user fills in a \"name\" field and clicks the \"save\" button, router POSTs that message to the API).\n\nYou can take that further on it's own - can you have an LLM route messages in a smalltalk\/ruby\/objective-c message-passing style language?\n\nBut where my head went is - given a specific context in a prompt, we can encode a bunch of information (in binary, hex?, emoji?) and enable new patterns that give us cost\/speed benefits from LLMs while also not having to explicitly write as much code. I need to do a bigger experiment, but in my screenshots, I'm showing it actually being able to encode and decode the information, at least from a simple binary encoding.\n\nA while back I followed a tutorial for building a chess engine in C, and they used a similar technique but with U64s and a lot of bitwise operations, bit masks, etc and I'm thinking there's a way to take inspiration from those techniques and use it with an LLM..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1689438033.723869",
        "client_msg_id": "1eddd47c-ef66-4c30-814a-c749fa93d0e9",
        "text": "OK, just me then! :grin:\n\nSorry, Rachel, perhaps we're over the AI hype curve in this community! :nerd_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689280926.077849",
        "parent_user_id": "UE6EFEPTQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7Wll",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "OK, just me then! "
                            },
                            {
                                "type": "emoji",
                                "name": "grin",
                                "unicode": "1f601"
                            },
                            {
                                "type": "text",
                                "text": "\n\nSorry, Rachel, perhaps we're over the AI hype curve in this community! "
                            },
                            {
                                "type": "emoji",
                                "name": "nerd_face",
                                "unicode": "1f913"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]