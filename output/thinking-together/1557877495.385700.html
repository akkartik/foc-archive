<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/53ffd374deb821ab07cdef9f7e321364.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Peter van Hardenberg</b>
<span style="margin:2em; color:#606060">2019-05-14 16:44</span><br/>
Reading what <span style="background-color:#ccf">@Drewverlee</span> and <span style="background-color:#ccf">@Ian Bicking</span> above wrote leaves me thinking that what I love most about writing software in Elm (and to a lesser extent React) or SQL is what I don't have to think about. Particularly these last couple of years writing decentralized systems writes can come at me from anywhere at any time -- if I had to translate those back into specific "display updates" the reconciliation would be abominable. Vice versa, by channeling writes through a single point I get tremendous leverage to be able to interpose whatever storage engine I want. The flip side of all this, of course, is that it doesn't scale. By that I mean that the abstraction breaks down inevitably when speed becomes a first-order concern. That happens in SQL databases when you get a few gigabytes more data than your system has RAM (if not before) or in Elm / React when you are trying to respond on the next frame for things like text entry.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557877538.385800"></a>
      <img src="https://secure.gravatar.com/avatar/53ffd374deb821ab07cdef9f7e321364.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1557877538.385800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Peter van Hardenberg</b>
<span style="margin:2em; color:#606060">2019-05-14 16:45</span><br/>
I don't have any real conclusions from all this -- maybe that Reactive Programming could be a good idea -- and I can't explain why I don't have a positive sentiment towards Haskell despite it demonstrating these properties.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557877669.386100"></a>
      <img src="https://secure.gravatar.com/avatar/53ffd374deb821ab07cdef9f7e321364.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1557877669.386100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Peter van Hardenberg</b>
<span style="margin:2em; color:#606060">2019-05-14 16:47</span><br/>
Broadly, I will note (as a recovering database person) that in the end you always have to look inside the box and inside the box is always a horrifying maze of abstractions and optimizations... or worse, it isn't.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557880966.387800"></a>
      <img src="https://secure.gravatar.com/avatar/8d7dd06bd18b8fce6a4c04dfede7f616.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1557880966.387800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Drewverlee</b>
<span style="margin:2em; color:#606060">2019-05-14 17:42</span><br/>
It's true that performance often adds complexity, in part, that's why it's interesting to consider a more declarative model to start. Eventually it might only become documentation, but it gives us something invaluable throughout, which is clarity of intent. <br/><br/>I think trying to get something perfect here is too much, if we can just get something slightly better that's enough, both in terms of personal satisfaction and improving the ecosystem.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557885105.389000"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1557885105.389000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-05-14 18:51</span><br/>
What with Turing tarpits, the value of a programming environment is not in what it can, but in what it does <b>not</b> do well.  It's not the features but the limitations.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557890704.389700"></a>
      <img src="https://secure.gravatar.com/avatar/8d7dd06bd18b8fce6a4c04dfede7f616.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1557890704.389700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Drewverlee</b>
<span style="margin:2em; color:#606060">2019-05-14 20:25</span><br/>
Sure, I'm not aware yet of the constraints around datalog as a query language. I'm sure they exist, I just haven't encountered it in my very short travels. <br/><br/>Though using it only as a query language is one form of limitation. <br/><br/>Datalog is based on prolog, so that would be interesting to study as a look into how the model applies more generally.<br/><br/>More directly, the biggest thing you can't do, is fine tune performance at this layer of abstraction.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557890817.390000"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1557890817.390000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-05-14 20:26</span><br/>
Datalog is a good example since it's like Prolog the good parts.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557970490.426600"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1557970490.426600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-15 18:34</span><br/>
&gt; Eventually a declarative model might only become documentation, but it gives us something invaluable throughout, which is clarity of intent.<br/><br/><span style="background-color:#ccf">@Drewverlee</span> This is a <em>really</em> great sentence, thank you.<br/><br/>The term 'declarative' has historically tended to conflate two concerns:<br/><br/><li> More concise phrasing. Syntax and so on.<br/><li> Error checking.<br/><br/>The conflating is unfortunate, because when you introduce a new syntax for the declarative model you also restrict what one can say in the lower level imperative substrate. That then prevents the organic "retreat to documentation". Creating a language has prevented you from thinking certain thoughts (or at least blocked on the authors to support your use case). Writing certain programs now requires leaving the declarative model entirely, with all its error checking benefits.<br/><br/>All I want is machine code with an extensible DSL for assertions :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1558009459.428300"></a>
      <img src="https://secure.gravatar.com/avatar/8d7dd06bd18b8fce6a4c04dfede7f616.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1558009459.428300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Drewverlee</b>
<span style="margin:2em; color:#606060">2019-05-16 05:24</span><br/>
Thanks Kartik,<br/><br/>I wasn't aware declarative implied anything about error checking. I was thinking  more of this definition:<br/><br/>&gt; denoting high-level programming languages which can be used to solve problems without requiring the programmer to specify an exact procedure to be followed.<br/><br/>For example using "map, filter, reduce" is more declarative because they don't specify the flow control. This is useful because, simply put, its one less thing to get wrong.<br/><br/>Another example would be Datalog being more declarative then SQL because you dont have to specify the joins.<br/><br/>Leading with these examples, i think a big next step could be made by reactive datalog, which would mean the client/browser dow declears its data needs and the rest of the system (from the users perspective) doesn't have to worry  about the flow control of how it gets there.<br/><br/>This of course, will always break down at some scale, but so does everything, and as i was suggesting, the declarative functions can remain, only their interpretation has to change.<br/>This is common practice in our field, make a function, now how it works can change without breaking callers.<br/><br/><br/>&gt; All I want is machine code with an extensible DSL for assertions<br/><br/>interesting, this would seem to be at the opposite end of the spectrum from what i'm describing. I dont have much machine code experience!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1558023658.428900"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1558023658.428900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-16 09:20</span><br/>
I was at least half kidding with that last line. I’ve been digging into low-level guts lately, so it’s been on my mind. But most programming models become intractable in the presence of unsafe code, so the extreme end of my spectrum reduces to absurdity.<br/><br/>We’ve all seen the surface definition of ‘declarative’, but that was exactly why your sentence seemed so insightful. It got me to return to first principles and ask where the benefits lay of communicating the ‘what’ rather than the ‘how’. None of the examples you cite — map/filter/reduce or Datalog — support the use case of treating them as executable documentation, of just specifying invariants that someone who wants more performance can implement for themselves. It seems worth designing declarative models with this escape hatch in mind.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1558023997.429200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1558023997.429200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-05-16 09:26</span><br/>
"A programming language is low level when its programs require attention to the irrelevant." - Alan Perlis<br/><br/>Of course even lower level languages hide some irrelevant details from us to provide something useful. The machine instruction set codes are irrelevant to the person writing assembly language.<br/><br/>&gt; what I love most about writing software in Elm (and to a lesser extent React) or SQL is what I don't have to think about<br/><br/>Yes. Until the irrelevant become relevant: mangling an SQL query to make it perform better, fine tuning struct memory layout in C, intertwining layers of caching code to improve performance, etc.<br/><br/>&gt; in the end you always have to look inside the box<br/><br/>Yeah. I wonder if it's possible that inside the box is also a nice, clean model that looks just like outside the box. Instead of trying to affect performance via 'side effect' (i.e. code munging), what if you could specify the implementation details separately from the higher level description? In most cases it seems the layer of abstraction is too hard. Rather it should be permeable when necessary. I wonder if any systems do this.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1558030017.431500"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1558030017.431500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-05-16 11:06</span><br/>
Isn’t this what some compilers do? They analyze code and optimize whatever they can. I’m thinking primarily of AOT, but JIT as well.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1558030092.431700"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1558030092.431700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-05-16 11:08</span><br/>
They let us write code that’s readable while still being fast. Rust is excellent in its commitment to “zero cost abstraction”, which I think is relevant to this discussion.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1558031347.431900"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557877495.385700.html#1558031347.431900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-16 11:29</span><br/>
Yes, there are two broad fronts:<br/><br/>a) Start at the lowest level and gradually “pull ourselves up by our bootstraps”, writing code at a higher and higher abstraction without losing performance or flexibility. Rust definitely pioneers a lot here. But there’s still access patterns where you’d be forced to use runtime reference counting and may therefore decide to switch to give up on Rust’s safety invariants. Even ignoring such cases, Rust programs are still pretty imperative. <b>You get performance, but may not be very declarative.</b><br/><br/>b) Start at a high level of declarativity and gradually support better performance. Prolog is the classic example that achieved huge gains in declarative expression. But if it was slow you didn’t really have a way to keep declarativity and performance. You’d end up with <tt>cut</tt> calls polluting your nice declarative program. Other high-level languages have the same problem. <b>You get declarative but have to pay some performance cost at times.</b><br/><br/>As far as I know there’s no high-level declarative model that also provides an “imperative side channel” independent of the declarative program.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
