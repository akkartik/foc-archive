<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1683513284.188029.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2023-05-07 19:34</span><br/>
I enjoyed this assessment.  I lived through the shift to recursion. I note, though, that recursion and functions make sense only for single-threaded pieces of hardware which is how CPUs and Memory were perceived in the 1950s.  Today, we can have bowls full of CPUs with their own local memories, which changes the ground truth about hardware.  While it is possible to extrapolate recursion to describe distributed systems, the recursive  mind-set leads to epicycles such as thread safety, multi-tasking operating systems, thread libraries, loops, etc., i.e. a generally horrible DX (Developer eXperience) for creating distributed programs.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
