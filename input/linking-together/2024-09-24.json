[
    {
        "text": "Hey future of coding folks,\n\nI want to advertise the idea of non-abelian spreadsheets. The idea has slowly drifted into the center of my thinking this last year. I'm not sure if its a good idea or not. It kinda depends on how you build on it. So for now I just want to convey the general idea.\n\nPicture in your mind a normal spreadsheet. In some sense it is 'abelian' (commutative) because from any cell going down and then right is the same as going right and then going down. If we make it non-abelian, so the order we go right and down matters, we get something like the picture attached below.\n\nIf you tilt your head slightly you may recognize it as the infinite binary tree. So an infinite binary tree is just the non-abelian version of the usual grid-based spreadsheet. The nodes of the tree are the cells. We can also think of finite binary trees as the analogue of tables.\n\nA key feature of regular spreadsheets is the ability to write formulas with relative references. For instance in a regular spreadsheet you can use relative references so a formula always refers to the cell to the right of the given one, and in a tree you can write a formula that always refers to the cell you get by going down and to the right from the given cell.\n\nAnother key feature of spreadsheets is that you put stuff in cells! And we do that with trees all the time. For example if we write down the syntax tree for (a+b)*c what we are doing is putting each of the symbols into a cell of the tree.\n\nWe can push this analogy to account for all trees (in particular all syntax trees). This tree can't really be visualized because it branches infinitely at each node. It is much easier to describe algebraically. I'll use the term 'free monoid on a set X', which if you aren't in the know just means the set of strings made out of the elements of X regarded as distinct characters. The infinite binary tree, or more precisely the set of nodes of the infinite binary tree, can be described as the free monoid on a two element set {L, R}. e.g. RLL describes the node you get by going right, then left, and then left again. Now let X_n denote a set with n elements and X the disjoint union of the X_n for all n. It suffices to take the free monoid on X.\n\nA reasonable question at this point is what is the interface for an infinitely branching tree? You would think it is even worse than an infinite dimensional grid, which is the abelian version. But if we are restricting ourselves to trees coming from symbolic expressions then for the most part we already have the interface. It is just the symbolic expressions we would have written down in the first place.\n\nI'll leave it at that.",
        "files": [
            {
                "id": "F07NH9CRN31",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "UFPRPSA4S",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sO9yD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hey future of coding folks,\n\nI want to advertise the idea of non-abelian spreadsheets. The idea has slowly drifted into the center of my thinking this last year. I'm not sure if its a good idea or not. It kinda depends on how you build on it. So for now I just want to convey the general idea.\n\nPicture in your mind a normal spreadsheet. In some sense it is 'abelian' (commutative) because from any cell going down and then right is the same as going right and then going down. If we make it non-abelian, so the order we go right and down matters, we get something like the picture attached below.\n\nIf you tilt your head slightly you may recognize it as the infinite binary tree. So an infinite binary tree is just the non-abelian version of the usual grid-based spreadsheet. The nodes of the tree are the cells. We can also think of finite binary trees as the analogue of tables.\n\nA key feature of regular spreadsheets is the ability to write formulas with relative references. For instance in a regular spreadsheet you can use relative references so a formula always refers to the cell to the right of the given one, and in a tree you can write a formula that always refers to the cell you get by going down and to the right from the given cell.\n\nAnother key feature of spreadsheets is that you put stuff in cells! And we do that with trees all the time. For example if we write down the syntax tree for (a+b)*c what we are doing is putting each of the symbols into a cell of the tree.\n\nWe can push this analogy to account for all trees (in particular all syntax trees). This tree can't really be visualized because it branches infinitely at each node. It is much easier to describe algebraically. I'll use the term 'free monoid on a set X', which if you aren't in the know just means the set of strings made out of the elements of X regarded as distinct characters. The infinite binary tree, or more precisely the set of nodes of the infinite binary tree, can be described as the free monoid on a two element set {L, R}. e.g. RLL describes the node you get by going right, then left, and then left again. Now let X_n denote a set with n elements and X the disjoint union of the X_n for all n. It suffices to take the free monoid on X.\n\nA reasonable question at this point is what is the interface for an infinitely branching tree? You would think it is even worse than an infinite dimensional grid, which is the abelian version. But if we are restricting ourselves to trees coming from symbolic expressions then for the most part we already have the interface. It is just the symbolic expressions we would have written down in the first place.\n\nI'll leave it at that."
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1727247298.811129",
        "client_msg_id": "68409b2a-9008-465b-b3d8-cfa1bbdc82ef",
        "thread_ts": "1727247298.811129",
        "reply_count": 11,
        "reply_users_count": 6,
        "latest_reply": "1728525557.513459",
        "reply_users": [
            "UBKNXPBAB",
            "U07CGRNH6S2",
            "U05UK5T7LPP",
            "UFPRPSA4S",
            "UJBAJNFLK",
            "U05M5A8E0NT"
        ],
        "replies": [
            {
                "user": "UBKNXPBAB",
                "ts": "1727251595.837229"
            },
            {
                "user": "U07CGRNH6S2",
                "ts": "1727273410.894979"
            },
            {
                "user": "U05UK5T7LPP",
                "ts": "1727287101.819389"
            },
            {
                "user": "U05UK5T7LPP",
                "ts": "1727289035.179019"
            },
            {
                "user": "UFPRPSA4S",
                "ts": "1727315013.354569"
            },
            {
                "user": "UFPRPSA4S",
                "ts": "1727315556.741189"
            },
            {
                "user": "UFPRPSA4S",
                "ts": "1727316086.657349"
            },
            {
                "user": "UFPRPSA4S",
                "ts": "1727319046.341889"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1727947740.224759"
            },
            {
                "user": "U05M5A8E0NT",
                "ts": "1728403394.792989"
            },
            {
                "user": "UFPRPSA4S",
                "ts": "1728525557.513459"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    }
]