[
    {
        "user": "U03B14DUZSA",
        "type": "message",
        "ts": "1665513794.865529",
        "client_msg_id": "c350e5bb-7fa3-4668-8dc3-6f7c7f8b59f6",
        "text": "I think of prototypes as a more fundamental mechanism of inheritance in OOP than classes, given that class systems can be simulated in prototypes, whether Smalltalk and Java in Self (<https:\/\/bluishcoder.co.nz\/self\/substrate.pdf>), NewtonScript (<https:\/\/beepdf.com\/wp-content\/uploads\/newton\/Class-based%20NewtonScript%20Programming.pdf>), or many different cases in JavaScript (Crockford - <https:\/\/web.archive.org\/web\/20110805161336\/http:\/\/crockford.com\/javascript\/inheritance.html>). I've made close to 10 in the past year in JS on an exploration of its potential. Prototypes are a lot easier to optimize than classes - the Smalltalk in Self project noted that their implementation was faster than contemporary commercial products, and V8, a descendant of the Self VM, is a marvel of dynamic languages. Yet this requires a complex VM that wasn't really possible at PARC.\n\nOn the other hand, prototypes are awkward for programming with, which is why prototypical systems tend to develop class systems, whether formalized or not. Even Self made use of traits that started to smell like classes. For the most part, the individual behavior of objects doesn't need to be specialized. JavaScript prototypes are especially awkward to use and hostile for beginners - the lanugage's saving grace are its first-class functions, with which the whole prototypical system can be ignored (besides in base types).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7358a16bdea5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-11-02\/4314864832259_7358a16bdea535168748_72.png",
            "first_name": "Riley",
            "real_name": "Riley Stewart",
            "display_name": "Riley Stewart",
            "team": "T5TCAFTA9",
            "name": "me1307",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1664945940.180779",
        "parent_user_id": "UBKNXPBAB",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/bqU6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think of prototypes as a more fundamental mechanism of inheritance in OOP than classes, given that class systems can be simulated in prototypes, whether Smalltalk and Java in Self ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bluishcoder.co.nz\/self\/substrate.pdf"
                            },
                            {
                                "type": "text",
                                "text": "), NewtonScript ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/beepdf.com\/wp-content\/uploads\/newton\/Class-based%20NewtonScript%20Programming.pdf"
                            },
                            {
                                "type": "text",
                                "text": "), or many different cases in JavaScript (Crockford - "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/web.archive.org\/web\/20110805161336\/http:\/\/crockford.com\/javascript\/inheritance.html"
                            },
                            {
                                "type": "text",
                                "text": "). I've made close to 10 in the past year in JS on an exploration of its potential. Prototypes are a lot easier to optimize than classes - the Smalltalk in Self project noted that their implementation was faster than contemporary commercial products, and V8, a descendant of the Self VM, is a marvel of dynamic languages. Yet this requires a complex VM that wasn't really possible at PARC.\n\nOn the other hand, prototypes are awkward for programming with, which is why prototypical systems tend to develop class systems, whether formalized or not. Even Self made use of traits that started to smell like classes. For the most part, the individual behavior of objects doesn't need to be specialized. JavaScript prototypes are especially awkward to use and hostile for beginners - the lanugage's saving grace are its first-class functions, with which the whole prototypical system can be ignored (besides in base types)."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]