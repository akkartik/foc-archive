<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Personal Dynamic Media</b>
<span style="margin:2em; color:#606060">2022-04-20 07:22</span><br/>
I've been pondering how to define a metric for how programmable a user's overall environment is. One thought I've had is to add up, for each application used in an average day, the percent of time it is used times the percent of features that can be programmed. Call it something like Overall Average Programmability.<br/><br/>I know this doesn't account for differences in how easy it is to use the programmability of a given app (mailx is much easier to automate than Gmail) or the importance of individual features that can or cannot be automated, or the ease of integrating applications with different built-in scripting languages, but I think this is a relatively well-defined metric that might still contain some meaning.<br/><br/>Does this sound like a meaningful and/or useful concept?<br/><br/>Would you estimate, over the course of your career, that your environment's Overall Average Programmability has trended upwards or downwards?<br/><br/>Any thoughts on the forces that may have impacted the trends?<br/><br/>Personally, I think mine has trended downwards, and I suspect it has something to do with the increasing roles played in my life by mobile apps, web apps, and services that make their money from advertising and want to maximize user engagement rather than productivity.<br/><br/>Thoughts?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1650486717.190599"></a>
      <img src="https://avatars.slack-edge.com/2019-02-14/551655871797_2624b1e78c0a9eaed529_72.jpg" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1650486717.190599" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Knott</b>
<span style="margin:2em; color:#606060">2022-04-20 13:31</span><br/>
I don't think it's a trend I've noticed. I would say the programmability of almost everything has stayed consistently low.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1650688301.617309"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1650688301.617309" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-04-22 21:31</span><br/>
Things did feel more programmable 20 years ago. I spent more of my computer time on a Unix server that encouraged more scripting. Now I do more on devices (phones) that I can't program. I've made changes to my mail client when it used to be Pine. I can no longer do that now that it's a webmail client.<br/><br/>Even on programmable devices the picture feels worse. Every single open source project has gotten larger and more complex and harder to build over the last 20 years. Pine is defunct, but observe:<br/><br/>mutt mail client: 41kLoC in 1998 -&gt; 95kLoC now. required perl in 1998, now also requires python.<br/><br/>tmux window manager: 24kLoC in 2009 -&gt; 64kLoC now. Required perl in 1998, now also requires awk and yacc.<br/><br/>One confounding factor: I wonder how much of things seeming worse has to do with me just burning out on this sort of hacking activity over the years.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1650702843.175699"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1650702843.175699" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-04-23 01:34</span><br/>
My experience is much the same as <span style="background-color:#ccf">@Kartik Agaram</span>'s. The one environment that feels as programmable today as it did 15 years ago is Emacs. I suspect Emacs itself also grew bigger, if only for GUI improvements such as better rendering. But from the point of view of add-ons and customization, it's constant.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1650727820.667669"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1650727820.667669" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-04-23 08:30</span><br/>
That was tantalizing enough that I did some more digging.<br/><br/>Emacs in 1997 (v20.1): 152kLoC C, 386kLoC lisp, 1010 lisp DEFUNs defined in C, 15k defuns defined in lisp<br/>Emacs in 2022: 405kLoC C, 1.25MLoC lisp, 1780 lisp DEFUNs defined in C, 42k defuns defined in lisp<br/><br/>This is pretty blunt, of course. I'm just counting <tt>DEFUN</tt> in the <tt>src/</tt> directory and <tt>^(defun</tt>  in the <tt>lisp/</tt> directory. Let me know if there's a more accurate approach. But my impression is that Emacs pays so much attention to backwards compatibility that you are able to ignore new affordances for add-ons and customization until you need to go find something.<br/><br/>For completeness:<br/><br/>Vim: 275kLoC in 2006 (v7.0) -&gt; 390kLoC now<br/>Neovim: 167kLoC in 2015 (v0.1.0) -&gt; 238kLoC now<br/><br/>Very interesting that Neovim is smaller now than Vim was in 2006.<br/><br/>tl;dr - <tt>sloccount</tt> is a useful tool!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1650728125.332199"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1650728125.332199" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-04-23 08:35</span><br/>
Another potential metric that occurs to me here is "build difficulty index". Not really covered at all by my stats above.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1650731586.091999"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1650731586.091999" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-04-23 09:33</span><br/>
My point is that I don't really care about the size of Emacs. I do look at Emacs source code (the Lisp part) quite often, but I get there by navigating from my own code to layers below. As long as the number of layers I have to go through doesn't increase, the size of the Lisp code is irrelevant for me.<br/><br/>As you note, Emacs values backwards compatibility highly, which is something I do care about. Perhaps even more importantly, Emacs values programmability, and therefore offers good support for exploring its own source code.<br/><br/>So a good metric would perhaps be "number of navigation steps until you hit a primitive" (which for Emacs would be a function implemented in C)&gt;
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1650733506.325319"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1650733506.325319" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-04-23 10:05</span><br/>
I'm kinda handwaving that the amount of elisp growing at the same pace as C above suggests there's no difference between C and Lisp once you start poking at the internals of the elisp. But if you're just <em>using</em> the elisp primitives, the surface area of names (which I'm estimating by counting <tt>defun</tt>s) does seem to grow a bit slower than the total volume of Emacs code.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1650781756.976969"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1650781756.976969" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-04-23 23:29</span><br/>
Surface matters more than volume, indeed, but any simple metric misses the importance of modularity. I suppose Emacs' size made a jump when org-mode was adopted into the core distribution, but this had no impact on people not using org-mode. They could (still can) simply ignore it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1650866524.759269"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1650866524.759269" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-04-24 23:02</span><br/>
Now you're making me wonder why we can't just all pile into the Emacs spaceship :smile: What does Emacs know that tmux or mutt does not, when it comes to modularity?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651083064.055419"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1651083064.055419" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-04-27 11:11</span><br/>
I can only speculate, but my favorite hypothesis is Conways's law: Emacs is modular, in spite of lacking any explicit support for modularity (it's just naming conventions), because its developer community is structured as subgroups working on specific aspects.<br/>I don't know anything about how tmux or mutt are developed, so I cannot really test my theory against those two examples.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651087623.141109"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1651087623.141109" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-04-27 12:27</span><br/>
Now I want to go back in time and see how things looked in 1995..
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651127734.277019"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1651127734.277019" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-04-27 23:35</span><br/>
Many of the people involved in 1995 are still around to talk to. As are mailing list archives. That could make a nice topic for a PhD in sociology.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651146116.406469"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1650464577.515109.html#1651146116.406469" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-04-28 04:41</span><br/>
<a href="https://corpora.tika.apache.org/base/docs/bug_trackers/ocrmypdf/ocrmypdf-LINK-325-0.pdf">https://corpora.tika.apache.org/base/docs/bug_trackers/ocrmy&hellip;</a> is a great read from 1988 (via Google: 'emacs retrospective')<br/><br/>I'm not sure if this running back and forth is still on topic, though. <span style="background-color:#ccf">@Personal Dynamic Media</span>?
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
