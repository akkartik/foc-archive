[
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1568532397.075600",
        "client_msg_id": "0435c592-558d-4c68-9564-b5970e5603c0",
        "text": "I find both OOP, FP, and Actor model to be lousy paradigms. They each have their own problems, and the more purely that philosophy was pursued the lousier the language. Smalltalk, absolute garbage. Try doing a bitmap rotation in it, crazy hard. Java, the COBOL of our time, and i don't use Haskell but i find it abhorrent. We are about to add 100 million more programmers in the next 5 years, and surely they will not want to work with any of the prior languages.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yja",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I find both OOP, FP, and Actor model to be lousy paradigms. They each have their own problems, and the more purely that philosophy was pursued the lousier the language. Smalltalk, absolute garbage. Try doing a bitmap rotation in it, crazy hard. Java, the COBOL of our time, and i don't use Haskell but i find it abhorrent. We are about to add 100 million more programmers in the next 5 years, and surely they will not want to work with any of the prior languages."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1568532454.075800",
        "client_msg_id": "e7b8a357-b21e-4eb6-8bde-b653daafd75a",
        "text": "Whatever the next popular language is going to be, it will have to be simpler, and in totality, require less learning, and be 10x faster and easier to debug, because that part of programming for a newbie is a real turn-off.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M5X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Whatever the next popular language is going to be, it will have to be simpler, and in totality, require less learning, and be 10x faster and easier to debug, because that part of programming for a newbie is a real turn-off."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1568533673.076000",
        "client_msg_id": "8cddc00c-c92d-4cb2-99a9-37db0fc1bdda",
        "text": "\"is considered a bad practice...\" by whom? and why? I am sick and tired of people telling me that global state is bad. If we are talking about a single source of truth from which all conclusions derive, isn't that a mandatory thing? If i have a banking system, and my bank balance says $100, that is global mutable state. If we allow my account to have multiple balance values, that would create chaos, an unworkable situation.  So having a bank balance is \"bad practice\"? This is the absurdity of these dogmatic statements about what is good or bad.  I am solely interested in  1) ease of initial programming, 2) ease of fixing errors as reported by customers, 3) ease of transferring the maintenance of the code base to someone other than the author.\n\nNone of the goals i hold important have anything directly to do with the details of the programming model. i am interested in the overall results of the technology. And to establish the quality of the results, build test programs, and test them for modification by someone other than the author. Without measurement, you have fad and fashion. I think a lot of FP code is among the least readable i have seen in years. If you are going to go that level of obscurity, just go back to LISP at least the programs will be a lot shorter.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568156672.259300",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1H0s",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"is considered a bad practice...\" by whom? and why? I am sick and tired of people telling me that global state is bad. If we are talking about a single source of truth from which all conclusions derive, isn't that a mandatory thing? If i have a banking system, and my bank balance says $100, that is global mutable state. If we allow my account to have multiple balance values, that would create chaos, an unworkable situation.  So having a bank balance is \"bad practice\"? This is the absurdity of these dogmatic statements about what is good or bad.  I am solely interested in  1) ease of initial programming, 2) ease of fixing errors as reported by customers, 3) ease of transferring the maintenance of the code base to someone other than the author.\n\nNone of the goals i hold important have anything directly to do with the details of the programming model. i am interested in the overall results of the technology. And to establish the quality of the results, build test programs, and test them for modification by someone other than the author. Without measurement, you have fad and fashion. I think a lot of FP code is among the least readable i have seen in years. If you are going to go that level of obscurity, just go back to LISP at least the programs will be a lot shorter."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UL3CJ7YKC",
        "type": "message",
        "ts": "1568537753.085900",
        "edited": {
            "user": "UL3CJ7YKC",
            "ts": "1568540501.000000"
        },
        "client_msg_id": "14519A03-6847-4067-98F8-BA480ADD9964",
        "text": "<@U8A5MS6R1> I am glad it made sense to someone! :) So I think what you are talking about is basically the thing the \"syncronization problem\". \n\nWhat is interesting about that to me is we dont even have to bring in concurrency, we can still mess up the \"syncronicity\" and end up in an invalid\/inconsistent state.\n\nHaving multiple refs to the same mutable state might solve that sometimes out of the box (if they have the same identity as you say?) which seems interesting, but other times it is just like \"accidental\" temporal similarity of two things which might refer to DIFFERENT aspects of something - and this similarity makes us call them often by the same name at different parts if the system.\n\nFunny observation: maybe if that is the case what we have (at least partially) is a kind of \"naming problem\" as well. :)\n\nI am just dumping my thoughs, however I am glad to hear any response, because that feels important.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "5612322b81b6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-11-14\/834114331988_5612322b81b6d142511b_72.jpg",
            "first_name": "Pezo",
            "real_name": "Pezo - Zoltan Peto",
            "display_name": "Pezo - Zoltan Peto",
            "team": "T5TCAFTA9",
            "name": "pezo1919",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vR5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " I am glad it made sense to someone! :) So I think what you are talking about is basically the thing the \"syncronization problem\". \n\nWhat is interesting about that to me is we dont even have to bring in concurrency, we can still mess up the \"syncronicity\" and end up in an invalid\/inconsistent state.\n\nHaving multiple refs to the same mutable state might solve that sometimes out of the box (if they have the same identity as you say?) which seems interesting, but other times it is just like \"accidental\" temporal similarity of two things which might refer to DIFFERENT aspects of something - and this similarity makes us call them often by the same name at different parts if the system.\n\nFunny observation: maybe if that is the case what we have (at least partially) is a kind of \"naming problem\" as well. :)\n\nI am just dumping my thoughs, however I am glad to hear any response, because that feels important."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UL3CJ7YKC",
        "type": "message",
        "ts": "1568539311.104100",
        "edited": {
            "user": "UL3CJ7YKC",
            "ts": "1568540697.000000"
        },
        "client_msg_id": "AA504168-AB83-4F25-966B-AAFDDA9FA5DA",
        "text": "I also found a related not I wrote a couple weeks ago: \n\n- Observer (pattern) feels an abstraction which does the syncronization \"on (virtually) every event\" (which make the value change).\n- But because (as said above) we sometimes need to alter references to states in different &amp; multiple steps (as business logic \/ consistency requirement) : the syncronization\/consistency of our  system is at risk.\nNote that 2 different references pointing to 2 different piece of data might refer to the \"same thing\", but because of the differrent rate of change we often have to copy data to use.\nBut what \"different rate of change\" virtually means from the Observation pattern view is like: we shall have a mechanism which does NOT syncronization on \"on virtually (every) event\" (which make the value change) =&gt; \n\nto sum up: We need something like a syncronization abstraction specifying the events \/ conditions when we want to synchronize.\n\nIdentity\/Model = State + the Events it changes on.\n&lt;&lt; is there anything known about that?\nThat feels similar to a \"Lifecycle\". But \"Lifecycle\" feels similar to a \"Process\".\n\nAnd I think this is what we as programmers have to fight a lot these days, but it feels partially accidental complexity, but if not at least it seems we (or at least I) lack of the correct viewpoint to think about these.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "5612322b81b6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-11-14\/834114331988_5612322b81b6d142511b_72.jpg",
            "first_name": "Pezo",
            "real_name": "Pezo - Zoltan Peto",
            "display_name": "Pezo - Zoltan Peto",
            "team": "T5TCAFTA9",
            "name": "pezo1919",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rEFp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I also found a related not I wrote a couple weeks ago: \n\n- Observer (pattern) feels an abstraction which does the syncronization \"on (virtually) every event\" (which make the value change).\n- But because (as said above) we sometimes need to alter references to states in different & multiple steps (as business logic \/ consistency requirement) : the syncronization\/consistency of our  system is at risk.\nNote that 2 different references pointing to 2 different piece of data might refer to the \"same thing\", but because of the differrent rate of change we often have to copy data to use.\nBut what \"different rate of change\" virtually means from the Observation pattern view is like: we shall have a mechanism which does NOT syncronization on \"on virtually (every) event\" (which make the value change) => \n\nto sum up: We need something like a syncronization abstraction specifying the events \/ conditions when we want to synchronize.\n\nIdentity\/Model = State + the Events it changes on.\n<< is there anything known about that?\nThat feels similar to a \"Lifecycle\". But \"Lifecycle\" feels similar to a \"Process\".\n\nAnd I think this is what we as programmers have to fight a lot these days, but it feels partially accidental complexity, but if not at least it seems we (or at least I) lack of the correct viewpoint to think about these."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UL3CJ7YKC",
        "type": "message",
        "ts": "1568540070.114100",
        "edited": {
            "user": "UL3CJ7YKC",
            "ts": "1568540835.000000"
        },
        "client_msg_id": "E7B478F1-17A1-46D3-9229-E9D37995B9A7",
        "text": "One more related note I found:\n\nObserver pattern has the same problem in some regard as imperative programming: there is too much \"temporal dependency\" going on which are not \"tamed\". \n\nIn both cases it is not just valid assumption to have as a programmer \"things change out there\" but a requirement - and we have no initial awareness of the problem of syncronization\/consistency problems this involved. To me both approch\/school say (if they were a person): \"oh, for sure, the programmer has to take care of these, but I don't have anything to do with that. I am not even aware of that being so hard and important aspect of the work to help the programmer at any level\".",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "5612322b81b6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-11-14\/834114331988_5612322b81b6d142511b_72.jpg",
            "first_name": "Pezo",
            "real_name": "Pezo - Zoltan Peto",
            "display_name": "Pezo - Zoltan Peto",
            "team": "T5TCAFTA9",
            "name": "pezo1919",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7j1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One more related note I found:\n\nObserver pattern has the same problem in some regard as imperative programming: there is too much \"temporal dependency\" going on which are not \"tamed\". \n\nIn both cases it is not just valid assumption to have as a programmer \"things change out there\" but a requirement - and we have no initial awareness of the problem of syncronization\/consistency problems this involved. To me both approch\/school say (if they were a person): \"oh, for sure, the programmer has to take care of these, but I don't have anything to do with that. I am not even aware of that being so hard and important aspect of the work to help the programmer at any level\"."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UL3CJ7YKC",
        "type": "message",
        "ts": "1568540161.116000",
        "client_msg_id": "53E12269-121A-49A8-AE5B-593D1BA1B5B4",
        "text": "Let me add also: maybe unfortunately there is no accidental complexity there, but still I feel I lack of a level of understanding.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "5612322b81b6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-11-14\/834114331988_5612322b81b6d142511b_72.jpg",
            "first_name": "Pezo",
            "real_name": "Pezo - Zoltan Peto",
            "display_name": "Pezo - Zoltan Peto",
            "team": "T5TCAFTA9",
            "name": "pezo1919",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yTek",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Let me add also: maybe unfortunately there is no accidental complexity there, but still I feel I lack of a level of understanding."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1568542197.120200",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1568544561.000000"
        },
        "client_msg_id": "1de6207a-744d-487e-af38-e6ba100c31bb",
        "text": "Type systems typically allow reasoning about the shape of data structures, and of functions that consume\/produce them. Has anyone seen any type systems \/ theories for describing the shape and compatibility of _changes_ (patches) to data structures? You could use this to reason about whether two operations on a data structure could be reordered, for example. You could also use it to reason about replicated state.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568542197.120200",
        "reply_count": 7,
        "reply_users_count": 5,
        "latest_reply": "1568633054.156700",
        "reply_users": [
            "UL3CJ7YKC",
            "UJUQESQ1Z",
            "UCGAK10LS",
            "UD3R8FKAN",
            "UEF95M2RH"
        ],
        "replies": [
            {
                "user": "UL3CJ7YKC",
                "ts": "1568543194.125300"
            },
            {
                "user": "UJUQESQ1Z",
                "ts": "1568546707.125800"
            },
            {
                "user": "UJUQESQ1Z",
                "ts": "1568546798.126200"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1568547388.126400"
            },
            {
                "user": "UD3R8FKAN",
                "ts": "1568569572.131400"
            },
            {
                "user": "UEF95M2RH",
                "ts": "1568570174.131800"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1568633054.156700"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xK6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Type systems typically allow reasoning about the shape of data structures, and of functions that consume\/produce them. Has anyone seen any type systems \/ theories for describing the shape and compatibility of "
                            },
                            {
                                "type": "text",
                                "text": "changes",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (patches) to data structures? You could use this to reason about whether two operations on a data structure could be reordered, for example. You could also use it to reason about replicated state."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJUQESQ1Z",
                    "UA14TGLTC",
                    "UNCP67JSK"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1568542473.121400",
        "client_msg_id": "6485a7ba-b194-4e9b-a905-1d4560574f12",
        "text": "There is some work like this being done in the realm of version control, but I've not seen it applied to program execution.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bYxM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is some work like this being done in the realm of version control, but I've not seen it applied to program execution."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UL3CJ7YKC",
        "type": "message",
        "ts": "1568543194.125300",
        "client_msg_id": "AAE8FE7F-356C-4FFB-9FF1-21123EC27548",
        "text": "Types might contain much more information than the shape of data for sure. Have you checked Agda\/Idris\/ Dependent Types\/Proof checkers? Types can express many kind of \"relations\" in the logic of the underlying code it is used with\/in.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "5612322b81b6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-11-14\/834114331988_5612322b81b6d142511b_72.jpg",
            "first_name": "Pezo",
            "real_name": "Pezo - Zoltan Peto",
            "display_name": "Pezo - Zoltan Peto",
            "team": "T5TCAFTA9",
            "name": "pezo1919",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568542197.120200",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "y\/82",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Types might contain much more information than the shape of data for sure. Have you checked Agda\/Idris\/ Dependent Types\/Proof checkers? Types can express many kind of \"relations\" in the logic of the underlying code it is used with\/in."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJUQESQ1Z",
        "type": "message",
        "ts": "1568546707.125800",
        "edited": {
            "user": "UJUQESQ1Z",
            "ts": "1568546713.000000"
        },
        "client_msg_id": "5c6fecbc-47be-4f02-86db-82c729dc4e26",
        "text": "This is something I’m super interested in too. I don’t think I’ve seen it much in type theory tbh, and I think it’s super important. I’ve seen <https:\/\/www.movereem.nl\/files\/2017SANER-eventsourcing.pdf>, which kind of hints at there being some ‘algebra’ or something of changes to event streams. Swift’s ABI stability stuff might also be interesting too: <https:\/\/forums.swift.org\/t\/swift-org-blog-abi-stability-and-more\/20250>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g52a48f76fc9",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e52a48f76fc911d40711f788d74773a0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png",
            "first_name": "",
            "real_name": "Brendan Zabarauskas",
            "display_name": "Brendan Zabarauskas",
            "team": "T5TCAFTA9",
            "name": "bjzaba",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568542197.120200",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yDDq9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is something I’m super interested in too. I don’t think I’ve seen it much in type theory tbh, and I think it’s super important. I’ve seen "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.movereem.nl\/files\/2017SANER-eventsourcing.pdf"
                            },
                            {
                                "type": "text",
                                "text": ", which kind of hints at there being some ‘algebra’ or something of changes to event streams. Swift’s ABI stability stuff might also be interesting too: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/forums.swift.org\/t\/swift-org-blog-abi-stability-and-more\/20250"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJUQESQ1Z",
        "type": "message",
        "ts": "1568546798.126200",
        "client_msg_id": "ba953f8d-2627-4eb1-983d-90ad2ba40059",
        "text": "Like, this is looking at type checking between versions of a code base’s public API, which is an interesting ‘temporal’ dimension to code.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g52a48f76fc9",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e52a48f76fc911d40711f788d74773a0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png",
            "first_name": "",
            "real_name": "Brendan Zabarauskas",
            "display_name": "Brendan Zabarauskas",
            "team": "T5TCAFTA9",
            "name": "bjzaba",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568542197.120200",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SEms",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Like, this is looking at type checking between versions of a code base’s public API, which is an interesting ‘temporal’ dimension to code."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1568547388.126400",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1568548551.000000"
        },
        "client_msg_id": "4d5ec518-c571-485a-a52d-a49fad40da80",
        "text": "Thanks for the links. Regarding the type theory, I've found several papers on \"patch theories\" which formalise patches to code repositories, and some authors (<https:\/\/bit.ly\/2lRgj6S>) have suggested that we can generalise our thinking about code to include replicated state (and therefore local state, which is strictly simpler). I've not really dug into this yet though.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568542197.120200",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IU1YF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for the links. Regarding the type theory, I've found several papers on \"patch theories\" which formalise patches to code repositories, and some authors ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bit.ly\/2lRgj6S"
                            },
                            {
                                "type": "text",
                                "text": ") have suggested that we can generalise our thinking about code to include replicated state (and therefore local state, which is strictly simpler). I've not really dug into this yet though."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1568547753.126600",
        "client_msg_id": "7aa662f5-0f52-4a6d-8568-500f9acae512",
        "text": ":smile: :thumbsup::skin-tone-3:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568156672.259300",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2=2m7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "emoji",
                                "name": "thumbsup",
                                "unicode": "1f44d-1f3fc",
                                "skin_tone": 3
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1568547801.126800",
        "client_msg_id": "609db245-6b5e-4ea2-9ba8-27d4179ea692",
        "text": "I put shared global mutable state at the front and centre of the Object Net - because if you're modelling reality, that's where you have to start!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568156672.259300",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WR7p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I put shared global mutable state at the front and centre of the Object Net - because if you're modelling reality, that's where you have to start!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568555015.127200",
        "client_msg_id": "6695b501-773d-4f1a-aa5f-35d6ed0eb96d",
        "text": "You should respond to what <@UKFNXF0F9> said instead of attacking a straw man. He mentioned global services and the service locator pattern. If a reusable software component has hard coded dependencies on global mutable state, then it is not very reusable, testable or composable. A very old example of this anti-pattern was the original C library, where many library functions received inputs or returned results via global variables.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568156672.259300",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aNXFo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You should respond to what "
                            },
                            {
                                "type": "user",
                                "user_id": "UKFNXF0F9"
                            },
                            {
                                "type": "text",
                                "text": " said instead of attacking a straw man. He mentioned global services and the service locator pattern. If a reusable software component has hard coded dependencies on global mutable state, then it is not very reusable, testable or composable. A very old example of this anti-pattern was the original C library, where many library functions received inputs or returned results via global variables."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UMVFWPZ36",
        "type": "message",
        "ts": "1568560014.127600",
        "client_msg_id": "62f00f90-a713-4424-9876-de859a43a498",
        "text": "This was a great SL talk: <https:\/\/www.reddit.com\/r\/ProgrammingLanguages\/comments\/d4k7fm\/parser_parser_combinators_for_program\/>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568560014.127600",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1568632801.156400",
        "reply_users": [
            "UJN1TAYEQ",
            "UFZFETUH1"
        ],
        "replies": [
            {
                "user": "UJN1TAYEQ",
                "ts": "1568578086.144200"
            },
            {
                "user": "UFZFETUH1",
                "ts": "1568632801.156400"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "service_name": "reddit",
                "title": "\"Parser Parser Combinators for Program Transformation\" by Rijnard van Tonder (Strange Loop 2019)",
                "title_link": "https:\/\/www.reddit.com\/r\/ProgrammingLanguages\/comments\/d4k7fm\/parser_parser_combinators_for_program\/",
                "text": "Posted in r\/ProgrammingLanguages by u\/mttd • 9 points and 4 comments",
                "fallback": "reddit: \"Parser Parser Combinators for Program Transformation\" by Rijnard van Tonder (Strange Loop 2019)",
                "image_url": "https:\/\/i.ytimg.com\/vi\/JMZLBB_BFNg\/hqdefault.jpg",
                "image_width": 333,
                "image_height": 250,
                "from_url": "https:\/\/www.reddit.com\/r\/ProgrammingLanguages\/comments\/d4k7fm\/parser_parser_combinators_for_program\/",
                "image_bytes": 11843,
                "service_icon": "http:\/\/www.redditstatic.com\/desktop2x\/img\/favicon\/apple-icon-57x57.png",
                "id": 1,
                "original_url": "https:\/\/www.reddit.com\/r\/ProgrammingLanguages\/comments\/d4k7fm\/parser_parser_combinators_for_program\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+PBB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This was a great SL talk: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.reddit.com\/r\/ProgrammingLanguages\/comments\/d4k7fm\/parser_parser_combinators_for_program\/"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UMVFWPZ36",
        "type": "message",
        "ts": "1568560026.128000",
        "client_msg_id": "bbfeb3af-ac6a-404a-bb07-317130ec0624",
        "text": "Any other ones people who are there would recommend?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568560026.128000",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1568643072.169600",
        "reply_users": [
            "U5TCAFTD3"
        ],
        "replies": [
            {
                "user": "U5TCAFTD3",
                "ts": "1568643072.169600"
            }
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1568643072.169600",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+UiN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Any other ones people who are there would recommend?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UKFNXF0F9",
        "type": "message",
        "ts": "1568560364.128100",
        "client_msg_id": "9db360ca-fae6-4cc6-afb5-a1ab4ee36d46",
        "text": "The framework I am designing also put global mutable state as the center of architecture, the decesion was made before I found this community. I vaguely feel it to be the right way, but can not articulate a convincing theory from huamn cognition perspective. It would be nice we can come up something to back up our shared design choice, and build a new paradigm on solid ground.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5651704a60f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/15651704a60f7ef1539f9b1fa2506188.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png",
            "first_name": "",
            "real_name": "taowen",
            "display_name": "taowen",
            "team": "T5TCAFTA9",
            "name": "taowen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568156672.259300",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "q0dIw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The framework I am designing also put global mutable state as the center of architecture, the decesion was made before I found this community. I vaguely feel it to be the right way, but can not articulate a convincing theory from huamn cognition perspective. It would be nice we can come up something to back up our shared design choice, and build a new paradigm on solid ground."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UHDQ62M4P",
                    "UE6EFEPTQ"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UKFNXF0F9",
        "type": "message",
        "ts": "1568560612.128300",
        "edited": {
            "user": "UKFNXF0F9",
            "ts": "1568561605.000000"
        },
        "client_msg_id": "cf594bf0-06a3-4a3b-89eb-1beef8c935f6",
        "text": "As a ex-thoughtworker, who received professional education from day one on IoC pricinple, I know how OOP runtime polymorphism fail in practice. Nowdays, I would prefer to depending on global service, instead of dependency injection. Here is my answer to the question I was asking:\n1. Dependency injection is a overkill, if we only have one impl for that service. There are many ways to change the impl to use, either through configuration file, or make the service a external dependency (lib or rpc). It is like the whole application process is a container, with dependency injected. Fine-grained encapsulation is too idealism, sometimes application process as a encapsulation unit is good enough. Checkout this video: <https:\/\/www.youtube.com\/watch?v=QM1iUe6IofM>\n2. Runtime polymorphism is hard to reason about, it is better to statically assemble the components than to defer it to runtime. Human cognition has limited working memory budget, it is better spend on the real problem, not on making software \"reusable\".\n3. In terms of having clear component signature to compose safely, I do admit \"depending on global service or state\" is problematic. But the fault is orignated from limited concept provided from the language we use. Why only input arguments and return value? The dependency on some pre-existing layer should be declared and enforced as contract. We need better language and tools to \"make it explicit\". Making it explicit does not necessary mean we must make it part of parameter list. We could have a \"global dependency list\" as part of the signature as well.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5651704a60f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/15651704a60f7ef1539f9b1fa2506188.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png",
            "first_name": "",
            "real_name": "taowen",
            "display_name": "taowen",
            "team": "T5TCAFTA9",
            "name": "taowen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568156672.259300",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NosMJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As a ex-thoughtworker, who received professional education from day one on IoC pricinple, I know how OOP runtime polymorphism fail in practice. Nowdays, I would prefer to depending on global service, instead of dependency injection. Here is my answer to the question I was asking:\n1. Dependency injection is a overkill, if we only have one impl for that service. There are many ways to change the impl to use, either through configuration file, or make the service a external dependency (lib or rpc). It is like the whole application process is a container, with dependency injected. Fine-grained encapsulation is too idealism, sometimes application process as a encapsulation unit is good enough. Checkout this video: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=QM1iUe6IofM"
                            },
                            {
                                "type": "text",
                                "text": "\n2. Runtime polymorphism is hard to reason about, it is better to statically assemble the components than to defer it to runtime. Human cognition has limited working memory budget, it is better spend on the real problem, not on making software \"reusable\".\n3. In terms of having clear component signature to compose safely, I do admit \"depending on global service or state\" is problematic. But the fault is orignated from limited concept provided from the language we use. Why only input arguments and return value? The dependency on some pre-existing layer should be declared and enforced as contract. We need better language and tools to \"make it explicit\". Making it explicit does not necessary mean we must make it part of parameter list. We could have a \"global dependency list\" as part of the signature as well."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD3R8FKAN",
        "type": "message",
        "ts": "1568569572.131400",
        "client_msg_id": "1f85a7cd-92ee-452f-ab80-372689f3f0e4",
        "text": "I'm really interested in this too, specifically typed database migrations",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gef4d12b293f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/def4d12b293fcad449ccc4cfafe86dc6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0000-72.png",
            "first_name": "",
            "real_name": "Gregory M Travis",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "greg.m.travis",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568542197.120200",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CVx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm really interested in this too, specifically typed database migrations"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1568570057.131600",
        "client_msg_id": "d88b43d9-64fe-48d6-b2d5-89b35e522b34",
        "text": "<@UEQ6M68H0> “Smalltalk, absolute garbage. Try doing a bitmap rotation in it, crazy hard. ” Isn’t that a function of the libraries and not the paradigm? e.g. it’s easy to do in Objective-C using AppKit.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bZWgT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " “Smalltalk, absolute garbage. Try doing a bitmap rotation in it, crazy hard. ” Isn’t that a function of the libraries and not the paradigm? e.g. it’s easy to do in Objective-C using AppKit."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UCUSW7WVD"
                ],
                "count": 2
            }
        ]
    },
    {
        "subtype": "thread_broadcast",
        "user": "UEF95M2RH",
        "thread_ts": "1568542197.120200",
        "root": {
            "user": "UCGAK10LS",
            "type": "message",
            "ts": "1568542197.120200",
            "edited": {
                "user": "UCGAK10LS",
                "ts": "1568544561.000000"
            },
            "client_msg_id": "1de6207a-744d-487e-af38-e6ba100c31bb",
            "text": "Type systems typically allow reasoning about the shape of data structures, and of functions that consume\/produce them. Has anyone seen any type systems \/ theories for describing the shape and compatibility of _changes_ (patches) to data structures? You could use this to reason about whether two operations on a data structure could be reordered, for example. You could also use it to reason about replicated state.",
            "team": "T5TCAFTA9",
            "thread_ts": "1568542197.120200",
            "reply_count": 7,
            "reply_users_count": 5,
            "latest_reply": "1568633054.156700",
            "reply_users": [
                "UL3CJ7YKC",
                "UJUQESQ1Z",
                "UCGAK10LS",
                "UD3R8FKAN",
                "UEF95M2RH"
            ],
            "replies": [
                {
                    "user": "UL3CJ7YKC",
                    "ts": "1568543194.125300"
                },
                {
                    "user": "UJUQESQ1Z",
                    "ts": "1568546707.125800"
                },
                {
                    "user": "UJUQESQ1Z",
                    "ts": "1568546798.126200"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1568547388.126400"
                },
                {
                    "user": "UD3R8FKAN",
                    "ts": "1568569572.131400"
                },
                {
                    "user": "UEF95M2RH",
                    "ts": "1568570174.131800"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1568633054.156700"
                }
            ],
            "is_locked": false,
            "subscribed": false,
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "=bG",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "Type systems typically allow reasoning about the shape of data structures, and of functions that consume\/produce them. Has anyone seen any type systems \/ theories for describing the shape and compatibility of "
                                },
                                {
                                    "type": "text",
                                    "text": "changes",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " (patches) to data structures? You could use this to reason about whether two operations on a data structure could be reordered, for example. You could also use it to reason about replicated state."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        "type": "message",
        "ts": "1568570174.131800",
        "edited": {
            "user": "UEF95M2RH",
            "ts": "1568570332.000000"
        },
        "client_msg_id": "18ca2c87-7f3d-4fd1-8790-5212723720cf",
        "text": "<@UCGAK10LS> I'm familiar with some work in this area.\n\nI've been working on a type system for a language called Datafun (<http:\/\/www.rntz.net\/datafun>) which enforces monotonicity, and monotonicity turns out to be related to eventual consistency in distributed and concurrent systems (see <http:\/\/bloom-lang.net\/calm\/> and Lindsey Kuper's work on LVars). The idea is to only permit _increasing_ changes, so the ordering on a type describes how things of that type may change. Kevin Clancy, Heather Miller, &amp; al. have applied a similar type system to distributed programming with CRDTs (<https:\/\/infoscience.epfl.ch\/record\/231867\/files\/monotonicity-types.pdf>).\n\nAlong slightly different lines, there's a _lot_ of work in incremental computation, which implicitly has some notion of _change_ underlying it. The most popular work here is in FRP systems or in self-adjusting computation (eg. the Incremental library for OCaml). However, the work I'm most familiar with, and which makes the notion of _changes_ as a data type of their own explicit, is the incremental λ-calculus (<https:\/\/www.informatik.uni-marburg.de\/~pgiarrusso\/ILC\/> and <https:\/\/www.informatik.uni-marburg.de\/~pgiarrusso\/papers\/pldi14-ilc-author-final.pdf>). I've adapted this approach to handle Datafun's type system, but this isn't published in its entirety yet (sometime in the next year).\n\nHowever, neither of these (yet!) explicitly accounts for reasoning about when changes can\/can't be reordered. (In the case of CRDTs, the whole point is that changes can _always_ be reordered, which is a handy property but can require a lot of cleverness to achieve.)",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1qpm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " I'm familiar with some work in this area.\n\nI've been working on a type system for a language called Datafun ("
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/www.rntz.net\/datafun"
                            },
                            {
                                "type": "text",
                                "text": ") which enforces monotonicity, and monotonicity turns out to be related to eventual consistency in distributed and concurrent systems (see "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/bloom-lang.net\/calm\/"
                            },
                            {
                                "type": "text",
                                "text": " and Lindsey Kuper's work on LVars). The idea is to only permit "
                            },
                            {
                                "type": "text",
                                "text": "increasing",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " changes, so the ordering on a type describes how things of that type may change. Kevin Clancy, Heather Miller, & al. have applied a similar type system to distributed programming with CRDTs ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/infoscience.epfl.ch\/record\/231867\/files\/monotonicity-types.pdf"
                            },
                            {
                                "type": "text",
                                "text": ").\n\nAlong slightly different lines, there's a "
                            },
                            {
                                "type": "text",
                                "text": "lot",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of work in incremental computation, which implicitly has some notion of "
                            },
                            {
                                "type": "text",
                                "text": "change",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " underlying it. The most popular work here is in FRP systems or in self-adjusting computation (eg. the Incremental library for OCaml). However, the work I'm most familiar with, and which makes the notion of "
                            },
                            {
                                "type": "text",
                                "text": "changes",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as a data type of their own explicit, is the incremental λ-calculus ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.informatik.uni-marburg.de\/~pgiarrusso\/ILC\/"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.informatik.uni-marburg.de\/~pgiarrusso\/papers\/pldi14-ilc-author-final.pdf"
                            },
                            {
                                "type": "text",
                                "text": "). I've adapted this approach to handle Datafun's type system, but this isn't published in its entirety yet (sometime in the next year).\n\nHowever, neither of these (yet!) explicitly accounts for reasoning about when changes can\/can't be reordered. (In the case of CRDTs, the whole point is that changes can "
                            },
                            {
                                "type": "text",
                                "text": "always",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " be reordered, which is a handy property but can require a lot of cleverness to achieve.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UD3AK9JRF"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1568570286.132300",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1568571084.000000"
        },
        "client_msg_id": "fc87c709-e5ea-43ac-b2a6-ab705204ab48",
        "text": "<@UJN1TAYEQ> “What makes Erlang functional is that data structures are immutable values and variables are immutable: they cannot be reassigned once they are bound to a value.” I think you’ve missed my point, which was that while it looks like an FP if viewed from within a process, it is an OOP (messages and objects w mutable state) if viewed at a higher scale of  what one sees happening between processes. Does that make sense?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "F0H\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " “What makes Erlang functional is that data structures are immutable values and variables are immutable: they cannot be reassigned once they are bound to a value.” I think you’ve missed my point, which was that while it looks like an FP if viewed from within a process, it is an OOP (messages and objects w mutable state) if viewed at a higher scale of  what one sees happening between processes. Does that make sense?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UC2A2ARPT",
                    "U8A5MS6R1"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "UHWC9PXBL",
        "type": "message",
        "ts": "1568570543.135500",
        "client_msg_id": "7FBFDAD0-7A32-4233-9CD8-E9379AC3D7BF",
        "text": "at about 10 minutes into this talk i become much more susceptible to <@UCUSW7WVD>’s burn it all down and start again philosophy. \n\nmemory layout randomness\/processor caching etc can introduce performance variability of up to 40% and can lead to things like performance differentials based on which user is logged in (changes environment variables, changes the cache layout) \n\n<https:\/\/youtu.be\/r-TLSBdHe1A>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "Garth",
            "real_name": "Garth Goldwater",
            "display_name": "garth",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568570543.135500",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1568571815.140700",
        "reply_users": [
            "UCUSW7WVD",
            "UEQ6M68H0"
        ],
        "replies": [
            {
                "user": "UCUSW7WVD",
                "ts": "1568571211.140100"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1568571815.140700"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "\"Performance Matters\" by Emery Berger",
                "title_link": "https:\/\/youtu.be\/r-TLSBdHe1A",
                "author_name": "Strange Loop",
                "author_link": "https:\/\/www.youtube.com\/channel\/UC_QIfHvN9auy2CoOdSfMWDw",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/r-TLSBdHe1A\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: \"Performance Matters\" by Emery Berger",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/r-TLSBdHe1A?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/youtu.be\/r-TLSBdHe1A",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/youtu.be\/r-TLSBdHe1A"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OYoo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "at about 10 minutes into this talk i become much more susceptible to "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": "’s burn it all down and start again philosophy. \n\nmemory layout randomness\/processor caching etc can introduce performance variability of up to 40% and can lead to things like performance differentials based on which user is logged in (changes environment variables, changes the cache layout) \n\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/youtu.be\/r-TLSBdHe1A"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJN1TAYEQ",
                    "UJUQESQ1Z",
                    "UBSMEUXAA",
                    "UN57U8V53",
                    "UJCHWTMH6",
                    "UNCP67JSK"
                ],
                "count": 6
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1568570965.139200",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1568570995.000000"
        },
        "client_msg_id": "0332a1b9-2892-401f-8d6b-ff236a7eb62f",
        "text": "It'd be interesting to see a well-done stratification showing how the paradigms sit with respect to one another, in terms of how \"in the small\" \/ \"in the large\" they are. For instance, you'd probably have FP (pure functions, immutable values) and procedural (mutable, side effects, place-oriented) at the small end, OO (classes, methods\/messages) and modules\/mixins and Gang of Four-style design patterns in the middle, and then things like CSP\/Actor\/process calculi\/dataflow\/MapReduce and HPC stuff in the large. It'd probably be useful to reference this when having \"my dad can beat up your dad\" debates, to avoid saying sort of useless things like \"my dad can beat up your great grandpa\" because, like, duh.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+du",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It'd be interesting to see a well-done stratification showing how the paradigms sit with respect to one another, in terms of how \"in the small\" \/ \"in the large\" they are. For instance, you'd probably have FP (pure functions, immutable values) and procedural (mutable, side effects, place-oriented) at the small end, OO (classes, methods\/messages) and modules\/mixins and Gang of Four-style design patterns in the middle, and then things like CSP\/Actor\/process calculi\/dataflow\/MapReduce and HPC stuff in the large. It'd probably be useful to reference this when having \"my dad can beat up your dad\" debates, to avoid saying sort of useless things like \"my dad can beat up your great grandpa\" because, like, duh."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1568571092.139600",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1568571146.000000"
        },
        "client_msg_id": "54ac85d4-9c10-47c2-82d8-fbc66a46a60a",
        "text": "For example: of course the feeling of complexity from OOP is different than the feeling of complexity from FP — they're for solving problems of different magnitude. Instead, you might be better off contrasting FP and procedural programming.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Of2=F",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For example: of course the feeling of complexity from OOP is different than the feeling of complexity from FP — they're for solving problems of different magnitude. Instead, you might be better off contrasting FP and procedural programming."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1568571211.140100",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1568571436.000000"
        },
        "client_msg_id": "c336a78f-d1f8-4f77-bccd-b4e881a6a61b",
        "text": "Heh, Emery Berger used to sit two cubes over from me for a couple of years in grad school. Definitely much smarter than me. I'm way past the time when I can use being younger as a fig leaf.\n\nTo clarify my own position, though: My philosophy is to start again, but not necessarily burn it all down. That may be excessive until we have a proven alternative. But if we find ourselves in a hole, maybe we should stop digging.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568570543.135500",
        "parent_user_id": "UHWC9PXBL",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iLkv2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Heh, Emery Berger used to sit two cubes over from me for a couple of years in grad school. Definitely much smarter than me. I'm way past the time when I can use being younger as a fig leaf.\n\nTo clarify my own position, though: My philosophy is to start again, but not necessarily burn it all down. That may be excessive until we have a proven alternative. But if we find ourselves in a hole, maybe we should stop digging."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "UBSMEUXAA",
                    "UJCHWTMH6",
                    "UFV8P4472",
                    "UJBAJNFLK"
                ],
                "count": 5
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1568571573.140500",
        "client_msg_id": "f4d18ce4-43e3-425b-9a51-2cd649e8bbed",
        "text": "In the original Smalltalk 80 book by Goldberg, which i eventually threw out (now a collector's item), because it wasn't worth carrying from apartment to apartment ( a true sign of a bad language when your $50 hardbound book is tossed), there was code to do a bitmap rotation that used recursion to subdivide the image into 4 sub-squares over and over, truly mind boggling, so tricky. Smalltalk may be bad, but the Pharo IDE for Smalltak is arguably the most refined and clever IDE extant for any language. Just goes to show how lots of elapsed time can polish something very well.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9sYef",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the original Smalltalk 80 book by Goldberg, which i eventually threw out (now a collector's item), because it wasn't worth carrying from apartment to apartment ( a true sign of a bad language when your $50 hardbound book is tossed), there was code to do a bitmap rotation that used recursion to subdivide the image into 4 sub-squares over and over, truly mind boggling, so tricky. Smalltalk may be bad, but the Pharo IDE for Smalltak is arguably the most refined and clever IDE extant for any language. Just goes to show how lots of elapsed time can polish something very well."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1568571815.140700",
        "client_msg_id": "8d43d9e7-5cd3-4193-9609-ad95c901181d",
        "text": "That is a good talk by Berger. It confirms my own tests where i turned off all the fancy intel instructions and didn't even get 1% difference in performance. It proved to me that Intel is just wasting everyone's time adding nutty instructions since the Pentium that basically accomplish a form of copy protection by forcing cloners to waste massive amounts of engineering time implementing worthless instructions merely for compatibility. Thank goodness for ARM which is driving energy efficiency at Intel; at least CPU's take a lot less power to run.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568570543.135500",
        "parent_user_id": "UHWC9PXBL",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4hXV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That is a good talk by Berger. It confirms my own tests where i turned off all the fancy intel instructions and didn't even get 1% difference in performance. It proved to me that Intel is just wasting everyone's time adding nutty instructions since the Pentium that basically accomplish a form of copy protection by forcing cloners to waste massive amounts of engineering time implementing worthless instructions merely for compatibility. Thank goodness for ARM which is driving energy efficiency at Intel; at least CPU's take a lot less power to run."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1568571928.140900",
        "client_msg_id": "bf553fe7-c113-48e2-bdd9-8296f656b141",
        "text": "<@UEQ6M68H0> I don’t see what that has to do with either the paradigm or language.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=95Xj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " I don’t see what that has to do with either the paradigm or language."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UC2A2ARPT"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1568573879.141700",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1568574137.000000"
        },
        "client_msg_id": "4bd1c501-9930-4f1d-8420-fa88e91c68c7",
        "text": "There are some purists who claim that Smalltalk is the only true OOP language. Languages like Java which are considered OOP by the vast majority of people is really a blended language, containing many ALGOL aspects which is procedural in style. Very few languages are pure; most throw in aspects and features from other paradigms and languages. Today it's more common to see kitchen sink languages like Swift and Rust.  This is why i discourage use of categorizations which are approximate at best. All languages eventually map to a registers+RAM+mutable data underlying form during execution on the hardware. The only thing that notation affects is ease of initial coding, ease of debugging, and ease of transferring to other people the code base. The inventor of FP John Backus was striving to create a world of interchangeable parts. I would argue that current FP languages have near zero interchangeable parts results. I think the high water for prior art in interchangeable parts was VB6, which was ages ago. A lot of the people pushing FP are members of the programming priesthood who have discovered how to lay a nice thick blanket of obfuscation over programming. Nothing like gnarly terms like functors and monoids to befuddle the newbies. We are going to see 100 million programmers added in the next 5 years, and the people in the field today are a bit insecure about the number of people coming onboard, and are erecting natural defenses. The demystification of programming is inevitable however. This next batch is less inclined to put up with arbitrary complexity.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KFLv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There are some purists who claim that Smalltalk is the only true OOP language. Languages like Java which are considered OOP by the vast majority of people is really a blended language, containing many ALGOL aspects which is procedural in style. Very few languages are pure; most throw in aspects and features from other paradigms and languages. Today it's more common to see kitchen sink languages like Swift and Rust.  This is why i discourage use of categorizations which are approximate at best. All languages eventually map to a registers+RAM+mutable data underlying form during execution on the hardware. The only thing that notation affects is ease of initial coding, ease of debugging, and ease of transferring to other people the code base. The inventor of FP John Backus was striving to create a world of interchangeable parts. I would argue that current FP languages have near zero interchangeable parts results. I think the high water for prior art in interchangeable parts was VB6, which was ages ago. A lot of the people pushing FP are members of the programming priesthood who have discovered how to lay a nice thick blanket of obfuscation over programming. Nothing like gnarly terms like functors and monoids to befuddle the newbies. We are going to see 100 million programmers added in the next 5 years, and the people in the field today are a bit insecure about the number of people coming onboard, and are erecting natural defenses. The demystification of programming is inevitable however. This next batch is less inclined to put up with arbitrary complexity."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1568577654.143400",
        "client_msg_id": "4A563168-D802-457B-ADB5-0C2DAA3EE4A4",
        "text": "<@UEQ6M68H0> I agree with most of that. ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lKaGR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " I agree with most of that."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568578086.144200",
        "client_msg_id": "dbc75725-2fd5-434e-aea0-d5fc4bfbd5be",
        "text": "Berger's talk on Performance Matters was amazing. Garth has already linked it. I also liked \"Building Haskell Programs with Fused Effects\". <https:\/\/www.youtube.com\/watch?v=vfDazZfxlNs>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568560014.127600",
        "parent_user_id": "UMVFWPZ36",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "\"Building Haskell Programs with Fused Effects\" by Patrick Thomson",
                "title_link": "https:\/\/www.youtube.com\/watch?v=vfDazZfxlNs",
                "author_name": "Strange Loop",
                "author_link": "https:\/\/www.youtube.com\/channel\/UC_QIfHvN9auy2CoOdSfMWDw",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/vfDazZfxlNs\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: \"Building Haskell Programs with Fused Effects\" by Patrick Thomson",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/vfDazZfxlNs?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/www.youtube.com\/watch?v=vfDazZfxlNs",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=vfDazZfxlNs"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3rcz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Berger's talk on Performance Matters was amazing. Garth has already linked it. I also liked \"Building Haskell Programs with Fused Effects\". "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=vfDazZfxlNs"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1568578745.147000",
        "client_msg_id": "92a1064a-71ca-4b80-bedd-08ad2d94cc06",
        "text": "&gt; We are going to see 100 million programmers added in the next 5 years",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VLHI",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "We are going to see 100 million programmers added in the next 5 years"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1568578751.147200",
        "client_msg_id": "f8aef705-b61b-43c2-b883-092618ddd55c",
        "text": "how do you know that?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RyI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "how do you know that?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1568579160.153300",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1568579256.000000"
        },
        "client_msg_id": "EA90F726-9B00-419A-98C4-ACDFCCD9FDBF",
        "text": "<@UC2A2ARPT> I’d also like to see a chart of these features but I feel the conventional terms like FP and OOP combine too many ideas to be useful here. For example, one can have a well encapsulated message sending OO language with immutable objects, as the original actor languages did.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8LOEQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " I’d also like to see a chart of these features but I feel the conventional terms like FP and OOP combine too many ideas to be useful here. For example, one can have a well encapsulated message sending OO language with immutable objects, as the original actor languages did."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UCUSW7WVD",
                    "U8A5MS6R1",
                    "UHWC9PXBL"
                ],
                "count": 4
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1568579497.153800",
        "client_msg_id": "a6e41697-eebc-43a1-87ae-db40b2f631e5",
        "text": "In general, bundling is a huge problem in software. Our entire discourse suffers from speaking in terms of Erlang and Zookeeper rather than referential transparency and Paxos.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Giz+2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In general, bundling is a huge problem in software. Our entire discourse suffers from speaking in terms of Erlang and Zookeeper rather than referential transparency and Paxos."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1568582056.154500",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1568623388.000000"
        },
        "client_msg_id": "5b8c4f6c-1714-40f1-b281-2d3345122122",
        "text": "The 100  million number is just repeating the estimate of Bob Martin. He did a recent interesting talk at Oxford where he estimates the current base of programmers (including VBA programmers from Excel), and extrapolates the growth rate. Pretty reasonable estimates. Martin does take a long time to get to talking about the future, but his honoring of Alan Turing is a worthy detour as he was a super genius. So sad they didn't treat him better.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uV1p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The 100  million number is just repeating the estimate of Bob Martin. He did a recent interesting talk at Oxford where he estimates the current base of programmers (including VBA programmers from Excel), and extrapolates the growth rate. Pretty reasonable estimates. Martin does take a long time to get to talking about the future, but his honoring of Alan Turing is a worthy detour as he was a super genius. So sad they didn't treat him better."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1568585732.154700",
        "client_msg_id": "bb27e4a1-6ad0-4bb3-8b32-69f95d21062d",
        "text": "That link didn't work but I did find this: <https:\/\/www.youtube.com\/watch?v=BHnMItX2hEQ>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "The Future of Programming - .NET Oxford - April 2019",
                "title_link": "https:\/\/www.youtube.com\/watch?v=BHnMItX2hEQ",
                "author_name": "Pusher",
                "author_link": "https:\/\/www.youtube.com\/user\/pusherapp",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/BHnMItX2hEQ\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: The Future of Programming - .NET Oxford - April 2019",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/BHnMItX2hEQ?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/www.youtube.com\/watch?v=BHnMItX2hEQ",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=BHnMItX2hEQ"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2JtY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That link didn't work but I did find this: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=BHnMItX2hEQ"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1568603017.155300",
        "client_msg_id": "c2bf79a5-7112-4736-856b-5d00a79351d9",
        "text": "<https:\/\/youtu.be\/gCWtkvDQ2ZI>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568603017.155300",
        "reply_count": 16,
        "reply_users_count": 3,
        "latest_reply": "1578498492.041600",
        "reply_users": [
            "UHWC9PXBL",
            "U8A5MS6R1",
            "UC6997THT"
        ],
        "replies": [
            {
                "user": "UHWC9PXBL",
                "ts": "1568667064.191400"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1568672443.192000"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1568672581.192200"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1568738802.200300"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1568738915.200700"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1568738926.200900"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1568739060.201300"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1568739276.201500"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1568739301.201700"
            },
            {
                "user": "UC6997THT",
                "ts": "1578456911.009300"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1578492220.024000"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1578492454.028700"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1578492866.035100"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1578492952.036700"
            },
            {
                "user": "UHWC9PXBL",
                "ts": "1578492993.037900"
            },
            {
                "user": "UC6997THT",
                "ts": "1578498492.041600"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "\"Unison: a new distributed programming language\" by Paul Chiusano",
                "title_link": "https:\/\/youtu.be\/gCWtkvDQ2ZI",
                "author_name": "Strange Loop",
                "author_link": "https:\/\/www.youtube.com\/channel\/UC_QIfHvN9auy2CoOdSfMWDw",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/gCWtkvDQ2ZI\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: \"Unison: a new distributed programming language\" by Paul Chiusano",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/gCWtkvDQ2ZI?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/youtu.be\/gCWtkvDQ2ZI",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/youtu.be\/gCWtkvDQ2ZI"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ayn3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/youtu.be\/gCWtkvDQ2ZI"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UAL7940NM",
                    "U5TCAFTD3",
                    "UD3AK9JRF",
                    "UHWC9PXBL"
                ],
                "count": 4
            },
            {
                "name": "+1",
                "users": [
                    "UL3CJ7YKC",
                    "U5TCAFTD3",
                    "UHWC9PXBL"
                ],
                "count": 3
            }
        ]
    }
]