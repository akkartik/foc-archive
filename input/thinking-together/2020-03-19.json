[
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1584626568.399800",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1584626608.000000"
        },
        "client_msg_id": "ff3be9c0-4279-479d-b1a9-6a80ece610fe",
        "text": "I think he's hallucinating some conspiracy theory over what is really just a \"Worse is Better\" scenario. It's sad, there are some great motivating observations in there, but it's all written from a very privileged tech bro perspective.\n\nI wish more people would not buy into the simplistic \"end user is stupid\" narrative when it was more like \"end users don't want to and shouldn't have to care about all that computing stuff and just get stuff done\". The first comment and the author's response to it are also valuable to look at.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584162895.317900",
        "parent_user_id": "U8A5MS6R1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GqyY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think he's hallucinating some conspiracy theory over what is really just a \"Worse is Better\" scenario. It's sad, there are some great motivating observations in there, but it's all written from a very privileged tech bro perspective.\n\nI wish more people would not buy into the simplistic \"end user is stupid\" narrative when it was more like \"end users don't want to and shouldn't have to care about all that computing stuff and just get stuff done\". The first comment and the author's response to it are also valuable to look at."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UN06QADNV",
        "type": "message",
        "ts": "1584643351.400400",
        "client_msg_id": "4c0476cb-86ed-4654-bc4f-0c45f58e366d",
        "text": "Hi all,\n\nI would be interested to hear thoughts on the current state of educational environments for programming skills and paradigms. \n\nI'm wondering if with a somewhat enhanced approach to sharing knowledge in our domain - certain things could be learnt (far?) more efficiently. Stretch goal would be to be learn the interesting parts of the go lang compiler in the morning, and compare their design decisions and trade offs to the internals of the dotty compiler in the afternoon. \n\nTo me; its another angle on \"accidental complexity.\" There certainly are a number of hard bits in building and understanding software; but, whenever I start to get my head somewhat around a code set; I generally feel that the interesting \/ insightful \/ useful bits of the solution are far too buried in boilerplate and various other forms of noise.\n\nI think the \"learning\" angle is a useful perspective to keep in mind. I do mainly mean it in the read a textbook \/ blog post, watch a youtube video, attend a (virtual) conference, go to coding bootcamp \/ university, onboard a new joiner to your team kinda way. But; I also feel that \"learning\" is pretty much all we are every trying to do. \"Learn\" how to implement this Rest API and make it slightly more testable than our last attempt. \"Learn\" what the root cause of this bug taking down our entire production platform is etc.\n\nOf course; all thoughts and comments welcome - I would be interested to hear peoples views on points such as\n- what events stand out as important learning points in your path to technical enlightenment?\n- what approaches have been used to \"get up to speed\" in order to contribute to open source software? Perhaps from the \"how did you learn enough stuff to be useful\" perspective\n- how well (or not) have you seen the \"living\" knowledge of a code-set be managed in secular projects?\n- Is Udemy all we should hope for; or could we build better environments within which to have our discussions?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g96c2c97e5ed",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/96c2c97e5edea550b6935e656f64204c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0023-72.png",
            "first_name": "",
            "real_name": "Brent",
            "display_name": "Brent",
            "team": "T5TCAFTA9",
            "name": "brentgracey",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "reply_count": 18,
        "reply_users_count": 5,
        "latest_reply": "1584716328.433000",
        "reply_users": [
            "UAJKEBGP8",
            "UAVCC2X70",
            "UD6EXQVM0",
            "UN06QADNV",
            "UKDM3GLAJ"
        ],
        "replies": [
            {
                "user": "UAJKEBGP8",
                "ts": "1584647438.404100"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1584647986.416000"
            },
            {
                "user": "UAJKEBGP8",
                "ts": "1584648446.416400"
            },
            {
                "user": "UAJKEBGP8",
                "ts": "1584648479.416600"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1584648804.416800"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1584663848.419200"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1584664097.419400"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1584666274.420200"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1584667089.420700"
            },
            {
                "user": "UN06QADNV",
                "ts": "1584702338.430300"
            },
            {
                "user": "UN06QADNV",
                "ts": "1584702366.430500"
            },
            {
                "user": "UN06QADNV",
                "ts": "1584702490.431300"
            },
            {
                "user": "UAJKEBGP8",
                "ts": "1584714145.431500"
            },
            {
                "user": "UAJKEBGP8",
                "ts": "1584714285.431700"
            },
            {
                "user": "UAJKEBGP8",
                "ts": "1584714702.432000"
            },
            {
                "user": "UAJKEBGP8",
                "ts": "1584714781.432300"
            },
            {
                "user": "UAJKEBGP8",
                "ts": "1584714802.432500"
            },
            {
                "user": "UKDM3GLAJ",
                "ts": "1584716328.433000"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qeyc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi all,\n\nI would be interested to hear thoughts on the current state of educational environments for programming skills and paradigms. \n\nI'm wondering if with a somewhat enhanced approach to sharing knowledge in our domain - certain things could be learnt (far?) more efficiently. Stretch goal would be to be learn the interesting parts of the go lang compiler in the morning, and compare their design decisions and trade offs to the internals of the dotty compiler in the afternoon. \n\nTo me; its another angle on \"accidental complexity.\" There certainly are a number of hard bits in building and understanding software; but, whenever I start to get my head somewhat around a code set; I generally feel that the interesting \/ insightful \/ useful bits of the solution are far too buried in boilerplate and various other forms of noise.\n\nI think the \"learning\" angle is a useful perspective to keep in mind. I do mainly mean it in the read a textbook \/ blog post, watch a youtube video, attend a (virtual) conference, go to coding bootcamp \/ university, onboard a new joiner to your team kinda way. But; I also feel that \"learning\" is pretty much all we are every trying to do. \"Learn\" how to implement this Rest API and make it slightly more testable than our last attempt. \"Learn\" what the root cause of this bug taking down our entire production platform is etc.\n\nOf course; all thoughts and comments welcome - I would be interested to hear peoples views on points such as\n- what events stand out as important learning points in your path to technical enlightenment?\n- what approaches have been used to \"get up to speed\" in order to contribute to open source software? Perhaps from the \"how did you learn enough stuff to be useful\" perspective\n- how well (or not) have you seen the \"living\" knowledge of a code-set be managed in secular projects?\n- Is Udemy all we should hope for; or could we build better environments within which to have our discussions?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UA14TGLTC",
                    "UD6EXQVM0",
                    "UQPHR6Y3S"
                ],
                "count": 4
            },
            {
                "name": "bulb",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UAJKEBGP8",
        "type": "message",
        "ts": "1584647438.404100",
        "client_msg_id": "c721c9a3-0580-42c2-ba22-1fcfcadd79cc",
        "text": "hey Brent, I’ve spent the last 5 years in online learning. I’ll speak specifically to “Is Udemy all we should hope for”?\n\nSpecifically, the company I worked for created an integrated environment for learning python, data science, etc (similar to Codecademy, hands-on, problem solving based approach). This was helpful for students that were motivated, b\/c they no longer had to spend hours debugging command line \/ installation \/ other computer issues. They could just focus on debugging their Python code (we also showed variable state to help a tiny bit with debugging, but it was definitely no “Python tutor” like environment).\n\nI think better environments can help highly motivated students, but not unmotivated students.. a word I’m using in the broadest sense and in a non-judgmental way. A biology student that doesn’t need to code or w\/e I’d argue is unmotivated. So then the question is … are you interested in turning unmotivated students into computational thinkers? Or do you want to teach motivated students better Python?\n\nThose are 2 very different problems :stuck_out_tongue:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "72578ab3b4f8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-10-09\/2610495978720_72578ab3b4f8ab9ef250_72.jpg",
            "first_name": "Srini",
            "real_name": "Srini K",
            "display_name": "Srini K",
            "team": "T5TCAFTA9",
            "name": "skadamat",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "parent_user_id": "UN06QADNV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eQFK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "hey Brent, I’ve spent the last 5 years in online learning. I’ll speak specifically to “Is Udemy all we should hope for”?\n\nSpecifically, the company I worked for created an integrated environment for learning python, data science, etc (similar to Codecademy, hands-on, problem solving based approach). This was helpful for students that were motivated, b\/c they no longer had to spend hours debugging command line \/ installation \/ other computer issues. They could just focus on debugging their Python code (we also showed variable state to help a tiny bit with debugging, but it was definitely no “Python tutor” like environment).\n\nI think better environments can help highly motivated students, but not unmotivated students.. a word I’m using in the broadest sense and in a non-judgmental way. A biology student that doesn’t need to code or w\/e I’d argue is unmotivated. So then the question is … are you interested in turning unmotivated students into computational thinkers? Or do you want to teach motivated students better Python?\n\nThose are 2 very different problems "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue",
                                "unicode": "1f61b"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1584647986.416000",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1584648242.000000"
        },
        "client_msg_id": "b2f4fcca-a54e-49e3-a326-ba383b14ff4b",
        "text": "So there's two different things going on here:\n* Learning \"programming\" (e.g. education)\n* Learning what's in a certain codebase, or how to use a specific tool or language or framework.\n\nI'll comment on the first:\n\n\"Programming\" is usually taught in terms of learning a specific language or tool, and getting it to compile and it's nuances, etc. In other words, in terms of the second category, above. I think that's a mistake, but that's NOT what programming IS. It's just what it HAPPENS to entail right now, as currently practiced \/ implemented. How the heck can we improve on or escape from any of that is it's taught that \"programming\" is getting a Java app to build, etc.\n\nInstead, I think we need custom tools or environments or whatever, that expose the now concrete concepts of programming to be explored. This might not be an actual language, or might be very sandboxed; but the important thing is the CONCEPTS.\n\nLearning using traditional programming bloat just gets in the way. People end up focusing more on the syntax to get a Java class to compile (sometimes not even knowing yet what that even means), and the understanding of what's being programmed and what that means, is lost \/ mixed up with a ton of boilerplate and tooling that is NOT PROGRAMMING. It's very confusing for new Learners.\n\nIt's true really of any language or tool. \"Learning python\" is not learning \"programming\" -- though some of that still happens as a side effect, that's not the same thing, and it's learned in a very specific context; the student will think that they are \"learning programming\" because they've learned some python commands; they will think that's what it means to program",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "parent_user_id": "UN06QADNV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1tB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So there's two different things going on here:\n* Learning \"programming\" (e.g. education)\n* Learning what's in a certain codebase, or how to use a specific tool or language or framework.\n\nI'll comment on the first:\n\n\"Programming\" is usually taught in terms of learning a specific language or tool, and getting it to compile and it's nuances, etc. In other words, in terms of the second category, above. I think that's a mistake, but that's NOT what programming IS. It's just what it HAPPENS to entail right now, as currently practiced \/ implemented. How the heck can we improve on or escape from any of that is it's taught that \"programming\" is getting a Java app to build, etc.\n\nInstead, I think we need custom tools or environments or whatever, that expose the now concrete concepts of programming to be explored. This might not be an actual language, or might be very sandboxed; but the important thing is the CONCEPTS.\n\nLearning using traditional programming bloat just gets in the way. People end up focusing more on the syntax to get a Java class to compile (sometimes not even knowing yet what that even means), and the understanding of what's being programmed and what that means, is lost \/ mixed up with a ton of boilerplate and tooling that is NOT PROGRAMMING. It's very confusing for new Learners.\n\nIt's true really of any language or tool. \"Learning python\" is not learning \"programming\" -- though some of that still happens as a side effect, that's not the same thing, and it's learned in a very specific context; the student will think that they are \"learning programming\" because they've learned some python commands; they will think that's what it means to program"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAJKEBGP8",
        "type": "message",
        "ts": "1584648446.416400",
        "client_msg_id": "1d04950a-9a0e-4c94-87e6-031d8a9cf563",
        "text": "Strongly agree, and I think most people here would, that programming is definitely not just “Python” or “javascript” .. which are just temporary quirks. However, I wonder how you’d define “programming”? Is it general computing? Is it the art of creating programs to do something creative \/ accomplish a task? Excel is kinda programming but the learning curve for that is very different than it is for a “real” language like Python or JavaScript (again real in quotation marks).\n\nAlso, sadly, I don’t think there’s much of an appetite \/ audience for “general programming” knowledge. Everyone’s rushing to teach “practical” skills. Even in K-12 they teach Python often, or they’ll teach a more conceptual pre-cursor like block based programming \/ Scratch .. but then level up to “real” coding like Python. Part of the problem too is .. teaching kids (or even new adults) something that feels like the fake version of the “real” thing can be demoralizing. One day, the “real” programming thing will feel a lot more like Excel (which I guess why this community exists) and the ramp from conceptual program to “real” programming will be smoother",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "72578ab3b4f8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-10-09\/2610495978720_72578ab3b4f8ab9ef250_72.jpg",
            "first_name": "Srini",
            "real_name": "Srini K",
            "display_name": "Srini K",
            "team": "T5TCAFTA9",
            "name": "skadamat",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "parent_user_id": "UN06QADNV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O8tK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Strongly agree, and I think most people here would, that programming is definitely not just “Python” or “javascript” .. which are just temporary quirks. However, I wonder how you’d define “programming”? Is it general computing? Is it the art of creating programs to do something creative \/ accomplish a task? Excel is kinda programming but the learning curve for that is very different than it is for a “real” language like Python or JavaScript (again real in quotation marks).\n\nAlso, sadly, I don’t think there’s much of an appetite \/ audience for “general programming” knowledge. Everyone’s rushing to teach “practical” skills. Even in K-12 they teach Python often, or they’ll teach a more conceptual pre-cursor like block based programming \/ Scratch .. but then level up to “real” coding like Python. Part of the problem too is .. teaching kids (or even new adults) something that feels like the fake version of the “real” thing can be demoralizing. One day, the “real” programming thing will feel a lot more like Excel (which I guess why this community exists) and the ramp from conceptual program to “real” programming will be smoother"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAJKEBGP8",
        "type": "message",
        "ts": "1584648479.416600",
        "client_msg_id": "35a84096-798d-4921-8e94-9aa13060a836",
        "text": "but I think the question of “what programming” actually is, is quite interesting. I don’t know if we’ve quite figured it out b\/c programming always lives in the assumptions and trappings of a pre-existing language of some kind!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "72578ab3b4f8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-10-09\/2610495978720_72578ab3b4f8ab9ef250_72.jpg",
            "first_name": "Srini",
            "real_name": "Srini K",
            "display_name": "Srini K",
            "team": "T5TCAFTA9",
            "name": "skadamat",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "parent_user_id": "UN06QADNV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "c1xn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "but I think the question of “what programming” actually is, is quite interesting. I don’t know if we’ve quite figured it out b\/c programming always lives in the assumptions and trappings of a pre-existing language of some kind!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1584648804.416800",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1584694290.000000"
        },
        "client_msg_id": "345b84b0-6fb7-4258-9776-2fbb728dd6ca",
        "text": "I'd say that Bret Victor captures very well what programming is \/ is not, in \"Learning Programming\"\n\n<http:\/\/worrydream.com\/LearnableProgramming\/|http:\/\/worrydream.com\/LearnableProgramming\/>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "parent_user_id": "UN06QADNV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I+qi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd say that Bret Victor captures very well what programming is \/ is not, in \"Learning Programming\"\n\n"
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/worrydream.com\/LearnableProgramming\/",
                                "text": "http:\/\/worrydream.com\/LearnableProgramming\/"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1584649231.419000",
        "client_msg_id": "ED4D7966-8376-4E01-9A26-B63EF811F8D2",
        "text": "No such dichotomy in Smalltalk either. The common point between Smalltalk and Lisp machines: the system comes with a GUI by default, it’s not an optional add-on.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584544384.396000",
        "parent_user_id": "USH01JEDQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MfGp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "No such dichotomy in Smalltalk either. The common point between Smalltalk and Lisp machines: the system comes with a GUI by default, it’s not an optional add-on."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1584663848.419200",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1584664378.000000"
        },
        "client_msg_id": "4f78deac-5bae-47d8-bd9c-cc4c21d5ba31",
        "text": "I find most programming tools and libraries remarkably hard to learn (usually because of a lack of documentation or poor-quality documentation), but perhaps even more amazing is how everybody acts like these things aren't hard to learn, as if maybe I have a learning disability even though I got A's in school. At the same time I feel (strongly) like I produce better code than almost everyone else. It's as if I'm unusually competent at production and unusually incompetent at consumption. It is confusing. I have various ideas about teaching, but they might be very effective if everybody else has a different learning style.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "parent_user_id": "UN06QADNV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kZ2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I find most programming tools and libraries remarkably hard to learn (usually because of a lack of documentation or poor-quality documentation), but perhaps even more amazing is how everybody acts like these things aren't hard to learn, as if maybe I have a learning disability even though I got A's in school. At the same time I feel (strongly) like I produce better code than almost everyone else. It's as if I'm unusually competent at production and unusually incompetent at consumption. It is confusing. I have various ideas about teaching, but they might be very effective if everybody else has a different learning style."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1584664097.419400",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1584664199.000000"
        },
        "client_msg_id": "c73bc827-c7ae-4d74-8374-e91579db79f1",
        "text": "Anyway, it seems like really good teaching is hard. I was really impressed with how <http:\/\/vuemastery.com|vuemastery.com> teaches Vue - at least the non-paywalled videos I saw have lots of great animations nicely timed to the instructor, but the animations sure look labor-intensive. <http:\/\/scrimba.com|scrimba.com> probably has much better \"bang for the buck\" in terms of \"teaching effectiveness per unit of time it takes to put a course together\", since the viewer can play with the code at any time and the instructor need not put lots of work into fancy animations.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "parent_user_id": "UN06QADNV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q5w6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Anyway, it seems like really good teaching is hard. I was really impressed with how "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/vuemastery.com",
                                "text": "vuemastery.com"
                            },
                            {
                                "type": "text",
                                "text": " teaches Vue - at least the non-paywalled videos I saw have lots of great animations nicely timed to the instructor, but the animations sure look labor-intensive. "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/scrimba.com",
                                "text": "scrimba.com"
                            },
                            {
                                "type": "text",
                                "text": " probably has much better \"bang for the buck\" in terms of \"teaching effectiveness per unit of time it takes to put a course together\", since the viewer can play with the code at any time and the instructor need not put lots of work into fancy animations."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1584666274.420200",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1584673216.000000"
        },
        "client_msg_id": "c5ef19e9-79b4-41f1-857b-74e344126329",
        "text": "Anyway, since watching Bret Victor's \"Inventing on Principle\" I was sure I wanted to \"Invent on Principle\" as he suggested, but the tricky part is figuring out what my Big Principle is.\n\nOne angle I've homed in on is the principle that \"easy-sounding things should be easy\". Programming is full of things that seem like they should be easy, but are *unnecessarily* hard in practice. Things like drawing graphics efficiently (you can start easily with Windows Forms but if you want efficient drawing you have to make this massive leap over to DirectX, in which case, good luck implementing your GUI widgets by hand) playing music and sounds (okay, playing a .wav file might be a simple static method call, but generating audio continuously or playing an mp3 or opus stream might be far more difficult), or keeping a user interface synchronized with the underlying data model (but see SwiftUI, Assisticant, MobX\/KnockoutJS for reactive solutions in Swift, C# and JS respectively)\n\nIn this view, then, the problem isn't so much education, the problem is that our tools are too hard to use. If the tools were easier, education would be easier too.\n\nTaking this a step further, I think there should be a toolset that allows a single universal education.\n\nWe haven't figured out what the \"ideal\" programming language looks like yet, as there are so many ideas still being explored (consider Unison, Idris, JAI, Nim, Ceylon, as well as the languages made by people right here in FoC). However, there are a lot of ideas that are highly useful and fairly universal: interfaces, unit testing, sequences (including singly-linked lists, growable arrays and hashtables, semi-persistent data structures (ask me about them), functional programming, ranges and slices of collections, <http:\/\/loyc.net\/loyc-trees\/|universal syntax trees>, serialization, asynchronous functions, symbols like in Lisps\/Ruby\/JS, reactive state, geometry primitives like points, infinite lines, planes, affine matricies, garbage collection slash refcounting with weak refs, graphics, sound, sending UDP packets...\n\nI would like to be part of a group that develops a really good <http:\/\/loyc.net\/2014\/design-elements-of-mlsl.html|multi-language standard library> and implements it in several languages. If such a library were widely available and if people bothered to learn it, it would bestow the ability to write code in many languages more easily. It would also be useful as the basis of tools for converting code between languages (the hardest part of converting code from one mainstream language to another is dealing with differences between standard libraries, since the actual semantics of popular languages are, at least on some level, fairly similar.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "parent_user_id": "UN06QADNV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YXAZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Anyway, since watching Bret Victor's \"Inventing on Principle\" I was sure I wanted to \"Invent on Principle\" as he suggested, but the tricky part is figuring out what my Big Principle is.\n\nOne angle I've homed in on is the principle that \"easy-sounding things should be easy\". Programming is full of things that seem like they should be easy, but are "
                            },
                            {
                                "type": "text",
                                "text": "unnecessarily",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " hard in practice. Things like drawing graphics efficiently (you can start easily with Windows Forms but if you want efficient drawing you have to make this massive leap over to DirectX, in which case, good luck implementing your GUI widgets by hand) playing music and sounds (okay, playing a .wav file might be a simple static method call, but generating audio continuously or playing an mp3 or opus stream might be far more difficult), or keeping a user interface synchronized with the underlying data model (but see SwiftUI, Assisticant, MobX\/KnockoutJS for reactive solutions in Swift, C# and JS respectively)\n\nIn this view, then, the problem isn't so much education, the problem is that our tools are too hard to use. If the tools were easier, education would be easier too.\n\nTaking this a step further, I think there should be a toolset that allows a single universal education.\n\nWe haven't figured out what the \"ideal\" programming language looks like yet, as there are so many ideas still being explored (consider Unison, Idris, JAI, Nim, Ceylon, as well as the languages made by people right here in FoC). However, there are a lot of ideas that are highly useful and fairly universal: interfaces, unit testing, sequences (including singly-linked lists, growable arrays and hashtables, semi-persistent data structures (ask me about them), functional programming, ranges and slices of collections, "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/loyc.net\/loyc-trees\/",
                                "text": "universal syntax trees"
                            },
                            {
                                "type": "text",
                                "text": ", serialization, asynchronous functions, symbols like in Lisps\/Ruby\/JS, reactive state, geometry primitives like points, infinite lines, planes, affine matricies, garbage collection slash refcounting with weak refs, graphics, sound, sending UDP packets...\n\nI would like to be part of a group that develops a really good "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/loyc.net\/2014\/design-elements-of-mlsl.html",
                                "text": "multi-language standard library"
                            },
                            {
                                "type": "text",
                                "text": " and implements it in several languages. If such a library were widely available and if people bothered to learn it, it would bestow the ability to write code in many languages more easily. It would also be useful as the basis of tools for converting code between languages (the hardest part of converting code from one mainstream language to another is dealing with differences between standard libraries, since the actual semantics of popular languages are, at least on some level, fairly similar.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1584667089.420700",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1584671721.000000"
        },
        "client_msg_id": "30174bb8-2b2d-4291-99bd-a7a5e3c02797",
        "text": "I also think certain programming principles are much more important than others. Bad code typically results from violating one of the following principles that I follow:\n\n1. Separate concerns!!! A program is like a house: just as walls give a house structure, separation of concerns gives a program structure. Most programming languages do not facilitate separation of concerns because they allow almost anything to touch almost anything else. Programmer discipline is required to create imaginary walls where no connections are allowed. For example, a language typically can't stop the GUI from directly running SQL update commands, so the wall between GUI and a specific data persistence library rests only in the minds of the developers. (I think some people \"solve\" this lack of compiler enforcement with \"microservices architectures\", but any solution that involves huge amounts of otherwise unnecessary plumbing code is not a good solution.)\n2. The Generalized Don't Repeat Yourself principle: avoid not just repeating information or business logic in multiple places, but minimize repetition of any patterns whatsoever. Elegant code minimizes the number of tokens in the program.\n3. Create functions and abstractions appropriately, but avoid excessive layering\/wrapping (doing so is often motivated by prior failure to refactor, or failure to test, leading to brittle code you don't dare touch). There is an appropriate number of layers of abstraction; too many or too few is confusing (and many programs have *both* too many *and* too few, in different places).\n4. Minimize the number of code entities by merging things that turn out to be very similar. For example, I realized that \"logging\" and \"reporting warnings and errors\" are essentially the same thing, so in the <http:\/\/core.loyc.net|Loyc.Essentials >way of doing things you would use the same interface `IMessageSink` for both (sometimes I wonder if no one else has noticed this). Similarly I often see interfaces like `ISomethingRetriever` whose job is to retrieve some kind of object given some kind of key. That's basically a dictionary! Just implement `IReadOnlyDictionary`, you fool, or whatever your language's equivalent is. Do not create a new and different interface every time you need to retrieve a new kind of object. More broadly, design both your interfaces and your components to be generic, reusable, and ignorant.\n5. Pick good names and write documentation that describes things in a _different way_ than the names do. I often write documentation for a class *before* its code, which leads to clear thinking and good separation of concerns. (However I have to correct the documentation later because I usually tweak something or change plans midstream.) Documentation of large-scale entities (classes, modules) and mutable state (e.g. invariants) is often more important than documentation of small-scale entities (small functions and code blocks).\n6. Write good tests (or prove correctness)\n7. Think long and hard about your decisions. _Agonize over them._ You'll never come up with an optimal design by doing the first thing that comes to mind. Even after you implement it, be on the lookout for a better approach (either so you can use it in the future, or ideally, improve the original code).\n8. Be on the lookout for new and better general-purpose techniques, and then actually use those techniques. I am slightly irritated whenever I see professional developers using strings when they should be using <https:\/\/www.codeproject.com\/Articles\/34753\/Symbols-as-extensible-enums-2-2-2|Symbols>. Why? Do you use strings in C# because it doesn't have Symbols? But you've seen Symbols in Ruby and ES6 - take the lesson you learned in the other language and apply it to C#.\n(When I wrote this I was thinking of the question \"what events stand out as important learning points in your path to technical enlightenment?\" but now I see that, rather than answer the question, I've simply explained what I think an enlightened programmer *does*. I don't remember how I learned this stuff, but I am quite convinced of its importance.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584643351.400400",
        "parent_user_id": "UN06QADNV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XcK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I also think certain programming principles are much more important than others. Bad code typically results from violating one of the following principles that I follow:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Separate concerns!!! A program is like a house: just as walls give a house structure, separation of concerns gives a program structure. Most programming languages do not facilitate separation of concerns because they allow almost anything to touch almost anything else. Programmer discipline is required to create imaginary walls where no connections are allowed. For example, a language typically can't stop the GUI from directly running SQL update commands, so the wall between GUI and a specific data persistence library rests only in the minds of the developers. (I think some people \"solve\" this lack of compiler enforcement with \"microservices architectures\", but any solution that involves huge amounts of otherwise unnecessary plumbing code is not a good solution.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The Generalized Don't Repeat Yourself principle: avoid not just repeating information or business logic in multiple places, but minimize repetition of any patterns whatsoever. Elegant code minimizes the number of tokens in the program."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Create functions and abstractions appropriately, but avoid excessive layering\/wrapping (doing so is often motivated by prior failure to refactor, or failure to test, leading to brittle code you don't dare touch). There is an appropriate number of layers of abstraction; too many or too few is confusing (and many programs have "
                                    },
                                    {
                                        "type": "text",
                                        "text": "both",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " too many "
                                    },
                                    {
                                        "type": "text",
                                        "text": "and",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " too few, in different places)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Minimize the number of code entities by merging things that turn out to be very similar. For example, I realized that \"logging\" and \"reporting warnings and errors\" are essentially the same thing, so in the "
                                    },
                                    {
                                        "type": "link",
                                        "url": "http:\/\/core.loyc.net",
                                        "text": "Loyc.Essentials "
                                    },
                                    {
                                        "type": "text",
                                        "text": "way of doing things you would use the same interface "
                                    },
                                    {
                                        "type": "text",
                                        "text": "IMessageSink",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " for both (sometimes I wonder if no one else has noticed this). Similarly I often see interfaces like "
                                    },
                                    {
                                        "type": "text",
                                        "text": "ISomethingRetriever",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " whose job is to retrieve some kind of object given some kind of key. That's basically a dictionary! Just implement "
                                    },
                                    {
                                        "type": "text",
                                        "text": "IReadOnlyDictionary",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": ", you fool, or whatever your language's equivalent is. Do not create a new and different interface every time you need to retrieve a new kind of object. More broadly, design both your interfaces and your components to be generic, reusable, and ignorant."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Pick good names and write documentation that describes things in a "
                                    },
                                    {
                                        "type": "text",
                                        "text": "different way",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " than the names do. I often write documentation for a class "
                                    },
                                    {
                                        "type": "text",
                                        "text": "before",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " its code, which leads to clear thinking and good separation of concerns. (However I have to correct the documentation later because I usually tweak something or change plans midstream.) Documentation of large-scale entities (classes, modules) and mutable state (e.g. invariants) is often more important than documentation of small-scale entities (small functions and code blocks)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Write good tests (or prove correctness)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Think long and hard about your decisions. "
                                    },
                                    {
                                        "type": "text",
                                        "text": "Agonize over them.",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " You'll never come up with an optimal design by doing the first thing that comes to mind. Even after you implement it, be on the lookout for a better approach (either so you can use it in the future, or ideally, improve the original code)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Be on the lookout for new and better general-purpose techniques, and then actually use those techniques. I am slightly irritated whenever I see professional developers using strings when they should be using "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https:\/\/www.codeproject.com\/Articles\/34753\/Symbols-as-extensible-enums-2-2-2",
                                        "text": "Symbols"
                                    },
                                    {
                                        "type": "text",
                                        "text": ". Why? Do you use strings in C# because it doesn't have Symbols? But you've seen Symbols in Ruby and ES6 - take the lesson you learned in the other language and apply it to C#."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n(When I wrote this I was thinking of the question \"what events stand out as important learning points in your path to technical enlightenment?\" but now I see that, rather than answer the question, I've simply explained what I think an enlightened programmer "
                            },
                            {
                                "type": "text",
                                "text": "does",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I don't remember how I learned this stuff, but I am quite convinced of its importance.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UTG9XLGKZ"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1584672264.423600",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1584672306.000000"
        },
        "client_msg_id": "d50b66c6-f192-4b2f-a98b-4ad2df36119c",
        "text": "<@UAVCC2X70> I've been thinking of making a \"WYSIWYT\" (what you see is what you type) editor for (the newer version of) <http:\/\/loyc.net\/les\/|LES>. The advantage of this approach would be that LES is not designed as a programming language, but rather as a foundation for building languages (especially DSLs), and so the editor could be re-used for various languages. Also, presumably while building the editor I could _figure out_ how to generalize parts of it so that those parts could be used to build WYSIWYT editors for somewhat different-looking languages... anyway, this is just a thing I'd like to do, but I might never find the time for it unless I pair up with someone, so I thought I'd mention it. I am also curious to hear about what you're building.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bres",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UAVCC2X70"
                            },
                            {
                                "type": "text",
                                "text": " I've been thinking of making a \"WYSIWYT\" (what you see is what you type) editor for (the newer version of) "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/loyc.net\/les\/",
                                "text": "LES"
                            },
                            {
                                "type": "text",
                                "text": ". The advantage of this approach would be that LES is not designed as a programming language, but rather as a foundation for building languages (especially DSLs), and so the editor could be re-used for various languages. Also, presumably while building the editor I could "
                            },
                            {
                                "type": "text",
                                "text": "figure out",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " how to generalize parts of it so that those parts could be used to build WYSIWYT editors for somewhat different-looking languages... anyway, this is just a thing I'd like to do, but I might never find the time for it unless I pair up with someone, so I thought I'd mention it. I am also curious to hear about what you're building."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "U01003H81UM"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1584672756.423900",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1584672792.000000"
        },
        "client_msg_id": "d95f8ff1-71aa-44f6-bfd8-6363217f47c0",
        "text": "I'm fascinated by the sentence \"The secret sauce was a kind of mathematics and design that seems quite missing today\" - I see code monkeys all around, banging out hundreds of thousands of lines of code as though this were normal and appropriate. Can we teach developers not to do this? Can we teach the missing mathematics and design with a \"Systems Sciences Department\"?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1584042706.253500",
        "parent_user_id": "UFB8STN7K",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VlPj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm fascinated by the sentence \"The secret sauce was a kind of mathematics and design that seems quite missing today\" - I see code monkeys all around, banging out hundreds of thousands of lines of code as though this were normal and appropriate. Can we teach developers not to do this? Can we teach the missing mathematics and design with a \"Systems Sciences Department\"?"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]