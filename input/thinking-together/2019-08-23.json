[
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1566546239.389400",
        "client_msg_id": "9d98221e-a05a-403e-b9f3-425c7f2f2a1b",
        "text": "<@UM1HH60GN> Is that so? What constructs do you use when you want to write concurrent Clojure programs?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565594209.273300",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ai3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UM1HH60GN"
                            },
                            {
                                "type": "text",
                                "text": " Is that so? What constructs do you use when you want to write concurrent Clojure programs?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566546759.390100",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1566546780.000000"
        },
        "client_msg_id": "f1ce4f50-abbc-4806-832a-cfbcadd3b307",
        "text": "Since John Backus invented his Red programming language (never released publicly) around 1972, functional programming with its insistence on immutability has been trying to win over hearts and minds for almost 50 years. Certainly in the last 10 years it has had a big uptick in popularity. However, it is an illusion, as both the Intel and ARM instruction sets have registers that mutate, and in fact there is nothing in the instruction set of either CPU architecture that makes immutability practical. The hardware is going to mutate, and the only way to create immutability is to use the \"mad hatter's tea party\" approach to memory. So there is going to be some resistance to immutability from the people who notice all the memory cache misses. Remember that it takes 100 clocks to get a piece of RAM that isn't in the cache. So you are going to pay dearly for immutability. It's a very interesting tension. Obviously they could change how CPU's work.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566430717.339900",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Kdato",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Since John Backus invented his Red programming language (never released publicly) around 1972, functional programming with its insistence on immutability has been trying to win over hearts and minds for almost 50 years. Certainly in the last 10 years it has had a big uptick in popularity. However, it is an illusion, as both the Intel and ARM instruction sets have registers that mutate, and in fact there is nothing in the instruction set of either CPU architecture that makes immutability practical. The hardware is going to mutate, and the only way to create immutability is to use the \"mad hatter's tea party\" approach to memory. So there is going to be some resistance to immutability from the people who notice all the memory cache misses. Remember that it takes 100 clocks to get a piece of RAM that isn't in the cache. So you are going to pay dearly for immutability. It's a very interesting tension. Obviously they could change how CPU's work."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1566546819.391300",
        "client_msg_id": "c1edc18e-ee27-45be-89cb-bdb50c3f2a9e",
        "text": "Global sync seems to me to be fundamentally over rigid and very much unlike reality. Indeed what you say looks very much like the real world to me, with people making best estimates of the state of things in the quickest way to hand!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hg\/0a",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Global sync seems to me to be fundamentally over rigid and very much unlike reality. Indeed what you say looks very much like the real world to me, with people making best estimates of the state of things in the quickest way to hand!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1566546845.392000",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1566546910.000000"
        },
        "client_msg_id": "f0842c3f-989b-4eab-9599-b28842fae5f5",
        "text": "I prefer to take a very loose approach to state: best efforts, push when you want, poll when you want (as in my Object Net work)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9rD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I prefer to take a very loose approach to state: best efforts, push when you want, poll when you want (as in my Object Net work)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1566547014.395300",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1566547117.000000"
        },
        "client_msg_id": "07a11e4f-7f84-4aa6-afb0-388241da0e07",
        "text": "My solution is to make state out in the open unlike OOP",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7AJ6c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My solution is to make state out in the open unlike OOP"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1566547031.395900",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1566547126.000000"
        },
        "client_msg_id": "1ad8fc9e-5bdd-4bc8-abfc-c4929c5735ca",
        "text": "Highly distributed but highly visible",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uy6p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Highly distributed but highly visible"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1566547044.396300",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1566547130.000000"
        },
        "client_msg_id": "c36c1bc4-4a09-4c3d-a29b-4090d514680d",
        "text": "Eventual consistency, etc",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8BjL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Eventual consistency, etc"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566547055.396600",
        "client_msg_id": "e7cf7003-78f4-4bad-9d4d-fdb3d82ec77b",
        "text": "What i mean by collecting state transition logic, is what they did in the Simula language. Unlike Java which has a tendency to disperse state transition logic across different source code files, because each class might have some logic associated with it, my assertion is that when the state logic is collated into one central place it is far easier to understand it. One of the toughest parts of learning someone else's code is understanding what the states are, and what causes the machine to go from one state to another. In complex systems it can be extremely hard to figure out, especially looking at a static system. Usually you have to fire up the system and put in tracing to see how it behaves. Debugging incorrect transitions is one of the reasons why reversible systems hold such great promise.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fwd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What i mean by collecting state transition logic, is what they did in the Simula language. Unlike Java which has a tendency to disperse state transition logic across different source code files, because each class might have some logic associated with it, my assertion is that when the state logic is collated into one central place it is far easier to understand it. One of the toughest parts of learning someone else's code is understanding what the states are, and what causes the machine to go from one state to another. In complex systems it can be extremely hard to figure out, especially looking at a static system. Usually you have to fire up the system and put in tracing to see how it behaves. Debugging incorrect transitions is one of the reasons why reversible systems hold such great promise."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566547246.399300",
        "client_msg_id": "d430e943-75df-44f9-bb83-7af94b079ada",
        "text": "For my first version, which is supposed to permit easy construction of multiplayer games, i am doing centralized tracked mutable state, with automatic sync during screen refresh. I don't want to try doing a real time first person shooter, because that requires full duplex communication, and for that i would prefer to have UDP packets, and unfortuantely web browsers ban UDP, you have to use TCP, which is slower and wasteful with all the ACK packets. I come from the telephony world where all the voice packets are UDP and it works great. So efficient.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x+eh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For my first version, which is supposed to permit easy construction of multiplayer games, i am doing centralized tracked mutable state, with automatic sync during screen refresh. I don't want to try doing a real time first person shooter, because that requires full duplex communication, and for that i would prefer to have UDP packets, and unfortuantely web browsers ban UDP, you have to use TCP, which is slower and wasteful with all the ACK packets. I come from the telephony world where all the voice packets are UDP and it works great. So efficient."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566547682.402200",
        "client_msg_id": "083466b2-a3e2-45a0-be82-ff34826b913c",
        "text": "The massive online multiplayer games require extremely clever networking stacks, and there are people who make their careers out of doing these stacks because when you have 100k+ people on one server you really watch the bits, and minimize transfer. There are some amusing rants on YouTube from Joe Armstrong during his lectures where he goes off on JSON, and how he practically pops a blood vessel thinking about how hard they worked at Ericsson to keep the network overhead, only to see ascii being passed around.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UXjVF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The massive online multiplayer games require extremely clever networking stacks, and there are people who make their careers out of doing these stacks because when you have 100k+ people on one server you really watch the bits, and minimize transfer. There are some amusing rants on YouTube from Joe Armstrong during his lectures where he goes off on JSON, and how he practically pops a blood vessel thinking about how hard they worked at Ericsson to keep the network overhead, only to see ascii being passed around."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGT2XN01W",
        "type": "message",
        "ts": "1566548444.402300",
        "client_msg_id": "1327a78a-966a-4f2b-beb1-a24f07f5810d",
        "text": "I haven't read the paper yet but I think such efforts often come from the frustration that so much data is opaque to other programs. Databases have a shared set of primitive types and a limited set of combination semantics that can be shared across languages. If programs would use a serialization format that would be inter-operable on the units of work of the application it would be much easier to create rich interactions between applications.\n\nImagine for example that image formats instead of being binary blogs with exif style metadata sections that are xml encoded rdf embedded in binary, the entire object model would be persisted into a database - let's say sqlite. Let's say further that no files would exist in the OS and instead applications would have to add additional tables and entries in those tables to store their data. It would then be much easier to create queries that want to find image files that were created in a certain period, with a certain camera and lens. Or it would be easier to query for emails in your local email client because every message, contact etc would live in the shared database.\n\nUnix style OSs solved this issue by treating everything as a file but thus you loose a lot of structure and ability to discern data from metadata.\n\nThe real world problem that I would see with such a system is that this is only really powerful if different applications share types as much as possible, but in reality applications rarely share type definitions even on a superficial level even for the exact same concern. I think that great effort would have to be spent to try to avoid a proliferation of types that would in the end not make it much easier to deal with data because every app would represent it's data in different tables in the database and queries would have to accommodate all these different forms.\n\nWinFS was a Microsoft effort around the mid 2000s that for what I can tell went into this direction but was unfortunately abandoned. I wrote about this back in ... 2005: <http:\/\/danielbachler.de\/coding\/2005\/07\/03\/how-we-will-be-crushed-by-terrabytes-of-data.html> (I just noticed that these old articles didn't transition the markup correctly, sorry about the mess)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g3405d9d5e0d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/b3405d9d5e0d530832a9511b27c6974e.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png",
            "first_name": "",
            "real_name": "Daniel Bachler",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "daniel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566430274.337300",
        "parent_user_id": "UCUSW7WVD",
        "attachments": [
            {
                "title": "How we will be crushed by terrabytes of data",
                "title_link": "http:\/\/danielbachler.de\/coding\/2005\/07\/03\/how-we-will-be-crushed-by-terrabytes-of-data.html",
                "text": "Imagine sitting in a room with a few hundred boxes. Each box contains a few dozen to a few hundred photos. Each photo has a number, but no name or anything. ...",
                "fallback": "How we will be crushed by terrabytes of data",
                "from_url": "http:\/\/danielbachler.de\/coding\/2005\/07\/03\/how-we-will-be-crushed-by-terrabytes-of-data.html",
                "service_name": "danielbachler.de",
                "id": 1,
                "original_url": "http:\/\/danielbachler.de\/coding\/2005\/07\/03\/how-we-will-be-crushed-by-terrabytes-of-data.html"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GUn0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I haven't read the paper yet but I think such efforts often come from the frustration that so much data is opaque to other programs. Databases have a shared set of primitive types and a limited set of combination semantics that can be shared across languages. If programs would use a serialization format that would be inter-operable on the units of work of the application it would be much easier to create rich interactions between applications.\n\nImagine for example that image formats instead of being binary blogs with exif style metadata sections that are xml encoded rdf embedded in binary, the entire object model would be persisted into a database - let's say sqlite. Let's say further that no files would exist in the OS and instead applications would have to add additional tables and entries in those tables to store their data. It would then be much easier to create queries that want to find image files that were created in a certain period, with a certain camera and lens. Or it would be easier to query for emails in your local email client because every message, contact etc would live in the shared database.\n\nUnix style OSs solved this issue by treating everything as a file but thus you loose a lot of structure and ability to discern data from metadata.\n\nThe real world problem that I would see with such a system is that this is only really powerful if different applications share types as much as possible, but in reality applications rarely share type definitions even on a superficial level even for the exact same concern. I think that great effort would have to be spent to try to avoid a proliferation of types that would in the end not make it much easier to deal with data because every app would represent it's data in different tables in the database and queries would have to accommodate all these different forms.\n\nWinFS was a Microsoft effort around the mid 2000s that for what I can tell went into this direction but was unfortunately abandoned. I wrote about this back in ... 2005: "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/danielbachler.de\/coding\/2005\/07\/03\/how-we-will-be-crushed-by-terrabytes-of-data.html"
                            },
                            {
                                "type": "text",
                                "text": " (I just noticed that these old articles didn't transition the markup correctly, sorry about the mess)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1566554252.402800",
        "client_msg_id": "9070783c-7549-42e4-95f7-265d5eba2a52",
        "text": "I like the way Richard Hickey put it: \"Immutability is the right default\". Mutability can be required either as part of requirements (e.g. in a file system) or for optimization (those cache misses), but it should be opt-in, by explicit choice.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566430717.339900",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "31Nf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like the way Richard Hickey put it: \"Immutability is the right default\". Mutability can be required either as part of requirements (e.g. in a file system) or for optimization (those cache misses), but it should be opt-in, by explicit choice."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1566555331.405700",
        "client_msg_id": "7e50e5d3-8340-48fa-bed7-fb9bc939f65d",
        "text": "Is anyone aware of work on what I'd call \"evolution-safe programming\"? The question is how one can write software in such a way that every part in every layer can evolve freely without breaking everything depending on it. There are some aspect of this in [Dark](<https:\/\/darklang.com\/>) (recently discussed here), and in [Unison](<http:\/\/unisonweb.org\/>), but is there any work on theoretical foundations or practical evaluation of proposed approaches?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566555331.405700",
        "reply_count": 13,
        "reply_users_count": 4,
        "latest_reply": "1566832948.464200",
        "reply_users": [
            "UC2A2ARPT",
            "UAVCC2X70",
            "UJBAJNFLK",
            "UJKKBAMLL"
        ],
        "replies": [
            {
                "user": "UC2A2ARPT",
                "ts": "1566583073.412500"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1566583374.412700"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1566583674.413000"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1566583742.413200"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1566591371.417600"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1566661220.430200"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1566661676.430600"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1566664138.431200"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1566664147.431600"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1566664190.432800"
            },
            {
                "user": "UJKKBAMLL",
                "ts": "1566809556.462500"
            },
            {
                "user": "UJKKBAMLL",
                "ts": "1566809794.462800"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1566832948.464200"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4pqQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is anyone aware of work on what I'd call \"evolution-safe programming\"? The question is how one can write software in such a way that every part in every layer can evolve freely without breaking everything depending on it. There are some aspect of this in [Dark]("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/darklang.com\/"
                            },
                            {
                                "type": "text",
                                "text": ") (recently discussed here), and in [Unison]("
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/unisonweb.org\/"
                            },
                            {
                                "type": "text",
                                "text": "), but is there any work on theoretical foundations or practical evaluation of proposed approaches?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1566567876.405900",
        "client_msg_id": "4f4310dd-1091-44d9-b920-a1d72100e1f9",
        "text": "<https:\/\/www.youtube.com\/watch?v=0nbkaYsR94c>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "You Suck at Excel with Joel Spolsky",
                "title_link": "https:\/\/www.youtube.com\/watch?v=0nbkaYsR94c",
                "author_name": "Joel Spolsky",
                "author_link": "https:\/\/www.youtube.com\/channel\/UC65NUFfqjWn3y02kYYl9nSQ",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/0nbkaYsR94c\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: You Suck at Excel with Joel Spolsky",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/0nbkaYsR94c?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/www.youtube.com\/watch?v=0nbkaYsR94c",
                "service_icon": "https:\/\/a.slack-edge.com\/2089\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=0nbkaYsR94c"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UJuco",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=0nbkaYsR94c"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UM1HH60GN",
        "type": "message",
        "ts": "1566569894.406200",
        "client_msg_id": "1b778299-7a93-4d45-a22e-45e47593b377",
        "text": "core.async for concurrent but not shared state",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "50ee467d1311",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-08-07\/719033961125_50ee467d13114e4314c2_72.jpg",
            "first_name": "Gary",
            "real_name": "Gary Trakhman",
            "display_name": "Gary Trakhman",
            "team": "T5TCAFTA9",
            "name": "gary.trakhman",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565594209.273300",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TzTlr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "core.async for concurrent but not shared state"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UM1HH60GN",
        "type": "message",
        "ts": "1566570020.406400",
        "edited": {
            "user": "UM1HH60GN",
            "ts": "1566570149.000000"
        },
        "client_msg_id": "93f987ec-3459-4e28-8ed4-0d87369fe326",
        "text": "atoms are generally fine for shared state in most programs, and even so, you're only ever using a handful.  I've never done or had to use the transact across multiple refs STM thing.  I did use agents once before core.async came along, but I think it's clearer to use core.async and an atom for that case.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "50ee467d1311",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-08-07\/719033961125_50ee467d13114e4314c2_72.jpg",
            "first_name": "Gary",
            "real_name": "Gary Trakhman",
            "display_name": "Gary Trakhman",
            "team": "T5TCAFTA9",
            "name": "gary.trakhman",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565594209.273300",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tvJjX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "atoms are generally fine for shared state in most programs, and even so, you're only ever using a handful.  I've never done or had to use the transact across multiple refs STM thing.  I did use agents once before core.async came along, but I think it's clearer to use core.async and an atom for that case."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UM1HH60GN",
        "type": "message",
        "ts": "1566570215.406700",
        "edited": {
            "user": "UM1HH60GN",
            "ts": "1566570238.000000"
        },
        "client_msg_id": "7fec8a9e-c330-4591-a756-e3d4a7a76f2d",
        "text": "I think the more valuable concurrency tool is using immutable data structures by default, so you can write small-scale isolated code and reuse it effectively later in a concurrent context with no changes.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "50ee467d1311",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-08-07\/719033961125_50ee467d13114e4314c2_72.jpg",
            "first_name": "Gary",
            "real_name": "Gary Trakhman",
            "display_name": "Gary Trakhman",
            "team": "T5TCAFTA9",
            "name": "gary.trakhman",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565594209.273300",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W6yej",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think the more valuable concurrency tool is using immutable data structures by default, so you can write small-scale isolated code and reuse it effectively later in a concurrent context with no changes."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1566582732.412400",
        "client_msg_id": "c020cdd4-4d59-4add-8c82-b3b95f5fd3e7",
        "text": "What are some of your favourite examples of differences between languages, tools, paradigms, etc that reduce incidental complexity? Ideally, examples that aren't too broad (eg: \"FP is less incidentally complex than OO\") nor too narrow (eg: \"Using HAMTs is less incidentally complex than other persistent immutable data structures\"). No need to go super in depth, feel free to just spew \"A is less incidentally complex than B, because X.\" at me. Based on the examples I might ask some follow-up questions if needed. Thanks!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ydU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What are some of your favourite examples of differences between languages, tools, paradigms, etc that reduce incidental complexity? Ideally, examples that aren't too broad (eg: \"FP is less incidentally complex than OO\") nor too narrow (eg: \"Using HAMTs is less incidentally complex than other persistent immutable data structures\"). No need to go super in depth, feel free to just spew \"A is less incidentally complex than B, because X.\" at me. Based on the examples I might ask some follow-up questions if needed. Thanks!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1566583073.412500",
        "client_msg_id": "cbae15fd-0d42-48f2-8bb6-8b297c1a7f1b",
        "text": "I've only heard this talked about in a rule-of-thumb or aspirational sense. For instance, that you should structure abstractions, or layers of your system, so that the things that are likely to be changed at the same time are easy to change at the same time, without needing to change any other things. Never really any explanation of how to do a good job of this. I've seen people say that composition via protocols (as opposed to class inheritance or interfaces) helps with this by allowing for better separation of concepts. The Clojure community is big on that. But again, nothing too formal. I believe the book Elements of Clojure by Zach Tellman (which is ostensibly more of a book of general principles than it is notions exclusive to Clojure) talks about this in more detail, but I haven't read it yet.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566555331.405700",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ahqW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've only heard this talked about in a rule-of-thumb or aspirational sense. For instance, that you should structure abstractions, or layers of your system, so that the things that are likely to be changed at the same time are easy to change at the same time, without needing to change any other things. Never really any explanation of how to do a good job of this. I've seen people say that composition via protocols (as opposed to class inheritance or interfaces) helps with this by allowing for better separation of concepts. The Clojure community is big on that. But again, nothing too formal. I believe the book Elements of Clojure by Zach Tellman (which is ostensibly more of a book of general principles than it is notions exclusive to Clojure) talks about this in more detail, but I haven't read it yet."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1566583374.412700",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1566583626.000000"
        },
        "client_msg_id": "f1322e21-88bc-4d96-a3b2-3e89afac39a4",
        "text": "Rails, Phoenix, and similar web frameworks are seemingly designed with this as an underlying goal. They make an attempt to help you organize your web service into conceptually separate slices of domain logic (\"resources\"), and to organize each piece of each slice into a purpose-specific area of the codebase (model, view, migration, controller, services, script, stylesheet, etc). They also create homes for code that *must* be shared, for cross-cutting concerns (literally called \"concerns\" in Rails).\n\nSo when you're working on a particular problem, you can think of it in terms of \"I need to make a change that will affect just models\", or \"... a change that affects just the Users resource\" and clearly identify which parts of the code need to be changed, and which don't.\n\nOf course, this falls apart in the real world, because resources are often tightly interdependent and it's hard to draw clear boundaries.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566555331.405700",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S45+\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Rails, Phoenix, and similar web frameworks are seemingly designed with this as an underlying goal. They make an attempt to help you organize your web service into conceptually separate slices of domain logic (\"resources\"), and to organize each piece of each slice into a purpose-specific area of the codebase (model, view, migration, controller, services, script, stylesheet, etc). They also create homes for code that "
                            },
                            {
                                "type": "text",
                                "text": "must",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " be shared, for cross-cutting concerns (literally called \"concerns\" in Rails).\n\nSo when you're working on a particular problem, you can think of it in terms of \"I need to make a change that will affect just models\", or \"... a change that affects just the Users resource\" and clearly identify which parts of the code need to be changed, and which don't.\n\nOf course, this falls apart in the real world, because resources are often tightly interdependent and it's hard to draw clear boundaries."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1566583674.413000",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1566583832.000000"
        },
        "client_msg_id": "26a6b0f6-5f10-48a9-b6eb-cac112cffea8",
        "text": "Elm does a little bit of this by using static types to enforce automatic semantic versioning, but that only really helps at the library level, not within a single codebase.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566555331.405700",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1GRQn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Elm does a little bit of this by using static types to enforce automatic semantic versioning, but that only really helps at the library level, not within a single codebase."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1566583742.413200",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1566583885.000000"
        },
        "client_msg_id": "351651f4-a519-4943-adb4-7563ce82271f",
        "text": "Rich Hickey gave a talk about safely evolving software and what the semantics around it are, but his recommendations were pretty controversial. Here's the HN discussion, so that you can get some meta commentary along with the talk itself if you'd like. <https:\/\/news.ycombinator.com\/item?id=13085952>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566555331.405700",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oOEp=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Rich Hickey gave a talk about safely evolving software and what the semantics around it are, but his recommendations were pretty controversial. Here's the HN discussion, so that you can get some meta commentary along with the talk itself if you'd like. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/news.ycombinator.com\/item?id=13085952"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UAL7940NM"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJ6LDMMN0",
        "type": "message",
        "ts": "1566590947.416400",
        "client_msg_id": "df14257f-7c74-43b4-b544-5895acc652df",
        "text": "In the context of audio\/music programming, box and arrow programming à la PureData and MaxMSP is less incidentally complex than text programming of WebAudio with JavaScript.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c210ee2df74",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-11-13\/2722434855730_0c210ee2df74838f8683_72.png",
            "first_name": "nicolas",
            "real_name": "nicolas decoster",
            "display_name": "ogadaki",
            "team": "T5TCAFTA9",
            "name": "nicolas.decoster",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lw4nu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the context of audio\/music programming, box and arrow programming à la PureData and MaxMSP is less incidentally complex than text programming of WebAudio with JavaScript."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJ6LDMMN0",
        "type": "message",
        "ts": "1566591017.417500",
        "client_msg_id": "82404c8e-9403-4721-ad33-5f100994d3a0",
        "text": "Is that count for you? Because the first can be seen as domain specific languages and maybe you meant comparing text languages?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c210ee2df74",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-11-13\/2722434855730_0c210ee2df74838f8683_72.png",
            "first_name": "nicolas",
            "real_name": "nicolas decoster",
            "display_name": "ogadaki",
            "team": "T5TCAFTA9",
            "name": "nicolas.decoster",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566591017.417500",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1566593972.421300",
        "reply_users": [
            "UC2A2ARPT"
        ],
        "replies": [
            {
                "user": "UC2A2ARPT",
                "ts": "1566593972.421300"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ixLO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is that count for you? Because the first can be seen as domain specific languages and maybe you meant comparing text languages?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1566591371.417600",
        "client_msg_id": "6ca44757-0627-4f4f-a419-65354b152adb",
        "text": "Like \"sheer layers\" in buildings: Being able to change the drapes without having to rip up the carpet",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566555331.405700",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Kfor",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Like \"sheer layers\" in buildings: Being able to change the drapes without having to rip up the carpet"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1566591528.419800",
        "client_msg_id": "6e74c726-5776-4e46-988b-1fe6d999fd2b",
        "text": "Monads are like Schrödinger's cat! (Or the container for it, anyway)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566591528.419800",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1566661279.430400",
        "reply_users": [
            "UC2A2ARPT",
            "UAVCC2X70"
        ],
        "replies": [
            {
                "user": "UC2A2ARPT",
                "ts": "1566651205.429900"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1566661279.430400"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IFx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Monads are like Schrödinger's cat! (Or the container for it, anyway)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "sunglasses",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566592666.420800",
        "client_msg_id": "836672e1-3247-405b-95ac-1f700c5efd8e",
        "text": "The future of programming is making programming much simpler, less frustrating, and more fun to do. It's about opening it up to a wider variety of people. I don't think Rich Hickey's products represent the future of ease of use. Clojure is a LISP derivative, and that is not a user friendly language. Clojure and ClojureScript are incredibly productive, but they don't solve interchangeable parts or simplify the biggest time suck of programming, which is debugging. That's why there are so many people in this group, but we know it can be much improved. The whole regime of deciding if something should be immutable, and trying to recast things awkwardly so that is true, is extra work and complexity. i don't think the programmer should have to bother considering that; it is like worrying about which register the CPU uses; that decision is all automated now, and I don't know or don't care how many registers my CPU has.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566430717.339900",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dfSB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The future of programming is making programming much simpler, less frustrating, and more fun to do. It's about opening it up to a wider variety of people. I don't think Rich Hickey's products represent the future of ease of use. Clojure is a LISP derivative, and that is not a user friendly language. Clojure and ClojureScript are incredibly productive, but they don't solve interchangeable parts or simplify the biggest time suck of programming, which is debugging. That's why there are so many people in this group, but we know it can be much improved. The whole regime of deciding if something should be immutable, and trying to recast things awkwardly so that is true, is extra work and complexity. i don't think the programmer should have to bother considering that; it is like worrying about which register the CPU uses; that decision is all automated now, and I don't know or don't care how many registers my CPU has."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1566593111.421000",
        "client_msg_id": "7c05fad1-7ad2-4f2b-b050-942f4c462298",
        "text": "You've mentioned \"interchangeable parts\" a couple of times, but could you elaborate? I am aware of <https:\/\/en.wikipedia.org\/wiki\/Gribeauval_system> and its descendants, but do you mean more by this than the conventional goal of 'reuse'?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566430717.339900",
        "parent_user_id": "UEQ6M68H0",
        "attachments": [
            {
                "image_url": "https:\/\/upload.wikimedia.org\/wikipedia\/commons\/a\/a2\/Gribeauval_system_elements.jpg",
                "image_width": 975,
                "image_height": 602,
                "image_bytes": 63089,
                "title": "Gribeauval system",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/Gribeauval_system",
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/Gribeauval_system",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/",
                "text": "The Gribeauval system (French: système Gribeauval) was an artillery system introduced by Lieutenant General Jean Baptiste Vaquette de Gribeauval during the 18th century. This system revolutionized French cannons, with a new production system that allowed lighter, more uniform guns without sacrificing range. The Gribeauval system superseded the Vallière system beginning in 1765. The new guns contributed to French military victories during the French Revolutionary Wars and Napoleonic Wars. The system included improvements to cannons, howitzers, and mortars. The Year XI system partly replaced the field guns in 1803 and the Valée system completely superseded the Gribeauval system in 1829.",
                "fallback": "wikipedia: Gribeauval system",
                "service_icon": "https:\/\/a.slack-edge.com\/bfaba\/img\/unfurl_icons\/wikipedia.png",
                "id": 1,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/Gribeauval_system"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R0Fs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You've mentioned \"interchangeable parts\" a couple of times, but could you elaborate? I am aware of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Gribeauval_system"
                            },
                            {
                                "type": "text",
                                "text": " and its descendants, but do you mean more by this than the conventional goal of 'reuse'?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1566593972.421300",
        "client_msg_id": "50799e0b-2d32-4ffd-9713-7eaa8a23ae60",
        "text": "Totally counts. Thanks!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566591017.417500",
        "parent_user_id": "UJ6LDMMN0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iCH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Totally counts. Thanks!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566609446.421500",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1566610800.000000"
        },
        "client_msg_id": "7bb2b3b2-6455-4076-9594-c7743b748065",
        "text": "Interchangeable parts were indeed pioneered by military suppliers. There is a famous anecdote about how the salesman showing president Abraham Lincoln how a gun could be assembled by picking a part from a series of tables, where the parts were pre-selected because the tolerances were not yet good enough to actually work. But the system was used to generate guns for the American Civil War, and it remains the most costly war in American history in terms of lives lost. Anyway interchangeable parts in software have been done a few times for selected ecosystems. Microsoft's VB6 was the high water mark in my opinion; they had a thriving marketplace of components for sale, and people were assembling products out of components that fit well together. To a smaller level of success but still a success the Borland Delphi system also has this going. They don't get any love from people as it is an old product, but it was well designed. If i am not mistake Anders Hejlsberg designed it, and he also designed TypeScript, so he is supremely accomplished tool developer.\n\nWe are definitely not in an era of interchangeable parts for software. If i have a project i am building and i peruse GitHub, i can search millions of repositories of code, yet I can't easily use any of it. There are too many framework and toolchain dependencies, and you either get a gigantic pile of dependencies, or it doesn't even work because things depend on conflicting versions of libraries. And the quality of the work is highly uncertain. You can't report a bug and be assured it will be fixed promptly because there is no incentive other than \"brownie points\" for keeping it up to date. You can't pay your mortgage with GitHub stars. And one cannot tell on these repositories how solid a piece of code is, and because of the tyranny of people who viciously attack any one daring to try and make a living directly and honestly from software, there is no marketplace for software components like the Apple iTunes app store or Google Play store. We really need a marketplace so people can be compensated for developing and maintaining components. For 3D models there are many marketplaces, like TurboSquid where you can pay a few dollars for a model of a ferrari that would take you 100 hours to build. A thriving business they have.\n\nIn this glorious future world, software will be more like Lego, with snap together pieces. Interestingly, there are some gigantic VC funded unicorns like Tableau which purports to offer interchangeable parts, but actually it is a bit of misdirection, as it is really just a collection of pre-made components all from one company, and it only works with their chassis. It is more like Excel with each special feature sold a-la-carte, which to me is more of a product marketing strategy than a technical breakthrough. You have to solve the dependency problem, the data interchange problem, and have a consistent drawing model for components to work harmoniously in a graphical interactive world. This is the tripartite challenge that makes it so difficult to achieve interchangeable parts. A gun is perhaps 30 pieces; compared to software a gun or a cannon is a very simple device. The whole motivation behind my Beads project is to create the possibility for interchangeable parts, which is why Beads includes a graph database, and a drawing\/event model, and an automatic dependency analyzer so pieces stay untangled. If you leave out any one of those 3 pieces, such as leaving the database outside the language, then people will choose a wide variety of databases, and then you can't mix part A with part B because one uses MySQL and the other Oracle. In toy systems like Scratch, they can achieve some interchangeability, but those kinds of systems have what i call a \"low ceiling\" where a product past a certain complexity level becomes burdensome, clumsy and clearly beyond the design vision of the original system.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566430717.339900",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cUm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Interchangeable parts were indeed pioneered by military suppliers. There is a famous anecdote about how the salesman showing president Abraham Lincoln how a gun could be assembled by picking a part from a series of tables, where the parts were pre-selected because the tolerances were not yet good enough to actually work. But the system was used to generate guns for the American Civil War, and it remains the most costly war in American history in terms of lives lost. Anyway interchangeable parts in software have been done a few times for selected ecosystems. Microsoft's VB6 was the high water mark in my opinion; they had a thriving marketplace of components for sale, and people were assembling products out of components that fit well together. To a smaller level of success but still a success the Borland Delphi system also has this going. They don't get any love from people as it is an old product, but it was well designed. If i am not mistake Anders Hejlsberg designed it, and he also designed TypeScript, so he is supremely accomplished tool developer.\n\nWe are definitely not in an era of interchangeable parts for software. If i have a project i am building and i peruse GitHub, i can search millions of repositories of code, yet I can't easily use any of it. There are too many framework and toolchain dependencies, and you either get a gigantic pile of dependencies, or it doesn't even work because things depend on conflicting versions of libraries. And the quality of the work is highly uncertain. You can't report a bug and be assured it will be fixed promptly because there is no incentive other than \"brownie points\" for keeping it up to date. You can't pay your mortgage with GitHub stars. And one cannot tell on these repositories how solid a piece of code is, and because of the tyranny of people who viciously attack any one daring to try and make a living directly and honestly from software, there is no marketplace for software components like the Apple iTunes app store or Google Play store. We really need a marketplace so people can be compensated for developing and maintaining components. For 3D models there are many marketplaces, like TurboSquid where you can pay a few dollars for a model of a ferrari that would take you 100 hours to build. A thriving business they have.\n\nIn this glorious future world, software will be more like Lego, with snap together pieces. Interestingly, there are some gigantic VC funded unicorns like Tableau which purports to offer interchangeable parts, but actually it is a bit of misdirection, as it is really just a collection of pre-made components all from one company, and it only works with their chassis. It is more like Excel with each special feature sold a-la-carte, which to me is more of a product marketing strategy than a technical breakthrough. You have to solve the dependency problem, the data interchange problem, and have a consistent drawing model for components to work harmoniously in a graphical interactive world. This is the tripartite challenge that makes it so difficult to achieve interchangeable parts. A gun is perhaps 30 pieces; compared to software a gun or a cannon is a very simple device. The whole motivation behind my Beads project is to create the possibility for interchangeable parts, which is why Beads includes a graph database, and a drawing\/event model, and an automatic dependency analyzer so pieces stay untangled. If you leave out any one of those 3 pieces, such as leaving the database outside the language, then people will choose a wide variety of databases, and then you can't mix part A with part B because one uses MySQL and the other Oracle. In toy systems like Scratch, they can achieve some interchangeability, but those kinds of systems have what i call a \"low ceiling\" where a product past a certain complexity level becomes burdensome, clumsy and clearly beyond the design vision of the original system."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0",
                    "ULM3U6275"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566610324.421700",
        "client_msg_id": "c186e02f-e26b-4dd4-a5e8-b7c73199f8bf",
        "text": "The great American inventor Eli Whitney was part of the group of Americans promoting interchangeable parts. As is so common in tech, military R&amp;D drove this technology forward.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566430717.339900",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=L26",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The great American inventor Eli Whitney was part of the group of Americans promoting interchangeable parts. As is so common in tech, military R&D drove this technology forward."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1566611906.422000",
        "client_msg_id": "6b9a76eb-6aff-436b-bdee-144659b5ca3e",
        "text": "Ok, so just reuse then. I don't buy it. People have been chasing reuse for 50 years now, and I expect them to still be looking for it long after I'm dead.\n\nAnd it's totally unnecessary. The programs we write are already boundless, factory-like desire amplifiers at runtime. Life can be pretty good even if the factories themselves need to be created in a bespoke, one-off manner.\n\nLegos are great, but playing with Legos is not programming, and it's not what I got into programming for. Programming is about bouncing between levels of abstraction, now high, now low. That's the superpower we should be trying to bring to everyone. Not infantilizing toys.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566430717.339900",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/k0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ok, so just reuse then. I don't buy it. People have been chasing reuse for 50 years now, and I expect them to still be looking for it long after I'm dead.\n\nAnd it's totally unnecessary. The programs we write are already boundless, factory-like desire amplifiers at runtime. Life can be pretty good even if the factories themselves need to be created in a bespoke, one-off manner.\n\nLegos are great, but playing with Legos is not programming, and it's not what I got into programming for. Programming is about bouncing between levels of abstraction, now high, now low. That's the superpower we should be trying to bring to everyone. Not infantilizing toys."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1566613576.427400",
        "client_msg_id": "f5c973c0-871a-4469-a3ed-7b01198876ff",
        "text": "Having recently helped someone with CS homework involving C, I had to pull the memory model of pointers to addresses out of my mind's cold storage, which suggests that the pointer model is incidental.  It is, of course, similar to the model of references to objects, but with the conceptual overhead of pointer arithmetic and dereferencing, let alone the gnarly typing syntax",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uxd=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Having recently helped someone with CS homework involving C, I had to pull the memory model of pointers to addresses out of my mind's cold storage, which suggests that the pointer model is incidental.  It is, of course, similar to the model of references to objects, but with the conceptual overhead of pointer arithmetic and dereferencing, let alone the gnarly typing syntax"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1566613671.428600",
        "client_msg_id": "ef32abff-468c-4ebb-8cf4-3ed90b71232b",
        "text": "(function pointers, I'm looking at you) as well as the call by value and call by reference distinction, which doesn't exactly go away in reference-to-objects languages.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566613671.428600",
        "reply_count": 15,
        "reply_users_count": 4,
        "latest_reply": "1566790335.462100",
        "reply_users": [
            "UC2A2ARPT",
            "UEQ6M68H0",
            "UE6EFEPTQ",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "UC2A2ARPT",
                "ts": "1566623792.428700"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1566629116.428900"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1566674705.435100"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1566693415.442200"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1566693614.442600"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1566736704.455300"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1566736722.455500"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1566736927.455700"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1566737409.455900"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1566752025.457000"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1566752355.457200"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1566752439.457400"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1566752463.457600"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1566752685.458000"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1566790335.462100"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xj8U",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(function pointers, I'm looking at you) as well as the call by value and call by reference distinction, which doesn't exactly go away in reference-to-objects languages."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1566623792.428700",
        "client_msg_id": "e5ccffaa-94fe-4985-a32d-1ed168457951",
        "text": "&gt; which doesn't exactly go away in reference-to-objects languages\n\nYou might have caught the scent of where I'm going with this gambit.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566613671.428600",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2E=H7",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "which doesn't exactly go away in reference-to-objects languages"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nYou might have caught the scent of where I'm going with this gambit."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566629116.428900",
        "client_msg_id": "e84dd459-653a-408e-89bd-5749aef80d85",
        "text": "Modula-2 had a fantastic composable type system, which made it easy to declare a pointer to an array[1..10] of a_record where a_record might have more arrays and pointers inside. Makes the C syntax look like it came from the stone age. Nothing uglier than a pointer to a function that returns a pointer to a pointer to a record, that is like a final exam in some hiring test, and pointless. The sad truth is that the designers of C where on teletypes which were painfully slow to type on, and they sacrificed readability to get low character count. People have paid for that tradeoff for almost 50 years.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566613671.428600",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EGg+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Modula-2 had a fantastic composable type system, which made it easy to declare a pointer to an array[1..10] of a_record where a_record might have more arrays and pointers inside. Makes the C syntax look like it came from the stone age. Nothing uglier than a pointer to a function that returns a pointer to a pointer to a record, that is like a final exam in some hiring test, and pointless. The sad truth is that the designers of C where on teletypes which were painfully slow to type on, and they sacrificed readability to get low character count. People have paid for that tradeoff for almost 50 years."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]