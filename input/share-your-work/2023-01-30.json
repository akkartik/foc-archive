[
    {
        "subtype": "thread_broadcast",
        "user": "U017TE5R09M",
        "thread_ts": "1670554845.886979",
        "root": {
            "user": "UC2A2ARPT",
            "type": "message",
            "ts": "1670554845.886979",
            "client_msg_id": "b4e7257c-3bee-43b0-a502-e4d8c6b9ebe2",
            "text": "Future of Coding • Episode 60\nBret Victor • Magic Ink\n:link: <https:\/\/futureofcoding.org\/episodes\/060>\n\nHey, ya'll ever hear of this guy? He posts some _wild_ stuff. Feels like it might be relevant to the folks here. Maybe a little fringe. For instance, he thinks that software could be — get this — _better!_ You might be surprised to learn that I also think software could be better. Radical idea, yes, but it feels like it's finally time for us to take the idea seriously.\n\nNext month, we're reading Peter Naur's Programming as Theory Building, with a little bit of Gilbert Ryle's The Concept of Mind as background.",
            "team": "T5TCAFTA9",
            "thread_ts": "1670554845.886979",
            "reply_count": 9,
            "reply_users_count": 4,
            "latest_reply": "1676302792.407509",
            "reply_users": [
                "U03CEGR3HSL",
                "UA14TGLTC",
                "U017TE5R09M",
                "U0112C10V4Y"
            ],
            "replies": [
                {
                    "user": "U03CEGR3HSL",
                    "ts": "1670652519.724689"
                },
                {
                    "user": "U03CEGR3HSL",
                    "ts": "1670689511.455829"
                },
                {
                    "user": "UA14TGLTC",
                    "ts": "1670824346.634189"
                },
                {
                    "user": "U017TE5R09M",
                    "ts": "1675090374.403969"
                },
                {
                    "user": "U017TE5R09M",
                    "ts": "1675091091.929849"
                },
                {
                    "user": "U017TE5R09M",
                    "ts": "1675098024.595069"
                },
                {
                    "user": "U0112C10V4Y",
                    "ts": "1676167277.746429"
                },
                {
                    "user": "U017TE5R09M",
                    "ts": "1676202770.639319"
                },
                {
                    "user": "UA14TGLTC",
                    "ts": "1676302792.407509"
                }
            ],
            "is_locked": false,
            "subscribed": false,
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "Ii=70",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "Future of Coding • Episode 60\nBret Victor • Magic Ink\n"
                                },
                                {
                                    "type": "emoji",
                                    "name": "link",
                                    "unicode": "1f517"
                                },
                                {
                                    "type": "text",
                                    "text": " "
                                },
                                {
                                    "type": "link",
                                    "url": "https:\/\/futureofcoding.org\/episodes\/060"
                                },
                                {
                                    "type": "text",
                                    "text": "\n\nHey, ya'll ever hear of this guy? He posts some "
                                },
                                {
                                    "type": "text",
                                    "text": "wild ",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": "stuff. Feels like it might be relevant to the folks here. Maybe a little fringe. For instance, he thinks that software could be — get this — "
                                },
                                {
                                    "type": "text",
                                    "text": "better!",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " You might be surprised to learn that I also think software could be better. Radical idea, yes, but it feels like it's finally time for us to take the idea seriously.\n\nNext month, we're reading Peter Naur's Programming as Theory Building, with a little bit of Gilbert Ryle's The Concept of Mind as background."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        "type": "message",
        "ts": "1675090374.403969",
        "client_msg_id": "58bb16fe-757c-4c15-814c-575eff680364",
        "text": "Just finished listening…great!\n\nSome thoughts on the whole “drawing the interface” vs. “building a machine arranging widgets using a grammar”:\n\n1. Widgets vs. drawn UI\nWe used to actually be much more in the “draw the interface” space, basically Views that draw what they have to display. Widgets were added later on for standard interactive elements such as text boxes and sliders etc.\n\nAnd there was a clear distinction, in that for most applications, the dynamic content (document) would be drawn dynamically using a custom view, whereas ancillary\/auxiliary information (inspectors etc.) would be fixed layouts of widgets, which might be dynamically enabled or disabled.\n\nBut the whole structure of the UI was largely fixed (dynamic content inside the views + widgets in static layouts).\n\nAlthough there was a bit of a trend towards widgets, that trend really took off with the Web and the iPhone.\n\nWith the iPhone, the content both got more dynamic, partly due to latency hiding with animations, partly due to the small screen making it necessary to hide unused UI, rather than juts disable it, and at the same time our tooling got more static, with UIViews that have dynamic content discouraged and preference given to static layers that are moved in and out and around.\n\nWith the DOM, you really don’t have many options except to change the structure if you want dynamic content (Canvas notwithstanding).\n\nSo we’ve been moving more and more towards a situation where even purely informational applications display their information via these static\/rigid widget sets, at the same time that they information got more dynamic.",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qSuR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Just finished listening…great!\n\nSome thoughts on the whole “drawing the interface” vs. “building a machine arranging widgets using a grammar”:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Widgets vs. drawn UI"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nWe used to actually be much more in the “draw the interface” space, basically Views that draw what they have to display. Widgets were added later on for standard interactive elements such as text boxes and sliders etc.\n\nAnd there was a clear distinction, in that for most applications, the dynamic content (document) would be drawn dynamically using a custom view, whereas ancillary\/auxiliary information (inspectors etc.) would be fixed layouts of widgets, which might be dynamically enabled or disabled.\n\nBut the whole structure of the UI was largely fixed (dynamic content inside the views + widgets in static layouts).\n\nAlthough there was a bit of a trend towards widgets, that trend really took off with the Web and the iPhone.\n\nWith the iPhone, the content both got more dynamic, partly due to latency hiding with animations, partly due to the small screen making it necessary to hide unused UI, rather than juts disable it, and at the same time our tooling got more static, with UIViews that have dynamic content discouraged and preference given to static layers that are moved in and out and around.\n\nWith the DOM, you really don’t have many options except to change the structure if you want dynamic content (Canvas notwithstanding).\n\nSo we’ve been moving more and more towards a situation where even purely informational applications display their information via these static\/rigid widget sets, at the same time that they information got more dynamic."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1675091091.929849",
        "client_msg_id": "8ff7b197-941c-4756-bb23-cd2e352b26ba",
        "text": "2. Drawing first (tooling)\n\nWe didn’t just have Flash, we also had Interface Builder. which didn’t quite have a general canvas, but also very much the workflow of creating the visuals first and then creating structure from that.\n\nThe problem with those tools is that they produce _horrible_ programs. I will go into more detail in a post I am currently writing on “What happened to MVC?“, but the gist is that to get a reasonably structured application, you really, really need to focus on the model.  In almost every codebase I’ve seen recently. people started with the screens (Product Mgt. talks to design, design creates the screens and throws them over to engineering), and so they have at best an anemic model.  And so all the coordination and in the end the application goes somewhere in\/above the view layer (iOS:  the ViewControllers or something else that’s just as horrible).  And so you get an intertwined, unstructured, untestable, unmaintainable mess.  Always.\n\nAnd of course that’s also what happened to MVC, because you can’t do proper MVC that way, and pretty much all the problems people think they have with “MVC”, they actually have because they’re not doing MVC.\n\nWhat’s really surprising about this is that, as you observed, the development tooling actually _has_ moved the other way, so we no longer really have those draw-first tools.   But despite getting rid of the tooling, we stuck with the mess that before was the price of those tools!   Worst of both worlds.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1670554845.886979",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "J5I3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "2. Drawing first (tooling)\n\nWe didn’t just have Flash, we also had Interface Builder. which didn’t quite have a general canvas, but also very much the workflow of creating the visuals first and then creating structure from that.\n\nThe problem with those tools is that they produce "
                            },
                            {
                                "type": "text",
                                "text": "horrible",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " programs. I will go into more detail in a post I am currently writing on “What happened to MVC?“, but the gist is that to get a reasonably structured application, you really, really need to focus on the model.  In almost every codebase I’ve seen recently. people started with the screens (Product Mgt. talks to design, design creates the screens and throws them over to engineering), and so they have at best an anemic model.  And so all the coordination and in the end the application goes somewhere in\/above the view layer (iOS:  the ViewControllers or something else that’s just as horrible).  And so you get an intertwined, unstructured, untestable, unmaintainable mess.  Always.\n\nAnd of course that’s also what happened to MVC, because you can’t do proper MVC that way, and pretty much all the problems people think they have with “MVC”, they actually have because they’re not doing MVC.\n\nWhat’s really surprising about this is that, as you observed, the development tooling actually "
                            },
                            {
                                "type": "text",
                                "text": "has",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " moved the other way, so we no longer really have those draw-first tools.   But despite getting rid of the tooling, we stuck with the mess that before was the price of those tools!   Worst of both worlds."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cry",
                "users": [
                    "UA14TGLTC",
                    "UC2A2ARPT",
                    "UJBAJNFLK"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1675098024.595069",
        "client_msg_id": "165c6daf-cf86-478b-a64b-3af32ebe45fb",
        "text": "I do think we can figure this out, but it’s going to be somewhat tricky.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1670554845.886979",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NTQ1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I do think we can figure this out, but it’s going to be somewhat tricky."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U03LMRE6MQE",
        "type": "message",
        "ts": "1675109516.195169",
        "client_msg_id": "8926bfdb-6c49-4ce0-9489-707113a02047",
        "text": "I've implemented Effect handlers in my language <https:\/\/vimeo.com\/794219638>\nThis is now the whole feature set I wanted to version 2 of my language. Now all that's left is to actually use it",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ea29e26e919b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-06-23\/3708469439522_ea29e26e919bc202feb6_72.png",
            "first_name": "Peter",
            "real_name": "Peter Saxton",
            "display_name": "Peter Saxton",
            "team": "T5TCAFTA9",
            "name": "peterhsaxton",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/vimeo.com\/794219638",
                "video_html": "<iframe src=\"https:\/\/player.vimeo.com\/video\/794219638?h=61d39dcf1b&amp;autoplay=1&amp;app_id=122963\" width=\"400\" height=\"225\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen title=\"30\/01\/2023, Effect Handlers\"><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "thumb_url": "https:\/\/i.vimeocdn.com\/video\/1599338787-c2856cb7a02d3d82fec9caf234f9b3dda832ff93849d29b09ca293d24a252b66-d_295x166",
                "thumb_width": 295,
                "thumb_height": 166,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/vimeo.png",
                "id": 1,
                "original_url": "https:\/\/vimeo.com\/794219638",
                "fallback": "Vimeo Video: 30\/01\/2023, Effect Handlers",
                "title": "30\/01\/2023, Effect Handlers",
                "title_link": "https:\/\/vimeo.com\/794219638",
                "author_name": "crowdhailer",
                "author_link": "https:\/\/vimeo.com\/crowdhailer",
                "service_name": "Vimeo",
                "service_url": "https:\/\/vimeo.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dX7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've implemented Effect handlers in my language "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/vimeo.com\/794219638"
                            },
                            {
                                "type": "text",
                                "text": "\nThis is now the whole feature set I wanted to version 2 of my language. Now all that's left is to actually use it"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04MAEU6VHN",
        "type": "message",
        "ts": "1675140821.935599",
        "edited": {
            "user": "U04MAEU6VHN",
            "ts": "1675140856.000000"
        },
        "client_msg_id": "6be892b8-a3aa-4fcd-be9b-43746129d32d",
        "text": "Hi friends! I'm new to this slack, but I've been dabbling in this space off and on for a while. I've completed a draft of a blog post about type inference in my projectional language \/ structured editor, and I'd love to get your feedback! <https:\/\/gist.github.com\/jaredly\/13abec33c7576c4636ca87039a999cf2|\"Type inference that sticks\">. thanks! :slightly_smiling_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43e7ef32ef6c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-01-25\/4713451001249_43e7ef32ef6c84455dbd_72.jpg",
            "first_name": "Jared",
            "real_name": "Jared Forsyth",
            "display_name": "Jared Forsyth",
            "team": "T5TCAFTA9",
            "name": "jabapyth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675140821.935599",
        "reply_count": 13,
        "reply_users_count": 5,
        "latest_reply": "1675265095.798459",
        "reply_users": [
            "UJBAJNFLK",
            "U0296ACR13M",
            "U013ZLJARC7",
            "U04MAEU6VHN",
            "U79HM6726"
        ],
        "replies": [
            {
                "user": "UJBAJNFLK",
                "ts": "1675146104.066659"
            },
            {
                "user": "U0296ACR13M",
                "ts": "1675151094.806049"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1675151708.421689"
            },
            {
                "user": "U04MAEU6VHN",
                "ts": "1675199807.657629"
            },
            {
                "user": "U0296ACR13M",
                "ts": "1675232368.604429"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1675247100.935179"
            },
            {
                "user": "U79HM6726",
                "ts": "1675258439.547849"
            },
            {
                "user": "U04MAEU6VHN",
                "ts": "1675258855.596559"
            },
            {
                "user": "U04MAEU6VHN",
                "ts": "1675259012.544649"
            },
            {
                "user": "U0296ACR13M",
                "ts": "1675260029.611249"
            },
            {
                "user": "U04MAEU6VHN",
                "ts": "1675261498.757329"
            },
            {
                "user": "U04MAEU6VHN",
                "ts": "1675261620.920069"
            },
            {
                "user": "U04MAEU6VHN",
                "ts": "1675265095.798459"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pczPy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi friends! I'm new to this slack, but I've been dabbling in this space off and on for a while. I've completed a draft of a blog post about type inference in my projectional language \/ structured editor, and I'd love to get your feedback! "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/gist.github.com\/jaredly\/13abec33c7576c4636ca87039a999cf2",
                                "text": "\"Type inference that sticks\""
                            },
                            {
                                "type": "text",
                                "text": ". thanks! "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJBAJNFLK",
                    "UA14TGLTC",
                    "U79HM6726",
                    "U01LCRM5RT7"
                ],
                "count": 4
            },
            {
                "name": "clap",
                "users": [
                    "U0296ACR13M",
                    "U01LCRM5RT7"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "U013ZLJARC7",
                    "U01LCRM5RT7"
                ],
                "count": 2
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT",
                    "U01LCRM5RT7"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1675146104.066659",
        "client_msg_id": "DE8B433D-5EC8-47A1-9516-418624D1CCC6",
        "text": "That looks very promising! Types are statements *about* code, so it makes sense to move them to an annotation layer and have tool support for that layer.\n\nNext: make that layer optional (perhaps it already is). Then: allow multiple type annotation layers for the same codebase. Allow programmers to add their own domain-specific type systems.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675140821.935599",
        "parent_user_id": "U04MAEU6VHN",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "c9w",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That looks very promising"
                            },
                            {
                                "type": "text",
                                "text": "!"
                            },
                            {
                                "type": "text",
                                "text": " Types are statements *about* code, so it makes sense to move them to an annotation layer and have tool support for that layer.\n\nNext: make that layer optional (perhaps it already is). Then: allow multiple type annotation layers for the same codebase. Allow programmers to add their own domain-specific type systems."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0296ACR13M",
        "type": "message",
        "ts": "1675151094.806049",
        "edited": {
            "user": "U0296ACR13M",
            "ts": "1675151127.000000"
        },
        "client_msg_id": "7907f051-fc90-40c9-98ce-35b11c72b160",
        "text": "Great stuff!\n\nMy favorite part, and I wonder if this would be *the* selling point for structure editors for pro-coders (I don't think it will ever be \"avoiding syntax errors\" etc.):\n\n&gt; the compiler is involved in the entire process of development, responding to programmer feedback, and giving context-aware feedback in return. In this model, the source code is enriched with the compiler's inferences along the way, which the programmer can inspect &amp; correct (but can also be elided from display for a more compact presentation).\nAbout this:\n&gt; When typing an identifier in Jerd, if you select something from autocomplete, the ID of that term is stuck onto the identifier node, and then the compilation pass doesn't need to do any name resolution -- it knows exactly what is being referenced. And, if you later change the name of a variable, none of the references are broken.\nHow do you plan on handling the case where a new higher precedence function overload is added after a id+arguments code has been 'bound' to an overload that should now be preceded by the new overload for the given id+arguments? So you could end up in a situation in which exactly the same function call expressions bind to different overload depending on which overloads existed at the time of writing (binding) of the call. I guess you could just run the overload resolution again for all the calls, but what if the result for a call depends on a (now hidden) user defined type annotation. You could still end visibly exactly the same function calls binding to different overloads. How would possible implicit casts\/conversions fit in?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "59de929720a2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-09-08\/4075674207584_59de929720a2fe0a13d8_72.jpg",
            "first_name": "",
            "real_name": "Jarno Montonen",
            "display_name": "Jarno Montonen",
            "team": "T5TCAFTA9",
            "name": "jarno.montonen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675140821.935599",
        "parent_user_id": "U04MAEU6VHN",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hbZyi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great stuff!\n\nMy favorite part, and I wonder if this would be "
                            },
                            {
                                "type": "text",
                                "text": "the",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " selling point for structure editors for pro-coders (I don't think it will ever be \"avoiding syntax errors\" etc.):\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the compiler is involved in the entire process of development, responding to programmer feedback, and giving context-aware feedback in return. In this model, the source code is enriched with the compiler's inferences along the way, which the programmer can inspect & correct (but can also be elided from display for a more compact presentation)."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAbout this:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When typing an identifier in Jerd, if you select something from autocomplete, the ID of that term is stuck onto the identifier node, and then the compilation pass doesn't need to do any name resolution -- it knows exactly what is being referenced. And, if you later change the name of a variable, none of the references are broken."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nHow do you plan on handling the case where a new higher precedence function overload is added after a id+arguments code has been 'bound' to an overload that should now be preceded by the new overload for the given id+arguments? So you could end up in a situation in which exactly the same function call expressions bind to different overload depending on which overloads existed at the time of writing (binding) of the call. I guess you could just run the overload resolution again for all the calls, but what if the result for a call depends on a (now hidden) user defined type annotation. You could still end visibly exactly the same function calls binding to different overloads. How would possible implicit casts\/conversions fit in?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U013ZLJARC7",
        "type": "message",
        "ts": "1675151708.421689",
        "client_msg_id": "c52e2bd8-a55f-4bc5-9ed6-6b4109b130a6",
        "text": "Glad to see you working on interactive approaches to this problem. :slightly_smiling_face: If you're looking into interesting prior art in the space, I strongly recommend this paper: <https:\/\/plover.com\/~mjd\/misc\/hbaker-archive\/TInference.html>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8ea58fc41bd6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-10-13\/6057269405632_8ea58fc41bd6baa7dda6_72.png",
            "first_name": "",
            "real_name": "Jack Rusher",
            "display_name": "Jack Rusher",
            "team": "T5TCAFTA9",
            "name": "jack529",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675140821.935599",
        "parent_user_id": "U04MAEU6VHN",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Oafct",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Glad to see you working on interactive approaches to this problem. "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " If you're looking into interesting prior art in the space, I strongly recommend this paper: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/plover.com\/~mjd\/misc\/hbaker-archive\/TInference.html"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]