[
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1552725903.098900",
        "client_msg_id": "ad8f40bc-616b-4c7e-8430-1927791cc40a",
        "text": "I just wrote up something about the way I tend to program: <http:\/\/akkartik.name\/post\/four-repos>. A sort of software-centered _usesthis.com_.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552725903.098900",
        "reply_count": 7,
        "reply_users_count": 2,
        "latest_reply": "1553293385.126000",
        "reply_users": [
            "UD6EXQVM0",
            "UCUSW7WVD"
        ],
        "replies": [
            {
                "user": "UD6EXQVM0",
                "ts": "1552880015.104100"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1552922198.104500"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1553279392.123900"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1553279847.124200"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1553281546.124800"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1553281694.125000"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1553293385.126000"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n=2P+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I just wrote up something about the way I tend to program: "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/akkartik.name\/post\/four-repos"
                            },
                            {
                                "type": "text",
                                "text": ". A sort of software-centered "
                            },
                            {
                                "type": "text",
                                "text": "usesthis.com",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U5TCAFTD3",
                    "UEGFXUK3M",
                    "UEZPBFZPC"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1552745426.100900",
        "client_msg_id": "a426219d-6fa9-495d-80f3-c235348940ee",
        "text": "<@UD6EXQVM0> I don't understand how Loyc trees are useful as a representation of a program. Programs written in different languages not only have different syntax, but different type systems and semantics. If you can't represent types and semantics, I don't know what operations you can usefully do with these trees. But perhaps I'm missing some of the reasoning here.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MzXX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UD6EXQVM0"
                            },
                            {
                                "type": "text",
                                "text": " I don't understand how Loyc trees are useful as a representation of a program. Programs written in different languages not only have different syntax, but different type systems and semantics. If you can't represent types and semantics, I don't know what operations you can usefully do with these trees. But perhaps I'm missing some of the reasoning here."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1552745619.101100",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1552745632.000000"
        },
        "client_msg_id": "37e1f426-54d0-4e0c-aece-008e35c4b7e8",
        "text": "If you're looking for program interoperability, you probably want a high-level assembly language. WebAssembly could actually become this over time, as it gets managed memory (coming soon), and potentially parametric polymorphism and algebraic types in the future.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iPJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you're looking for program interoperability, you probably want a high-level assembly language. WebAssembly could actually become this over time, as it gets managed memory (coming soon), and potentially parametric polymorphism and algebraic types in the future."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1552746273.101400",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1552746439.000000"
        },
        "client_msg_id": "f9d8c672-5d92-4ec8-b876-9be27c9a068c",
        "text": "(That would make it easier to link memory managed languages together, but wouldn't help them link with C, which will forever be awkward due to irreconcilable differences)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n+jm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(That would make it easier to link memory managed languages together, but wouldn't help them link with C, which will forever be awkward due to irreconcilable differences)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1552748715.101800",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1552749587.000000"
        },
        "client_msg_id": "6d226165-0815-45b2-9410-a1ea601a467a",
        "text": "<@UCGAK10LS> I agree that a better route to interoperability is via WebAssembly. However interoperability is explicitly a non-goal of Wasm and I can't figure out how to break into working in that area anyway. (e.g. they have online CG meetings I couldn't attend while I had a job; they have in-person meetings in the Bay Area and somewhere in Europe (France?).) Two weeks ago I emailed the two main people involved in the GC\/managed area to ask if there's any way I could find work in WebAssembly, or something like that, and neither of them replied.\n\nLoyc trees are obviously not a solution to interoperability by themselves. They are simply a better representation than what has been used for similar purposes in the past: XML, JSON and ad-hoc plain text formats.\n\nPartly it's about communication, between humans as much as machines - no one wants to explain that the syntax tree of `class Foo { int x; }` is `&lt;TypeDefinitionStatement name=\"Foo\"&gt;&lt;VariableDefinitionStatement type=\"System.Int32\" name=\"x\"\/&gt;&lt;\/TypeDefinitionStatement&gt;`, especially since the actual internal representation will be somewhat different anyway. I think ASTs are a lot easier to discuss via LES.\n\nYes, every language has different semantics and dealing with that automatically is very tricky, but if we agree on a convention that `#class(Foo, #(), { #var(#int32, x); })` means something like `class Foo { int x; }`, that's a meaningful step on the path toward language conversion. Ì'm starting to write a TypeScript language printer, and it's no big deal to translate the standardized type name `#int32` to `number`, so that this tree prints as `class Foo { x: number; }`.\n\nOnce a number of printers exist and I write a few macros to provide some ad-hoc transformations, I think a small language will emerge that can be translated to a few other languages automatically. This is nowhere near the end-goal, but it's another step on the path.\n\n<@UCUSW7WVD> asked \"why you?\".\n1. Why not me?\n2. I never wanted it to just be me, I've always wanted more people working on it and providing feedback.\n\nI'm not sure where you got the idea I didn't work on Loyc trees since 2015 - if it's the html page for Loyc trees, I actually made some edits without remembering to change the last-modified date. But it's true that I didn't work on Loyc stuff a lot in the last 3 years, and the reason is that I had failed to attract interest in my work for the 3 years before that, aside from one person. I believed in my ideas, but since my goal is to make the world a better place, seeing that the world was entirely disinterested was disheartening.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0KS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " I agree that a better route to interoperability is via WebAssembly. However interoperability is explicitly a non-goal of Wasm and I can't figure out how to break into working in that area anyway. (e.g. they have online CG meetings I couldn't attend while I had a job; they have in-person meetings in the Bay Area and somewhere in Europe (France?).) Two weeks ago I emailed the two main people involved in the GC\/managed area to ask if there's any way I could find work in WebAssembly, or something like that, and neither of them replied.\n\nLoyc trees are obviously not a solution to interoperability by themselves. They are simply a better representation than what has been used for similar purposes in the past: XML, JSON and ad-hoc plain text formats.\n\nPartly it's about communication, between humans as much as machines - no one wants to explain that the syntax tree of "
                            },
                            {
                                "type": "text",
                                "text": "class Foo { int x; }",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is "
                            },
                            {
                                "type": "text",
                                "text": "<TypeDefinitionStatement name=\"Foo\"><VariableDefinitionStatement type=\"System.Int32\" name=\"x\"\/><\/TypeDefinitionStatement>",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", especially since the actual internal representation will be somewhat different anyway. I think ASTs are a lot easier to discuss via LES.\n\nYes, every language has different semantics and dealing with that automatically is very tricky, but if we agree on a convention that "
                            },
                            {
                                "type": "text",
                                "text": "#class(Foo, #(), { #var(#int32, x); })",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " means something like "
                            },
                            {
                                "type": "text",
                                "text": "class Foo { int x; }",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", that's a meaningful step on the path toward language conversion. Ì'm starting to write a TypeScript language printer, and it's no big deal to translate the standardized type name "
                            },
                            {
                                "type": "text",
                                "text": "#int32",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to "
                            },
                            {
                                "type": "text",
                                "text": "number",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", so that this tree prints as "
                            },
                            {
                                "type": "text",
                                "text": "class Foo { x: number; }",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nOnce a number of printers exist and I write a few macros to provide some ad-hoc transformations, I think a small language will emerge that can be translated to a few other languages automatically. This is nowhere near the end-goal, but it's another step on the path.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " asked \"why you?\".\n1. Why not me?\n2. I never wanted it to just be me, I've always wanted more people working on it and providing feedback.\n\nI'm not sure where you got the idea I didn't work on Loyc trees since 2015 - if it's the html page for Loyc trees, I actually made some edits without remembering to change the last-modified date. But it's true that I didn't work on Loyc stuff a lot in the last 3 years, and the reason is that I had failed to attract interest in my work for the 3 years before that, aside from one person. I believed in my ideas, but since my goal is to make the world a better place, seeing that the world was entirely disinterested was disheartening."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1552751597.102300",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1552752156.000000"
        },
        "client_msg_id": "69fe4705-74c6-4056-ae07-8370a2e8698f",
        "text": "Oh, and of course, it's meant as an equivalent of s-expressions for non-Lisp languages. Just as s-expressions form the basis of several different programming languages with different semantics, LES is designed to be a basis for future languages, so that you can build a non-Lisp programming language without writing a parser or printer. Very good for DSLs and prototypes.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U5K",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh, and of course, it's meant as an equivalent of s-expressions for non-Lisp languages. Just as s-expressions form the basis of several different programming languages with different semantics, LES is designed to be a basis for future languages, so that you can build a non-Lisp programming language without writing a parser or printer. Very good for DSLs and prototypes."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1552778529.103100",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1552778544.000000"
        },
        "client_msg_id": "8169016d-38dc-414a-b9fa-42a7d105acce",
        "text": "Thanks for the explanation David. Personally, the reason why LES doesn't sound exciting to me is simply that I've never considered language interoperability an important enough problem to work on (compared to problems of language design, implementation, and especially use). If I were to tackle the problem, I feel like assembly languages would be the only practical pathway, because they're the only way to capture the execution semantics alongside the program structure. It's unfortunate that it's not easy to contribute to the WebAssembly project: I agree it's only an \"open\" community group in theory, and not in practice (especially when Google and Mozilla are the ones who have the final say on design decisions). Nevertheless, there are some good people working on it, and I think it has a bright future ahead, even if they're prioritising things a little differently to how we'd like.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U\/R8B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for the explanation David. Personally, the reason why LES doesn't sound exciting to me is simply that I've never considered language interoperability an important enough problem to work on (compared to problems of language design, implementation, and especially use). If I were to tackle the problem, I feel like assembly languages would be the only practical pathway, because they're the only way to capture the execution semantics alongside the program structure. It's unfortunate that it's not easy to contribute to the WebAssembly project: I agree it's only an \"open\" community group in theory, and not in practice (especially when Google and Mozilla are the ones who have the final say on design decisions). Nevertheless, there are some good people working on it, and I think it has a bright future ahead, even if they're prioritising things a little differently to how we'd like."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1552778641.103400",
        "client_msg_id": "cbff6c56-1c1f-4f60-86b9-da41a4d2ba91",
        "text": "Also, for building parsers, there are purpose-designed projects like <https:\/\/github.com\/harc\/ohm>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6dP19",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, for building parsers, there are purpose-designed projects like "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/harc\/ohm"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1552783110.103600",
        "client_msg_id": "c64dd497-2ad7-4b43-9641-5f68a0e134b9",
        "text": "Yeah, I made a parser generator too, called LLLPG; it is used to parse LES and EC#. But this one sounds like it has a good design philosophy.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/0b",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I made a parser generator too, called LLLPG; it is used to parse LES and EC#. But this one sounds like it has a good design philosophy."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]