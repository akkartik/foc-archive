[
    {
        "user": "UERRYNVMM",
        "type": "message",
        "ts": "1565081676.230600",
        "client_msg_id": "61529bf0-01d4-412f-a844-ca3c7e5060a4",
        "text": "I’ll be at PPIG as well",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g37b97c5f969",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/537b97c5f969fbb1fc4c2c0e2470c81c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0000-72.png",
            "first_name": "",
            "real_name": "Clemens Klokmose",
            "display_name": "Clemens",
            "team": "T5TCAFTA9",
            "name": "clemens",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565013732.224700",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oP9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I’ll be at PPIG as well"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U5TCAFTD3"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UFEQUBNNT",
        "type": "message",
        "ts": "1565105384.233700",
        "client_msg_id": "C90BBD16-0872-4708-AAEC-795EB0700EE6",
        "text": "<@U8A5MS6R1> That’s the static analysis library I was using that I thought was internal-only. So maybe I could be working on it outside the walled garden. Looks pretty tied to bazel, though, so maybe not very useful externally.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "565c54a4fa91",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2508698086192_565c54a4fa91a0c8c75a_72.png",
            "first_name": "Tom",
            "real_name": "Tom Lieber",
            "display_name": "alltom",
            "team": "T5TCAFTA9",
            "name": "tom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1564729170.159200",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=qx\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " That’s the static analysis library I was using that I thought was internal-only. So maybe I could be working on it outside the walled garden. Looks pretty tied to bazel, though, so maybe not very useful externally."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1565129769.234100",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1565139715.000000"
        },
        "client_msg_id": "19b925b3-4dd8-4845-9225-cdf4f6877298",
        "text": "I have done measurements of MTTR and maintenance costs, with the same team, switching languages. That generates a very pure measurement of language effectiveness because you are only changing one factor at a time. I saw a 2:1 improvement from switching from C to Modula-2, and that was well worth the effort to change, which is considerable, because you have to retrain personnel, and disconnecting from the most popular language to one that had virtually no support materials and community. Cost of MTTR is not really about tooling; when you are doing maintenance you are making small changes to a program, and what trips you up are unseen dependencies and ripple effects. Some languages are very localized and have few dependencies, while others are like tangled spaghetti, where the tiniest change breaks things in baffling ways. LISP is one of the worst offenders, because of the nefarious S-expression data structures, which are typically addressed by position, and adding new data to a tree change the position of other items, thereby breaking existing code inadvertently. APL has different problems, but was actually more maintainable than LISP.\n\nI am not making any statement about the variation between programmers; in some of the literature they estimate that there is a 20:1 productivity range among programmers. Textual languages have a wide variety of MTTR, yet that factor is hardly ever mentioned in language discussions. You see lots of charts showing performance of various benchmarks, which is an obsession about run speed. Given how cheap and omnipresent computers are, the cost of the software development typically dwarfs any cost of execution.\n\n I estimate some languages are dozens of times worse in terms of readability which will impact MTTR. Programmers are a group are always thinking about how easy it was to build the project in the beginning; few are concerned with what management is going to spend to carry that program forward through several different people. Maintenance costs dominate the world of commercial programming, and it is high time that languages and toolchains which lower MTTR are given recognition.\n\nThe large pool of people using a language is frankly of very little value much of the time for repair and improvement of a codebase. What help are outside people in updating some complex thing?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1564958324.214400",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0g1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have done measurements of MTTR and maintenance costs, with the same team, switching languages. That generates a very pure measurement of language effectiveness because you are only changing one factor at a time. I saw a 2:1 improvement from switching from C to Modula-2, and that was well worth the effort to change, which is considerable, because you have to retrain personnel, and disconnecting from the most popular language to one that had virtually no support materials and community. Cost of MTTR is not really about tooling; when you are doing maintenance you are making small changes to a program, and what trips you up are unseen dependencies and ripple effects. Some languages are very localized and have few dependencies, while others are like tangled spaghetti, where the tiniest change breaks things in baffling ways. LISP is one of the worst offenders, because of the nefarious S-expression data structures, which are typically addressed by position, and adding new data to a tree change the position of other items, thereby breaking existing code inadvertently. APL has different problems, but was actually more maintainable than LISP.\n\nI am not making any statement about the variation between programmers; in some of the literature they estimate that there is a 20:1 productivity range among programmers. Textual languages have a wide variety of MTTR, yet that factor is hardly ever mentioned in language discussions. You see lots of charts showing performance of various benchmarks, which is an obsession about run speed. Given how cheap and omnipresent computers are, the cost of the software development typically dwarfs any cost of execution.\n\n I estimate some languages are dozens of times worse in terms of readability which will impact MTTR. Programmers are a group are always thinking about how easy it was to build the project in the beginning; few are concerned with what management is going to spend to carry that program forward through several different people. Maintenance costs dominate the world of commercial programming, and it is high time that languages and toolchains which lower MTTR are given recognition.\n\nThe large pool of people using a language is frankly of very little value much of the time for repair and improvement of a codebase. What help are outside people in updating some complex thing?"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]