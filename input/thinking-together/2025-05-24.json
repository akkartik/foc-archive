[
    {
        "user": "U03U0SCU5LH",
        "type": "message",
        "ts": "1748091000.131309",
        "client_msg_id": "985d8131-404a-426d-9b0a-5b06b60d135d",
        "text": "Is everybody agreeing with nodes and wires as functional programming? I think it's (more precisely?) dataflow programming. Functional PL usually do a lot with, lambdas (functions), you \"pass along functions\". In node and wires, the pipes usually pass data.. or sometimes contraflow (blueprints). I can't name any nodes and wires PL, that even has functions as data.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gdf6784b7d6d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/df6784b7d6d97fb67dec89320cc88a84.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0007-72.png",
            "first_name": "Dany",
            "real_name": "Dany",
            "display_name": "Dany",
            "team": "T5TCAFTA9",
            "name": "bitteldany",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747897811.070679",
        "parent_user_id": "U06SS0DHZD1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0XuVh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is everybody agreeing with nodes and wires as functional programming? I think it's (more precisely?) dataflow programming. Functional PL usually do a lot with, lambdas (functions), you \"pass along functions\". In node and wires, the pipes usually pass data.. or sometimes contraflow (blueprints). I can't name any nodes and wires PL, that even has functions as data."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U02QC0PPER3"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1748099863.637139",
        "client_msg_id": "07bdb7eb-c07c-4519-ae12-182ebea2cad7",
        "text": "Yeah you're right. It's functional in the sense that circuit design is combinatorial rather than sequential. Simple circuits tend to have no memory and outputs are functions of inputs. So not functional in the sense of first class functions. Functional in the sense of stateless by default.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747897811.070679",
        "parent_user_id": "U06SS0DHZD1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BOdSJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah you're right. It's functional in the sense that circuit design is combinatorial rather than sequential. Simple circuits tend to have no memory and outputs are functions of inputs. So not functional in the sense of first class functions. Functional in the sense of stateless by default."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02QC0PPER3",
        "type": "message",
        "ts": "1748112951.739449",
        "client_msg_id": "8637fd72-a4f4-4eea-b925-40661ca59175",
        "text": "The Morphic authors had a neat goals paper <https:\/\/worrydream.com\/refs\/Maloney_1995_-_Directness_and_Liveness_in_Morphic.pdf|https:\/\/worrydream.com\/refs\/Maloney_1995_-_Directness_and_Liveness_in_Morphic.pdf>\n&gt; Directness and liveness in Morphic are supported by four implementation techniques:\n&gt; ● structural reification (supports directness),\n&gt; ● layout reification (supports directness and liveness),\n&gt; ● ubiquitous animation (supports liveness), and\n&gt; ● live editing (supports directness and liveness).\n&gt; \nBoxer had debatable :pinching_hand: but strong :eyes: for stateful objects, naming it \"Naive Realism\": the user should not need to imagine any hidden state beyond what can be inspected on the screen.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "90c9108c61f5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-12\/2854686602576_90c9108c61f5d809eb8a_72.jpg",
            "first_name": "Beni",
            "real_name": "Beni Cherniavsky-Paskin",
            "display_name": "Beni Cherniavsky-Paskin",
            "team": "T5TCAFTA9",
            "name": "beni.cherniavsky",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747897811.070679",
        "parent_user_id": "U06SS0DHZD1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/Dab0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The Morphic authors had a neat goals paper "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/worrydream.com\/refs\/Maloney_1995_-_Directness_and_Liveness_in_Morphic.pdf",
                                "text": "https:\/\/worrydream.com\/refs\/Maloney_1995_-_Directness_and_Liveness_in_Morphic.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Directness and liveness in Morphic are supported by four implementation techniques:\r\n"
                            },
                            {
                                "type": "text",
                                "text": "● structural reification (supports directness),\r\n"
                            },
                            {
                                "type": "text",
                                "text": "● layout reification (supports directness and liveness),\r\n"
                            },
                            {
                                "type": "text",
                                "text": "● ubiquitous animation (supports liveness), and\r\n"
                            },
                            {
                                "type": "text",
                                "text": "● live editing (supports directness and liveness).\n"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nBoxer had debatable "
                            },
                            {
                                "type": "emoji",
                                "name": "pinching_hand",
                                "unicode": "1f90f"
                            },
                            {
                                "type": "text",
                                "text": " but strong "
                            },
                            {
                                "type": "emoji",
                                "name": "eyes",
                                "unicode": "1f440"
                            },
                            {
                                "type": "text",
                                "text": " for stateful objects, naming it \"Naive Realism\": the user should not need to imagine any hidden state beyond what can be inspected on the screen."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U05UK5T7LPP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02QC0PPER3",
        "type": "message",
        "ts": "1748116561.435739",
        "client_msg_id": "796156da-069d-4f56-abc5-06870f5eb662",
        "text": "[nit: \"Block based\" is not specific to procedural style.\n• Snap! can do functional too.  It has lambdas, some higher-order builtins (keep items _ from list _), custom blocks can even look like \"C-shaped\" custom control structures reveiving the nested body as a lambda; even call\/cc continuations...\n• OOP too: Sprites are stateful objects.  There is builtin properties like position visibility size etc. but also variables can be made per-instance.  Sprites can be cloned, with prototypical inheritance of properties.  In Snap!, i know sprites can also be composed in a hierarchy, with position orientation and size being relative to parent - similar to Morphic's structural reification.\n• OOP in message-passing sense: Scratch uses message passing for coordination between sprites, but it's limited.  Snap! has more, plus \"ask\/tell to execute this code in your context\" instead of named methods (Screw encapsulation :stuck_out_tongue_winking_eye:)\nbut none of this answers your Q]",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "90c9108c61f5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-12\/2854686602576_90c9108c61f5d809eb8a_72.jpg",
            "first_name": "Beni",
            "real_name": "Beni Cherniavsky-Paskin",
            "display_name": "Beni Cherniavsky-Paskin",
            "team": "T5TCAFTA9",
            "name": "beni.cherniavsky",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747897811.070679",
        "parent_user_id": "U06SS0DHZD1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tdJ\/8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[nit: \"Block based\" is not specific to procedural style.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Snap! can do functional too.  It has lambdas, some higher-order builtins (keep items _ from list _), custom blocks can even look like \"C-shaped\" custom control structures reveiving the nested body as a lambda; even call\/cc continuations..."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "OOP too: Sprites are stateful objects.  There is builtin properties like position visibility size etc. but also variables can be made per-instance.  Sprites can be cloned, with prototypical inheritance of properties.  In Snap!, i know sprites can also be composed in a hierarchy, with position orientation and size being relative to parent - similar to Morphic's structural reification."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "OOP in message-passing sense: Scratch uses message passing for coordination between sprites, but it's limited.  Snap! has more, plus \"ask\/tell to execute this code in your context\" instead of named methods (Screw encapsulation "
                                    },
                                    {
                                        "type": "emoji",
                                        "name": "stuck_out_tongue_winking_eye",
                                        "unicode": "1f61c"
                                    },
                                    {
                                        "type": "text",
                                        "text": ")"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "offset": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "but none of this answers your Q]"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02QC0PPER3",
        "type": "message",
        "ts": "1748116899.721779",
        "client_msg_id": "d36d2d54-f5c5-4475-ac4f-33a7099766a3",
        "text": "I'd say Factorio fits your description well, what with both data and behaviors reified in the world?\nBut what's the paradigm? :thinking_face: \nA lot of \"conveyers and pipeline oriented programming\" -- which sounds like dataflow, and doesn't capture nuance of behaviors also being mutable, destructible etc.\n\nAnd whats the paradigm of Baba Is You?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "90c9108c61f5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-12\/2854686602576_90c9108c61f5d809eb8a_72.jpg",
            "first_name": "Beni",
            "real_name": "Beni Cherniavsky-Paskin",
            "display_name": "Beni Cherniavsky-Paskin",
            "team": "T5TCAFTA9",
            "name": "beni.cherniavsky",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747897811.070679",
        "parent_user_id": "U06SS0DHZD1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "blhlx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd say Factorio fits your description well, what with both data and behaviors reified in the world?\nBut what's the paradigm? "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            },
                            {
                                "type": "text",
                                "text": " \nA lot of \"conveyers and pipeline oriented programming\" -- which sounds like dataflow, and doesn't capture nuance of behaviors also being mutable, destructible etc.\n\nAnd whats the paradigm of Baba Is You?"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]