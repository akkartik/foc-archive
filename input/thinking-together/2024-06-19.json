[
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1718810777.714349",
        "client_msg_id": "d5805118-109b-4240-9b3e-5159c976bbaa",
        "text": "On closer inspection, the boundary between “what” and “how” is often blurry, at best. At least I have a hard time finding it.\n\nConsider SQL. There are many details about “how” that are not hidden. You have to make a choice about how the schema should be split across tables by deciding which normal form to use for representing the exact same information. For a given schema, there are multiple alternative queries that will return the same results, but have wildly different performance characteristics (a simple example is using a JOIN vs an IN clause). Explicitly having to join a primary key with a foreign key is also arguably about “how” and not “what” (why is this not implicit? it doesn’t make sense to join on another column). Prolog and Haskell programs end up in the same situation as well.\n\nI consider SQL to be successful and useful, but I hesitate from calling it declarative. Many other declarative languages have similar issues.\n\nIn “Hints and Principles..” Butler Lampson <https:\/\/arxiv.org\/abs\/2011.02455|says> declarative is just having fewer steps:\n\n&gt; I agreed to write a piece for Alan Kay’s 70th birthday celebration,R60 and recklessly provided\n&gt; the title “Declarative Programming”; this seemed safe, since everyone knows that declarative is\n&gt; good. When it came time to write the paper I realized that I didn’t actually know what declarative\n&gt; programming is, and searching the literature didn’t help much. I finally concluded that a program\n&gt; is declarative if it has few steps; this makes it easier to understand (as long as each step is under-\n&gt; standable), since people are bad at understanding long sequences of steps. Often it’s also easier to\n&gt; optimize, since it doesn’t commit to the sequence of steps the machine should take. \nThe idea of how vs what seems related to non-declarative vs declarative and also related to incidental and essential complexity. For instance you could say you only want to express the essential part of the solution in your program.\n\nIn any case, I think we want both - what *and* how. We want to specify the “what” to be able to clearly express the semantics of the system and want to express the “how” for pragmatic reasons.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1718511602.536409",
        "parent_user_id": "UN57U8V53",
        "attachments": [
            {
                "from_url": "https:\/\/arxiv.org\/abs\/2011.02455",
                "service_icon": "https:\/\/arxiv.org\/static\/browse\/0.3.4\/images\/icons\/apple-touch-icon.png",
                "thumb_url": "https:\/\/arxiv.org\/static\/browse\/0.3.4\/images\/arxiv-logo-fb.png",
                "thumb_width": 1200,
                "thumb_height": 700,
                "id": 1,
                "original_url": "https:\/\/arxiv.org\/abs\/2011.02455",
                "fallback": "arXiv.org: Hints and Principles for Computer System Design",
                "text": "This new long version of my 1983 paper suggests the goals you might have for your system -- Simple, Timely, Efficient, Adaptable, Dependable, Yummy (STEADY) -- and techniques for achieving them -- Approximate, Incremental, Divide &amp; Conquer (AID). It also gives some principles for system design that are more than just hints, and many examples of how to apply the ideas.",
                "title": "Hints and Principles for Computer System Design",
                "title_link": "https:\/\/arxiv.org\/abs\/2011.02455",
                "service_name": "arXiv.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Xhtkd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On closer inspection, the boundary between “what” and “how” is often blurry, at best. At least I have a hard time finding it.\n\nConsider SQL. There are many details about “how” that are not hidden. You have to make a choice about how the schema should be split across tables by deciding which normal form to use for representing the exact same information. For a given schema, there are multiple alternative queries that will return the same results, but have wildly different performance characteristics (a simple example is using a JOIN vs an IN clause). Explicitly having to join a primary key with a foreign key is also arguably about “how” and not “what” (why is this not implicit? it doesn’t make sense to join on another column). Prolog and Haskell programs end up in the same situation as well.\n\nI consider SQL to be successful and useful, but I hesitate from calling it declarative. Many other declarative languages have similar issues.\n\nIn “Hints and Principles..” Butler Lampson "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/arxiv.org\/abs\/2011.02455",
                                "text": "says"
                            },
                            {
                                "type": "text",
                                "text": " declarative is just having fewer steps:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agreed to write a piece for Alan Kay’s 70th birthday celebration,R60 and recklessly provided\nthe title “Declarative Programming”; this seemed safe, since everyone knows that declarative is\ngood. When it came time to write the paper I realized that I didn’t actually know what declarative\nprogramming is, and searching the literature didn’t help much. I finally concluded that a program\nis declarative if it has few steps; this makes it easier to understand (as long as each step is under-\nstandable), since people are bad at understanding long sequences of steps. Often it’s also easier to\noptimize, since it doesn’t commit to the sequence of steps the machine should take. "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe idea of how vs what seems related to non-declarative vs declarative and also related to incidental and essential complexity. For instance you could say you only want to express the essential part of the solution in your program.\n\nIn any case, I think we want both - what "
                            },
                            {
                                "type": "text",
                                "text": "and",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " how. We want to specify the “what” to be able to clearly express the semantics of the system and want to express the “how” for pragmatic reasons."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U05SU27S1M2"
                ],
                "count": 1
            }
        ]
    }
]