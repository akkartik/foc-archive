[
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1550909672.001400",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1550911003.000000"
        },
        "client_msg_id": "320a3c03-945e-40bb-8442-fd498b5ea10e",
        "text": "unfortunately it is completely infeasible to bring the languages together. If you stick to rudimentary arithmetical data types like JS' Float64 implied type which holds all numeric values you can map that to C's equivalent, but you can't go the other way, because JS doesn't have int or unsigned int, or single characters, or single precision floating point, nor does it have 64 bit integers and unsigned integers. So right there, between those 2 languages you can't swallow anything general from C unless the C code restricts itself to a small subset emulating JS. One can in general model a more restrictive language in a more expansive one that is closer to the full intel instruction sets. But the goal of sharing libraries between languages is fairly hopeless. Web assembly down the road may become a somewhat standard virtual instruction set, but in Web Assembly you also have the problem that simple atomic things in many languages are very complex internal structures, like the very general array type in JS, and concepts in Python simply don't exist in JS. If the two languages are similar enough, like ActionScript 3 and JS, i have found that simple text editing scripts will convert 99% of AS3 code into JS. So there are some easy mappings out there. Since there are Python to C compilers out there, that mapping has been achieved. But I doubt very much you can go C to Python. So we are fairly doomed to eternity to keep rewriting similar libraries over and over, unless we picked a very stripped down language that could be exported to most others by some straightforward conversion process. Something like Modula-2 which is among the simplest languages ever devised, however, it presumes record structures which don't exist in many languages today, and one would have to restrict oneself to not using the VAR parameter type, as many languages today like JS and AS3 don't allow you to change a value from inside a function unless it is a property of an object. In fact the closer you get to the Intel\/ARM hardware, the more problematic many modern languages are, with their typical insistence on garbage collection instead of explicit allocation\/deallocation.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1550369313.016100",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9w=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "unfortunately it is completely infeasible to bring the languages together. If you stick to rudimentary arithmetical data types like JS' Float64 implied type which holds all numeric values you can map that to C's equivalent, but you can't go the other way, because JS doesn't have int or unsigned int, or single characters, or single precision floating point, nor does it have 64 bit integers and unsigned integers. So right there, between those 2 languages you can't swallow anything general from C unless the C code restricts itself to a small subset emulating JS. One can in general model a more restrictive language in a more expansive one that is closer to the full intel instruction sets. But the goal of sharing libraries between languages is fairly hopeless. Web assembly down the road may become a somewhat standard virtual instruction set, but in Web Assembly you also have the problem that simple atomic things in many languages are very complex internal structures, like the very general array type in JS, and concepts in Python simply don't exist in JS. If the two languages are similar enough, like ActionScript 3 and JS, i have found that simple text editing scripts will convert 99% of AS3 code into JS. So there are some easy mappings out there. Since there are Python to C compilers out there, that mapping has been achieved. But I doubt very much you can go C to Python. So we are fairly doomed to eternity to keep rewriting similar libraries over and over, unless we picked a very stripped down language that could be exported to most others by some straightforward conversion process. Something like Modula-2 which is among the simplest languages ever devised, however, it presumes record structures which don't exist in many languages today, and one would have to restrict oneself to not using the VAR parameter type, as many languages today like JS and AS3 don't allow you to change a value from inside a function unless it is a property of an object. In fact the closer you get to the Intel\/ARM hardware, the more problematic many modern languages are, with their typical insistence on garbage collection instead of explicit allocation\/deallocation."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1550909811.001600",
        "client_msg_id": "ca6f4b1b-4a9b-4d63-9b73-7a455e3d7746",
        "text": "For bridging to C, I've found SWIG remarkably productive and hassle free <http:\/\/www.swig.org\/>.  Certainly doesn't feel comfy though.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1550369313.016100",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IlP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For bridging to C, I've found SWIG remarkably productive and hassle free "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/www.swig.org\/"
                            },
                            {
                                "type": "text",
                                "text": ".  Certainly doesn't feel comfy though."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]