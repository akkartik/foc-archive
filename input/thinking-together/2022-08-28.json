[
    {
        "user": "U03LT7540HZ",
        "type": "message",
        "ts": "1661714181.001949",
        "client_msg_id": "689c0535-26e1-45bd-9dde-8b1dcdaa0bf8",
        "text": "Something with a solid stdlib or ecosystem would be nice. I'd like to be production IRL without needing to rewrite the world",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "754abc97c5ce",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-06-22\/3731055996048_754abc97c5ce87f6c99f_72.jpg",
            "first_name": "Tony",
            "real_name": "Tony Worm",
            "display_name": "Tony Worm",
            "team": "T5TCAFTA9",
            "name": "tony066",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1661481349.386469",
        "parent_user_id": "U03LT7540HZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "26p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Something with a solid stdlib or ecosystem would be nice. I'd like to be production IRL without needing to rewrite the world"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1661748033.254809",
        "client_msg_id": "9869891d-d0af-43a7-8c2a-f954b6baf18c",
        "text": ":thread: on the first 25 minutes of <https:\/\/futureofcoding.org\/episodes\/057>\n\nSummary:\n• It would be cool to create a visualizer for low level software. Assembly language in particular would benefit from visualization to catch errors in register allocation, manual memory management.\n• A retro game console may be a simple test bed for trying out various FoC ideas. You could literally save snapshots of all 64KB of RAM for some machines every single frame, and then perform further analysis on them, diffs and so on.\n• A similar idea: GPU Maker 2000 like <https:\/\/en.wikipedia.org\/wiki\/RPG_Maker|RPG Maker 2000> but for GPU programming.\n• The Gameboy has a particularly ideal form factor for a convivial tool for thought. In particular, it has a camera, something I wasn't aware of.\nDoes anyone have a good sense of the space of Assemblers out there? Surely there exist debuggers for Assembly? Maybe reverse engineering is a space to look at? Are there any debuggers or reverse-engineering tools with command languages? Ghidra does seem to have something: <https:\/\/resolute-tech.com\/an-introduction-to-ghidra-scripting>. Does anyone here have experience with it?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1661748033.254809",
        "reply_count": 8,
        "reply_users_count": 8,
        "latest_reply": "1662377734.921869",
        "reply_users": [
            "UCUSW7WVD",
            "U02E4DAQGSZ",
            "U02028JHX37",
            "UJFN50C00",
            "UDQBTJ211",
            "UA14TGLTC",
            "UGWUJUZHT",
            "U013ZLJARC7"
        ],
        "replies": [
            {
                "user": "UCUSW7WVD",
                "ts": "1661748147.872909"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1661755558.793479"
            },
            {
                "user": "U02028JHX37",
                "ts": "1661771355.018379"
            },
            {
                "user": "UJFN50C00",
                "ts": "1661787164.655669"
            },
            {
                "user": "UDQBTJ211",
                "ts": "1661790059.113149"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1661837764.866939"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1661850313.524709"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1662377734.921869"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qja",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "emoji",
                                "name": "thread",
                                "unicode": "1f9f5"
                            },
                            {
                                "type": "text",
                                "text": " on the first 25 minutes of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.org\/episodes\/057"
                            },
                            {
                                "type": "text",
                                "text": "\n\nSummary:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "It would be cool to create a visualizer for low level software. Assembly language in particular would benefit from visualization to catch errors in register allocation, manual memory management."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A retro game console may be a simple test bed for trying out various FoC ideas. You could literally save snapshots of all 64KB of RAM for some machines every single frame, and then perform further analysis on them, diffs and so on."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A similar idea: GPU Maker 2000 like "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/RPG_Maker",
                                        "text": "RPG Maker 2000"
                                    },
                                    {
                                        "type": "text",
                                        "text": " but for GPU programming."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The Gameboy has a particularly ideal form factor for a convivial tool for thought. In particular, it has a camera, something I wasn't aware of."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nDoes anyone have a good sense of the space of Assemblers out there? Surely there exist debuggers for Assembly? Maybe reverse engineering is a space to look at? Are there any debuggers or reverse-engineering tools with command languages? Ghidra does seem to have something: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/resolute-tech.com\/an-introduction-to-ghidra-scripting"
                            },
                            {
                                "type": "text",
                                "text": ". Does anyone here have experience with it?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1661748147.872909",
        "client_msg_id": "ac4bb68b-606f-49b5-925b-46312fd5055f",
        "text": "One reaction I had listening to the podcast: do we _really_ need a visualizer? Mu would check register allocations and raise errors when you got them wrong. Ditto memory allocation errors. A visualizer would add a lot of complexity to it. Is it really worthwhile?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1661748033.254809",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hYV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One reaction I had listening to the podcast: do we "
                            },
                            {
                                "type": "text",
                                "text": "really",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " need a visualizer? Mu would check register allocations and raise errors when you got them wrong. Ditto memory allocation errors. A visualizer would add a lot of complexity to it. Is it really worthwhile?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1661755558.793479",
        "client_msg_id": "63684d4d-6e64-4bd1-a730-0d5682f0de7b",
        "text": "I am converging on the idea that the FoC is not replacement of text with no-code, but augmentation of text with dataviz, i.e. dataviz assisted development. This seems to be what you want here (I can't help with the specifics of assembly). Yo do not need the same set of dataviz for all problems, so I think complexity is not an issue, as you only pick the tools that make sense.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1661748033.254809",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GhIov",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am converging on the idea that the FoC is not replacement of text with no-code, but augmentation of text with dataviz, i.e. dataviz assisted development. This seems to be what you want here (I can't help with the specifics of assembly). Yo do not need the same set of dataviz for all problems, so I think complexity is not an issue, as you only pick the tools that make sense."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]