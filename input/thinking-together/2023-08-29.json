[
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1693292544.844609",
        "client_msg_id": "6abc064c-de6a-4238-9690-5c08dbbfd021",
        "text": "It's curious that value types are so favored among all the useful summary\/analysis operations we can do on programming languages.  I mean similar techniques can track references, side-effects, entity life-cycles, resource usage, even evaluation of the language itself.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1693231453.379599",
        "parent_user_id": "U03LJBR6THT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yDaRR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's curious that value types are so favored among all the useful summary\/analysis operations we can do on programming languages.  I mean similar techniques can track references, side-effects, entity life-cycles, resource usage, even evaluation of the language itself."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02QC0PPER3",
        "type": "message",
        "ts": "1693308077.142209",
        "client_msg_id": "563c72ca-8723-4684-b76d-1b081a5c4803",
        "text": "Hofstadter in _Gödel, Esches, Bach_ had pretty similar arguments in a whole chapter on reductionism vs. holism. The leading example was \"Aunt Hillary\", a sentient entity that is physically an ant hill :ant: where the ants and chemical signalling  happen to implement rules isomorphic to some \"symbol activation\".  He argues that while the ants are real, they hold little explanatory power for her thinking; the relashionships between symbols are more insightful, and those explanations won't care much if you replaced the ants with neurons, or a software model.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "90c9108c61f5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-12\/2854686602576_90c9108c61f5d809eb8a_72.jpg",
            "first_name": "Beni",
            "real_name": "Beni Cherniavsky-Paskin",
            "display_name": "Beni Cherniavsky-Paskin",
            "team": "T5TCAFTA9",
            "name": "beni.cherniavsky",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1692925047.641699",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hMA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hofstadter in "
                            },
                            {
                                "type": "text",
                                "text": "Gödel, Esches, Bach",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " had pretty similar arguments in a whole chapter on reductionism vs. holism. The leading example was \"Aunt Hillary\", a sentient entity that is physically an ant hill "
                            },
                            {
                                "type": "emoji",
                                "name": "ant",
                                "unicode": "1f41c"
                            },
                            {
                                "type": "text",
                                "text": " where the ants and chemical signalling  happen to implement rules isomorphic to some \"symbol activation\".  He argues that while the ants are real, they hold little explanatory power for her thinking; the relashionships between symbols are more insightful, and those explanations won't care much if you replaced the ants with neurons, or a software model."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "U05597GCDDK"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02QC0PPER3",
        "type": "message",
        "ts": "1693308584.284529",
        "client_msg_id": "29103615-3000-4b6d-a115-5a61efe610ed",
        "text": "I loved that because (1) it gave useful meaning to mind\/body dualism without dragging in religious\/mystic axioms; (2) this philosophic idea is particularly clear &amp; quantifiable to us programmers through the measure of _portability_.\nWhat would it actually take to swap one underlying platform for another?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "90c9108c61f5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-12\/2854686602576_90c9108c61f5d809eb8a_72.jpg",
            "first_name": "Beni",
            "real_name": "Beni Cherniavsky-Paskin",
            "display_name": "Beni Cherniavsky-Paskin",
            "team": "T5TCAFTA9",
            "name": "beni.cherniavsky",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1692925047.641699",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=F7W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I loved that because (1) it gave useful meaning to mind\/body dualism without dragging in religious\/mystic axioms; (2) this philosophic idea is particularly clear & quantifiable to us programmers through the measure of "
                            },
                            {
                                "type": "text",
                                "text": "portability",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\nWhat would it actually take to swap one underlying platform for another?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "U5STGTB3J"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1693313836.138309",
        "client_msg_id": "caaf3e18-b71c-4bb6-9224-6ffa69e33681",
        "text": "Sync programming is complicated\n\nAsync programming is complicated.\n\nBut, they are not the same.\n\nI argue that adding the meme of little networks to your toolbelt can result in better solutions, and, can, at least sometimes, be more efficient.\n\nUsing the wrong meme to solve a problem causes complication (Accidental complexity, workarounds, epicycles).  Choose your weapons, don’t have them forced upon you.  Don’t approach every problem using only a single meme.\n\nSync is good for building fancier calculators, e.g. ballistics calculations for cruise missiles, cryptography, chatbots that hallucinate and create B.S., etc.  Async is good for GUIs, internet, robotics, blockchain, p2p, etc.\n\nI claim that async is a superset of sync.  Async can be thought of as a bunch of sync nodes sending async messages to one another.\n\nFeldman claims that FoC will come about through the vehement avoidance of the little network meme.  He bases his conclusion on the faulty reasoning that the sync meme is the only way to create little networks.  I claim exactly the opposite.  FoC must evolve towards little networks - networking in the small.  Maybe closures+queues plus a way to compose solutions using multiple memes.\n\nMuch more here: <https:\/\/publish.obsidian.md\/programmingsimplicity\/2023-08-28-Sync+Programming+vs+Distributed+Programming>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1691945999.321379",
        "parent_user_id": "UCUSW7WVD",
        "attachments": [
            {
                "image_url": "https:\/\/ogimage.obsidian.md\/og-image.png?title=2023-08-28-Sync+Programming+vs+Distributed+Programming&description=Sync+programming+is+complicated.+Distributed+programming+%28aka+async%29+is+complicated.+They+are+not+the+same%2C+though.+++They+are+completely+orthogonal.+Using+a+sync-based+language+to+program+a+distribu%E2%80%A6",
                "image_width": 1200,
                "image_height": 630,
                "image_bytes": 66773,
                "from_url": "https:\/\/publish.obsidian.md\/programmingsimplicity\/2023-08-28-Sync+Programming+vs+Distributed+Programming",
                "id": 1,
                "original_url": "https:\/\/publish.obsidian.md\/programmingsimplicity\/2023-08-28-Sync+Programming+vs+Distributed+Programming",
                "fallback": "2023-08-28-Sync Programming vs Distributed Programming - Obsidian Publish",
                "text": "Sync programming is complicated. Distributed programming (aka async) is complicated. They are not the same, though. They are completely orthogonal. Using a sync-based language to program a distribu…",
                "title": "2023-08-28-Sync Programming vs Distributed Programming - Obsidian Publish",
                "title_link": "https:\/\/publish.obsidian.md\/programmingsimplicity\/2023-08-28-Sync+Programming+vs+Distributed+Programming",
                "service_name": "publish.obsidian.md"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uNW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sync programming is complicated\n\nAsync programming is complicated.\n\nBut, they are not the same.\n\nI argue that adding the meme of little networks to your toolbelt can result in better solutions, and, can, at least sometimes, be more efficient.\n\nUsing the wrong meme to solve a problem causes complication (Accidental complexity, workarounds, epicycles).  Choose your weapons, don’t have them forced upon you.  Don’t approach every problem using only a single meme.\n\nSync is good for building fancier calculators, e.g. ballistics calculations for cruise missiles, cryptography, chatbots that hallucinate and create B.S., etc.  Async is good for GUIs, internet, robotics, blockchain, p2p, etc.\n\nI claim that async is a superset of sync.  Async can be thought of as a bunch of sync nodes sending async messages to one another.\n\nFeldman claims that FoC will come about through the vehement avoidance of the little network meme.  He bases his conclusion on the faulty reasoning that the sync meme is the only way to create little networks.  I claim exactly the opposite.  FoC must evolve towards little networks - networking in the small.  Maybe closures+queues plus a way to compose solutions using multiple memes.\n\nMuch more here: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/publish.obsidian.md\/programmingsimplicity\/2023-08-28-Sync+Programming+vs+Distributed+Programming"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1693368096.745299",
        "client_msg_id": "b8ceaba7-d4d5-4bf4-b8bc-2fd1a8ee01f1",
        "text": "One reason types are built inside languages is undecidability. We tend to want the type checker to always terminate, and to err on the side of soundness rather than completeness. This is why the type language is weaker, whereas the \"main\" language can be Turing-complete.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1693231453.379599",
        "parent_user_id": "U03LJBR6THT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jSE=d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One reason types are built inside languages is undecidability. We tend to want the type checker to always terminate, and to err on the side of soundness rather than completeness. This is why the type language is weaker, whereas the \"main\" language can be Turing-complete."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1693372751.567049",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1693372919.000000"
        },
        "client_msg_id": "1d5c8ed6-e155-4576-ba3b-de3fb7e8df42",
        "text": "<@UGWUJUZHT> I don't think you have enough evidence to make your claims quite so strong.\n\nIs it really _fine_ for a little network to squirrel away little bits of state all over the place? Is it _really_ just the fault of all those dang synchronous returns? You need a lot more evidence for both sides of that claim. Why is it only synchronous returns that couples all parts of a system together? Why does async magically make them decoupled? Why does _state_ bear zero responsibility for coupling?\n\n&gt; Async-based senders don't wait for a result by default, and sometimes - but only sometimes - need to bother with sync'ing later.\nThis seems completely at odds with my experience. The number of times in my life that I've made an async call truly fire-and-forget is _at most_ 2. With a generous margin for forgetfulness. Invariably I want to check for errors. At best there is syntax to hide the error checking -- but it does that for sync calls as well. So I fail to see what the fuss is about. So far, sync vs async seems like an _implementation detail_.\n\nI don't think calling things epicycles or tired or fallacious or vehement is very persuasive by itself. At best you can claim, \"look, here's an alternative prognosis for these symptoms that I'm working to falsify.\" And tell a story about _how_ that might be the case. So far I haven't seen either enough evidence or a compelling alternative narrative.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1691945999.321379",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Fg6K",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " I don't think you have enough evidence to make your claims quite so strong.\n\nIs it really "
                            },
                            {
                                "type": "text",
                                "text": "fine",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " for a little network to squirrel away little bits of state all over the place? Is it "
                            },
                            {
                                "type": "text",
                                "text": "really",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " just the fault of all those dang synchronous returns? You need a lot more evidence for both sides of that claim. Why is it only synchronous returns that couples all parts of a system together? Why does async magically make them decoupled? Why does "
                            },
                            {
                                "type": "text",
                                "text": "state",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " bear zero responsibility for coupling?\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Async-based senders don't wait for a result by default, and sometimes - but only sometimes - need to bother with sync'ing later."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThis seems completely at odds with my experience. The number of times in my life that I've made an async call truly fire-and-forget is "
                            },
                            {
                                "type": "text",
                                "text": "at most",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " 2. With a generous margin for forgetfulness. Invariably I want to check for errors. At best there is syntax to hide the error checking -- but it does that for sync calls as well. So I fail to see what the fuss is about. So far, sync vs async seems like an "
                            },
                            {
                                "type": "text",
                                "text": "implementation detail",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nI don't think calling things epicycles or tired or fallacious or vehement is very persuasive by itself. At best you can claim, \"look, here's an alternative prognosis for these symptoms that I'm working to falsify.\" And tell a story about "
                            },
                            {
                                "type": "text",
                                "text": "how",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that might be the case. So far I haven't seen either enough evidence or a compelling alternative narrative."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "guitar",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    }
]