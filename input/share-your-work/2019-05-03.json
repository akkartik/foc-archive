[
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1556901860.014800",
        "client_msg_id": "c31a9c89-a3fe-42c2-9f78-82f5117a870d",
        "text": "I guess I hadn't posted this here since it is about a \"traditional language\", but some of you may be interested: automatic ownership memory management in Lobster: <http:\/\/aardappel.github.io\/lobster\/memory_management.html>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1556901860.014800",
        "reply_count": 47,
        "reply_users_count": 5,
        "latest_reply": "1569379958.024300",
        "reply_users": [
            "UCUSW7WVD",
            "UHDQ62M4P",
            "U8A5MS6R1",
            "UD6EXQVM0",
            "U5STGTB3J"
        ],
        "replies": [
            {
                "user": "UCUSW7WVD",
                "ts": "1556901939.014900"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556902336.015100"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1556913352.015400"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1556923265.015700"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556980994.016200"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556998003.016400"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1556999102.016600"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556999476.016900"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556999578.017100"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556999676.017300"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556999781.017500"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556999828.017700"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556999900.017900"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556999919.018100"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1556999985.018300"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557000276.018500"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1557001793.018800"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557002283.019000"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1557002367.019200"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557002807.019500"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557002994.019700"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557003108.020000"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557003195.020200"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1557003640.020500"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557004252.020700"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1557009526.021400"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557016495.021700"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557016613.021900"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557016700.022100"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1557075269.022400"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1557075604.022600"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557078110.023500"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557078182.023700"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1557078964.023900"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1557079074.024100"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1557079122.024300"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1557079139.024500"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1557079360.024900"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1557080790.025100"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557081549.025400"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1557081660.025600"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1557083533.025800"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1557095894.026000"
            },
            {
                "user": "U5STGTB3J",
                "ts": "1557488858.028700"
            },
            {
                "user": "U5STGTB3J",
                "ts": "1557489039.029000"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1559892564.011100"
            },
            {
                "user": "UD6EXQVM0",
                "ts": "1569379958.024300"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lqXl=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess I hadn't posted this here since it is about a \"traditional language\", but some of you may be interested: automatic ownership memory management in Lobster: "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/aardappel.github.io\/lobster\/memory_management.html"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1556901939.014900",
        "client_msg_id": "4b9200af-9058-457d-bb9a-476308974416",
        "text": "At least IMO there’s a far lower bar for ‘on topic’ in <#CCL5VVBAN|share-your-work>. I love seeing what people I chat with here are working on, no matter how indirectly relevant.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1556901860.014800",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7dFM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At least IMO there’s a far lower bar for ‘on topic’ in "
                            },
                            {
                                "type": "channel",
                                "channel_id": "CCL5VVBAN"
                            },
                            {
                                "type": "text",
                                "text": ". I love seeing what people I chat with here are working on, no matter how indirectly relevant."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1556902336.015100",
        "client_msg_id": "d2a7e76f-975d-4fd0-bb1a-c4c6748c8fc4",
        "text": "Good to know :slightly_smiling_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1556901860.014800",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MSo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good to know "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1556913352.015400",
        "client_msg_id": "f64d285f-5cfd-4f19-b864-e43d7bb74ddd",
        "text": "Definitely hits my interests. I’m with you that the memory model is crucial and often under-studied. Languages make design choices there without much thought, just propagating mainstream choices.\n\n&gt; I’ve personally always thought of reference counting as the “least bad” solution, which is why it was initially used for Lobster. Many people dismiss it out-right because it can’t collect cycles, but I’ve found that, in practical use, getting a “cycle report” at program exit that helps the programmer know where to break those cycles, is largely sufficient.\n\nThis hits at a frustration I often struggle to articulate[1]: I think people think of programming languages as platonic ideals when they’re really not in the platonic world at all. Error messages and your idea of “cycle reports” are perhaps the best examples of this disconnect. The warnings and errors a compiler generates should absolutely be considered part of the programming language “interface”, because languages often make decisions about syntax and semantics on the basis of what diagnostics they can print out in different situations. It’s not just about the characters you see in your text editor.\n\nThanks for sharing this!\n\n[1] One past attempt: <https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1536959125000100?thread_ts=1532963038.000621&amp;cid=C5T9GPWFL>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1556901860.014800",
        "parent_user_id": "UHDQ62M4P",
        "attachments": [
            {
                "from_url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1536959125000100?thread_ts=1532963038.000621&amp;cid=C5T9GPWFL",
                "fallback": "[September 14th, 2018 2:05 PM] ak: My rant on this is that we programmers need to replace our obsession with programming languages with an obsession for runtimes[1]. The runtime is the car, the language is the color of the bumper.\n\nFor me the big problem boils down to making it easy to copy code from one codebase to another, and have confidence when you're done that you didn't cause any regressions.\n\nIf you can do this, working with multiple runtimes becomes a lot more tractable.\n\n(Avoiding bugs is a separate problem. As is coming up with the ideal architecture for a codebase. Both these seem about as solvable as world peace. But making codebases more malleable seems like the most ambitious problem we can work on that actually may admit a solution.)\n\n[1] This may not be the best thing I've written on the subject, but it's something: <https:\/\/news.ycombinator.com\/item?id=10397026#10397931>",
                "ts": "1536959125.000100",
                "author_id": "UCUSW7WVD",
                "author_subname": "Kartik Agaram",
                "channel_id": "C5T9GPWFL",
                "is_msg_unfurl": true,
                "is_reply_unfurl": true,
                "text": "My rant on this is that we programmers need to replace our obsession with programming languages with an obsession for runtimes[1]. The runtime is the car, the language is the color of the bumper.\n\nFor me the big problem boils down to making it easy to copy code from one codebase to another, and have confidence when you're done that you didn't cause any regressions.\n\nIf you can do this, working with multiple runtimes becomes a lot more tractable.\n\n(Avoiding bugs is a separate problem. As is coming up with the ideal architecture for a codebase. Both these seem about as solvable as world peace. But making codebases more malleable seems like the most ambitious problem we can work on that actually may admit a solution.)\n\n[1] This may not be the best thing I've written on the subject, but it's something: <https:\/\/news.ycombinator.com\/item?id=10397026#10397931>",
                "author_name": "Kartik Agaram",
                "author_link": "https:\/\/futureofcoding.slack.com\/team\/UCUSW7WVD",
                "author_icon": "https:\/\/avatars.slack-edge.com\/2018-09-14\/435669206004_3ed0e6ac6eafe8bcf338_48.jpg",
                "mrkdwn_in": [
                    "text"
                ],
                "id": 1,
                "original_url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1536959125000100?thread_ts=1532963038.000621&amp;cid=C5T9GPWFL",
                "footer": "Thread in Slack Conversation"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Jcn8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Definitely hits my interests. I’m with you that the memory model is crucial and often under-studied. Languages make design choices there without much thought, just propagating mainstream choices.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I’ve personally always thought of reference counting as the “least bad” solution, which is why it was initially used for Lobster. Many people dismiss it out-right because it can’t collect cycles, but I’ve found that, in practical use, getting a “cycle report” at program exit that helps the programmer know where to break those cycles, is largely sufficient."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nThis hits at a frustration I often struggle to articulate[1]: I think people think of programming languages as platonic ideals when they’re really not in the platonic world at all. Error messages and your idea of “cycle reports” are perhaps the best examples of this disconnect. The warnings and errors a compiler generates should absolutely be considered part of the programming language “interface”, because languages often make decisions about syntax and semantics on the basis of what diagnostics they can print out in different situations. It’s not just about the characters you see in your text editor.\n\nThanks for sharing this!\n\n[1] One past attempt: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1536959125000100?thread_ts=1532963038.000621&amp;cid=C5T9GPWFL",
                                "text": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1536959125000100?thread_ts=1532963038.000621&cid=C5T9GPWFL"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U79HM6726"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1556923265.015700",
        "client_msg_id": "9fb1a214-07e9-40c3-951d-de946e92fcdb",
        "text": "I like the idea of having refcounting by default but allowing the compiler to elide certain refcounting operations. I’m curious to see what concepts and syntax you introduce for specifying Rust-style linear types where the refcount can’t ever exceed 1.\n\nI see your non-standard use of `struct` to mean “always passed by value”. Can structs contain pointers to heap allocations? A couple of years ago I built a VM for teaching programming (<https:\/\/github.com\/akkartik\/mu\/blob\/master\/Readme.md>) which uses refcounting everywhere, mostly to insulate students from hairy use-after-free bugs. Updating refcounts inside structs became a hairy problem. Particularly in the presence of sum types, I ended up having to make checks like, “if offset x has value y, then increment offset z”. I have a lot more appreciation now for why Java never inlines one object within an other.\n\nI’m also interested in schemes for managing memory manually that include runtime checks for use-after-free. My favorite consists of fat pointers that include an allocation id. When you dereference a pointer you also need to ensure that the pointer’s alloc id matches the payload’s alloc id. Just in case you like thinking about stuff like this.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1556901860.014800",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VGI2U",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like the idea of having refcounting by default but allowing the compiler to elide certain refcounting operations. I’m curious to see what concepts and syntax you introduce for specifying Rust-style linear types where the refcount can’t ever exceed 1.\n\nI see your non-standard use of "
                            },
                            {
                                "type": "text",
                                "text": "struct",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to mean “always passed by value”. Can structs contain pointers to heap allocations? A couple of years ago I built a VM for teaching programming ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/akkartik\/mu\/blob\/master\/Readme.md"
                            },
                            {
                                "type": "text",
                                "text": ") which uses refcounting everywhere, mostly to insulate students from hairy use-after-free bugs. Updating refcounts inside structs became a hairy problem. Particularly in the presence of sum types, I ended up having to make checks like, “if offset x has value y, then increment offset z”. I have a lot more appreciation now for why Java never inlines one object within an other.\n\nI’m also interested in schemes for managing memory manually that include runtime checks for use-after-free. My favorite consists of fat pointers that include an allocation id. When you dereference a pointer you also need to ensure that the pointer’s alloc id matches the payload’s alloc id. Just in case you like thinking about stuff like this."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]