[
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1744879162.186079",
        "client_msg_id": "366353d1-b5dd-4194-9fb4-aca822dc8705",
        "text": "You can \"grow up\" and you can go \"deeper\", as you can say you can go \"right\" on latin text or \"left\" on arabic numbers or <https:\/\/en.wikipedia.org\/wiki\/Boustrophedon|both>. The only constant is \"away\".",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a07cdcb6d037",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-09\/1376906509376_a07cdcb6d037bf7b6a5e_72.jpg",
            "first_name": "",
            "real_name": "Denny Vrandečić",
            "display_name": "Denny Vrandečić",
            "team": "T5TCAFTA9",
            "name": "dvrandecic",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1744816008.382139",
        "parent_user_id": "U06SS0DHZD1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3s2Og",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You can \"grow up\" and you can go \"deeper\", as you can say you can go \"right\" on latin text or \"left\" on arabic numbers or "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Boustrophedon",
                                "text": "both"
                            },
                            {
                                "type": "text",
                                "text": ". The only constant is \"away\"."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1744879169.452939",
        "client_msg_id": "735de2d2-3aa3-45f8-8aed-3f0c16c1b14b",
        "text": "(And time, I really like the \"later\" answer)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a07cdcb6d037",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-09\/1376906509376_a07cdcb6d037bf7b6a5e_72.jpg",
            "first_name": "",
            "real_name": "Denny Vrandečić",
            "display_name": "Denny Vrandečić",
            "team": "T5TCAFTA9",
            "name": "dvrandecic",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1744816008.382139",
        "parent_user_id": "U06SS0DHZD1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4\/IF4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(And time, I really like the \"later\" answer)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0282PL61U1",
        "type": "message",
        "ts": "1744898129.637789",
        "edited": {
            "user": "U0282PL61U1",
            "ts": "1744912102.000000"
        },
        "client_msg_id": "587388e9-44e3-47ea-92f6-f601315dd949",
        "text": "<https:\/\/tomasp.net\/blog\/2015\/library-frameworks\/>\n\nA good comparison can be Qt vs Skia.\n\nI agree with most claims of this essay. However, having used many frameworks and after having analyzed why they work well, it boils down to.\n\n1. Good documentation\n2. Multiplatform abstraction behind a standard interface\n3.  Combine many calls into a simple end point (button->draw in Qt vs drawing a button via Skia)\nIf these are addressed by libraries, then libraries with simple callbacks are much more preferrable to frameworks.\n\nOne problem which frameworks and libraries don't address or hide away is state machines.\nAn app is fundamentally event loop + state machine.\n\nAny framework that you use long enough, you will want to peek into how it is actually handling events and customize it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8f365fd896e9",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-02-28\/8529753983250_8f365fd896e9c8f573b5_72.jpg",
            "first_name": "xyzzy",
            "real_name": "xyzzy",
            "display_name": "xyzzy",
            "team": "T5TCAFTA9",
            "name": "moodyharsh",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1744898129.637789",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1744911387.006499",
        "reply_users": [
            "U02E4DAQGSZ"
        ],
        "replies": [
            {
                "user": "U02E4DAQGSZ",
                "ts": "1744911387.006499"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "from_url": "https:\/\/tomasp.net\/blog\/2015\/library-frameworks\/",
                "service_icon": "https:\/\/tomasp.net\/img\/favicon-big.png",
                "thumb_url": "http:\/\/tomasp.net\/blog\/2015\/library-frameworks\/diagram.png",
                "thumb_width": 350,
                "thumb_height": 180,
                "id": 1,
                "original_url": "https:\/\/tomasp.net\/blog\/2015\/library-frameworks\/",
                "fallback": "Library patterns: Why frameworks are evil",
                "text": "This article continues my mini-series on functional library design. Previously, I discussed why your library should provide multiple levels of abstraction. Today, we look at composability and avoiding callbacks. These two often go together - frameworks are based on callbacks and are not composable, while good libraries avoid callbacks and compose well.",
                "title": "Library patterns: Why frameworks are evil",
                "title_link": "https:\/\/tomasp.net\/blog\/2015\/library-frameworks\/",
                "service_name": "tomasp.net"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bvc1d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/tomasp.net\/blog\/2015\/library-frameworks\/"
                            },
                            {
                                "type": "text",
                                "text": "\n\nA good comparison can be Qt vs Skia.\n\nI agree with most claims of this essay. However, having used many frameworks and after having analyzed why they work well, it boils down to.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Good documentation"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Multiplatform abstraction behind a standard interface"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": " Combine many calls into a simple end point (button->draw in Qt vs drawing a button via Skia)"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIf these are addressed by libraries, then libraries with simple callbacks are much more preferrable to frameworks.\n\nOne problem which frameworks and libraries don't address or hide away is state machines.\nAn app is fundamentally event loop + state machine.\n\nAny framework that you use long enough, you will want to peek into how it is actually handling events and customize it."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "ok_hand",
                "users": [
                    "U02E4DAQGSZ",
                    "U08DYF4SEAE"
                ],
                "count": 2
            },
            {
                "name": "eyes",
                "users": [
                    "UDCLA1HU4"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1744904015.191639",
        "client_msg_id": "a08a1c64-a463-4091-9c7b-3588c2439c7c",
        "text": "The only universal answer: a spiral with zero in the middle. I kid, mostly.\n\nFor UI about memory, I would honestly go with the conventions for other UIs about memory like hexdumps, where smaller-numbered addresses are at the top of the page and proceed down, usually with a little bit of LTR or RTL within 16 byte blocks or so (possibly worth localizing?).\n\nUnless you really want to innovate the UI, in which case do whatever. They're just numbers. You can use any consistent ordering, and they've all _been_ used for something, so there's not a firm precedent. I think bringing in endianness, 2d cartesian coordinates, etc is a bit of a red herring. I'd only caution that trying to have numbers that grow up and sideways like a cartesian graph will be really confusing, just because if it's embedded in a UI that reads topdown\/LTR like English, it'll be really hard to avoid applying that to the memory UI too.\n\nIf you want to do something weird, I guess there's also the good ol' space-filling curve visualization; that'll keep things compact without privileging any direction or even either end of the ordering too much, at the cost of, well, being weird.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1744816008.382139",
        "parent_user_id": "U06SS0DHZD1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wMQA+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The only universal answer: a spiral with zero in the middle. I kid, mostly.\n\nFor UI about memory, I would honestly go with the conventions for other UIs about memory like hexdumps, where smaller-numbered addresses are at the top of the page and proceed down, usually with a little bit of LTR or RTL within 16 byte blocks or so (possibly worth localizing?).\n\nUnless you really want to innovate the UI, in which case do whatever. They're just numbers. You can use any consistent ordering, and they've all "
                            },
                            {
                                "type": "text",
                                "text": "been",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " used for something, so there's not a firm precedent. I think bringing in endianness, 2d cartesian coordinates, etc is a bit of a red herring. I'd only caution that trying to have numbers that grow up and sideways like a cartesian graph will be really confusing, just because if it's embedded in a UI that reads topdown\/LTR like English, it'll be really hard to avoid applying that to the memory UI too.\n\nIf you want to do something weird, I guess there's also the good ol' space-filling curve visualization; that'll keep things compact without privileging any direction or even either end of the ordering too much, at the cost of, well, being weird."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06SS0DHZD1",
        "type": "message",
        "ts": "1744907868.575129",
        "client_msg_id": "3353a868-5680-471b-b641-cfa7826f5b62",
        "text": "<https:\/\/binvis.io\/|https:\/\/binvis.io\/> uses the last one for reverse engineering (and it works wonderfully there!). Memory in this view feels a little like a long noodle squeezed into a container :joy:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "287ba5559ee1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-04-04\/6922823105585_287ba5559ee1cedd6b98_72.png",
            "first_name": "Marek",
            "real_name": "Marek Rogalski",
            "display_name": "maf",
            "team": "T5TCAFTA9",
            "name": "mafikpl",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1744816008.382139",
        "parent_user_id": "U06SS0DHZD1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZBx7N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/binvis.io\/",
                                "text": "https:\/\/binvis.io\/"
                            },
                            {
                                "type": "text",
                                "text": " uses the last one for reverse engineering (and it works wonderfully there!). Memory in this view feels a little like a long noodle squeezed into a container "
                            },
                            {
                                "type": "emoji",
                                "name": "joy",
                                "unicode": "1f602"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1744911387.006499",
        "client_msg_id": "1faba924-85c3-45c4-afa9-f5a579eebb0c",
        "text": "I think frameworks can change the programming model whereas a library cannot.\n\nSo a runtime like Akka is really a framework (note also has a state machine abstraction) , but there is no real way you can add the actor model without giving up execution control. Similarly, React gave a declarative programming model to the imperative DOM.  Not sure if its possible as a library (it kinda of is a library until you hit the JSX bit)\n\nProgramming languages don't compose either. I see frameworks as a less drastic version of a language change. They can fundamentally change the whole programming model. They change a programming language into a different programming language, but without changing the syntax (React did change the syntax too tho) or access to the ecosystem libraries.\n\nSo sometimes a thing needs to be a framework, but you should use the least powerful thing to achieve your needs. If it can be done as a library then do it as a library.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1744898129.637789",
        "parent_user_id": "U0282PL61U1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rt9ZO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think frameworks can change the programming model whereas a library cannot.\n\nSo a runtime like Akka is really a framework (note also has a state machine abstraction) , but there is no real way you can add the actor model without giving up execution control. Similarly, React gave a declarative programming model to the imperative DOM.  Not sure if its possible as a library (it kinda of is a library until you hit the JSX bit)\n\nProgramming languages don't compose either. I see frameworks as a less drastic version of a language change. They can fundamentally change the whole programming model. They change a programming language into a different programming language, but without changing the syntax (React did change the syntax too tho) or access to the ecosystem libraries.\n\nSo sometimes a thing needs to be a framework, but you should use the least powerful thing to achieve your needs. If it can be done as a library then do it as a library."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]