[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1674396396.762359",
        "client_msg_id": "cb4cf249-d755-4613-a53c-0e8a4dba7441",
        "text": "# Summary 2022\nFor me 2022 was:\n1. 0D\n2. transpiler pipelines\nExplanations below.\n\nThere is nothing “new” here.   I believe that our crop of programming languages subtly discourages certain kinds of thoughts. You *can* do these things with our programming languages, but, you *don’t bother*.\n\n[I wrote this on Jan 1\/2023.  Then I promptly got sick and found new ways to procrastinate.  I will gladly remove this if it is inappropriate or too long...]\n\n# TL;DR\n## 0D\n• 0D is part of traditional parallelism (zero-dependency, total decoupling)\n• breaking 0D away from parallelism enables other uses\n• 0D uses FIFOs, whereas functions use LIFOs (LIFOs are used by most modern programming languages, Python, Rust, etc. and stifle possible solutions)\n## Transpiler Pipelines\n• “skip over” uninteresting bits of syntax, whereas CFG requires full language specification\n• leads to a different class of tools -&gt; parser used for “quickie” matches instead of for building compilers ; different way of using parser DSLs ; like mathematical manipulation of notation\n• “skipping over” bits of syntax allows syntactic composition ; syntactic composition enables pipelines ; \n# 0D\n\n0D is a short-hand for the phrase *zero dependency*.  Total decoupling.\n\nProgrammers already know how to write 0D code, but, they tangle this simple concept up with other concepts and call the result “parallelism”.\n\nAt a very, very basic level, you can achieve 0D by using FIFOs instead of LIFOs (queues vs stacks).  LIFOs - callstacks - are good for expressing synchronous code.  LIFOs are less-good for expressing asynchronous code.\n\nProgrammers often conflate nested, recursive functions with the notion of pipelines.  If a component sends itself a message, the message is queued up in FIFO order and there is a “delay” before the message is processed, whereas if a component recursively calls itself, the function parameters are pushed onto a stack and the processing happens immediately, in LIFO order.  This subtle difference in processing sequence manifests itself in design differences.  For example, in electronics - where all components are asynchronous by default - you often see the use of “negative feedback”, say in Op-Amp designs. You rarely see this technique used in software design.  In electronics, negative feedback is used by components to self-regulate, whereas in software, recursion is used as a form of divide and conquer.  Feedback loops make it possible to be explicit about software design, whereas recursion hides the key element - the callstack - of the design.\n\nEEs had this issue sussed out, before the advent of the “everything must be synchronized” mentality.\n\nAll components in an electronic circuit are asynchronous by default.  Synchrony is judiciously, explicitly designed-in through the use of *protocols*.  Synchrony is not designed-in everywhere *by default* and is explicitly designed in on an *as needed* basis.  There is a reason - a subtle reason - why it is easy to draw diagrams of computer networks and not-so-easy to draw diagrams of synchronous code.\n\nIn EE designs, concurrency is so cheap that you can’t help but use it.  In software, concurrency implies difficulty and designers end up avoiding concurrency in their designs.\n\nThis subtle difference has a trickle-down effect to end-user code.  When it is difficult to draw diagrams of programs and to snap components together, programmers tend not to provide such features to end-users.  Or, when they provide such features, they implement such features under duress.  If DaS and snappable components were abundantly available, such features would naturally leak through to end-user apps.\n\n0D can be implemented a lot more efficiently than by using operating system processes and IPCs.  Most modern programming languages support closures (anonymous functions) and make it easy to build queue data structures.  Stick one queue at the front of a closure - the “input queue” - and one queue at the tail of a closure - the “output queue” - and, you get 0D.  Then, you need to write a wrapper component that routes “messages” from the output queue of one closure to the input queue of another closure.  Can this concept be generalized?  This ain’t rocket science.\n\nWhen you build 0D software components, does the order-of-operation of components matter?  Nope.  Can a 0D component create more than one result during its operation?  Yep.  Can a 0D component directly refer to another 0D component?  Nope.  The best you can do is to compose networks of 0D components inside of routing wrappers.\n\n# Transpiler Pipelines\nIt would be nice to build up solutions using pipelines of many little solutions and syntaxes made expressly for those solutions.\n\nWhat do you need to be able to do this?\n\n1) You need to be able to write grammars that are very, very small and that allow you to”ignore” bits of syntax that don’t pertain to a problem, e.g. kind-of like REGEX, but, better.\n2) Total isolation of building blocks.\n\n## Very Small Grammars That Ignore Uninteresting Items\nOhm-JS - a derivative of PEG (Parsing Expression Grammars) - makes it possible to write grammars that skip over uninteresting bits of text.\n\nFor example, if you want to write a quickie parser for C code, you might want to say:\n`... function-name (...) {...}`\n\nIn Ohm-JS, you can say this, whereas in a CFG-based parser generator you need to over-specify all of the niggly bits of C syntax.  In Ohm-JS, this results in a few minutes of work and only a few lines of code.  The Ohm-Editor assists in developing the micro-grammar.\n\nIn YACC and CFG-based approaches, though, you’re looking at a gargantuan job (days, weeks, months, ...) and you simply *don’t bother* to write such a quickie parser.  You either *don’t bother* with the whole idea, or you use something like REGEX which fails on a number of edge-cases for this kind of thing.  REGEX can’t search recursively for matching brackets, Ohm-JS can.  Using REGEX, you might get away with a partial solution, or, the project might grow larger as you hit unexpected speed bumps.  You either persevere or you just give up.\n\nFor the record, the grammar plus the accompanying code fabricator specification  for the above simple example are shown in the appendix.\n\n### DaS Comes For Free\n\nWhen you can build totally isolated building blocks, you can draw sensible diagrams of how the building blocks should be snapped together to solve a problem.\n\nLater, you can steal (cut\/copy\/paste) chunks of previous solutions and use them as building blocks for new problems.\n\nDaS: Diagrams as Syntax.\n\nDaS is not diagrams as an Art Form.  DaS is diagrams as programming languages.  For example, instead of writing `{...}`, you draw a rectangle.\n\nProgramming languages were created by culling the English language and by choosing only the words and phrases that could be compiled to executable code.\n\nCan we cull diagrams in the same way to invent new programming languages?\n\nEE’s have done this and they call the resulting diagrams “schematics”.\n\nBuilding construction engineers have done this and call the resulting diagrams “blueprints”.\n\n## Don’t We Already Use Building Blocks?\n\n“Code Libraries” *look* like building blocks, but, contain subtle bits of coupling that discourage building-block-iness.\n\nFor example, the very common idiom of a function call `f(x)` introduces at least 3 kinds of coupling:\n1. The name `f` is hard-wired into the caller’s code.  The calling code cannot be cut\/copy\/pasted into some other solution without also dragging in the called code, or, by futzing with the source code.\n2. The function call `f(x)` waits for the callee to return a value.  This is also known as *blocking*.  Function call notation works fine on paper, where functions can be evaluated instantaneously.  It’s different when you map function call syntax onto hardware that has propagation delays wherein functions take finite amounts of time to “run”.  This subtle difference in behaviour leads to hidden gotchas.  A glaring example of the impact of such a difference can be seen in the Mars Pathfinder disaster[^pathfinder].  \n3. The function return `v = f(x)` hard-wires a routing decision into the callee’s code.  The callee *must* direct its response back to the caller.  This is called “returning a value”.  Again, this doesn’t look like a problem when you just want to build fancier calculators, but, this hard-wired routing decision discourages simple solutions to non-calculator problems, like machine control.\n[^pathfinder]: <https:\/\/www.rapitasystems.com\/blog\/what-really-happened-software-mars-pathfinder-spacecraft>\n\nWhen you don’t have complete isolation, you don’t have building blocks.  Imagine a LEGO® set where all the pieces are joined together with a single, long sewing thread glued to each LEGO® block.  Or, you have two real-world objects, e.g. one apple and one orange.  You cut the apple in half.  What happens to the orange?\n\nAs humans, we are used to the idea that objects are completely isolated.  Programs don’t work that way.  We have to stop and think hard when writing programs.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "reply_count": 31,
        "reply_users_count": 5,
        "latest_reply": "1676468736.567129",
        "reply_users": [
            "UGWUJUZHT",
            "UCUSW7WVD",
            "U01JNTE35QS",
            "U017TE5R09M",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "UGWUJUZHT",
                "ts": "1674396645.606299"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1674413048.780219"
            },
            {
                "user": "U01JNTE35QS",
                "ts": "1674427195.703659"
            },
            {
                "user": "U01JNTE35QS",
                "ts": "1674427198.559319"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1674476389.286669"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1674555091.488049"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1674562402.434799"
            },
            {
                "user": "U017TE5R09M",
                "ts": "1675068378.006549"
            },
            {
                "user": "U017TE5R09M",
                "ts": "1675068549.772679"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1675094970.899729"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1675097023.539569"
            },
            {
                "user": "U017TE5R09M",
                "ts": "1675603917.529659"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1675630292.911339"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1675630323.576739"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1675630535.285029"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1675678641.863779"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1675685850.521639"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1675686938.256409"
            },
            {
                "user": "U017TE5R09M",
                "ts": "1675764936.721009"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1675766777.386399"
            },
            {
                "user": "U017TE5R09M",
                "ts": "1675930032.174079"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1676278129.929629"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1676278268.593209"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1676278407.969789"
            },
            {
                "user": "U017TE5R09M",
                "ts": "1676284952.600019"
            },
            {
                "user": "U017TE5R09M",
                "ts": "1676286086.501359"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1676375261.699049"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1676375275.618309"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1676375398.111889"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1676375477.575019"
            },
            {
                "user": "U017TE5R09M",
                "ts": "1676468736.567129"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ztq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "# Summary 2022\nFor me 2022 was:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "0D"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "transpiler pipelines"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nExplanations below.\n\nThere is nothing “new” here.   I believe that our crop of programming languages subtly discourages certain kinds of thoughts. You "
                            },
                            {
                                "type": "text",
                                "text": "can",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " do these things with our programming languages, but, you "
                            },
                            {
                                "type": "text",
                                "text": "don’t bother",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\n[I wrote this on Jan 1\/2023.  Then I promptly got sick and found new ways to procrastinate.  I will gladly remove this if it is inappropriate or too long...]\n\n# TL;DR\n## 0D\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "0D is part of traditional parallelism (zero-dependency, total decoupling)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "breaking 0D away from parallelism enables other uses"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "0D uses FIFOs, whereas functions use LIFOs (LIFOs are used by most modern programming languages, Python, Rust, etc. and stifle possible solutions)"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "## Transpiler Pipelines\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "“skip over” uninteresting bits of syntax, whereas CFG requires full language specification"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "leads to a different class of tools -> parser used for “quickie” matches instead of for building compilers ; different way of using parser DSLs ; like mathematical manipulation of notation"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "“skipping over” bits of syntax allows syntactic composition ; syntactic composition enables pipelines ; "
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n# 0D\n\n0D is a short-hand for the phrase "
                            },
                            {
                                "type": "text",
                                "text": "zero dependency",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  Total decoupling.\n\nProgrammers already know how to write 0D code, but, they tangle this simple concept up with other concepts and call the result “parallelism”.\n\nAt a very, very basic level, you can achieve 0D by using FIFOs instead of LIFOs (queues vs stacks).  LIFOs - callstacks - are good for expressing synchronous code.  LIFOs are less-good for expressing asynchronous code.\n\nProgrammers often conflate nested, recursive functions with the notion of pipelines.  If a component sends itself a message, the message is queued up in FIFO order and there is a “delay” before the message is processed, whereas if a component recursively calls itself, the function parameters are pushed onto a stack and the processing happens immediately, in LIFO order.  This subtle difference in processing sequence manifests itself in design differences.  For example, in electronics - where all components are asynchronous by default - you often see the use of “negative feedback”, say in Op-Amp designs. You rarely see this technique used in software design.  In electronics, negative feedback is used by components to self-regulate, whereas in software, recursion is used as a form of divide and conquer.  Feedback loops make it possible to be explicit about software design, whereas recursion hides the key element - the callstack - of the design.\n\nEEs had this issue sussed out, before the advent of the “everything must be synchronized” mentality.\n\nAll components in an electronic circuit are asynchronous by default.  Synchrony is judiciously, explicitly designed-in through the use of "
                            },
                            {
                                "type": "text",
                                "text": "protocols",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  Synchrony is not designed-in everywhere "
                            },
                            {
                                "type": "text",
                                "text": "by default",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and is explicitly designed in on an "
                            },
                            {
                                "type": "text",
                                "text": "as needed",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " basis.  There is a reason - a subtle reason - why it is easy to draw diagrams of computer networks and not-so-easy to draw diagrams of synchronous code.\n\nIn EE designs, concurrency is so cheap that you can’t help but use it.  In software, concurrency implies difficulty and designers end up avoiding concurrency in their designs.\n\nThis subtle difference has a trickle-down effect to end-user code.  When it is difficult to draw diagrams of programs and to snap components together, programmers tend not to provide such features to end-users.  Or, when they provide such features, they implement such features under duress.  If DaS and snappable components were abundantly available, such features would naturally leak through to end-user apps.\n\n0D can be implemented a lot more efficiently than by using operating system processes and IPCs.  Most modern programming languages support closures (anonymous functions) and make it easy to build queue data structures.  Stick one queue at the front of a closure - the “input queue” - and one queue at the tail of a closure - the “output queue” - and, you get 0D.  Then, you need to write a wrapper component that routes “messages” from the output queue of one closure to the input queue of another closure.  Can this concept be generalized?  This ain’t rocket science.\n\nWhen you build 0D software components, does the order-of-operation of components matter?  Nope.  Can a 0D component create more than one result during its operation?  Yep.  Can a 0D component directly refer to another 0D component?  Nope.  The best you can do is to compose networks of 0D components inside of routing wrappers.\n\n# Transpiler Pipelines\nIt would be nice to build up solutions using pipelines of many little solutions and syntaxes made expressly for those solutions.\n\nWhat do you need to be able to do this?\n\n1) You need to be able to write grammars that are very, very small and that allow you to”ignore” bits of syntax that don’t pertain to a problem, e.g. kind-of like REGEX, but, better.\n2) Total isolation of building blocks.\n\n## Very Small Grammars That Ignore Uninteresting Items\nOhm-JS - a derivative of PEG (Parsing Expression Grammars) - makes it possible to write grammars that skip over uninteresting bits of text.\n\nFor example, if you want to write a quickie parser for C code, you might want to say:\n"
                            },
                            {
                                "type": "text",
                                "text": "... function-name (...) {...}",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nIn Ohm-JS, you can say this, whereas in a CFG-based parser generator you need to over-specify all of the niggly bits of C syntax.  In Ohm-JS, this results in a few minutes of work and only a few lines of code.  The Ohm-Editor assists in developing the micro-grammar.\n\nIn YACC and CFG-based approaches, though, you’re looking at a gargantuan job (days, weeks, months, ...) and you simply "
                            },
                            {
                                "type": "text",
                                "text": "don’t bother",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to write such a quickie parser.  You either "
                            },
                            {
                                "type": "text",
                                "text": "don’t bother",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with the whole idea, or you use something like REGEX which fails on a number of edge-cases for this kind of thing.  REGEX can’t search recursively for matching brackets, Ohm-JS can.  Using REGEX, you might get away with a partial solution, or, the project might grow larger as you hit unexpected speed bumps.  You either persevere or you just give up.\n\nFor the record, the grammar plus the accompanying code fabricator specification  for the above simple example are shown in the appendix.\n\n### DaS Comes For Free\n\nWhen you can build totally isolated building blocks, you can draw sensible diagrams of how the building blocks should be snapped together to solve a problem.\n\nLater, you can steal (cut\/copy\/paste) chunks of previous solutions and use them as building blocks for new problems.\n\nDaS: Diagrams as Syntax.\n\nDaS is not diagrams as an Art Form.  DaS is diagrams as programming languages.  For example, instead of writing "
                            },
                            {
                                "type": "text",
                                "text": "{...}",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", you draw a rectangle.\n\nProgramming languages were created by culling the English language and by choosing only the words and phrases that could be compiled to executable code.\n\nCan we cull diagrams in the same way to invent new programming languages?\n\nEE’s have done this and they call the resulting diagrams “schematics”.\n\nBuilding construction engineers have done this and call the resulting diagrams “blueprints”.\n\n## Don’t We Already Use Building Blocks?\n\n“Code Libraries” "
                            },
                            {
                                "type": "text",
                                "text": "look",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " like building blocks, but, contain subtle bits of coupling that discourage building-block-iness.\n\nFor example, the very common idiom of a function call "
                            },
                            {
                                "type": "text",
                                "text": "f(x)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " introduces at least 3 kinds of coupling:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The name "
                                    },
                                    {
                                        "type": "text",
                                        "text": "f",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " is hard-wired into the caller’s code.  The calling code cannot be cut\/copy\/pasted into some other solution without also dragging in the called code, or, by futzing with the source code."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The function call "
                                    },
                                    {
                                        "type": "text",
                                        "text": "f(x)",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " waits for the callee to return a value.  This is also known as "
                                    },
                                    {
                                        "type": "text",
                                        "text": "blocking",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": ".  Function call notation works fine on paper, where functions can be evaluated instantaneously.  It’s different when you map function call syntax onto hardware that has propagation delays wherein functions take finite amounts of time to “run”.  This subtle difference in behaviour leads to hidden gotchas.  A glaring example of the impact of such a difference can be seen in the Mars Pathfinder disaster[^pathfinder].  "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The function return "
                                    },
                                    {
                                        "type": "text",
                                        "text": "v = f(x)",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " hard-wires a routing decision into the callee’s code.  The callee "
                                    },
                                    {
                                        "type": "text",
                                        "text": "must",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " direct its response back to the caller.  This is called “returning a value”.  Again, this doesn’t look like a problem when you just want to build fancier calculators, but, this hard-wired routing decision discourages simple solutions to non-calculator problems, like machine control."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[^pathfinder]: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.rapitasystems.com\/blog\/what-really-happened-software-mars-pathfinder-spacecraft"
                            },
                            {
                                "type": "text",
                                "text": "\n\nWhen you don’t have complete isolation, you don’t have building blocks.  Imagine a LEGO® set where all the pieces are joined together with a single, long sewing thread glued to each LEGO® block.  Or, you have two real-world objects, e.g. one apple and one orange.  You cut the apple in half.  What happens to the orange?\n\nAs humans, we are used to the idea that objects are completely isolated.  Programs don’t work that way.  We have to stop and think hard when writing programs."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1674396645.606299",
        "client_msg_id": "4a709262-01da-4785-86dc-b310be43dff2",
        "text": "# Appendix\nIf you want to play along with this experiment, the code is in <https:\/\/github.com\/guitarvydas\/cfunc>.\n\n## c.ohm\nA quickie grammar that matches function declarations in a C file.\n\nNote that this grammar is longer than a REGEX, but, is significantly shorter than a CFG specification (LR(k), YACC, etc.) for the C programming language.\n\n```Cfunctions {\n  program = item+\n  item =\n    | comment\n    | string\n    | applySyntactic&lt;FunctionDecl&gt; -- decl\n    | any -- other\n  FunctionDecl = name \"(\" param+ \")\" \"{\" block+ \"}\"\n\n    param =\n      | \"(\" param+ \")\" -- nested\n      | ~\"(\" ~\")\" any  -- flat\n\n    block =\n      | \"{\" block+ \"}\" -- nested\n      | ~\"{\" ~\"}\" any  -- flat\n\n      name = letter (alnum | \"_\")*\n      comment =\n        | \"\/\/\" (~nl any)* nl\n        | \"\/*\" (~\"*\/\" any)* \"*\/\"\n      string =\n        | bqstring\n        | dqstring\n        | sqstring\n      bqstring = \"`\" (qbq | (~\"`\" any))* \"`\"\n      dqstring = \"\\\"\" (qdq | (~\"\\\"\" any))* \"\\\"\"\n      sqstring = \"'\" (qsq | (~\"'\" any))* \"'\"\n      qbq = \"\\\\\" \"`\"\n      qdq = \"\\\\\" \"\\\"\"\n      qsq = \"\\\\\" \"'\"\n      nl = \"\\n\"\n      spaces += comment\n}```\nCan this grammar be improved and optimized?  Probably.  But, why would you care?\n\nYou would care only if you used this code in an end-user product.\n\nIf you use this code in something like a batch-editing environment, “efficiency” takes on a different meaning.  End-users don’t care about the efficiency of your code editor and its Find-and-Replace function.  End-users don’t care how efficient your command line tools, like *grep*, are.\n\nWhen you treat Ohm-JS + Fab as batch editors for development, then, only *development efficiency* matters.\n\nI strongly believe that one shouldn’t write code.  One should write code that writes code.  From this perspective, “efficiency” breaks down into 2 camps:\n1. developer efficiency\n2. end-user efficiency.\nNote that traditional *compilers* are simply apps that write code.  Developers use *compilers*.  End-users don’t care if a developer created end-user app code by hand or by using a compiler.  The only things that end-users care about is if the app is cheap and runs on cheap hardware.  The final app is assembler, regardless of how it was created. Developers, on the other hand, do care about development time and effort.  Hand-writing apps requires much more effort than using high-level language compilers to generate the final app code.  Debugging apps is easier when using high-level languages with type-checkers.  On the other hand, developers usually buy fancier hardware than that which is used by end-users.  Developers can afford to burn CPU cycles on their fancy hardware to give themselves faster - and cheaper - development and debugging times.\n\nThe final step in development is that of Production Engineering an app to make it cheap-enough to sell.  Up until that point, the development workflow should consist of *anything* that speeds up and cheapens development time, for example, dynamic language environments and REPLs.  For example, *Rust* is a Production Engineering language and needn’t be used until the last moment.\n\n## c.fab\n\nA `.fab` file is a specification that creates strings based on the above grammar.  *Fab* is an experimental transpiler tool that works with Ohm-JS.  It generates JavaScript code required by Ohm-JS.  This could all be done by off-the-shelf Ohm-JS.  *Fab* simply reduces the amount of keyboarding needed for creating JavaScript “semantics” code required by Ohm-JS.  *Fab* is written in Ohm-JS.\n```Cfunctions {\n  program [item+] = ‛«item»'\n  item_decl [x] =  ‛«x»'\n  item_other [x] =  ‛'\n  FunctionDecl [name lp param+ rp lb block+ rb] = ‛\\n«name»'\n    param_nested [lp param+ rp] = ‛'\n    param_flat [c] = ‛'\n    block_nested [lp block+ rp] = ‛'\n    block_flat [c] = ‛'\n      name [letter c*] = ‛«letter»«c»'\n      comment [begin cs end] = ‛'\n      nl [c] =  ‛«c»'\n      spaces [cs] =  ‛«cs»'\n      bqstring [begin cs* end] = ‛'\n      dqstring [begin cs* end] = ‛'\n      sqstring [begin cs* end] = ‛'\n      qbq [bslash c] = ‛'\n      qdq [bslash c] = ‛'\n      qsq [bslash c] = ‛'\n}```\n## grep.c\nThe above was tested against `grep.c` from the Gnu grep repo.\n\n`git clone <https:\/\/git.savannah.gnu.org\/git\/grep.git>`\n## Even Smaller\nI’m playing with the design of a new tool that I call *bred* (bracket editor).  It’s like a super-simple batch editor that walks through text that contains bracketed constructs.\n\nThe full specification consists of 2 strings\n1. what to match\n2. how to rewrite it.\nThe above specifications might be re-expressed as:\n```‛«name» («params») {«block»}'\n‛«name»'```\nwhich reads as:\n1. match, recursively, anything that looks like `«name» («params») {«block»}`\n2. then, throw away everything except the name\nCurrently, my concepts have warts - what happens when a comment or a string or a character constant contains brackets, or, even worse, what happens if they contain unmatched brackets?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kx3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "# Appendix\nIf you want to play along with this experiment, the code is in "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/guitarvydas\/cfunc"
                            },
                            {
                                "type": "text",
                                "text": ".\n\n## c.ohm\nA quickie grammar that matches function declarations in a C file.\n\nNote that this grammar is longer than a REGEX, but, is significantly shorter than a CFG specification (LR(k), YACC, etc.) for the C programming language.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Cfunctions {\n  program = item+\n  item =\n    | comment\n    | string\n    | applySyntactic<FunctionDecl> -- decl\n    | any -- other\n  FunctionDecl = name \"(\" param+ \")\" \"{\" block+ \"}\"\n\n    param =\n      | \"(\" param+ \")\" -- nested\n      | ~\"(\" ~\")\" any  -- flat\n\n    block =\n      | \"{\" block+ \"}\" -- nested\n      | ~\"{\" ~\"}\" any  -- flat\n\n      name = letter (alnum | \"_\")*\n      comment =\n        | \"\/\/\" (~nl any)* nl\n        | \"\/*\" (~\"*\/\" any)* \"*\/\"\n      string =\n        | bqstring\n        | dqstring\n        | sqstring\n      bqstring = \"`\" (qbq | (~\"`\" any))* \"`\"\n      dqstring = \"\\\"\" (qdq | (~\"\\\"\" any))* \"\\\"\"\n      sqstring = \"'\" (qsq | (~\"'\" any))* \"'\"\n      qbq = \"\\\\\" \"`\"\n      qdq = \"\\\\\" \"\\\"\"\n      qsq = \"\\\\\" \"'\"\n      nl = \"\\n\"\n      spaces += comment\n}"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCan this grammar be improved and optimized?  Probably.  But, why would you care?\n\nYou would care only if you used this code in an end-user product.\n\nIf you use this code in something like a batch-editing environment, “efficiency” takes on a different meaning.  End-users don’t care about the efficiency of your code editor and its Find-and-Replace function.  End-users don’t care how efficient your command line tools, like "
                            },
                            {
                                "type": "text",
                                "text": "grep",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", are.\n\nWhen you treat Ohm-JS + Fab as batch editors for development, then, only "
                            },
                            {
                                "type": "text",
                                "text": "development efficiency",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " matters.\n\nI strongly believe that one shouldn’t write code.  One should write code that writes code.  From this perspective, “efficiency” breaks down into 2 camps:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "developer efficiency"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "end-user efficiency."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nNote that traditional "
                            },
                            {
                                "type": "text",
                                "text": "compilers",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " are simply apps that write code.  Developers use "
                            },
                            {
                                "type": "text",
                                "text": "compilers",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  End-users don’t care if a developer created end-user app code by hand or by using a compiler.  The only things that end-users care about is if the app is cheap and runs on cheap hardware.  The final app is assembler, regardless of how it was created. Developers, on the other hand, do care about development time and effort.  Hand-writing apps requires much more effort than using high-level language compilers to generate the final app code.  Debugging apps is easier when using high-level languages with type-checkers.  On the other hand, developers usually buy fancier hardware than that which is used by end-users.  Developers can afford to burn CPU cycles on their fancy hardware to give themselves faster - and cheaper - development and debugging times.\n\nThe final step in development is that of Production Engineering an app to make it cheap-enough to sell.  Up until that point, the development workflow should consist of "
                            },
                            {
                                "type": "text",
                                "text": "anything",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that speeds up and cheapens development time, for example, dynamic language environments and REPLs.  For example, "
                            },
                            {
                                "type": "text",
                                "text": "Rust",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is a Production Engineering language and needn’t be used until the last moment.\n\n## c.fab\n\nA "
                            },
                            {
                                "type": "text",
                                "text": ".fab",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " file is a specification that creates strings based on the above grammar.  "
                            },
                            {
                                "type": "text",
                                "text": "Fab",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is an experimental transpiler tool that works with Ohm-JS.  It generates JavaScript code required by Ohm-JS.  This could all be done by off-the-shelf Ohm-JS.  "
                            },
                            {
                                "type": "text",
                                "text": "Fab",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " simply reduces the amount of keyboarding needed for creating JavaScript “semantics” code required by Ohm-JS.  "
                            },
                            {
                                "type": "text",
                                "text": "Fab",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is written in Ohm-JS.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Cfunctions {\n  program [item+] = ‛«item»'\n  item_decl [x] =  ‛«x»'\n  item_other [x] =  ‛'\n  FunctionDecl [name lp param+ rp lb block+ rb] = ‛\\n«name»'\n    param_nested [lp param+ rp] = ‛'\n    param_flat [c] = ‛'\n    block_nested [lp block+ rp] = ‛'\n    block_flat [c] = ‛'\n      name [letter c*] = ‛«letter»«c»'\n      comment [begin cs end] = ‛'\n      nl [c] =  ‛«c»'\n      spaces [cs] =  ‛«cs»'\n      bqstring [begin cs* end] = ‛'\n      dqstring [begin cs* end] = ‛'\n      sqstring [begin cs* end] = ‛'\n      qbq [bslash c] = ‛'\n      qdq [bslash c] = ‛'\n      qsq [bslash c] = ‛'\n}"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "## grep.c\nThe above was tested against "
                            },
                            {
                                "type": "text",
                                "text": "grep.c",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " from the Gnu grep repo.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "git clone ",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/git.savannah.gnu.org\/git\/grep.git",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n## Even Smaller\nI’m playing with the design of a new tool that I call "
                            },
                            {
                                "type": "text",
                                "text": "bred",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (bracket editor).  It’s like a super-simple batch editor that walks through text that contains bracketed constructs.\n\nThe full specification consists of 2 strings\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "what to match"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "how to rewrite it."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe above specifications might be re-expressed as:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "‛«name» («params») {«block»}'\n‛«name»'"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "which reads as:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "match, recursively, anything that looks like "
                                    },
                                    {
                                        "type": "text",
                                        "text": "«name» («params») {«block»}",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "then, throw away everything except the name"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCurrently, my concepts have warts - what happens when a comment or a string or a character constant contains brackets, or, even worse, what happens if they contain unmatched brackets?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1674413048.780219",
        "client_msg_id": "67ff7467-7488-450c-b2df-1ab92f75bae6",
        "text": "Nice ideas.\n\nRe 0D, my next question is: how to decide at what granularity to stop using function calls? Or are you suggesting eliminating them entirely?\n\nRe transpiler pipelines: I tried this for a while a few years ago. The conclusion I reached was that they were great for adding capabilities but they can't add restrictions. In first class languages often a lot of value comes from guarantees that certain events won't occur. An int won't be assigned to a string. There you need a single coherent grammar. Does this seem right?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "d9TM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Nice ideas.\n\nRe 0D, my next question is: how to decide at what granularity to stop using function calls? Or are you suggesting eliminating them entirely?\n\nRe transpiler pipelines: I tried this for a while a few years ago. The conclusion I reached was that they were great for adding capabilities but they can't add restrictions. In first class languages often a lot of value comes from guarantees that certain events won't occur. An int won't be assigned to a string. There you need a single coherent grammar. Does this seem right?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01JNTE35QS",
        "type": "message",
        "ts": "1674427195.703659",
        "client_msg_id": "d066a1d7-85fa-4ab7-a9eb-f3b842648126",
        "text": "this talk is quite relevant —",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "97155db555c2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-01-13\/1631845309525_97155db555c2091ecd20_72.jpg",
            "first_name": "",
            "real_name": "Vijay Chakravarthy",
            "display_name": "Vijay Chakravarthy",
            "team": "T5TCAFTA9",
            "name": "vchakrav",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/6PCm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this talk is quite relevant —"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01JNTE35QS",
        "type": "message",
        "ts": "1674427198.559319",
        "client_msg_id": "a427843d-b2b5-42cd-a0b9-95c7cecde864",
        "text": "<https:\/\/youtu.be\/JMZLBB_BFNg>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "97155db555c2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-01-13\/1631845309525_97155db555c2091ecd20_72.jpg",
            "first_name": "",
            "real_name": "Vijay Chakravarthy",
            "display_name": "Vijay Chakravarthy",
            "team": "T5TCAFTA9",
            "name": "vchakrav",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "attachments": [
            {
                "from_url": "https:\/\/youtu.be\/JMZLBB_BFNg",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/JMZLBB_BFNg\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/JMZLBB_BFNg?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen title=\"&quot;Parser Parser Combinators for Program Transformation&quot; by Rijnard van Tonder\"><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/youtu.be\/JMZLBB_BFNg",
                "fallback": "YouTube Video: \"Parser Parser Combinators for Program Transformation\" by Rijnard van Tonder",
                "title": "\"Parser Parser Combinators for Program Transformation\" by Rijnard van Tonder",
                "title_link": "https:\/\/youtu.be\/JMZLBB_BFNg",
                "author_name": "Strange Loop Conference",
                "author_link": "https:\/\/www.youtube.com\/@StrangeLoopConf",
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IwT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/youtu.be\/JMZLBB_BFNg"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    }
]