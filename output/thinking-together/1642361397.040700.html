<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2021-12-16/2861597891505_f3d63cdd315711ff17a4_72.jpg" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Sonnentag</b>
<span style="margin:2em; color:#606060">2022-01-16 11:29</span><br/>
I’ve been obsessed with the question of how the future of coding might look like for a while, and I’m at the point where I have to ask myself if I’m actually progressing or just jumping from idea to idea.<br/><br/>I was initially motivated by the vague feeling that something about software development today is wrong and that there has to be a better way. My working hypothesis was that programming is too complicated. If we made it more accessible, everyone could create precisely the tools they need to solve their problems.<br/><br/>Is this true? If we gave everyone the ability to program overnight, very little would change. People still couldn’t quickly build tools to solve problems. I know this because I currently don’t use any tool I’ve created for myself. Most of the time, it’s just not worth it to build a tool for myself. Making programming easier isn’t sufficient to create an ecosystem of DIY tools. The shape of the artifact that we produce when we program has to change as well.<br/><br/>The next question is: Do people even want to create their own tools? The answer is most people probably don’t. B Nardi [1] surveyed how people use applications that support end-user programming like spreadsheets or CAD software. What she discovered is that most people only used basic features. If they wanted to do something more advanced, they relied on the few people on their team (10 - 20%) that had an intrinsic interest to tinker with computers and read manuals. She called these expert users local developers because they helped raise the technical sophistication of everyone by supporting their colleagues with questions and by sharing macros or formulas that they’ve created. We can see the emergence of local developers also in the no-code movement. There are now dedicated agencies that focus purely on creating no-code applications [2].<br/><br/>My initial hypothesis that we have to make programming easier was naive and too focused on the creation process. In the future, I want to focus more on the shape that applications should have once they are built. So, for example, I’m less interested in finding more user-friendly abstractions than the EXCEL formula language. Instead, I want applications that you can take apart into recombinable parts.<br/><br/>How could a tangible building material of information software look like?<br/>• structured search<br/>• drag and drop of data objects<br/>How to address the different classes of users of the system?<br/>• A base material that is useful without programming<br/>• A framework for developers to create domain-specific components<br/>• A glue language for local developers to recombine the components<br/>[1] <a href="https://mitpress.mit.edu/books/small-matter-programming">https://mitpress.mit.edu/books/small-matter-programming</a><br/>[2] <a href="https://nocodeagencies.com/">https://nocodeagencies.com/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642362767.040800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642362767.040800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2022-01-16 11:52</span><br/>
&gt; I know this because I currently don’t use any tool I’ve created for myself.<br/>A reason that the people who <em>can</em> program often don't feel the <em>need</em> to program is that many of their software needs have already been met by the mountain of past work from people similar to them — programmers. But people who can't currently program will have needs they face in their work that are less likely to have been met by software, because "people similar to them" are also presumably not able to program.<br/><br/>But that's just a quibble with this one supporting argument. I still agree with the conclusions you draw.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642373843.041500"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642373843.041500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2022-01-16 14:57</span><br/>
&gt; If we gave everyone the ability to program overnight, very little would change. People still couldn’t quickly build tools to solve problems.<br/>I strongly disagree with this assertion, assuming I'm interpreting it correctly. I think we can make it practical for end users with technical aptitude to make apps.<br/><br/>&gt; My working hypothesis was that programming is too complicated. If we made it more accessible, everyone could create precisely the tools they need to solve their problems.<br/>What do you mean by "make it more accessible"? There are many ways you could interpret that goal. Oftentimes when people say this, they mean making programming easier to <em>learn</em>. Other times, they mean making the programming community more <em>friendly</em> and <em>diverse</em>. Personally, I'm focused on re-inventing the very foundations of programming to make it <em>simpler</em>.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642374407.042000"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642374407.042000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2022-01-16 15:06</span><br/>
That said, I do agree we need "applications that you can take apart into recombinable parts". Many companies are already doing this with their "no code" and "low code" apps, but of course these are <b>closed</b> ecosystems. If you want an <b>open</b>, universal ecosystem of combinable code snippets, I would call that a (distributed) programming environment.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642381535.042400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642381535.042400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-01-16 17:05</span><br/>
There are 2 relevant threads starting at <a href="https://marianoguerra.github.io/future-of-coding-weekly/history/?fromDate=2020-09-08&amp;toDate=2020-09-14&amp;channel=thinking-together#2020-09-08T18:06:34.135Z">https://marianoguerra.github.io/future-of-coding-weekly/hist&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642385647.043000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642385647.043000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-01-16 18:14</span><br/>
An alternative, more comprehensive listing requires a few steps to obtain an offline copy of this group's archives:<br/><br/>• Download <a href="http://akkartik.name/mu/mu-browser-20210815.img.gz">http://akkartik.name/mu/mu-browser-20210815.img.gz</a><br/>• Download <a href="http://akkartik.name/mu/foc-data-20210814.img.gz">http://akkartik.name/mu/foc-data-20210814.img.gz</a><br/>• Unzip both files.<br/>• Install Qemu and run <tt>qemu-system-i386 -m 2G -hda mu-browser-20210815.img -hdb foc-data-20210814.img</tt> (You don't have to trust me since Qemu is a well-trusted project and my code is perfectly sandboxed inside Qemu. Running a program within Qemu is more secure than browsing to a website in a web browser.)<br/>• Wait 2 minutes for the ~60MB of archives to get loaded into RAM.<br/>• Press <tt>/</tt> to search and then type in exactly <tt>Is there any hope</tt> and hit enter. (There's no keyword search and search is case-sensitive at the moment.)<br/>• Press enter on the post by Roben Kleene that is highlighted. It won't look like much has happened, the highlight will just disappear. But you're in a new page now, having jumped from the search screen to a thread view. Press up arrow to browse comments of this thread (arranged in reverse chronological order). Other shortcuts appear in the menu at the bottom. I particularly commend to your attention my own comments in this thread :slightly_smiling_face:<br/>• For the second thread, search for <tt>opinionated overflow thread</tt>. Again, hit enter on the highlighted post to jump to its thread view.<br/>• Oh, bonus third thread. Search for <tt>old blog posts</tt> for my list of programs I've written for myself. It's a comment on a third thread which is also relevant.<br/>Apologies in advance for the crappy UX, but I have high hopes that these image files -- with every byte lovingly hand-crafted all the way up from machine code -- will continue to be browseable in 50 years time. (You'd just need to get your hands on a 2070-era x86 emulator.) I'd also love to jam with anyone interested in improving the search or anything else.<br/><br/>Needless to say, both <span style="background-color:#ccf">@Mariano Guerra</span>'s history browser and mine are examples of programs we've written for ourselves. They're kinda idiosyncratic, and we often work around their limitations rather than fix them. But they've both allowed us to treat this group's history as part of our exo-brain. I consider them great examples of the sorts of programs people would benefit from (without learning machine code) if they learned programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642389507.043600"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642389507.043600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-01-16 19:18</span><br/>
I wrote up some opinionated notes on <em>A small matter of programming</em> for this group a couple of years ago: <a href="http://akkartik.name/post/nardi">http://akkartik.name/post/nardi</a>. From my recollection, Bonnie Nardi is careful to distinguish between how people use software today and what is possible.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642415516.044700"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642415516.044700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-01-17 02:31</span><br/>
I think discovery and distribution is a difficult problem more than creation, hence I orbit a coding community I think might achieve criticality (i.e. <a href="http://observablehq.com">observablehq.com</a>) that also supports what I think the future of coding should look like: personal customization of other people's software.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642448028.051100"></a>
      <a href="../thinking-together/1642361397.040700.html#1642448028.051100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Sonnentag</b>
<span style="margin:2em; color:#606060">2022-01-17 11:33</span><br/>
&gt; I strongly disagree with this assertion, assuming I’m interpreting it correctly. I think we can make it practical for end users with technical aptitude to make apps.<br/><br/>I should have been more clear. I think it is possible to provide end-users with an environment that allows them to build custom tools. I was trying to argue that the main problem isn’t that people cannot program because it’s too hard. The main problem I see is that most of our programming environments are made for building professional software that will be used by thousands to millions of users.<br/>I think programming should be easier, but first I want to focus on a better shape for software that enables casual remixes and recombination of tools. Boxer [1] is a good example for such an environment.<br/><br/><span style="background-color:#ccf">@Kartik Agaram</span> Thanks for linking back to previous conversations. I think the future of coding history tool is a great example of the kind of tools I’m talking about. In my dream world, something like this wouldn’t require writing any code at all, and you could just take apart the slack interface to create a custom view.<br/><br/>[1] <a href="https://boxer-project.github.io/">https://boxer-project.github.io/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642449732.051300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642449732.051300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-01-17 12:02</span><br/>
It's a dream shared by many, and I am in the minority in considering it obviously unrealistic. Slack has its own incentives, and has to compete with the abstractions above and below it [1]. You're never going to be in a situation where you can forget about incommensurable incentives.<br/><br/>[1] <a href="https://www.joelonsoftware.com/2002/06/12/strategy-letter-v">https://www.joelonsoftware.com/2002/06/12/strategy-letter-v</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642452457.051700"></a>
      <img src="https://avatars.slack-edge.com/2021-12-16/2861597891505_f3d63cdd315711ff17a4_72.jpg" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642452457.051700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Sonnentag</b>
<span style="margin:2em; color:#606060">2022-01-17 12:47</span><br/>
I don't think Slack would ever provide something like that. What I aspire to is an environment that would make it feasible for a community like ours to build our own communication tool.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642468451.051900"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642468451.051900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-01-17 17:14</span><br/>
&gt; The main problem I see is that most of our programming environments are made for building professional software that will be used by thousands to millions of users.<br/>1000% agreed!<br/><br/>However, I believe your metaphor of "A glue language to recombine the components" [like Legos] is fundamentally ill-posed. We programmers have a long history of over-estimating how composable software is. I believe that no matter what components you come up with, anybody putting them together will still have to reason about a wide variety of cases, scenarios, error conditions. That is to me the essence of programming, and it takes some minimum effort to learn no matter how easy it is to compose the final program out of primitives.<br/><br/>Given that fundamental uncomposability, I think you'll always have disagreements within the community. People and subgroups who can navigate disagreements are more empowered than people and subgroups who can't. And so you'll never be able to stop thinking about how the components are implemented.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642486724.052500"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642486724.052500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-01-17 22:18</span><br/>
I am wondering how observable does not fit this want,  here is someone building a data summary tool in userspace with other members contributing opinions and suggestions <a href="https://observablehq.com/@observablehq/summary-table">https://observablehq.com/@observablehq/summary-table</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642493615.053200"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642493615.053200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-01-18 00:13</span><br/>
I think there is nothing wrong per se with Observable's approach, but if the stuff I need to glue together is not in Observable, it won't work for me. I suspect that the uncomposability that <span style="background-color:#ccf">@Kartik Agaram</span> describes is mostly due to different conventions used by different software tools/environments and different communities. Software components can be assembled together only if the interfaces fit perfectly, and given the enormous amount of detail that can go into software, that's a big constraint.<br/>My current view (likely to change, as it has changed in the past) is that the main culprit is the widespread approach of "my language is the entire universe, except that I interface to C or JavaScript for practical reasons". If we want software components to interface easily to components written by someone else far way in time and space, the first thing we need is languages and runtimes designed for being one among many.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642498194.053900"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642498194.053900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-01-18 01:29</span><br/>
&gt;  if the stuff I need to glue together is not in Observable, it won't work for me.<br/>But Observablehq consumes ES6 modules, and emits ES6 modules. It has standard connector and can directly depend on NPM hosted code. The code is vanilla javascript. You can flip on your DevTools and debug it. You can use javascript's dynamic imports to load ES6 code from any URL on the internet. So it couldn't be more composable and compatible with of one of the largest software ecosystems on the planet.<br/><br/>&gt; my language is the entire universe<br/>Javascript call APIs, which is where cross language composability lives.<br/><br/>&gt; the first thing we need is languages and runtimes designed for being one among many.<br/>This is what REST HTTP/gRPC is for, we have that at the network layer.<br/><br/>I maybe don't understand your points properly but I don't think Observable is a "my way of the highway" approach that I have seen many other tools do (Darklang, ELM), its vanilla Javascript (and SQL, TEX, Markdown and HTML). Maybe the fact you are forced a certain IDE is a problem but I think hosting on the browser is actually a huge win for accessibility (no installation).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642502568.054700"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642502568.054700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-01-18 02:42</span><br/>
&gt; Observablehq consumes ES6 modules<br/>Fine, but what if the components I need are in Python, or R? Not a made-up example, that's my daily work environment. I'd love to be able to use Observablehq, but none of the ingredients I need  (pretty specialized stuff for molecular simulations) exist in the JS ecosystem. For the same reason, I can't use Clerk (the recently published notebook for Clojure), which looks neat as well.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642502806.054900"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642502806.054900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-01-18 02:46</span><br/>
&gt; | the first thing we need is languages and runtimes designed for being one among many.<br/>&gt; This is what REST HTTP/gRPC is for, we have that at the network layer.<br/>If everyone agreed on using HTTP-based component interfaces, that might perhaps work. I have some doubts, however. The popular  approach of "Let's start on HTTP server on some random-looking port number, hoping that it's free" doesn't scale. And configuring all port numbers by hand to avoid conflicts doesn't scale either.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642509648.055100"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642509648.055100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-01-18 04:40</span><br/>
I totally agree that the python and R ecosystem each has a lot of unique software that is unavailable elsewhere. But this is not the fault of the javascript ecosystem, which is more or less available <b>everywhere</b>. Javascript is running in a sandbox <b>expressly</b> to make it portable, and it is a wild success because we hardly worry about whether your JS is running on a Mac or PC. These same cannot be said for Python, where a numpy installation is a pain on pretty much every platform, and python 2 does not work with python 3. JS has a remarkably strong backwards compatibility story in comparison.<br/><br/>&gt;  And configuring all port numbers by hand to avoid conflicts doesn't scale either.<br/>this is what docker-compose solves. It gives you a way of wiring a bunch of different binaries written differently together . It's not a great solution but its best we have at the moment. I do think cross language composability is more or less solved at the network layer, we have pretty good standards for networks.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642512790.055300"></a>
      <img src="https://avatars.slack-edge.com/2021-11-14/2726013476404_46b1d789abee49842525_72.jpg" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642512790.055300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Henning Sato von Rosen</b>
<span style="margin:2em; color:#606060">2022-01-18 05:33</span><br/>
<span style="background-color:#ccf">@Paul Sonnentag</span> “Instead, I want applications that you can take apart into recombinable parts.”<br/><br/><span style="background-color:#ccf">@Nick Smith</span> “Personally, I’m focused on re-inventing the very foundations of programming to make it <em>simpler</em>.”<br/><br/><em>[ disclaimer: the following is a hunch and I definitely do not have links to research backing up any of it, etc ]</em><br/><br/>I strongly believe that much more is possible than is currently considered. I feel that (1) we, as computer scientists, developers, or just users of PL’s / digital artifacts are blinded by our own tradition; that we are flattening our comprehension of our own human cognitive/linguistic capacities by subconsciously projecting them onto the plane of known PL’s and traditional formalisms. And (2) that each of the two quotes above, minus overlap, embodies at least one prospective magnitude of improvement in accessibility/usability/metrics of cognitive complexity growth.<br/><br/>And that’s a huge part of why I appreciate the general openness of FoC! We need to enter a state of playfulness on all levels; inviting our minds to free play outside of our schooling and current experiences. We also need to consciously seek out other points of reference than the current focal points in CS/PLT and find more reference points that can span a broader PL design space. We need to find ways to let go of our discomfort with human cognition/perception/language capacity, accepting… no,  embracing, first-principles thinking; immersing ourselves in a decent level first-principles playfulness.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642545905.092400"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642545905.092400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2022-01-18 14:45</span><br/>
That is exactly what I am doing :unicorn_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642579021.093400"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1642361397.040700.html#1642579021.093400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-01-18 23:57</span><br/>
&gt; But this is not the fault of the javascript ecosystem<br/>Lack of communication is never the fault of any (potential) participant. It's the shared attitude of everyone. JavaScript is just like Python, R, Java, etc.: there is a wall around the ecosystem, and most of the computing world is outside of it. Which means that you have to choose the most suitable walled ecosystem for your projects, and live without the good stuff from the others.<br/><br/>Note that "success" (meaning adoption) is not really a good criterion. Software is everywhere, each application has different needs. Being good in a large niche is no better than being good in a small one.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
