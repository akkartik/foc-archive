<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2025-01-24/8368890056976_f15ff7293c7610751dc7_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jon Secchis</b>
<span style="margin:2em; color:#606060">2025-01-24 07:48</span><br/>
Worth rewatching and reflecting on what we had vs what we have now. Can be pretty chilling depending on how you frame the comparison<br/><br/><a href="https://www.youtube.com/watch?v=pzf3VlKNLiI">https://www.youtube.com/watch?v=pzf3VlKNLiI</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1737946867.623109"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1737946867.623109" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-01-26 19:01</span><br/>
the most import part is at 13:40 ... <a href="https://programmingsimplicity.substack.com/p/functions-and-pipes?r=1egdky">https://programmingsimplicity.substack.com/p/functions-and-pipes?r=1egdky</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738020643.583569"></a>
      <img src="https://avatars.slack-edge.com/2025-01-24/8368890056976_f15ff7293c7610751dc7_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738020643.583569" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jon Secchis</b>
<span style="margin:2em; color:#606060">2025-01-27 15:30</span><br/>
Yeah! I personally think that, idiosyncrasies apart, programming directly in the shell is really elegant. I still prefer doing simple automation stuff on the shell because it has unconstrained access to the system. It's aways a bit awkward to do plumbing tasks in a programming language, too much bureaucracy. From time to time I dream about a sort of stream/iterator based concatenative programming language with a rich standard library. Hard to beat the simplicity of programs as data pipelines
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738033216.213819"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738033216.213819" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-01-27 19:00</span><br/>
Imagine: <tt>A</tt> produces a text string that looks like some sort of "language" (machine readable, not necessarily human-readable, kind of like assembler vs. "C"). <tt>A</tt> sends the string - as data - through the pipe to <tt>B</tt>. <tt>B</tt> "parses" the string and calls functions based on what it finds in the parse. This might be called "syntax directed serialization". FP is hinting at this kind of thing, calling it "pattern matching". The key, again, is that A does not <em>CALL</em> B, it simply <em>sends</em> data to B. In UNIX, B already does something like this, but at a feeble level. Add PEG parsing to B's inhalation process to improve on its feeble parsing abilities. It's been done before to build non-trivial programs like compilers.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738080875.010749"></a>
      <img src="https://avatars.slack-edge.com/2025-01-24/8368890056976_f15ff7293c7610751dc7_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738080875.010749" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jon Secchis</b>
<span style="margin:2em; color:#606060">2025-01-28 08:14</span><br/>
If you squint a little you see that's very similar to how compiled code is actually executed at the low-level, where procedures put their return values on a stack, to then be picked up by the next procedure in the queue. There's no direct coupling except for the ordering of procedures. I think lifting this paradigm so we could program like this at a higher level would be tremendously fun! We sort of have it with languages like <a href="https://github.com/factor/factor">Factor</a>, but I personally find this breed of languages awkward to work with. Once you have the high level words defined they're ok, but to get there you have to code lots of <a href="https://github.com/factor/factor/blob/master/extra/html/parser/parser.factor">small procedures</a>, which IMO imposes some heavy cognitive load
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738086207.135309"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738086207.135309" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-01-28 09:43</span><br/>
&gt; code lots of <a href="https://github.com/factor/factor/blob/master/extra/html/parser/parser.factor">small procedures</a>, which IMO imposes some heavy cognitive load<br/>The cognitive loading does not come from the small-ness of the procedures, but, is due to the flat-ness of the namespace, i.e. the "infinite canvas" mentality. The UNIX shell gets around this problem by allowing layering. A shell script can invoke commands or other shell scripts to an infinite depth (as opposed to infinite breadth). The shell and functional programming, fail to restrict this concept. There should be one kind of part to choreograph parts and another kind of part to do the work. Functions allow you to do this, but, functions don't restrict you from doing something broader, too. It's kinda like the GOTO problem in the early days, you <em>could</em> write structured programs using GOTOs but the existence of GOTOs tempted one to break structuring. Here, it's the same, you <em>can</em> write layered programs, but, you tend not to. Just try to understand someone else's code, 90% of the time it's hard, only a few programmers actually shine through as being capable of "writing good code".<br/><br/>Another thing to note: UNIX worker commands cannot directly invoke other commands [*]. The UNIX kernel provides a privileged routine called the Dispatcher which decides which command gets to run and when. Again, it is easy to do this with closures choreographed by connecting layers, but, one tends not to structure code this way due to lack of enforced structuring constraints. A piece of worker code that CALLs another piece of code breaks the UNIX-y data-flow (message-sending) paradigm.<br/><br/>One must be careful of stack-based ideas. LIFO-based code works on single computer systems, but breaks down in distributed systems, due to under-the-hood coupling caused by the global-ness of the stack. Code that works on single computers, doesn't necessarily scale up when distributed across many computers. [Elsewhere, I argue that context-switching is a crutch that doesn't scale well. We'd be better off using closures and message-sending using FIFO queues. Using functions works on paper for mathematics, but, isn't such a good paradigm for distributed computing].<br/><br/>[*] Modulo tricky uses of system calls, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738099854.642659"></a>
      <img src="https://avatars.slack-edge.com/2025-01-24/8368890056976_f15ff7293c7610751dc7_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738099854.642659" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jon Secchis</b>
<span style="margin:2em; color:#606060">2025-01-28 13:30</span><br/>
Very interesting remark regarding stack vs queue for coordination. On this context, doesn't using queues for inter-procedure messaging implies the need for "actors"? I mean, if there're per-procedure queue you'll always end up in Erlang land, no? Now you need addresses and lightweight processes, since all procedures need to be "live". I'm not saying it's bad, but definitely an explosion in complexity. I wonder if using something like a global tuple-space as a communication backbone isn't a simpler mechanism of equal capability, which further decouples components. Since retrieving a tuple from the space requires a query, the addressing scheme is lifted to the domain of application conventions, giving much more flexibility in exchange for more discipline. I'd be fine with that trade-off. The advantage of tuple-spaces is that the whole system can be made heterogeneous, you're not forced to use a single language and environment.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738293692.926829"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738293692.926829" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-01-30 19:21</span><br/>
<span style="background-color:#ccf">@Jon Secchis</span> I have the same concerns about tuple spaces as I do with stacks. I would be interested in your further thoughts about "complexity explosion". Some more of my thoughts ... <a href="https://programmingsimplicity.substack.com/p/extreme-decoupling?r=1egdky">Extreme Decoupling</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738293727.593619"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738293727.593619" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-01-30 19:22</span><br/>
<span style="background-color:#ccf">@Jon Secchis</span> I've expanded on my earlier comments about <a href="https://open.substack.com/pub/programmingsimplicity/p/divide-and-conquer-vs-cognitive-loading?r=1egdky">cognitive load</a>. I wonder if this makes things more clear to the likes of <span style="background-color:#ccf">@Kartik Agaram</span> who wanted to better understand what I meant by using the word "synchronous"?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738382740.328549"></a>
      <img src="https://avatars.slack-edge.com/2025-01-24/8368890056976_f15ff7293c7610751dc7_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738382740.328549" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jon Secchis</b>
<span style="margin:2em; color:#606060">2025-01-31 20:05</span><br/>
I have read both essays, and I think I somewhat understand the general critique and idea. I can't help but think that what you're proposing can already be done with intentional design and architecture, as a matter of "style", let's say. But I do recognize that having such "style" cemented in the environment, say a in PL, makes it much more manageable and enforceable. Now the clash between "things good for serial programs" vs "things good for parallel/distributed programs", I'm not sure that there's a broad enough domain intersection enabling a single paradigm to shine at both fronts. Tight coupling is inevitably better suited for single-cpu programs, and the opposite for loose coupling and distributed programs on multi-cpu.<br/><br/>&gt;  "complexity explosion"<br/>Surely you know that definitely assessing complexity is sort of impossible to do impartially, as it's always context-dependent. In the context of per-process queues, and particularly in the Erlang environment, I was using "complexity" as a proxy for the size of the domain ontology needed to establish the architecture. By embracing Erlang's model, you are bound to accept everything that comes within it, you gotta eat it all. Now, for something like tuple spaces, the vocabulary is significantly simpler. It becomes a tool you can integrate however you like, or rather it's more like a material, a foundational component, not the entire blueprint and framework. The complexity and solidity of what you build with it will depend on your ability to adapt it to your necessity, how well you employ it as an architect. The baseline complexity is low. That's my perspective, and I tend to like this trade-off better. I think it's also the preference of most people, that's why we don't have FP and full-blown actor systems as mainstream technologies. These things are binding, unforgiving, all-encompassing, long-term commitments. Turns out soundness is not that big of a deal; reality and the markets are more amenable to heterogeneity, even if it translates to a mess most of the time. The mess allows for moving faster and achieving good-enough quality at a fair price. Worse is better, as they say.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738385697.921419"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738385697.921419" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-01-31 20:54</span><br/>
<span style="background-color:#ccf">@Jon Secchis</span> Thanks. Why is this model equivalent to the Erlang model? Assume that I don't know what the Erlang model is.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738432255.847549"></a>
      <img src="https://avatars.slack-edge.com/2025-01-24/8368890056976_f15ff7293c7610751dc7_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738432255.847549" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jon Secchis</b>
<span style="margin:2em; color:#606060">2025-02-01 09:50</span><br/>
I am using Erlang as a benchmark since it's the canonical model of decoupling functional components via message passing with per-process message queues, where programs are modeled as choreographed distributed systems
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738432568.772069"></a>
      <img src="https://avatars.slack-edge.com/2025-01-24/8368890056976_f15ff7293c7610751dc7_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738432568.772069" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jon Secchis</b>
<span style="margin:2em; color:#606060">2025-02-01 09:56</span><br/>
I'm assuming it's the closest thing we have to the unix model of composition but for the applications domain
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738443675.882939"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738443675.882939" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-02-01 13:01</span><br/>
When I look at Erlang all I see are it's faults and its relationship to functional programming. Maybe I should look again? Let me know if you have a suggestion of a good overview / starting place.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738443785.533899"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1737733719.957079.html#1738443785.533899" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-02-01 13:03</span><br/>
Message passing can result in a big mess (aka "state explosion") when it's laid out flat. What we need is "GOTO Considered Harmful" for message passing. [It may be a surprise, but, I have a suggestion. Function-based, synchronous, 1-in, 1-out perspective is insufficient for practical/useful message-passing style].
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
