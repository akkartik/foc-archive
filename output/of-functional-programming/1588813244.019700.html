<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #of-functional-programming</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-functional-programming/1588813244.019700.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-06 18:00</span><br/>
When did functional programming begin?<br/>• 1952, "The Use of Sub-Routines in Programmes", D.J.Wheeler, <a href="https://dl.acm.org/doi/pdf/10.1145/609784.609816">https://dl.acm.org/doi/pdf/10.1145/609784.609816</a> Mentions higher order functions like "integrate", which is (somehow) parameterized by the function to be integrated.<br/>• 1956, Fortran, John Backus. FORTRAN=FORmula TRANslation. Fortran supports nested arithmetic expressions. "Programming on the right side of the assignment statement" is an early glimpse of expression-oriented functional programming, as mentioned later in [Landin 1966].<br/>• 1960, LISP, John McCarthy, "<em>Recursive functions of symbolic expressions and their computation by machine, part I</em>". Lisp is the first programming language with conditional expressions, recursive functions, higher order functions (including "map" under the name "maplist"), plus garbage collection. This is the true birth of functional programming, even though LISP has a strong imperative core, and some key elements are missing: LISP is not lexically scoped; there are no closures, and no convenient syntax for curried function calls. <a href="http://www-formal.stanford.edu/jmc/recursive.pdf">http://www-formal.stanford.edu/jmc/recursive.pdf</a><br/>• 1962, APL, Kenneth Iverson, the book "A Programming Language" is published. Has an exceptionally powerful expression language, including the now standard "map" and "reduce" higher order functions (under different names). There is no APL interpreter yet. <a href="http://www.softwarepreservation.org/projects/apl/Books/APROGRAMMING%20LANGUAGE">http://www.softwarepreservation.org/projects/apl/Books/APROGRAMMING%20LANGUAGE</a><br/>• 1964, P.J.Landin, "The Mechanical Evaluation of Expressions" describes a referentially transparent, lexically scoped, pure functional language with lexically scoped closures and curried functions. The syntax is a recognizable precursor to ML and Haskell. A virtual machine called the SECD machine is described for implementing functional languages (including lexical scoping and closures, which are missing from LISP). Earliest use of "referential transparency" to describe a programming language? <a href="https://www.cs.cmu.edu/~crary/819-f09/Landin64.pdf">https://www.cs.cmu.edu/~crary/819-f09/Landin64.pdf</a><br/>• 1966, P.J.Landin, "The Next 700 Programming Languages". This is the earliest published use of the term "functional programming" I can find, although it is by now reportedly in common use. This is the original <em>manifesto</em> for functional (ie, non-imperative) programming. It describes the research language ISWIM, spawning the ML/Haskell lineage of functional languages. <a href="http://www-formal.stanford.edu/jmc/recursive.pdf">http://www-formal.stanford.edu/jmc/recursive.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1588822484.019900"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../of-functional-programming/1588813244.019700.html#1588822484.019900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-05-06 20:34</span><br/>
Something I'm curious about, along these lines — what were the first computer languages that were in acknowledged as being related to / derived from lambda calculus?<br/><br/>Anything prior to this? 1965, P.J. Landin, "Correspondence between ALGOL 60 and Church's Lambda-notation" <a href="https://dl.acm.org/doi/10.1145/363744.363749">https://dl.acm.org/doi/10.1145/363744.363749</a><br/><br/>My curiosity stems from.. wondering at what point people in the nascent PL world realized that there correspondences with the work being done to pin down math's foundations.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1588840584.020400"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../of-functional-programming/1588813244.019700.html#1588840584.020400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2020-05-07 01:36</span><br/>
For me FP hits its stride somewhere between non-strict evaluation and type classes.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1588856960.020700"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-functional-programming/1588813244.019700.html#1588856960.020700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-07 06:09</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> After Fortran exploded onto the scene in 1956, the record suggests that in the late 1950's, computer scientists on both sides of the Atlantic were working on programming languages inspired by lambda calculus.<br/><br/>The lambda calculus is a mathematical formalism: it is a model of the "recursive functions" aka the "computable functions". It is not a programming language. For one thing, there is no defined order of evaluation. Two popular choices are applicative order (most programming languages) and normal order (Algol 60 and Haskell). Normal order evaluation is more powerful, because it terminates and produces a result in cases where applicative order evaluation fails to terminate.<br/><br/>On the American side, McCarthy was a theoretician, and LISP was originally intended to be a mathematical model of the recursive functions, heavily inspired by lambda calculus, that was also executable on a computer. The ability to represent lambda expressions as data structures ("S-expressions" or symbolic expressions) was a key idea of Lisp. It led to Lisp FEXPRs and macros. But the identification of functions with LAMBDA expressions prevented early LISP from representing function values as closures or supporting lexical scoping. LISP has always used applicative order evaluation (except for FEXPRs and MACROs).<br/><br/>Across the Atlantic, Algol 60 was the successor to Algol 58 (aka IAL). In Algol 60, function parameters by default use "call by name" as the parameter passing mechanism (normal order evaluation). If you explicitly use the "value" keyword then you get "call by value", aka applicative order evaluation. It's just like using the ! operator in Haskell to force a function parameter to be strict. Allegedly, this strange choice of "call by name" as the default parameter passing mechanism was directly inspired by lambda calculus, where normal order evaluation is more powerful. I'd like to know who put normal order evaluation into the Algol 60 standard.<br/><br/>However, Algol 60 is an imperative language, and the interaction between call-by-name and side effects made programs difficult to understand. The performance was also terrible, so call-by name gained a bad reputation and was dropped. It didn't reappear (AFAIK) until Haskell.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
