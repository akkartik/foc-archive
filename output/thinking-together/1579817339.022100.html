<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1579817339.022100.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2020-01-23 14:08</span><br/>
I think it’s the ancestor of the technology in the Oracle/OpenJDK JVM (the Self VM lead to a VM for Strongtalk, which lead to HotSpot).<br/><br/>I can’t talk about how it worked in Self, but today, the rough idea is that you have an interpreter and a compiler[0]. When you compile the code, you maintain a set of safepoints where the stack of the compiled code can be reliably mapped back into the state of the interpreter. Those safepoints tend to be at loop boundaries, or at points where the assumptions made by the JIT compiler might be invalidated.<br/><br/>In between safepoints, the compiled code can’t be interrupted by the VM, and can’t be debugged through. But, when you set a breakpoint, it will revert to the interpreter when it reaches that point.<br/><br/>(Btw: there are probably better people to describe this. I hope I haven’t made a mistake above).<br/><br/> [0] in fact, you have two compilers: one fast and less thorough, one slower and more thorough.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
