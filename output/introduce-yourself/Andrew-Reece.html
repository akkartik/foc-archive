<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, introductions by Andrew Reece</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2021-04-20/1975289475446_adf09dea9be29fa422a0_72.png" style="float:left"/>
      <a href="../introduce-yourself/1545141138.109900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Andrew Reece</b>
<span style="margin:2em; color:#606060">2018-12-18 05:52</span><br/>
Hi all,<br/>- I came across the future of coding podcast a few weeks ago, and got through just about all of the back catalogue by listening whenever I was driving<br/><br/>- I'm from the UK, currently near Bristol.<br/><br/>- My undergrad was in Ergonomics/Human Factors Design<br/>	- My dissertation was on improving the graphical communication of a commonly used (in the field) cognitive tool/methodology (hierarchical task analysis)<br/><br/>- I've done a lot more programming in C than Javascript/functional languages, so I may be coming from a slightly different place than many here, but hey, it takes all sorts right?! :wink:<br/>	- I'm also a 'fan' of the Handmade Hero/Handmade Network approach to programming. I'm hoping that these aren't incompatible!<br/>	- I do want the programmer/software design experience to be better, but I want to make sure this is not at the expense of the end user of the software.<br/>		- The key components of the argument are roughly<br/>			- We can't expect improved hardware to account for reduced software performance:<br/>				1) Individual processors seem to have reached a heat barrier in terms of clock speed<br/>				2) Most problems are not trivially parallelizable across multiple processors.<br/>			- Generalized abstractions tend to have a significant performance cost attached<br/>		- As such, there is (at least for the moment) a class of problems where the cost of writing in beautiful abstractions is too high in terms of end program performance.<br/>		- For this area, I think that the biggest wins are likely to be in improving the UI/UX/representation and reducing the feedback loop<br/>	- I've previously made rudimentary C tools aimed at reducing the feedback loop - live recompiling, live variable editing.<br/><br/>- I'm currently working on something similar to Glen Chiacchieri's REPLugger using LLVM/Clang. This is starting with C(++), but should hopefully not be too difficult to add frontends for other compiled languages due to the way LLVM works.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
