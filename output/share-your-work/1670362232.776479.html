<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1670362232.776479.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-06 13:30</span><br/>
An essay about the history of compiler-appeasement languages, meant for discussion.<br/><br/>[meta: I would be glad to move this to another channel or to remove it completely.  One aspect of my “work” is to observe.  FWIW, I share this...]<br/><br/>Type checkers are helpers for development.  Similar to parsing and syntax checkers.  Type checkers are - currently - more difficult to write than syntax checkers.  There was a time when syntax checking was not well understood and was difficult and was written in an ad-hoc manner.  Early FORTRAN had syntax that we would consider weird today.  Early FORTRAN did not treat spaces specially and went for the shortest match (I think).  For example <tt>IF</tt> and <tt>IFX</tt> were both parsed as the beginning of an <tt>IF</tt> statement.  Later, it was discovered that making spaces “special” would help in making parsers and would help in cleaning up silliness like <tt>IF</tt> and <tt>IFX</tt>.  At the time, the character set consisted of ASCII (well, there was EBCDIC, championed by IBM, but, IBM was hated even more than Microsoft and Apple are hated today, so EBCDIC was mostly avoided by non-IBMers).  The fact that ASCII only has 128 characters to choose from (some 32 “unprintables” must be subtracted from this count) made for silly decisions like denoting strings with the same beginning and ending quote (which makes parsing more difficult) and not-allowing spaces to be embedded in names.  With Unicode, we have many more choices, but, we remain stuck with decisions made to appease 1950s hardware.  Aside: in 2022, we have hardware that can handle vector graphics and overlapping graphical elements, e.g. windows and very-small windows (“buttons”, “widgets”), but, we are stuck with decisions made to appease 1950s hardware.  I argue that we should be building languages based on vector graphics instead of non-overlapping characters.  SVG is a simple example of something that might work on this front (rectangles, ellipses, lines, text, groups). Aside: “declaration before use” is a result of 1950s thinking (save CPU time by making compilers 1-pass), even though, in 2022, we could easily burn CPU cycles to figure out “declaration after use”. Aside: declaration-checking (before or after use) is only a helper for developers. The machine doesn’t care if you make a typo.  “Declaration-checking” is an app to help developers stamp out simple errors (like typos).  Demanding that programmers rearrange their code so that the declarations ALL come before the code is compiler-appeasement (based on 1950s hardware).<br/><br/>The best way to write a type checker is to use a Relational Language (like PROLOG, miniKanren, Datalog, etc., etc.).  Relational languages are shining examples of languages that don’t appease compilers.  In a relational language, you write relations (“truth”) and let the underlying system figure out how to implement the machinery for matching up the relations.  Other technologies that bark up this same tree: declarative languages and ML. (Aside: oh my, HTML is a declarative language.  But, HTML needs to lean on JavaScript to allow imperative break-outs).<br/><br/>There is no “ideal language”.  The notation you use depends on the problem you are trying to solve.  A simple example would be the idea of Spreadsheets vs. Lambda Calculus.  Accountants and financial analysts like Spreadsheets.  Programming rigor analysts like Lambda Calculus.  Accountants would not want to use Lambda Calculus and rigor-ists would not want to use Spreadsheets.  Another example, closer to my heart, is the difference between using Language Theory to generate parsers and using PEG to generate parsers. Language Theory-based parsers cannot do what PEG-based parsers can do (for example, parse balanced parentheses).  Trying to force-fit language theory onto parsing has stagnated the field.  Most languages look the same, with minor differences. (Aside: PEG is Parser Theory, not Language Theory, despite the superficial similarities in syntax).  The fact that parsing is “difficult” has restricted programmers to using only a small number of programming languages, instead of using a zillion nano-languages and defining their own nano-languages (I call these SCNs (Solution Centric Notations)).<br/><br/>“Dynamic” languages are “good” for fast turnaround on ideas, but are “bad” for producing end-user apps which are cost-optimized.  “Static languages” are “good” for Production Engineering apps, but, are “bad” for inventing new products.  Trying to force-fit all use-cases into one language results in a watered-down notation which isn’t particularly good for either use-case.  (Aside: at the moment, efforts to force-fit all use-cases into one language favour the Production Engineering side over the Design side of things, and, this is what I call “compiler appeasement”.  When programmers have to stop and rearrange their inventions to help the compiler figure out how to optimize, they are appeasing the compiler). (Aside: if Physicists <b>ALL</b> engaged in worshipping functional notation, we wouldn’t have Feynman Diagrams, nor Polyani’s “Order Out of Chaos”, etc.).<br/><br/><em>Barnacles</em> might be invented for helping developers, e.g. type checkers and linters. Twisting a language design to appease <b>only</b> pre-compilation is <b>not OK</b> in my book. At the moment, most of our programming languages are compiler-appeasement languages and insist that developers waste time (and imagination) on dealing with compiler-appeasement and pre-compilation issues, long before the program works.<br/><br/>Barnacle-like pre-compilation was researched in the mid-1900s with work like Fraser/Davidson peephole technologies. This was called RTL and formed the basis of <em>gcc</em>. Cordy’s Orthogonal Code Generator is a generalization of this technique replete with declarative syntax for portability choice-trees (MISTs) and Data Descriptors and Condition Descriptors that improve on the virtual registers used by RTL.<br/><br/>[This essay can be found in <a href="https://github.com/guitarvydas/py0d/issues/2">https://github.com/guitarvydas/py0d/issues/2</a>]
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670397432.998059"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1670362232.776479.html#1670397432.998059" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-12-06 23:17</span><br/>
I tend to agree with most of this, except that I am not sure I understand your ideas about SVG. In mainstream programming, the ground-truth representation of code is text (a linear stream of characters), and the UI is a slightly rendered version of that text (syntax coloring etc.). I see how SVG could yield better UIs, but it sounds as if you want SVG to become the ground-truth representation of code. If that's the case, I don't see why.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670397749.199189"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1670362232.776479.html#1670397749.199189" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-12-06 23:22</span><br/>
On a different topic, your essay contains the eternal "we are so stuck in the past, we need to move on" thread that comes up frequently here (and elsewhere). What I have yet to see is a realistic proposition for "moving on". If it's "start from scratch", it just won't happen. We are not stuck with 1950s hardware, we have built up an enormous IT edifice <em>starting</em> with 1950s hardware. We are still adding to it, and it has become infrastructure for other human endeavours. It won't go away (except maybe in a major civilization crash).<br/><br/>A realistic scenario for moving on must either start from the present edifice and evolve it into something better, remaining functional along the way, or build a second, disconnected edifice to which the world can slowly migrate as it matures.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670399906.320549"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1670362232.776479.html#1670399906.320549" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-12-06 23:58</span><br/>
Your point regarding declarations reminds me of my <a href="https://archive.org/details/akkartik-2min-2020-06-07">https://archive.org/details/akkartik-2min-2020-06-07</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670553263.601349"></a>
      <img src="https://avatars.slack-edge.com/2022-11-07/4336773837699_2a2aca0fcc14c8e11371_72.png" style="float:left"/>
      <a href="../share-your-work/1670362232.776479.html#1670553263.601349" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nicholas Yang</b>
<span style="margin:2em; color:#606060">2022-12-08 18:34</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> I really agree with this sentiment on the “we are so stuck in the past” thread. It’s a little cliche almost to complain about how software development is such a mess. And not necessarily the most productive mindset.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670594473.668969"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1670362232.776479.html#1670594473.668969" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-09 06:01</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span>  Yes.<br/><br/>The machine does the work instead of asking programmers to rearrange their code.<br/><br/>Your reminder reminds me of Holt’s Data Descriptors, which reminds me of Cordy’s Orthogonal Code Generator which reminds me of RTL (which is used in gcc).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670847926.804909"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1670362232.776479.html#1670847926.804909" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-12 04:25</span><br/>
<a href="https://raw.githubusercontent.com/guitarvydas/drawware/dev/sourcecodehelloworld.png">https://raw.githubusercontent.com/guitarvydas/drawware/dev/s&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670847958.542229"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1670362232.776479.html#1670847958.542229" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-12 04:25</span><br/>
Thank you all, for your comments!  I find the insightful criticism to be quite helpful.<br/><br/>Hoping to clarify some points:<br/><br/>• IMO The Ground Truth is Programming, not Code.<br/>• IMO, change, even big change, is possible, especially in a young discipline like this.  We are witnessing big change right now - the conversion of gasoline-powered automobiles to electric-powered automobiles.  The enormous infrastructure for supplying gasoline is being replaced.  The figurehead for this huge change believes in “First Principles Thinking” [<a href="https://fs.blog/first-principles/">https://fs.blog/first-principles/</a>].   Counter-arguments against big change might include: <br/>• The fact that electric cars still have 4 wheels and still have offset steering wheels (instead of centered steering sticks as in the first automobile) <br/>• The fact that the change-over from gas to electric is being facilitated by the existence of hybrid cars.  <br/>• Computer keyboards are still QWERTY.  <br/>	IMO, change is driven by perceived orders-of-magnitude improvement (in process? ... in what?).  It remains incumbent on me to explain why I think that it is possible to improve on programming, noting that hardware has improved, and, noting that end-user apps have improved, while maintaining the assertion that programming languages have not improved proportionally.<br/>• PEG blurs the line between characters in a Scanner vs. tokens in a Parser.  IMO this is important and may lead to change.<br/>• IMO, snipping ALL dependencies is important and may lead to change.  Hence, this long response to an issue in an experimental code repo. To my eyes even simple<tt>f(x)</tt> causes several kinds of dependencies that are ripe for snipping.<br/>• SVG.  This is the simplest (albeit useless) example of SVG as a “programming language” that I could imagine.  There’s more, and this is but a hint.  This useless example transpiles a diagram to running Python code. The live code is at <a href="https://github.com/guitarvydas/drawware">drawware</a>.<br/><a href="https://github.com/guitarvydas/drawware/blob/dev/sourcecodehelloworld.png?raw=true">https://github.com/guitarvydas/drawware/blob/dev/sourcecodeh&hellip;</a><br/>	<br/><pre style="white-space:pre-wrap">&lt;html&gt;<br/>  &lt;body&gt;<br/>    <br/>    &lt;h1&gt;My first SVG&lt;/h1&gt;<br/>    <br/>    &lt;svg&gt;<br/>      &lt;g id='myfunc'&gt;<br/>        &lt;rect x="20" y="0" width="280" height="130" rx="19.5" ry="19.5" fill="none" stroke="black"/&gt;<br/>        &lt;text x="120" y="19"&gt;myfunc&lt;/text&gt;<br/><br/>        &lt;g&gt;<br/>          &lt;rect x="60" y="40" width="200" height="60" fill="#f8cecc" stroke="#b85450"/&gt;<br/>          &lt;text x="70" y="64"&gt;print ('Hello ', end='')&lt;/text&gt;<br/>          &lt;text x="70" y="84"&gt;print ('World')&lt;/text&gt;<br/>        &lt;/g&gt;<br/>        <br/>      &lt;/g&gt;<br/>    &lt;/svg&gt;<br/>    <br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre><br/>the Ohm-JS grammar that I used is:<br/><pre style="white-space:pre-wrap">CodeDrawing {<br/>  Main = "&lt;html&gt;" "&lt;body&gt;" H1 Drawing "&lt;/body&gt;" "&lt;/html&gt;"<br/>  H1 = "&lt;h1&gt;" stuff "&lt;/h1&gt;"<br/><br/>  Drawing = "&lt;svg" stuff "&gt;" CodeContainer "&lt;/svg&gt;"<br/>  <br/>  CodeContainer = "&lt;g" FunctionName "&gt;" Boundary Title CodeBlock "&lt;/g&gt;"<br/>  <br/>  Boundary = "&lt;rect" stuff "/&gt;"<br/>  Title = "&lt;text" stuff "&gt;" name "&lt;/text&gt;"<br/>  CodeBlock = "&lt;g&gt;" RedRect Text+ "&lt;/g&gt;"<br/>  RedRect = "&lt;rect" (~AttrRed any)* AttrRed stuff "/&gt;"<br/><br/>  FunctionName = "id=" sq name sq<br/>  Text = "&lt;text" stuff "&gt;" stuff "&lt;/text&gt;"<br/>  AttrRed = "fill=" dq "#f8cecc" dq<br/><br/>  stuff = notElementChar+<br/>  notElementChar = ~"&lt;" ~"&gt;" ~"/&gt;" any<br/>  name = letter alnum*<br/>  sq = "'"<br/>  dq = "\""<br/>}</pre><br/>And my personal notation (“Fab”) that completes the transpiler is:<br/><pre style="white-space:pre-wrap">CodeDrawing {<br/>  Main [khtml kbody H1 Drawing kbodyend khtmlend] = ‛«Drawing»'<br/>  H1 [kh1 stuff kh1end] = ‛«kh1»«stuff»«kh1end»'<br/><br/>  Drawing [ksvg CodeContainer ksvgend] = ‛«CodeContainer»'<br/>  <br/>  CodeContainer [kgroup FunctionName k Boundary Title CodeBlock kgroupend] = ‛def «FunctionName» ():«CodeBlock»<br/>«FunctionName» ()'<br/>  <br/>  Boundary [krect stuff kend] = ‛«krect»«stuff»«kend»'<br/>  Title [ktext stuff k name ktextend] = ‛«ktext»«stuff»«k»«name»«ktextend»'<br/>  CodeBlock [kgroup RedRect Texts+ kgroupend] = ‛\n(-«Texts»-)'<br/>  RedRect [krect cs* AttrRed stuff kend] = ‛«krect»«cs»«AttrRed»«stuff»«kend»'<br/><br/>  FunctionName [kid sq1 name sq2] = ‛«name»'<br/>  Text [ktext stuff kend stuff2 ktextend] = ‛\n«stuff2»'<br/>  AttrRed [kfill dq kred dq2] = ‛«kfill»«dq»«kred»«dq2»'<br/><br/>  stuff [cs+] = ‛«cs»'<br/>  notElementChar [c] = ‛«c»'<br/>  name [c1 cs*] = ‛«c1»«cs»'<br/>  sq  [c] = ‛«c»'<br/>  dq  [c] = ‛«c»'<br/>}</pre><br/>The generated Python code (from the diagram) is:<br/><pre style="white-space:pre-wrap">def myfunc ():<br/><br/>  print ('Hello ', end='')<br/>  print ('World')<br/>myfunc ()</pre><br/><br/>FYI - Fab transpiles to JavaScript code that can be used in conjunction with Ohm-JS.  I got tired of writing JavaScript, so I built an SCN (nano-DSL) for myself.<br/><br/>I’ve chosen not to include the generated JavaScript code in this thread, but have pushed a working transpiler to the github listed above.<br/><br/>[pardon the cave-man HTML, but I don’t know enough about building web pages, and, clearly, need help]<br/><br/>31:50~ “In a ‘real’ Computer Science, the best languages of an era should serve as ’assembly code” for the next generation of expression.<br/><a href="https://www.youtube.com/watch?v=fhOHn9TClXY&amp;t=859s">https://www.youtube.com/watch?v=fhOHn9TClXY&amp;t=859s</a><br/>Alan Kay
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670867882.919139"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1670362232.776479.html#1670867882.919139" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-12-12 09:58</span><br/>
Thanks <span style="background-color:#ccf">@Paul Tarvydas</span> ! My understanding of your examples is that you use SVG primitives as the tokens of your language. Interesting idea!<br/><br/>As for your comments on change, I'd use the gas-&gt;electric transition for cars as a perfect example for small-step evolution. You change the engine and energy source, but little else. In particular, all the infrastructure for using cars, i.e. roads, parking lots, garages, etc. remains the same, and allows a co-existence of old and new cars. A tech analogue would be the "rewrite it in rust" campaign.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
