[
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1547243783.313200",
        "client_msg_id": "cafdf187-353d-4304-9039-ca084f8b3f62",
        "text": "Great essay by <@UFB8STN7K>: <http:\/\/willcrichton.net\/notes\/gradual-programming\/>. Reminded me of the somewhat related: <@UDCLA1HU4>'s <http:\/\/tomasp.net\/blog\/2018\/programming-interaction\/>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1547243783.313200",
        "reply_count": 10,
        "reply_users_count": 4,
        "latest_reply": "1547521148.321100",
        "reply_users": [
            "U8A5MS6R1",
            "UFB8STN7K",
            "UE1JQM9HQ",
            "UD43R8ZFV"
        ],
        "replies": [
            {
                "user": "U8A5MS6R1",
                "ts": "1547250882.314100"
            },
            {
                "user": "UFB8STN7K",
                "ts": "1547258474.314400"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1547260586.314600"
            },
            {
                "user": "UFB8STN7K",
                "ts": "1547260881.314800"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1547274786.315000"
            },
            {
                "user": "UFB8STN7K",
                "ts": "1547275098.315200"
            },
            {
                "user": "UE1JQM9HQ",
                "ts": "1547306357.316400"
            },
            {
                "user": "UFB8STN7K",
                "ts": "1547320897.317500"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1547489760.320300"
            },
            {
                "user": "UD43R8ZFV",
                "ts": "1547521148.321100"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "title": "              Gradual Programming | Will Crichton            ",
                "title_link": "http:\/\/willcrichton.net\/notes\/gradual-programming\/",
                "text": "Programming is a fundamentally incremental (or gradual) process, and our programming languages should reflect that. I show several ways in which program models transition over time and discuss how future research can further a human-centric vision for programming languages.",
                "fallback": "              Gradual Programming | Will Crichton            ",
                "from_url": "http:\/\/willcrichton.net\/notes\/gradual-programming\/",
                "service_name": "willcrichton.net",
                "id": 1,
                "original_url": "http:\/\/willcrichton.net\/notes\/gradual-programming\/"
            },
            {
                "title": "Programming as interaction: A new perspective for programming language research",
                "title_link": "http:\/\/tomasp.net\/blog\/2018\/programming-interaction\/",
                "text": "In programming research, we say a lot about programs and languages, but very little about the actual process of programming. One simple trick that will make programming language research significantly more interesting is to think about programs not as expressions, but as a result of a sequence of interactions that create it. This includes usual things such as writing code and refactoring, but if we also include, say, running a part of the program, we become capable of saying many more interesting things and building new powerful programming tools.",
                "fallback": "Programming as interaction: A new perspective for programming language research",
                "thumb_url": "http:\/\/tomasp.net\/blog\/2018\/programming-interaction\/kent-sq.png",
                "from_url": "http:\/\/tomasp.net\/blog\/2018\/programming-interaction\/",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "http:\/\/tomasp.net\/img\/favicon-big.png",
                "service_name": "tomasp.net",
                "id": 2,
                "original_url": "http:\/\/tomasp.net\/blog\/2018\/programming-interaction\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ha118",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great essay by "
                            },
                            {
                                "type": "user",
                                "user_id": "UFB8STN7K"
                            },
                            {
                                "type": "text",
                                "text": ": "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/willcrichton.net\/notes\/gradual-programming\/"
                            },
                            {
                                "type": "text",
                                "text": ". Reminded me of the somewhat related: "
                            },
                            {
                                "type": "user",
                                "user_id": "UDCLA1HU4"
                            },
                            {
                                "type": "text",
                                "text": "'s "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/tomasp.net\/blog\/2018\/programming-interaction\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UFB8STN7K",
                    "UEGFXUK3M",
                    "UA14TGLTC",
                    "UEQ7QL15F",
                    "UD43R8ZFV"
                ],
                "count": 5
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1547250882.314100",
        "client_msg_id": "02b57731-7afd-4028-9c6b-dd8d1d5a9cee",
        "text": "&gt; Gradual programming is the programmer tracking the co-evolution of two things: 1) the syntactic representation of the program, as expressed to the computer via a programming language, and 2) a conceptual representation of the program, inside the mind\n\nFollow up question: could\/should the conceptual representation also be externalized in the computer?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1547243783.313200",
        "parent_user_id": "U8A5MS6R1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DxQg",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Gradual programming is the programmer tracking the co-evolution of two things: 1) the syntactic representation of the program, as expressed to the computer via a programming language, and 2) a conceptual representation of the program, inside the mind"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nFollow up question: could\/should the conceptual representation also be externalized in the computer?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFB8STN7K",
        "type": "message",
        "ts": "1547258474.314400",
        "client_msg_id": "d95cd4d0-f6c8-4386-bf18-9877cdd1bd28",
        "text": "What do you mean here by externalized?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ge240a8e5a8f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "Will",
            "real_name": "Will Crichton",
            "display_name": "Will",
            "team": "T5TCAFTA9",
            "name": "wcrichto",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1547243783.313200",
        "parent_user_id": "U8A5MS6R1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CpO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What do you mean here by externalized?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1547260586.314600",
        "client_msg_id": "65694f50-d56c-4d78-b2b2-20adaefabb47",
        "text": "Represented in the computer.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1547243783.313200",
        "parent_user_id": "U8A5MS6R1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kCL8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Represented in the computer."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFB8STN7K",
        "type": "message",
        "ts": "1547260881.314800",
        "client_msg_id": "20e3f4c7-07fc-4dd0-b460-76a8bfb124c5",
        "text": "You mean as a separate artifact from the code itself? Like a UML diagram or something?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ge240a8e5a8f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "Will",
            "real_name": "Will Crichton",
            "display_name": "Will",
            "team": "T5TCAFTA9",
            "name": "wcrichto",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1547243783.313200",
        "parent_user_id": "U8A5MS6R1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eMo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You mean as a separate artifact from the code itself? Like a UML diagram or something?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1547274786.315000",
        "client_msg_id": "948bf77c-c000-45f8-9d36-aa08f96910f3",
        "text": "No, as part of the code itself. Perhaps the language could support incremental refinement. So initially you write the high level concepts, sequences and relations. Then you append the details. The motivation for the idea is that the high level conceptual representation should be directly accessible to the readers. Otherwise you have to read these low level logic and rebuild the high level model in your mind. Also it seems useful to have a representation where it is clear what level you are modifying - the higher level execution or some lower level details.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1547243783.313200",
        "parent_user_id": "U8A5MS6R1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ak0W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "No, as part of the code itself. Perhaps the language could support incremental refinement. So initially you write the high level concepts, sequences and relations. Then you append the details. The motivation for the idea is that the high level conceptual representation should be directly accessible to the readers. Otherwise you have to read these low level logic and rebuild the high level model in your mind. Also it seems useful to have a representation where it is clear what level you are modifying - the higher level execution or some lower level details."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFB8STN7K",
        "type": "message",
        "ts": "1547275098.315200",
        "client_msg_id": "9a269039-e223-42f5-a12a-3b8aa5022c96",
        "text": "Yeah that makes sense. I think there’s two axes here: declarative&lt;-&gt;imperative and empty&lt;-&gt;complete. A conceptual representation usually starts off with the task you’re trying to accomplish. That’s kind of what all these specification languages are for, is declarative writing down tasks. And then you usually refine that with imperative commands until the task is accomplishable. The other side of this is that some part of your specification is often empty or ill-defined in an exploratory setting if you’re not sure what task you’re solving. So it would be important to represent that as well. At a low-level this is captured by structure editors (cc <@UC25EFSJC>) , but I think there’s an interesting question of handling higher-level underspecifications.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ge240a8e5a8f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "Will",
            "real_name": "Will Crichton",
            "display_name": "Will",
            "team": "T5TCAFTA9",
            "name": "wcrichto",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1547243783.313200",
        "parent_user_id": "U8A5MS6R1",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0l9N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah that makes sense. I think there’s two axes here: declarative<->imperative and empty<->complete. A conceptual representation usually starts off with the task you’re trying to accomplish. That’s kind of what all these specification languages are for, is declarative writing down tasks. And then you usually refine that with imperative commands until the task is accomplishable. The other side of this is that some part of your specification is often empty or ill-defined in an exploratory setting if you’re not sure what task you’re solving. So it would be important to represent that as well. At a low-level this is captured by structure editors (cc "
                            },
                            {
                                "type": "user",
                                "user_id": "UC25EFSJC"
                            },
                            {
                                "type": "text",
                                "text": ") , but I think there’s an interesting question of handling higher-level underspecifications."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]