<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2024-07-05 07:36</span><br/>
pond’ring aloud:<br/><br/>I wonder if the problem with VPLs is the word “language”.<br/><br/>It appears to me that the word “programming” has been generally accepted to mean “sequential language” or writing sequential codes (aka “coding”). I view this view as being too restrictive. Programming is more than just commanding a machine with sequentialistic instructions. Programming a <b>CPU</b>, though, is - by definition - sequentialistic. But,,, programming a <b>machine(s)</b> need not be sequentialistic. Especially in the age of nothing-is-central. In fact, LLMs are an example of non-sequentialism. The machines that run LLMs were programmed, arduously, in sequential notation, but, the inner success of LLMs is not sequential, but something else (massively parallel plinko?).<br/><br/>VPLs and DPLs are, to me, not sequentialistic things. Maybe they should be called “notations” instead of “languages”? VNP and DNP? Visual Notation for Programming, Diagrammatic Notation for Programming? [In which case, “programming languages” as we know them, are TNPs - Textual Notations for Programming].<br/><br/>In fact, programming is not the difficult part. Re-programming is the novel aspect of Design that computers bring to the world. We have been programming machines to do <b>single</b> things for centuries (using metal lathes, etc.). This time through, though, we have built machines capable of doing <b>many</b> things.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720190918.263649"></a>
      <img src="https://secure.gravatar.com/avatar/4e5750bb485db473fc5fcaac227b78e3.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720190918.263649" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shen Li</b>
<span style="margin:2em; color:#606060">2024-07-05 07:48</span><br/>
On one end of the spectrum we have dumb machines, where we use “language” to make it do things, on the other end of the spectrum, we have human beings, we use “X” to make them do things. I think we need to find a word between “language” and “X”
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720193960.291349"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720193960.291349" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2024-07-05 08:39</span><br/>
observation: Electrical Engineers create 2 manifestations of each circuit. (1) is the circuit itself and (2) a schematic on paper for other Engineers to read. You can understand (1), but you have to spend time to reverse-engineer what’s there. #2 is (usually) more useful in communicating to other Engineers what is going on, without needing them to reverse engineer the actual circuit #1. You still have to spend a few years in university to understand #2, but, once you learn how to read #2, you can devise circuits and show other Engineers what you intended to accomplish. Likewise, Structural Engineers build bridges with bolts and I-beams, and built human-understandable drawings using blueprints. Programmers are trying to squeeze both #1 and #2 into the same notation. AFAICT, concern #1 usually wins and programmers have to spend time reverse-engineering code, since #2 doesn’t exist. In programming, programmers <b>should</b> be able to create #1 from #2, but, instead programmers create #1 from #1 and leave #2 mostly unaddressed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720194421.907399"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720194421.907399" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2024-07-05 08:47</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> Programmers squeeze #1 and #2 together, only if you consider the code to be the product. However, what if you consider the (running) program the actual product? Wouldn’t that put programmers back in line with electrical and structural engineers?<br/><br/>A schematic or a blueprint are a state description optimized for legibility, so there is complexity missing, which is present in the instantiation of the schematic or blueprint in the real world. I believe the same could be said about the process description of an algorithm, which leaves out the actual values that are processed when the program runs.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720195643.900529"></a>
      <a href="../thinking-together/1720190169.723829.html#1720195643.900529" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Christopher Shank</b>
<span style="margin:2em; color:#606060">2024-07-05 09:07</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> love your thoughts here! I try to use “notation” (or “executable notation”) as a replacement for “programming language” these days. It’s more inclusive to non-textual programming languages and alternative paradigms of computing. <br/><br/>You might also like “diagrammatic” from <a href="https://github.com/Little-Languages/reading-club/blob/main/topics/visual%20notation%20and%20diagrams/Trace%2C%20Writing%2C%20Diagram-%20Reflections%20on%20Spatiality%2C%20Intuition%2C%20Graphical%20Practices%20and%20Thinking.pdf">https://github.com/Little-Languages/reading-club/blob/main/t&hellip;</a><br/><br/>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720196529.056219"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720196529.056219" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2024-07-05 09:22</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span>  Good point. In reading your reply, I begin to wonder if there’s something between #1 and #2 (#1.5?) in software that isn’t there in other kinds of engineering. I don’t think that programmers are doing a good job of communicating to other programmers what their Design Intent (DI) is…
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720199988.806949"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720199988.806949" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2024-07-05 10:19</span><br/>
The closest to a design intent would be a formal specification.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720200523.635419"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720200523.635419" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2024-07-05 10:28</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> The only difference I see between electrical/structural engineers and programmers in this example is that the former create <em>state</em> descriptions (blueprints), whereas the latter create <em>process</em> descriptions (recipes).<br/>• <em>State</em> descriptions are <em>declarative</em> and describe the <em>spatial structure</em> of the result.<br/>• <em>Process</em> descriptions are <em>imperative</em> and describe the <em>temporal behavior</em> of how to <em>generate</em> a result.<br/>But both are generalizable in the sense that they are both abstract descriptions, leaving out detail.<br/><br/>I suspect what makes them feel qualitatively different is the cross-over from temporal to spatial domain in one that’s missing in the other. When programmers have to inspect the actual result — the running program in a debugger that makes state visible — then they “have arrived” on the same level the electrical/structural engineers operate at. But usually programmers describe the thing that “builds” the thing, whereas engineers build the thing. (Which is why I asked previously <em><a href="https://stefanlesser.substack.com/p/to-build-or-not-to-build">To build or not to build?</a></em>)<br/><br/>“But what about <em>declarative</em> programming languages?”<br/>While they tend to describe results and are less concerned about the process, they are still ultimately generative — they generate a result from specific input (functional programming) or from axioms (logical programming).<br/><br/><em>(I’m just thinking out loud because I just read</em> <a href="https://curtclifton.net/papers/MoseleyMarks06a.pdf">Out of the Tar Pit</a> <em>again and thought I try applying what I learned…)</em>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720267903.315089"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720267903.315089" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2024-07-06 05:11</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> Formal specifications are too flat (not layered) and too detailed and too ivory-tower. Comments are disconnected and become misleading. I hope to prove that we can do better.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720267956.233259"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720267956.233259" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2024-07-06 05:12</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span> I like your use of these words. I agree that blueprints are state descriptions. I agree that programs are process descriptions. I believe that electronics schematics are <b>both</b>, though - blueprints <b>and</b> recipes. Schematics contain a lot of implementation details. I think that the difference between schematics and code is that you can lasso areas on schematics and treat them in a stand-alone manner, whereas you can’t do this with code (programmers are only “fooled” into believing that they can). Items on electronic schematics are loosely-coupled (asynchronous) whereas items in code are tightly-coupled (synchronous). I hope to elaborate…
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720276359.939919"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720276359.939919" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2024-07-06 07:32</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> I fully agree that the state of formal methods today needs some serious improvement. There are some good ideas for getting out of the ivory tower in <a href="https://www.youtube.com/watch?v=ehrYEdt8NKE">this talk</a> by Shriram Krishnamurthi. As for flatness, that's something I write about in my submission to Onwards! Essays this year. And something I am working on under the title "Digital Scientific Notations", which are just formal specifications under another name and with a different intent.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720440733.921109"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720440733.921109" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2024-07-08 05:12</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> I’m watching this talk and loving it, meanwhile thinking … The description (including words like “verification”, “view” and, even, “moldable development”) makes me think that the emphasis is on understanding programs /after/-the-fact (that’s my impression, even if it’s incorrect). Yes, the claims of usability made in papers are not being subjected to fundamental testing for veracity. Yes, the programming community tends to ignore research in other fields. FYI, my interest is in devising notations /before/-the-fact and using specific notations to solve specific problems.  Revelation (a): we don’t need to use text for every notation - our current tech likes to parse text, but, many syntactic elements (e.g. drawings) can be reduced to text (e.g. XML) before parsing by machines ; in fact, text and function-based notation is horrible in many situations, (b) ensuring total decoupling and isolation makes this a lot easier (i.e. what I call “0D”) and makes it possible to fight flatness (by enabling layering) (c) using OhmJS (or, its ancestor PEG (or ESRAP in CL)) and Ohm-editor, makes it a /lot/ easier to imagine whipping up new, specific notations in only a few hours.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720463040.659099"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720463040.659099" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2024-07-08 11:24</span><br/>
My understanding is that this video presents the beginning of a new line of research, so what you find missing may still come. But yes, it's firmly in the "language" (meaning text) paradigm, in spite of the graphical views in an added layer.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1720591252.750889"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1720591252.750889" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2024-07-09 23:00</span><br/>
I feel the word “language” is problematic not just for VPLs but for PLs in general. We should be thinking about programmable systems. For instance Unix is a programming system with a popular workflow being as follows: write a program in a PL (usually plain text), compile it into an executable, run the executable as a process, which then modifies some state typically organized in files. The study of PLs is honed in on one aspect of this specific workflow and looks at everything through that lens.<br/><br/>By expanding the scope to systems, we can start talking about other workflows of interactions, including things like liveness and notation (great word, btw). Here’s a great starting point that breaks apart these dimensions of programming systems: <a href="https://2021-assets.programming-conference.org/conversations-starters/prog21-tech-dims.pdf">https://2021-assets.programming-conference.org/conversations&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1721078680.266679"></a>
      <a href="../thinking-together/1720190169.723829.html#1721078680.266679" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Guyren Howe</b>
<span style="margin:2em; color:#606060">2024-07-15 14:24</span><br/>
That folks synonimise programming with programming languages is hugely distorting.<br/><br/>The most successful non-programmer programming systems are Excel and end-user databases like FileMaker and access.<br/><br/>Excel has declarative formulas but much of the programming is in the structure of the spreadsheets.<br/><br/>A relational database with a strong user-modifiable UI is a great way of solving problems that would otherwise need a programmer. Our whole industry has almost ignored the Relational Model because it has been synonimised with the execrable SQL.<br/><br/>I am working toward a system that resembles FileMaker but that brings in any and all data that I can into the same UI. Imagine FileMaker but there are relations representing your calendar, your filesystem, your email and social media feeds, a vast array of online data sources and services, all in one UI and freely joinable etc.<br/><br/><b>This</b> is the way to enable non-programmers to solve their computing problems.<br/><br/>I would throw in regular programming <em>also</em>, but  a relational query interface over everything just solves <b>so</b> many problems.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1721078763.811459"></a>
      <img src="https://avatars.slack-edge.com/2023-08-29/5820723719363_3ecb3076c7b047d665ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1721078763.811459" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Guyren Howe</b>
<span style="margin:2em; color:#606060">2024-07-15 14:26</span><br/>
Just discovered this: <a href="https://github.com/juji-io/datalevin?tab=readme-ov-file">https://github.com/juji-io/datalevin?tab=readme-ov-file</a> which I’ll likely use as my primary datastore, and the user will use Datalog for queries (if they need to go beyond the typical FileMaker query UI).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1721079507.061979"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1721079507.061979" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2024-07-15 14:38</span><br/>
&gt; I would throw in regular programming also, but  a relational query interface over everything just solves so many problems.<br/>Agreed. Prolog and miniKanren seem useful in this respect. Yet, relational languages do not solve - cleanly - the problems of (a) formatting a string (JavaScript does it better than relational languages :-), (b) parsing text (OhmJS / PEG does it better), (c) etc. I argue that we need to compose programs using many languages, each tuned for specific purposes (paradigms). The idea of “one language to rule them all” is a chimera.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1721081811.975269"></a>
      <img src="https://avatars.slack-edge.com/2023-08-29/5820723719363_3ecb3076c7b047d665ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1721081811.975269" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Guyren Howe</b>
<span style="margin:2em; color:#606060">2024-07-15 15:16</span><br/>
Agreed. My point here is that we <em>know</em> how to make a non-programmer friendly relational query interface. We <em>can</em> move much more of what we now do in Turing Complete languages into a relational system instead.<br/><br/>We should <em>also</em> make programming better. But reducing the surface area of what we are doing in TC programming by moving as much of it out of there as is practical is another part of the Future of Coding.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1721081856.860579"></a>
      <img src="https://avatars.slack-edge.com/2023-08-29/5820723719363_3ecb3076c7b047d665ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1720190169.723829.html#1721081856.860579" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Guyren Howe</b>
<span style="margin:2em; color:#606060">2024-07-15 15:17</span><br/>
I have a blog post about how I plan to do that: <a href="https://frest.substack.com/p/what-is-frest">https://frest.substack.com/p/what-is-frest</a>
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
