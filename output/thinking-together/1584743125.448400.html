<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2020-03-20/1016274741157_0d46a3ab765beca61fd1_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Michael Mamic</b>
<span style="margin:2em; color:#606060">2020-03-20 15:25</span><br/>
I've been researching formal logic and came across Begriffsschrift, a book by Gottlob Frege which details what I would consider the first programming language in history. It was published in 1879 yet many of the ideas outlined in its premise remind me of what this community is trying to accomplish. The actual notation that this book describes is not too relevant but I would encourage you to read the four page premise that Frege wrote. Note that this comes after the translator's note, which is the first thing in the PDF. <a href="https://www.informationphilosopher.com/solutions/philosophers/frege/Frege_Begriffsschrift.pdf">PDF is here</a>.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584749482.458800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html#1584749482.458800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-03-20 17:11</span><br/>
I agree that Begriffsschrift laid some foundations that were important in the development of programming languages. But Frege himself didn't want to create a mere programming language (which is just symbol manipulation system, executed by a machine). He wanted to create a human language for precisely and unambiguously reasoning about the real world. Some quotes:<br/>• "My intention was not to represent an abstract logic in formulas, but to express a content through written signs in a more precise and clear way than it is possible to do through words. In fact, what I wanted to create was not a mere calculus ratiocinator but a lingua characterica in Leibniz's sense". [I interpret "calculus ratiocinator" as meaning formal language or programming language.]<br/>• I called what alone mattered to me the conceptual content. Hence this definition must always be kept in mind if one wishes to gain a proper understanding of what my formula language is. That, too, is what led me to the name "Begriffsschrift". Since I confined myself for the time being to expressing relations that are independent of the particular characteristics of objects, I was also able to use the expression "formula language for pure thought". That it is modeled upon the formula language of arithmetic, as I indicated in the title, has to do with fundamental ideas rather than with details of execution. Any effort to create an artificial similarity by regarding a concept as the sum of its marks was entirely alien to my thought.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584750028.459000"></a>
      <img src="https://avatars.slack-edge.com/2020-03-20/1016274741157_0d46a3ab765beca61fd1_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html#1584750028.459000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Michael Mamic</b>
<span style="margin:2em; color:#606060">2020-03-20 17:20</span><br/>
It's true that his goal was more specific than just a  symbol manipulation system, but so are our programming languages themselves. While Frege's language maps to logical thought, our programming languages map to API usage, hardware communication, and data generation. Note also how he talks about it being the glue for more specific systems that might be invented in the future.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584756326.459800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html#1584756326.459800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-03-20 19:05</span><br/>
There is another goal that programming languages can have, and that is to communicate ideas to other humans. My project, Curv, is a language for describing geometric shapes. Ideally, I would like to keep the language "pure", and omit any features that are not needed for the purpose of describing shapes in an abstract, mathematical way. For example, the language has numbers, but for the pure purpose of describing mathematical relationships to another human being, I just need the abstract concept of numbers. To execute code efficiently on a GPU, I need to introduce concepts like 'int32', 'float32', 'float64', and so on, which adds a lot of extra complexity. This tension in my language is one thing that came to mind when I was reading Frege.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584756981.465700"></a>
      <img src="https://secure.gravatar.com/avatar/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html#1584756981.465700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robin Allison</b>
<span style="margin:2em; color:#606060">2020-03-20 19:16</span><br/>
Thanks for sharing. I knew of the Begriffsschrift for inventing first order logic but I’ve never read it before. I was surprised he brought up Leibniz’s ratiocinator which also is somewhat similar to the goals of this community. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584758397.466500"></a>
      <img src="https://secure.gravatar.com/avatar/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html#1584758397.466500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robin Allison</b>
<span style="margin:2em; color:#606060">2020-03-20 19:39</span><br/>
Some hopefully not too random questions: How do you regard it as the first programming language? What makes something a programming language. I usually don't think of first order logic as a programming language wheras the lambda calculus could be a programming language (why is this, can anyone say?). What is the relation between formal languages, programming languages, and languages for the purpose of thinking and communicating?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584804157.477600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html#1584804157.477600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-03-21 08:22</span><br/>
One of the design principles of my Curv language is that it has simple, compositional semantics. The meaning of a compound expression is determined by the meanings of the subexpressions and by the rules used to combine them, in a simple way, with a minimum of "spooky action at a distance". This supports "local reasoning": you shouldn't need a mental model of the execution semantics or type inference semantics of a large chunk of the program, in order to understand the meaning of a small program fragment. The goal is to have semantics that are an order of magnitude simpler and easier to understand than in conventional programming languages.<br/><br/>I got this idea from Denotational Semantics, but according to Wikipedia, this is called the Principal of Compositionality, and it was invented by Frege. If we look at a more reliable source than Wikipedia (<a href="https://plato.stanford.edu/entries/compositionality/#FregContPrin">https://plato.stanford.edu/entries/compositionality/#FregContPrin</a>), we can find this principle in section 60 of the <em>Foundations of Arithmetic</em> (1884).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584818857.485500"></a>
      <img src="https://avatars.slack-edge.com/2020-03-20/1016274741157_0d46a3ab765beca61fd1_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html#1584818857.485500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Michael Mamic</b>
<span style="margin:2em; color:#606060">2020-03-21 12:27</span><br/>
From what I've heard of Curv, I would say that it falls under the category of data generation. In this case, the data being generated is the shape on the GPU. But keep in mind I don't think that there is an end-all written description to tell what is and isn't a programing language. It's my belief that definitions are products of deeper, more enigmatic understandings and not the other way around.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584821951.485700"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html#1584821951.485700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-03-21 13:19</span><br/>
Curv doesn't use data (triangle meshes) to describe shapes, it uses signed distance functions. These functions are executed on the GPU, and a form of ray tracing is used to render the geometry on the monitor. So Curv is a language for defining pure mathematical functions.<br/><br/>I brought up the principle of compositionality because it's the key idea underlying denotational semantics, and I'm trying to see how Frege's work relates to programming languages. I think that the Begriffsschrift was the first predicate calculus. A calculus is a formal language; expressions written in a calculus can be transformed using rules of symbol manipulation, and that is how reasoning works within such a formal system. Another example is the lambda calculus. Since expressions written in a calculus can be transformed mechanically, that provides a justification for calling a calculus a "programming language". So I think that whether the Begriffsschrift was the first programming language depends on whether it was the first calculus. I guess it would also depend on what things can be expressed by earlier calculi (whether they are Turing complete).<br/><br/>Ada Lovelace is sometimes credited as being the first computer programmer. She wrote a program to compute Berboulli Numbers in 1843, 36 years before the Begriffsschrift was published. Wasn't the language that Lovelace wrote her code in (Difference Engine assembly language) a "programming language"? Yes, but this language was surely lacking in the abstraction mechanisms we associate with modern programming languages.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584824128.486500"></a>
      <img src="https://avatars.slack-edge.com/2020-03-20/1016274741157_0d46a3ab765beca61fd1_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584743125.448400.html#1584824128.486500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Michael Mamic</b>
<span style="margin:2em; color:#606060">2020-03-21 13:55</span><br/>
Again, refining my written definition of programming language through the socratic method is the last thing that I want to do. <br/><br/>If Curv were purely mathematical it would not be coupled to the GPU. It's a case of applied mathematics. Curv doesn't need to output polygons to generate data, signed distance functions accomplish the same thing.<br/><br/>As for Turing-Completeness, many people consider HTML and Markdown to be programming languages. Others do not consider assembly and machine languages to be programming languages.<br/><br/>Personally, when I want to talk about LaTeX or HTML I would say "Markup Language", and when referring to some assembly language for architecture X I would say "X assembly language". However, I wouldn't see it necessary to correct someone who called Intel x86 Assembly a programming language.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
