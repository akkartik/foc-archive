<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 10:02</span><br/>
<span style="background-color:#ccf">@Alan Johnson</span> that intuitively makes sense but in practice this doesn't seem to happen. While managed languages don't have to worry about issues like aliasing in C++, so in theory they could be faster, in practice they never go that far. The levels to which a compiler like LLVM can collapse both code and data in C++ to almost nothing is crazy, nothing in the managed world compares. Languages like Java have their own optimisation challenges, e.g. as soon as escape analysis fails it gets very inefficient.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561139756.185400"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561139756.185400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-06-21 10:55</span><br/>
I'd be interested to see whether this balance changed if there was an LLVM or JVM-sized investment put behind a language where the programming model was a better fit for modern CPU design â€” where the programming model mapped more cleanly to the different classes of speculative execution (branch prediction, etc) than C-like languages that expect execution to be strictly in order.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561139820.186000"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561139820.186000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-06-21 10:57</span><br/>
Not sure that this is practical currently, but it's surely theoretically possible if one of the titans of industry decided it was a good idea. Or if, say, Intel decided they wanted to create the next hit systems programming language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561139859.186400"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561139859.186400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-06-21 10:57</span><br/>
See also <a href="https://queue.acm.org/detail.cfm?id=3212479">https://queue.acm.org/detail.cfm?id=3212479</a> of course.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561140948.197100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561140948.197100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:15</span><br/>
Yup, very much agree that the amount of effort put into making a language faster makes all the difference
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561140954.197300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561140954.197300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-06-21 11:15</span><br/>
Or if there was an equivalent investment in hardware that was more suitable for so called 'higher level' languages. E.g. <a href="https://en.wikipedia.org/wiki/Tagged_architecture">https://en.wikipedia.org/wiki/Tagged_architecture</a> which is emulated in software by almost every high level language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141036.197900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141036.197900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:17</span><br/>
Rust is a good candidate: it lacks C++ aliasing issues (which are a huge impediment to optimisation) but is otherwise equivalent. So given endless effort put into optimizing it, it should eventually be faster than C++
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141038.198100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141038.198100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-06-21 11:17</span><br/>
The fact that LLVM is the best we have is evidence to me that we're running on brute force rather than good ideas. All that complexity of millions of LOC to get good performance of even the simple programs.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141146.198300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141146.198300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:19</span><br/>
And of course crazy efforts have gone into making JS fast, whereas similarly dynamic languages like Python have received relatively little optimisation
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141293.198500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141293.198500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:21</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> that's a nice article.. yes the machine that C targets its far from reality :slightly_smiling_face: But we can't actually target the real hardware anymore, as even the CPU ISA pretends its still 1990 or so
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141384.198900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141384.198900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-06-21 11:23</span><br/>
The other angle important to me, where this whole model fails is that in a large scale system, one-process/binary is just one piece of the puzzle. Large scale architecture and topology design will dominate any single process optimization. Basically LLVM is then just a peephole optimizer for the whole system.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141444.199100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141444.199100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:24</span><br/>
<span style="background-color:#ccf">@Shalabh</span> well yes, but that's a chicken and egg problem. certainly if we changed hardware, we'd favor different kind of languages.. but we are not. So as a language designer currently considering should I design this feature as having X or Y semantics, where Y is 2x slower on current hardware, that is still a real concern in terms of the practicality of your language
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141541.199400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141541.199400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:25</span><br/>
of all the things we can try to improve about this world, changing the hardware is about the furthest from our abilities :slightly_smiling_face: It may suck, but there's little point in complaining about it
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141557.199600"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141557.199600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-06-21 11:25</span><br/>
..so we need a whole system optimization model - so a language/environment to express and execute the larger (whole system) processes rather than local RAM bit fiddling optimizers.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141678.199800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141678.199800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:27</span><br/>
you will always need the latter
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141864.200000"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141864.200000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:31</span><br/>
the largest "whole systems" that I am somewhat familiar with are the ones at Google, and we're very far off any kind of optimizing at that level (in a compiler optimisation sense), it's all done by humans. This LLVM level optimization you so dislike controls 99% of data center costs
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561141979.200200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561141979.200200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-06-21 11:32</span><br/>
&gt; if all the things we can try to improve about this world, changing the hardware is about the furthest from our abilities :slightly_smiling_face: It may suck, but there's little point in complaining about it<br/><br/><span style="background-color:#ccf">@Wouter van Oortmerssen</span> - yeah I think this is the situated vs radical perspectives that came up earlier. How much we want to work with existing tech, how much we want to reinvent and rethink etc. If we're looking at this as research and imagining ~50+ years out, ideas today may end up being actualized. So it's still worth and interesting to explore and develop the ideas. Depends on the end goals and motivations.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561142087.200400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561142087.200400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:34</span><br/>
I guess I personally prefer to work on designs I can implement myself, today :slightly_smiling_face: Maybe I'm conservative? :stuck_out_tongue:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561142139.200600"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561142139.200600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:35</span><br/>
Also, even 50 years may not be enough to turn the tide in whatever way you think
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561142223.200800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561142223.200800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:37</span><br/>
remember, in the previous 50 years, we've seen little to no fundamental change in basic technologies like CPUs, memory, and OSes etc.. it is not impossible we're going to spend another 50 with them :stuck_out_tongue:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561143244.207900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561143244.207900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-06-21 11:54</span><br/>
&gt; rather than local RAM bit fiddling optimizers<br/><br/>&gt; you will always need the latter<br/><br/>Agree, but I'm saying that it could be much simpler than millions of LOC and the C++ language spec without cost.<br/><br/>&gt; This LLVM level optimization you so dislike controls 99% of data center costs<br/><br/>Yes, I'm well aware. But also looking at how much proxying, redundant encoding/decoding, RPC fan-out and model duplication happens across all the services, it seems we're losing a lot as well.<br/><br/>I don't dislike LLVM, I think it's pretty solid. I'm arguing for exploring a different model starting top-down. Not just LLVM but all language runtimes/compilers come from a world where 'process' meant OS/Unix process (maybe your whole world was a single OS instance). But processes in large scale systems are very different and we're kind of hacking them on top as a separate layer.<br/><br/>&gt; I guess I personally prefer to work on designs I can implement myself, today :slightly_smiling_face: Maybe I'm conservative?<br/><br/>Why not do both? :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561143326.208100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561143326.208100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:55</span><br/>
I have limited time :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561144783.211900"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561144783.211900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-06-21 12:19</span><br/>
I would be very surprised if Apple didn't end up making changes to some of their hardware to accommodate some Swift feature or framework. They're already knocking at the door with features like BitCode, and they'll be making their own ARM chips for Macs soon. I expect they eventually stop licensing ARM and develop their own instruction set and architecture, maybe even within the decade. That's why I suggested Intel could also end up doing something similar. It's not within the realm of possibility for any of us, but there are people that have the entire stack from wafer to monad within their purview.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561146298.212800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561146298.212800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-06-21 12:44</span><br/>
FPGAs are another architecture that's growing again and folks are using it in data centers.<br/><br/>&gt; I have limited time<br/><br/>Fair. I guess I'm not arguing for other folks to take this position but just that these positions focused on managed/higher level systems with longer term horizons are valuable and can become net wins.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561147405.213800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561147405.213800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-06-21 13:03</span><br/>
&gt; Also, even 50 years may not be enough to turn the tide in whatever way you think<br/><br/>Yes, yes. It may not turn at all or likely even turn a completely different way. But these ideas are still very interesting to me.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561152390.215300"></a>
      <a href="../thinking-together/1561136547.176300.html#1561152390.215300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>fyr</b>
<span style="margin:2em; color:#606060">2019-06-21 14:26</span><br/>
Check out <a href="https://millcomputing.com/">https://millcomputing.com/</a> for some ISA differences from "50 years ago" - still heavily in(slow) development alas
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561171780.220000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561171780.220000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-06-21 19:49</span><br/>
&gt; in the previous 50 years, we've seen little to no fundamental change in basic technologies like CPUs, memory<br/><br/>We have GPUs, which have a radically different architecture from CPUs optimized for running C programs, and which are capable of a wider range of general purpose computing than is admitted by conventional wisdom. And we now have non-volatile RAM. Current software doesn't fully exploit this hardware: we need new languages and operating systems for that.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561172647.220200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561172647.220200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-06-21 20:04</span><br/>
&gt; The levels to which a compiler like LLVM can collapse both code and data in C++ to almost nothing is crazy, nothing in the managed world compares.<br/><br/>"Managed" means uses a garbage collector, or compiles to VM code, or both. There's no necessary conflict between "managed" and using LLVM as a backend code generator, it's just a matter of designing the language or compiler to support this. My Curv language is an interpreted, dynamically typed language, with a subset that compiles into highly optimized machine code for the CPU and GPU.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561178209.220500"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561178209.220500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-06-21 21:36</span><br/>
And don't forget RAM caches.  A recall a funny Ruby performance improvement that was accomplished by <b>increasing</b> the base size of objects from five words to eight.  No other change than just padding out the struct.  <a href="https://github.com/ruby/ruby/pull/495">https://github.com/ruby/ruby/pull/495</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561203753.225100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561203753.225100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-06-22 04:42</span><br/>
&gt; don't forget RAM caches<br/><br/>K is a dynamically typed, interpreted language used for performance critical applications (high speed financial trading). It is super fast in part because the entire interpreter and runtime fits in L1 cache.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561426536.326900"></a>
      <img src="https://secure.gravatar.com/avatar/3db61a4a42000b4ff62648c0979e8920.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561426536.326900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ken Kan</b>
<span style="margin:2em; color:#606060">2019-06-24 18:35</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> What would a new operating system look like that could exploit GPU and NVRAM technologies?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561466692.337700"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561466692.337700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-06-25 05:44</span><br/>
<span style="background-color:#ccf">@Ken Kan</span> With NVRAM, your operating system doesn't lose its state when the hardware is shut down and loses power. That's called "persistence", and current operating systems support this via "hibernation". In current Unix-like operating systems, there's a big difference in how data is represented in RAM, vs how it is represented on disk (files, directories). With NVRAM, you could unify these representations. HP had a research project called "The Machine" which explored the implications of an NVRAM operating system in more detail. <a href="https://www.hpl.hp.com/research/systems-research/themachine/">https://www.hpl.hp.com/research/systems-research/themachine/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561472834.354100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561472834.354100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-06-25 07:27</span><br/>
<span style="background-color:#ccf">@Ken Kan</span> GPUs support data-parallel computing. This is a powerful paradigm for general purpose computing. If you have thousands, or tens of thousands of processing units for each gigabyte of memory, that might be a more scalable and efficient architecture, a better way to allocate your transistor budget. HP's "The Machine" project proposed to "bring processing closer to the data", and that's what GPUs do when you have thousands of cores and gigabytes of memory on the same chip. (Although the HP material doesn't talk about GPUs explicitly.) There have been many research projects that investigated scalable, massively parallel computing, with huge numbers of cores, each having local memory. The advantage of GPUs is that every personal computer has one (I'm including cell phones in my definition of personal computer).<br/><br/>Currently, GPUs are difficult to program, the standard APIs are quite terrible. High level language support for data-parallel computing is quite limited. Conventional programming languages and libraries push you to use idioms that don't map well to data-parallel computing. So there are all these barriers that inhibit more widespread use of GPU capabilities, and I see a lot of wasted potential. Because of these barriers, GPUs are only used for a few specialized applications, like graphics and machine learning. If these barriers could be removed, via better languages and libraries, then GPUs and data-parallel programming might come to be used in a more general and pervasive way. GPU manufacturers will respond by designing GPU hardware to be more general purpose (eg, like the way they are currently responding to the rise of machine learning). That could eventually lead to more GPU-centric operating systems.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561492205.367400"></a>
      <img src="https://secure.gravatar.com/avatar/3db61a4a42000b4ff62648c0979e8920.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1561136547.176300.html#1561492205.367400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ken Kan</b>
<span style="margin:2em; color:#606060">2019-06-25 12:50</span><br/>
Interesting. It looks like The Machine is something HP designs from the ground up so that the hardware and the OS are optimized for memory localized to GPUs. Is that the idea? The missing piece seems to be how to write software for it.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
