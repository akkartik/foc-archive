<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2020-07-03/1220847671058_4980e1f3e51a273b630a_72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ope</b>
<span style="margin:2em; color:#606060">2020-08-17 06:40</span><br/>
What is future of hardware and how will it impact the future of code? What are the most promising approaches to breaking free of Von Neumann bottleneck? &lt;- is this still a thing?<br/>I have heard Simon Peyton Jones say a couple of times that they tried to create new architectures for functional languages but they failed.<br/>Would these architectures succeed today? Are the constraints(business, technical, community) different enough or will be differ enough in 10 years that they could succeed?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597671789.010300"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597671789.010300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2020-08-17 06:43</span><br/>
the memristor and non volatile RAM should change how we code, no longer need to think about state persistence as a separate step, the problem is that now we can't fix by rebooting :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597672015.014600"></a>
      <img src="https://avatars.slack-edge.com/2024-06-15/7281936611971_808c371ba00918560d75_72.jpg" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597672015.014600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Orion Reed</b>
<span style="margin:2em; color:#606060">2020-08-17 06:46</span><br/>
I’m unrelentingly hyped for <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGAs</a> and anything resembling graph-processing. Merging memory, storage, and computing into the same substrate is also exciting.<br/><br/>More than the specific possible hardware, my real hope is to remember <em>computation</em> is king, and hardware should be in support of the computation we’d like to do quickly. If you have a way of computing that may be awesome but is hard to reconcile with hardware, that’s a sign hardware should adapt to fit.<br/><br/>Intel has had long enough dictating the terms of programming, and we certainly don’t want to replace them with an ARMs race to the next monopoly.<br/><br/>“If hardware is unjust, change hardware!”<br/>— stealing from a quote about naturalism
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597672674.024200"></a>
      <img src="https://avatars.slack-edge.com/2020-07-03/1220847671058_4980e1f3e51a273b630a_72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597672674.024200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ope</b>
<span style="margin:2em; color:#606060">2020-08-17 06:57</span><br/>
I was lead down this path by wondering if there are enough people writing python, for example, that a python interpreter compiled to hardware (a machine that only knows to how to interpret python 3.7 for example and optimised to do so) would be a great idea i.e makes sense from a unit cost perspective and efficient in other ways. <br/><br/>We probably don’t want to compile user code to hardware since we still want to be able to change code so quickly but things like the interpreter that are relatively fixed and are used by enough people maybe it makes sense. <br/>Should we hardware be a more significant portion of the stack? Does the tradeoff make sense? Flexibility for power. (Just checked Wikipedia, yeah ASIC or FPGA that is just for python for example). Wonder if anyone has tried it and if it would be more widespread in future. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597672921.024600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597672921.024600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-08-17 07:02</span><br/>
It looks like GPUs are the way we break free of the Von Neumann bottleneck. Desktop discrete GPUs have thousands of processing units. Every personal computer (desktop, laptop, mobile) now has a powerful GPU. Machine learning has made GPUs even more relevant. The future of code needs to take GPUs into account, and not ignore this powerful hardware. My project, Curv, lets you write simple, high level code that executes either on the CPU or on the GPU. Curv is a pure functional language because it's easier to compile pure functional code into massively parallel GPU code. I think that GPUs are viable as an architecture for pure functional programming. I do think that you need to design your pure functional language with GPUs in mind, and that wasn't a consideration for the design of Haskell. I'm not claiming that Haskell is the ideal GPU programming language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597673306.027000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597673306.027000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-08-17 07:08</span><br/>
&gt; If you have a way of computing that may be awesome but is hard to reconcile with hardware, that’s a sign hardware should adapt to fit.<br/>That hasn't worked out for the Haskell people:<br/>&gt; I have heard Simon Peyton Jones say a couple of times that they tried to create new architectures for functional languages but they failed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597673365.027200"></a>
      <img src="https://avatars.slack-edge.com/2024-06-15/7281936611971_808c371ba00918560d75_72.jpg" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597673365.027200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Orion Reed</b>
<span style="margin:2em; color:#606060">2020-08-17 07:09</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> +1<br/>I hope one day in the future we can design programming systems on top of computational constructs like concurrency, parallelism, uncertainty, etc. and have hardware like GPUs, CPUs or networked machines be chosen dynamically without human design interventions for specific architectures.<br/><br/>These are all technically challenging and won’t always succeed, but for it to have a chance we’ll need to change the direction of funding around, flowing from code requirements to hardware imperatives.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597679586.036000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597679586.036000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-08-17 08:53</span><br/>
My criticism of Haskell is that ubiquitous lazy evaluation is not a good idea. This feature means that understanding and tuning the performance of a program is much harder in Haskell than in any other language. Debugging is also messed up: it doesn't really make sense to ask for a stack trace. Attempts to build high performance Haskell hardware have failed. All these facts are closely related. Haskell is somehow lacking in mechanical empathy.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597679968.036200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597679968.036200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-08-17 08:59</span><br/>
Modern CPUs are designed to execute single threaded C programs as quickly as possible. There is a ton of silicon devoted to superscalar out-of-order speculative execution, etc. It isn't an efficient use of hardware.<br/><br/>&gt; My real hope is to remember <em>computation</em> is king, and hardware should be in support of the computation we’d like to do quickly.<br/>Modern GPUs are designed to maximize the percentage of silicon that contains ALUs, relative to the amount of control logic. It is an efficient way to use silicon, if your goal is to maximize the amount of compute that can be accomplished with a given transistor budget.<br/><br/>So we start with this super powerful hardware with monster compute abilities, and we build languages that let us easily program it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597714530.042300"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597714530.042300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2020-08-17 18:35</span><br/>
<a href="https://youtu.be/ubaX1Smg6pY">this Alan Kay talk</a> recommended to me when I first joined the community by <span style="background-color:#ccf">@Garth Goldwater</span>. That talk was very profound for me, it just keeps providing nuggets of wisdom! Thanks again Garth!<br/><br/>At one point in the presentation, Alan Kay talks about when he was at Xerox Park, they could just tell the Intel guys to adjust the microcode on the CPU's. He goes on to say that modern FPGAs are the closest thing we have to that in the modern era.<br/>As usual, Alan Kay is way ahead of his time! I hope he is right.<br/><br/>&gt; My real hope is to remember <em>computation</em> is king, and hardware should be in support of the computation we’d like to do quickly.<br/>I disagree with this statement on some fundamental points. This statement implies that there is a fundamental adversarial hierarchy: Us Vs. Them; Software Vs. Hardware; One must submit to the other! This is a counterproductive view imo.<br/><br/>My ideal future of hardware will come from better symbiosis of computation and hardware. Not domination of one over the other.<br/><br/>Referring to the Alan Kay talk again, Hardware and Software design used to be much closer together. A Programmer and a Hardware engineer would sit down and solve problems together, fighting the tyranny of Physics together :stuck_out_tongue:.<br/>My hope for the future is that this kind of symbiosis has a renaissance.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597715941.044400"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597715941.044400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2020-08-17 18:59</span><br/>
alan kay often cites Bob Barton as a huge inspiration for the hardware/software overlap, if anyone who knows more about hardware than me was looking for a productive name to google
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597716224.044700"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597716224.044700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-08-17 19:03</span><br/>
I tend to be bearish on this whole idea of a "Von Neumann bottleneck".<br/><br/><li> There have been many, many attempts to create processors that operate on graphs. One of the more recent ones was by my research group in grad school 10 or so years ago: <a href="https://www.cs.utexas.edu/~trips">https://www.cs.utexas.edu/~trips</a>. But see also Dataflow architectures (<a href="https://en.wikipedia.org/wiki/Dataflow_architecture">https://en.wikipedia.org/wiki/Dataflow_architecture</a>), and MIT's Raw processor (<a href="http://groups.csail.mit.edu/cag/raw">http://groups.csail.mit.edu/cag/raw</a>). While it's possible we're just one breakthrough away from making it work, it is an Open Research Problem.<br/><li> Hardware people know what they're doing, far more than us software people. Whether that's because they're Superior Human Beings, or because their domain is easier, you seek to make hardware more like software at your peril. Imagine having to fix a security vulnerability in a chip instead of a compiler.<br/><li> Hardware has less open source, and you seek to implement layers of software in hardware at your peril. Imagine having to convince your processor supplier of the value of open source. Imagine having to create a new programming language in nights and weekends <em>in hardware</em>. Now ask yourself why you would want to ask others to do something that hobbyists wouldn't do, to put up with a less malleable medium. The best ideas in computing have come from hobbyists. I want a more inclusive future, not less.<br/><li> Python is Python only because all the hard stuff has native libraries that work with existing processors. If you plan to migrate those to pure Python, that gives up much of the benefit of using an existing language with a large install base. Might as well use a better language.<br/><li> The term "von neumann bottleneck" is fundamentally about improving performance. Improving performance isn't in my top 10 major problems facing the future of software.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597750723.066600"></a>
      <img src="https://avatars.slack-edge.com/2024-06-15/7281936611971_808c371ba00918560d75_72.jpg" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597750723.066600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Orion Reed</b>
<span style="margin:2em; color:#606060">2020-08-18 04:38</span><br/>
<span style="background-color:#ccf">@Ray Imber</span><br/>&gt; My ideal future of hardware will come from better symbiosis of computation and hardware. Not domination of one over the other.<br/>&gt; <br/>&gt; <br/>I realise how what I said may have come across, and want to clarify here I totally agree! I say computation in reference to the abstract notion of <em>doing things</em> with computers, wether through hardware or code. It was actually Alan Kay who inspired me to give that response though I forget from where.<br/><br/>Another way to put it might be to say that both hardware and software are things we invent to serve some computing goal, and we only sometimes know how they’ll help.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597770790.068600"></a>
      <img src="https://secure.gravatar.com/avatar/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597770790.068600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Will Crichton</b>
<span style="margin:2em; color:#606060">2020-08-18 10:13</span><br/>
There’s a group at Stanford called the “Agile Hardware Group” (<a href="https://aha.stanford.edu/">https://aha.stanford.edu/</a>). I’m not involved, but my advisor + many people in my group are.<br/><br/>My 10k ft perspective: hardware tools suck. Like, orders of magnitude worse than any software stack.<br/>• Production tools for hardware are literally Tcl/Perl scripts that generate strings of Verilog code and smash them together. <br/>• Place&amp;route (lowering a design into wires on a board) takes potentially <b>hours</b> to run. No notion of incremental compilation, small change -&gt; hours to run.<br/>• Verilog is a trash fire. It’s a programming language designed by hardware engineers, so it has insane, poorly specified semantics.<br/>• Everything is closed source!! From circuit pieces to compilers, everything tool is considered valuable IP. It’s 1970s era computing, but today.<br/>These issues need to be fixed for hardware to really take off beyond its current state.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597776144.072700"></a>
      <img src="https://avatars.slack-edge.com/2020-07-03/1220847671058_4980e1f3e51a273b630a_72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597776144.072700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ope</b>
<span style="margin:2em; color:#606060">2020-08-18 11:42</span><br/>
The maker movement was poised to make hardware more accessible but seems to have fizzled out. I used to be so involved with it. Wonder what 2.0 would look like.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597781351.073300"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597781351.073300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2020-08-18 13:09</span><br/>
On the open source side, I remain cautiously interested in <a href="https://riscv.org">https://riscv.org</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597782108.073800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597782108.073800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-08-18 13:21</span><br/>
There is also the <a href="http://Libre-SOC.org">Libre-SOC.org</a> project, which is also Open Hardware. They are building a system-on-a-chip that contains an integrated CPU and GPU and VPU, inspired by the CDC 6600 architecture. I gather that their architecture is more efficient than RISC-V, that programming the GPU is much simpler than a conventional GPU due to close integration with the CPU, but I don't follow the project closely.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1597784262.074200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1597671602.008000.html#1597784262.074200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-08-18 13:57</span><br/>
Yeah, very bullish on open-source hardware. I'd like for it to get commoditized and lose leverage.<br/><br/>I'm also interested in attempts to route around pre-firmware backdoors: <a href="https://puri.sm/learn/avoiding-intel-amt">https://puri.sm/learn/avoiding-intel-amt</a>; <a href="https://openpowerfoundation.org">https://openpowerfoundation.org</a> (latter via <a href="https://www.talospace.com/2019/11/talos-ii-and-talos-ii-lite-officially.html">https://www.talospace.com/2019/11/talos-ii-and-talos-ii-lite-officially.html</a>)
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
