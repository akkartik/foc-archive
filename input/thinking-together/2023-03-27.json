[
    {
        "user": "U04LWR320HK",
        "type": "message",
        "ts": "1679902126.038549",
        "client_msg_id": "1171c40e-8815-400c-9981-ba25a5e39e88",
        "text": "<@UA14TGLTC> As long as _human_ creativity is the limiting factor, I don't think we have anything to worry about. I feel like for most, the anxiety kicks in when you start to think about the point where it's the AI's creativity that surpasses it. :smile:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a1bbcd907c88",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-05-02\/5198196217986_a1bbcd907c8887f98ffa_72.png",
            "first_name": "Jonas",
            "real_name": "Jonas",
            "display_name": "Jonas",
            "team": "T5TCAFTA9",
            "name": "jonas.merlin.schumach",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679642239.661619",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e=RHW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " As long as "
                            },
                            {
                                "type": "text",
                                "text": "human",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " creativity is the limiting factor, I don't think we have anything to worry about. I feel like for most, the anxiety kicks in when you start to think about the point where it's the AI's creativity that surpasses it. "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0296ACR13M",
        "type": "message",
        "ts": "1679902227.016569",
        "edited": {
            "user": "U0296ACR13M",
            "ts": "1679904038.000000"
        },
        "client_msg_id": "f4e09a8c-b02f-4cf5-aec4-31e39b1361c4",
        "text": "On the heels of the \"LLMs and the future of programming\" discussion (<https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1679642239661619>, <https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1679892669316079>), I'd like to start a more concentrated discussion around their effect on Future of Coding projects. There was already some sentiment that LLMs are going to kill FoC projects. Some yes, but certainly not all. So what kind of FoC projects LLMs will not kill?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "59de929720a2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-09-08\/4075674207584_59de929720a2fe0a13d8_72.jpg",
            "first_name": "",
            "real_name": "Jarno Montonen",
            "display_name": "Jarno Montonen",
            "team": "T5TCAFTA9",
            "name": "jarno.montonen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679902227.016569",
        "reply_count": 4,
        "reply_users_count": 2,
        "latest_reply": "1679982547.990119",
        "reply_users": [
            "U0296ACR13M",
            "UCGAK10LS"
        ],
        "replies": [
            {
                "user": "U0296ACR13M",
                "ts": "1679903697.650859"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1679958556.634899"
            },
            {
                "user": "U0296ACR13M",
                "ts": "1679982392.919849"
            },
            {
                "user": "U0296ACR13M",
                "ts": "1679982547.990119"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vvnq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On the heels of the \"LLMs and the future of programming\" discussion ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1679642239661619"
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1679892669316079"
                            },
                            {
                                "type": "text",
                                "text": "), I'd like to start a more concentrated discussion around their effect on Future of Coding projects. There was already some sentiment that LLMs are going to kill FoC projects. Some yes, but certainly not all. So what kind of FoC projects LLMs will not kill?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1679902332.167169",
        "client_msg_id": "435AEDC4-44B9-4DB3-B8B2-ACFE040BFC76",
        "text": "Trying to synthesize various replies in now various threads here, it seems there are different dimensions that deserve to get pulled apart:\n\n1. Regardless of how optimistic or pessimistic we are what that means for the future, it seems most of us acknowledge that there are both _valuable_ uses cases for generative AI that can enhance and augment what programmers do (generate variety, add perspectives, muse over oracle, just do the boring part, etc.) and there are also _uninspired_ use cases to just automate something away (autocomplete worship, do this thing, probably wrong and\/or buggy, but don’t care, good enough).\n2. In terms of enabling people to program, dare I say “democratizing programming”, there are also two perspectives: some are excited about getting into the game (or back into it) because it seems to get easier, others are worried it’s going to kill their job as their expertise seems to be worth a lot less now.\n3. Our current business environment incentivizes massive exploitation, which will double down on the uninspired use cases that will make the bad outcomes of 1+2 more likely and push us all towards (and over?) the cliff. Perhaps though, instead of pushing us over the edge, this could push our boundaries, get us to tackle even more complex problems, because it frees up capacity to let us focus on more important issues, whether related to programming or beyond.\nIs that an appropriate summary? \nDid I miss another dimension?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679642239.661619",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QxH9H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Trying to synthesize various replies in now various threads here, it seems there are different dimensions that deserve to get pulled apart:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Regardless of how optimistic or pessimistic we are what that means for the future, it seems most of us acknowledge that there are both "
                                    },
                                    {
                                        "type": "text",
                                        "text": "valuable",
                                        "style": {
                                            "bold": false,
                                            "italic": true,
                                            "strike": false
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " uses cases for generative AI that can enhance and augment what programmers do (generate variety, add perspectives, muse over oracle, just do the boring part, etc.) and there are also "
                                    },
                                    {
                                        "type": "text",
                                        "text": "uninspired",
                                        "style": {
                                            "bold": false,
                                            "italic": true,
                                            "strike": false
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " use cases to just automate something away (autocomplete worship, do this thing, probably wrong and\/or buggy, but don’t care, good enough)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "In terms of enabling people to program, dare I say “democratizing programming”, there are also two perspectives: some are excited about getting into the game (or back into it) because it seems to get easier, others are worried it’s going to kill their job as their expertise seems to be worth a lot less now."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Our current business environment incentivizes massive exploitation, which will double down on the uninspired use cases that will make the bad outcomes of 1+2 more likely and push us all towards (and over?) the cliff. Perhaps though, instead of pushing us over the edge, this could push our boundaries, get us to tackle even more complex problems, because it frees up capacity to let us focus on more important issues, whether related to programming or beyond."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "offset": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIs that an appropriate summary? \nDid I miss another dimension?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UA14TGLTC",
                    "U04KZ8A9WCT"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U0296ACR13M",
        "type": "message",
        "ts": "1679903697.650859",
        "client_msg_id": "9e75b372-2579-40f1-872b-c6a7eb7d9ba0",
        "text": "To kick off the discussion I did the only logical thing and asked ChatGPT.\n\n_what are the strengths of low-code and no-code tools against programming with the help of an LLM?_:\n\n`Low-code and no-code tools, as well as Language Models (LLMs) like GPT-4, each have their own strengths in software development. Here, we will focus on the strengths of low-code and no-code tools when compared to programming with the help of an LLM.`\n1. `Accessibility: Low-code and no-code platforms are designed to be accessible to non-technical users, enabling more people to create software applications without needing extensive programming knowledge. LLMs, while powerful, still require a basic understanding of programming concepts to be used effectively.`\n2. `Visual Interface: Low-code and no-code tools often provide a visual, drag-and-drop interface, making it easy to design applications and see the structure of the application. This can be more intuitive than using an LLM, which generally requires text-based communication and code editing.`\n3. `Standardization: Low-code and no-code platforms typically enforce standardized coding practices and patterns, which can result in more maintainable and organized code. On the other hand, LLMs might generate code with different styles and conventions depending on the input.`\n4. `Integration: Low-code and no-code platforms often provide pre-built integrations with popular services, databases, and APIs. While LLMs can also help generate code to interact with various services, they might require more manual work to integrate and configure the connections.`\n5. `Speed of Development: Low-code and no-code tools can significantly speed up the development process, as they automate repetitive tasks and allow users to focus on the overall application design. LLMs can also speed up development, but the improvement might not be as dramatic, especially for simpler applications.`\n6. `Collaboration: Low-code and no-code platforms often have built-in collaboration features, allowing multiple team members to work on the same project simultaneously. While it's possible to collaborate using LLMs, it might not be as streamlined as using dedicated low-code\/no-code tools.`\n7. `Predictability: Low-code and no-code platforms provide a more predictable development environment, as they consist of predefined components and actions. LLMs can sometimes generate unexpected or inconsistent code, depending on the input and training data.`\n`While low-code and no-code tools have these strengths, it's important to remember that they also have limitations, such as less flexibility in terms of customization, and potential issues with scaling or performance. The choice between using low-code\/no-code tools and an LLM depends on the specific project requirements, the technical expertise of the team, and the desired level of customization.`\n\n_How about if we expand the scope to the whole process of software development_\n\n`Expanding the scope to the entire software development process allows us to compare low-code\/no-code tools and LLMs across various aspects of the development lifecycle. The following comparison highlights the strengths of low-code\/no-code tools in the broader context of software development.`\n1. `Requirement gathering and prototyping: Low-code\/no-code platforms excel at quickly creating prototypes and mockups, which can help in gathering and refining requirements. LLMs can be used for generating code snippets, but they might not provide a complete solution for creating interactive prototypes.`\n2. `Development and implementation: Low-code\/no-code tools can speed up the development process by automating repetitive tasks and providing pre-built components. However, they may lack the flexibility needed for highly customized or complex applications. LLMs can help generate code, but developers still need to manage the overall application structure and logic.`\n3. `Testing: Low-code\/no-code platforms often include built-in testing tools or features, making it easy to validate the application's functionality. While LLMs can help generate test cases or test code, they are not a complete solution for software testing.`\n4. `Deployment and maintenance: Low-code\/no-code platforms usually have straightforward deployment and maintenance processes, often with built-in support for continuous integration and delivery. LLMs can help automate parts of the deployment process, but developers still need to manage the overall infrastructure and maintenance.`\n5. `Documentation: Low-code\/no-code tools often automatically generate documentation based on the application's structure and components. LLMs can be used to generate code comments or external documentation, but they might require more manual effort to ensure that the documentation is accurate and comprehensive.`\n6. `Collaboration and project management: Low-code\/no-code platforms often include collaboration and project management features, allowing teams to work together more efficiently. While LLMs can be used in a collaborative context, they may not provide the same level of support for project management.`\n7. `Training and onboarding: Low-code\/no-code tools generally have a lower learning curve, enabling new team members to become productive more quickly. LLMs can be helpful for generating code samples or answering programming-related questions, but they might not be as effective for onboarding new developers who are not familiar with programming concepts.`\n`While low-code and no-code tools have these strengths in the software development process, they also have limitations. For example, they might not be suitable for highly customized applications or for situations where performance is critical. Moreover, they might result in vendor lock-in, which can limit flexibility and long-term scalability.`\n`Ultimately, the choice between using low-code\/no-code tools and an LLM depends on the specific project requirements, the technical expertise of the team, and the desired level of customization and flexibility. In some cases, a combination of low-code\/no-code tools and LLMs might be the most effective approach to software development.`\n\n_so, if I'm working on a low-code\/no-code tool and I'm worried that LLMs will make the tool obsolete or significantly decrease it's market potential, what should I concentrate on?_\n\n`If you're working on a low-code\/no-code tool and concerned about the impact of LLMs on your market potential, you should focus on several aspects that can help differentiate your product and provide value to users beyond what an LLM can offer:`\n1. `User Experience: Create a user-friendly, intuitive, and visually appealing interface that makes it easy for users to build applications without prior programming knowledge. This will help your tool stand out from LLM-based solutions, which often require more programming expertise to use effectively.`\n2. `Integrations and Ecosystem: Offer seamless integrations with popular third-party services, databases, and APIs. By providing a rich ecosystem of pre-built connectors and integrations, you can save users time and effort, making your tool more attractive than working with LLMs alone.`\n3. `Collaboration Features: Build in features that facilitate collaboration and communication among team members, making it easier for them to work together on projects. This can provide a significant advantage over LLMs, which may not inherently support collaborative development.`\n4. `Customization and Extensibility: While low-code\/no-code tools are often associated with less flexibility, you can differentiate your product by offering customization options and extensibility features that cater to various use cases and industries. This could include allowing users to create custom components, use scripting languages, or integrate with external code.`\n5. `Education and Support: Provide comprehensive documentation, tutorials, and support to help users get the most out of your tool. By offering exceptional customer service and resources, you can create a loyal user base and distinguish your product from LLM-based solutions.`\n6. `Performance and Scalability: Focus on optimizing your platform for performance and scalability, ensuring that it can handle the demands of larger and more complex applications. This will help attract users who require high-performance solutions that might not be achievable with LLM-generated code.`\n7. `Security and Compliance: Address security and compliance concerns by incorporating features that ensure data privacy, secure user authentication, and adherence to industry-specific regulations. This can be an essential differentiator for customers in regulated industries.`\n8. `Target Niche Markets: Identify specific industries or use cases where your low-code\/no-code tool can provide unique value, and tailor your features and marketing efforts towards those niches. By becoming a specialized solution, you can carve out a market segment less affected by LLMs.`\n9. `Community Building: Foster a community around your low-code\/no-code tool, encouraging users to share their experiences, tips, and best practices. A strong community can help drive user adoption and increase your product's visibility.`\n`By focusing on these aspects, you can create a competitive low-code\/no-code tool that offers value beyond what an LLM can provide, ensuring that your product remains relevant and successful in the market.`\n\nI would like to add that programming using LLMs still suffers from all of the possible pain points of the chosen programming language, beyond the act of writing code. Such as debugging experience and compilation or deployment times. This is where live programming tools excel for example.\n\nOf course, some of the LLM weaknesses will be fixed. Which ones will be fixed first? Which ones last or never? Are there niches (user groups, industries or domains) in which the strengths of LLMs don't apply or are decreased? Are there domains in which LLMs can't\/will not be utilized for some (political, financial, social, security, emotional, ..) reason?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "59de929720a2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-09-08\/4075674207584_59de929720a2fe0a13d8_72.jpg",
            "first_name": "",
            "real_name": "Jarno Montonen",
            "display_name": "Jarno Montonen",
            "team": "T5TCAFTA9",
            "name": "jarno.montonen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679902227.016569",
        "parent_user_id": "U0296ACR13M",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "McmA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To kick off the discussion I did the only logical thing and asked ChatGPT.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "what are the strengths of low-code and no-code tools against programming with the help of an LLM?",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ":\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Low-code and no-code tools, as well as Language Models (LLMs) like GPT-4, each have their own strengths in software development. Here, we will focus on the strengths of low-code and no-code tools when compared to programming with the help of an LLM.",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Accessibility: Low-code and no-code platforms are designed to be accessible to non-technical users, enabling more people to create software applications without needing extensive programming knowledge. LLMs, while powerful, still require a basic understanding of programming concepts to be used effectively.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Visual Interface: Low-code and no-code tools often provide a visual, drag-and-drop interface, making it easy to design applications and see the structure of the application. This can be more intuitive than using an LLM, which generally requires text-based communication and code editing.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Standardization: Low-code and no-code platforms typically enforce standardized coding practices and patterns, which can result in more maintainable and organized code. On the other hand, LLMs might generate code with different styles and conventions depending on the input.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Integration: Low-code and no-code platforms often provide pre-built integrations with popular services, databases, and APIs. While LLMs can also help generate code to interact with various services, they might require more manual work to integrate and configure the connections.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Speed of Development: Low-code and no-code tools can significantly speed up the development process, as they automate repetitive tasks and allow users to focus on the overall application design. LLMs can also speed up development, but the improvement might not be as dramatic, especially for simpler applications.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Collaboration: Low-code and no-code platforms often have built-in collaboration features, allowing multiple team members to work on the same project simultaneously. While it's possible to collaborate using LLMs, it might not be as streamlined as using dedicated low-code\/no-code tools.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Predictability: Low-code and no-code platforms provide a more predictable development environment, as they consist of predefined components and actions. LLMs can sometimes generate unexpected or inconsistent code, depending on the input and training data.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "While low-code and no-code tools have these strengths, it's important to remember that they also have limitations, such as less flexibility in terms of customization, and potential issues with scaling or performance. The choice between using low-code\/no-code tools and an LLM depends on the specific project requirements, the technical expertise of the team, and the desired level of customization.",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "How about if we expand the scope to the whole process of software development",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Expanding the scope to the entire software development process allows us to compare low-code\/no-code tools and LLMs across various aspects of the development lifecycle. The following comparison highlights the strengths of low-code\/no-code tools in the broader context of software development.",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Requirement gathering and prototyping: Low-code\/no-code platforms excel at quickly creating prototypes and mockups, which can help in gathering and refining requirements. LLMs can be used for generating code snippets, but they might not provide a complete solution for creating interactive prototypes.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Development and implementation: Low-code\/no-code tools can speed up the development process by automating repetitive tasks and providing pre-built components. However, they may lack the flexibility needed for highly customized or complex applications. LLMs can help generate code, but developers still need to manage the overall application structure and logic.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Testing: Low-code\/no-code platforms often include built-in testing tools or features, making it easy to validate the application's functionality. While LLMs can help generate test cases or test code, they are not a complete solution for software testing.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Deployment and maintenance: Low-code\/no-code platforms usually have straightforward deployment and maintenance processes, often with built-in support for continuous integration and delivery. LLMs can help automate parts of the deployment process, but developers still need to manage the overall infrastructure and maintenance.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Documentation: Low-code\/no-code tools often automatically generate documentation based on the application's structure and components. LLMs can be used to generate code comments or external documentation, but they might require more manual effort to ensure that the documentation is accurate and comprehensive.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Collaboration and project management: Low-code\/no-code platforms often include collaboration and project management features, allowing teams to work together more efficiently. While LLMs can be used in a collaborative context, they may not provide the same level of support for project management.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Training and onboarding: Low-code\/no-code tools generally have a lower learning curve, enabling new team members to become productive more quickly. LLMs can be helpful for generating code samples or answering programming-related questions, but they might not be as effective for onboarding new developers who are not familiar with programming concepts.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "While low-code and no-code tools have these strengths in the software development process, they also have limitations. For example, they might not be suitable for highly customized applications or for situations where performance is critical. Moreover, they might result in vendor lock-in, which can limit flexibility and long-term scalability.",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "Ultimately, the choice between using low-code\/no-code tools and an LLM depends on the specific project requirements, the technical expertise of the team, and the desired level of customization and flexibility. In some cases, a combination of low-code\/no-code tools and LLMs might be the most effective approach to software development.",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "so, if I'm working on a low-code\/no-code tool and I'm worried that LLMs will make the tool obsolete or significantly decrease it's market potential, what should I concentrate on?",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "If you're working on a low-code\/no-code tool and concerned about the impact of LLMs on your market potential, you should focus on several aspects that can help differentiate your product and provide value to users beyond what an LLM can offer:",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "User Experience: Create a user-friendly, intuitive, and visually appealing interface that makes it easy for users to build applications without prior programming knowledge. This will help your tool stand out from LLM-based solutions, which often require more programming expertise to use effectively.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Integrations and Ecosystem: Offer seamless integrations with popular third-party services, databases, and APIs. By providing a rich ecosystem of pre-built connectors and integrations, you can save users time and effort, making your tool more attractive than working with LLMs alone.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Collaboration Features: Build in features that facilitate collaboration and communication among team members, making it easier for them to work together on projects. This can provide a significant advantage over LLMs, which may not inherently support collaborative development.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Customization and Extensibility: While low-code\/no-code tools are often associated with less flexibility, you can differentiate your product by offering customization options and extensibility features that cater to various use cases and industries. This could include allowing users to create custom components, use scripting languages, or integrate with external code.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Education and Support: Provide comprehensive documentation, tutorials, and support to help users get the most out of your tool. By offering exceptional customer service and resources, you can create a loyal user base and distinguish your product from LLM-based solutions.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Performance and Scalability: Focus on optimizing your platform for performance and scalability, ensuring that it can handle the demands of larger and more complex applications. This will help attract users who require high-performance solutions that might not be achievable with LLM-generated code.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Security and Compliance: Address security and compliance concerns by incorporating features that ensure data privacy, secure user authentication, and adherence to industry-specific regulations. This can be an essential differentiator for customers in regulated industries.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Target Niche Markets: Identify specific industries or use cases where your low-code\/no-code tool can provide unique value, and tailor your features and marketing efforts towards those niches. By becoming a specialized solution, you can carve out a market segment less affected by LLMs.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Community Building: Foster a community around your low-code\/no-code tool, encouraging users to share their experiences, tips, and best practices. A strong community can help drive user adoption and increase your product's visibility.",
                                        "style": {
                                            "code": true
                                        }
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "By focusing on these aspects, you can create a competitive low-code\/no-code tool that offers value beyond what an LLM can provide, ensuring that your product remains relevant and successful in the market.",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nI would like to add that programming using LLMs still suffers from all of the possible pain points of the chosen programming language, beyond the act of writing code. Such as debugging experience and compilation or deployment times. This is where live programming tools excel for example.\n\nOf course, some of the LLM weaknesses will be fixed. Which ones will be fixed first? Which ones last or never? Are there niches (user groups, industries or domains) in which the strengths of LLMs don't apply or are decreased? Are there domains in which LLMs can't\/will not be utilized for some (political, financial, social, security, emotional, ..) reason?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01JNTE35QS",
        "type": "message",
        "ts": "1679926482.489929",
        "client_msg_id": "cdd7c82d-67c3-4b4f-b99c-e0b175e6ac0b",
        "text": "Yes, 4. This summary was not written by GPT-4. :slightly_smiling_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "97155db555c2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-01-13\/1631845309525_97155db555c2091ecd20_72.jpg",
            "first_name": "",
            "real_name": "Vijay Chakravarthy",
            "display_name": "Vijay Chakravarthy",
            "team": "T5TCAFTA9",
            "name": "vchakrav",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679642239.661619",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Wa2=S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, 4. This summary was not written by GPT-4. "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "wink",
                "users": [
                    "U5STGTB3J",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "joy",
                "users": [
                    "U04KZ8A9WCT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U04MTMF6Y4W",
        "type": "message",
        "ts": "1679927549.898479",
        "client_msg_id": "9A64F82D-6ED4-4E29-B293-5E891ED552A6",
        "text": "Has anyone tried to square “computing is a metamedium” (able to simulate all other mediums) with “medium is the message” school? I can think of a number of places where existing mediums can’t be emulated by a computer. But curious where people might say that’s an inherent limit vs a stage of expression computers have not yet reached (I think probably a mix of both). Is thinking there’s a limit “bad” if you are interested in the Future of Coding or does it help in some way with maximizing on strengths?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e4fc5f2a2c70",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-06-24\/5478852762419_e4fc5f2a2c70210c1841_72.png",
            "first_name": "Ibro",
            "real_name": "Ibro C.",
            "display_name": "ibro",
            "team": "T5TCAFTA9",
            "name": "foc214",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679927549.898479",
        "reply_count": 10,
        "reply_users_count": 2,
        "latest_reply": "1680196155.914259",
        "reply_users": [
            "UE6EFEPTQ",
            "U04MTMF6Y4W"
        ],
        "replies": [
            {
                "user": "UE6EFEPTQ",
                "ts": "1680043116.983189"
            },
            {
                "user": "U04MTMF6Y4W",
                "ts": "1680085791.707429"
            },
            {
                "user": "U04MTMF6Y4W",
                "ts": "1680085826.178509"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1680104500.834899"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1680104648.988199"
            },
            {
                "user": "U04MTMF6Y4W",
                "ts": "1680193691.864459"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1680194214.148599"
            },
            {
                "user": "U04MTMF6Y4W",
                "ts": "1680195012.354479"
            },
            {
                "user": "U04MTMF6Y4W",
                "ts": "1680195096.859449"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1680196155.914259"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+jT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Has anyone tried to square “computing is a metamedium” (able to simulate all other mediums) with “medium is the message” school? I can think of a number of places where existing mediums "
                            },
                            {
                                "type": "text",
                                "text": "can’t"
                            },
                            {
                                "type": "text",
                                "text": " be emulated by a computer. But curious where people might say "
                            },
                            {
                                "type": "text",
                                "text": "that’s"
                            },
                            {
                                "type": "text",
                                "text": " an inherent limit vs a stage of expression computers have not yet reached (I think probably a mix of both). Is thinking "
                            },
                            {
                                "type": "text",
                                "text": "there’s"
                            },
                            {
                                "type": "text",
                                "text": " a limit “bad” if you are interested in the Future of Coding or does it help in some way with maximizing on strengths?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "joy",
                "users": [
                    "U03JUAWDVSR"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U0112C10V4Y",
        "type": "message",
        "ts": "1679929542.004789",
        "client_msg_id": "d0443f66-897d-4ce0-8402-0ce6f70750c5",
        "text": "Why can't an AI skip the intermediate step and just output direct machine code? After all, do you verify what your compiler is spitting out?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf521cc065bb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Naveen Michaud-Agrawal",
            "display_name": "Naveen Michaud-Agrawal",
            "team": "T5TCAFTA9",
            "name": "naveen.michaudagrawal",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679892669.316079",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "30S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Why can't an AI skip the intermediate step and just output direct machine code? After all, do you verify what your compiler is spitting out?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0112C10V4Y",
        "type": "message",
        "ts": "1679929692.502719",
        "client_msg_id": "ed808f00-7d46-45f8-af6f-9b8bf6faa722",
        "text": "People are still thinking in terms of the old paradigm of write, compile, run program. But a computer system where you can interact with an AI that is able to directly access input and output pretty much removes the need for any sort of programming. Programming is in the end a roundabout way of getting a computer to perform some action\/compute some result.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf521cc065bb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Naveen Michaud-Agrawal",
            "display_name": "Naveen Michaud-Agrawal",
            "team": "T5TCAFTA9",
            "name": "naveen.michaudagrawal",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679892669.316079",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kExBR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "People are still thinking in terms of the old paradigm of write, compile, run program. But a computer system where you can interact with an AI that is able to directly access input and output pretty much removes the need for any sort of programming. Programming is in the end a roundabout way of getting a computer to perform some action\/compute some result."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UNCP67JSK",
        "type": "message",
        "ts": "1679936905.902369",
        "client_msg_id": "28E4201F-A908-4B68-812A-E8C2A3BC9362",
        "text": "gpt4 excerpt:\n&gt;&gt; LLMs for bridging the gap between domain experts and developers: LLMs can help facilitate communication between domain experts and developers by translating domain-specific requirements into programming constructs or even generating code prototypes. This can reduce miscommunications and speed up the development process, especially for interdisciplinary projects.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "9e950179feb1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-02-11\/947800888119_9e950179feb1f81e1123_72.jpg",
            "first_name": "Leonard",
            "real_name": "Leonard Pauli",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "leonardpauli",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679892669.316079",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oeRyZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "gpt4 excerpt:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "LLMs for bridging the gap between domain experts and developers: LLMs can help facilitate communication between domain experts and developers by translating domain-specific requirements into programming constructs or even generating code prototypes. This can reduce miscommunications and speed up the development process, especially for interdisciplinary projects."
                            }
                        ],
                        "border": 1
                    }
                ]
            }
        ]
    },
    {
        "user": "UNCP67JSK",
        "type": "message",
        "ts": "1679937330.895309",
        "client_msg_id": "7AA6A812-5700-4D5E-9600-5BEE061E4497",
        "text": "<@UCGAK10LS> LLM's is now an essential component in most tools for thoughts; the interface and information organization\/representation (eg. higher order language, pkm\/graph, etc) to facilitate both the LLM-tft side and the tft-human side is still up for a huuuge improvement. Feeling pretty good about working just in that zone :)) ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "9e950179feb1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-02-11\/947800888119_9e950179feb1f81e1123_72.jpg",
            "first_name": "Leonard",
            "real_name": "Leonard Pauli",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "leonardpauli",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679892669.316079",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RsP8P",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " LLM's is now an essential component in most tools for thoughts; the interface and information organization\/representation (eg. higher order language, pkm\/graph, etc) to facilitate both the LLM-tft side and the tft-human side is still up for a huuuge improvement. Feeling pretty good about working just in that zone :)) "
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U04MTMF6Y4W",
        "type": "message",
        "ts": "1679941681.352839",
        "client_msg_id": "F2850C2A-B770-4BEB-BFF0-F835FD6DF125",
        "text": "Porting my reply from <@U0296ACR13M> ‘s question to build of what was already said here. I think there’s broadly two categories of software “consumer”, adapters and users. Users want it to just work and adapters are interested in how. Maybe we could even map it to wanting the right thing vs worse is better. For users LLMs could be a more natural interface to existing tools, APIs, automation. There the question might be, “Is this a better interface than what you get from other methods of interaction?” Sometimes?\n\nFor adapters, visibility and clarity are as important as the end product. As far as I’ve seen, using prompts to program a system builds a different skill from doing it manually . Similar to using an existing library or hiring a developer you abstract the process by outsourcing to a third-party. If that’s valuable depends on what the task is. But good abstraction, comes from being able to peel that back if needed. With current AI tools the person writing is also responsible for defining those layers. So speed could improve, but required skill would still be similar.\n\nPessimist take: Tooling tailored to AI programming seems more likely than them using existing ones. Historically that means a split, probably with more mainstream effort on the AI language side. But people tend to do this a lot: cities rebuilt for cars, modern assembly areas are too dangerous to walk around, optimized javascript limits view source’s benefits. Billion dollar SaaS black box as the best option for improving usability of existing tools software seems like digging deeper into present coding’s problems.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e4fc5f2a2c70",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-06-24\/5478852762419_e4fc5f2a2c70210c1841_72.png",
            "first_name": "Ibro",
            "real_name": "Ibro C.",
            "display_name": "ibro",
            "team": "T5TCAFTA9",
            "name": "foc214",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679892669.316079",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vk7A7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Porting my reply from "
                            },
                            {
                                "type": "user",
                                "user_id": "U0296ACR13M"
                            },
                            {
                                "type": "text",
                                "text": " ‘s question to build of what was already said here. I think there’s broadly two categories of software “consumer”, adapters and users. Users want it to just work and adapters are interested in how. Maybe we could even map it to wanting the right thing vs worse is better. For users LLMs could be a more natural interface to existing tools, APIs, automation. There the question might be, “Is this a better interface than what you get from other methods of interaction?” Sometimes?\n\nFor adapters, visibility and clarity are as important as the end product. "
                            },
                            {
                                "type": "text",
                                "text": "As far as I’ve seen, using prompts to program a system builds a different skill from doing it"
                            },
                            {
                                "type": "text",
                                "text": " manually "
                            },
                            {
                                "type": "text",
                                "text": ". Similar to using an "
                            },
                            {
                                "type": "text",
                                "text": "existing"
                            },
                            {
                                "type": "text",
                                "text": " library or "
                            },
                            {
                                "type": "text",
                                "text": "hiring"
                            },
                            {
                                "type": "text",
                                "text": " a developer you abstract the process by outsourcing to a third-party. If that’s valuable depends on what the task is. "
                            },
                            {
                                "type": "text",
                                "text": "But good abstraction, comes from being able to peel that back if needed. With current AI tools the person writing is also responsible for defining those layers. So speed could improve, but required skill would still be similar.\n\nPessimist take: Tooling tailored to AI programming seems more likely than them using existing ones. Historically that means a split, probably with more mainstream effort on the AI language side. But people tend to do this a lot: cities rebuilt for cars, modern assembly areas are too dangerous to walk around, optimized javascript limits view source’s benefits. Billion dollar SaaS black box as the best option for improving usability of existing tools software seems like digging deeper into present coding’s problems."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1679958556.634899",
        "client_msg_id": "0adb6b06-9067-4b07-9881-afae4be146c4",
        "text": "The points that ChatGPT produced above are quite reasonable. However, the comparison being made is between:\n• Low-code\/no-code tools\n• LLMs that generate code in traditional programming languages (e.g. Python code)\nMany of the listed benefits of no-code tools can be hypothetically be achieved through conventional language design as well. For example, the \"opportunities for FoC researchers\" that I listed in my previous <#C5T9GPWFL|thinking-together> post focus on how to make LLM-generated code easier to understand, accessible to a wider audience, and less error-prone. Those qualities (amongst others) are major selling points of low-code\/no-code tools. My contention is that we — as FoC researchers — can develop new general-purpose programming languages that continue to close the gap between *no-code* and *code* while _embracing_ LLMs as a valuable tool in our tool belt.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679902227.016569",
        "parent_user_id": "U0296ACR13M",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "czL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The points that ChatGPT produced above are quite reasonable. However, the comparison being made is between:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Low-code\/no-code tools"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "LLMs that generate code in traditional programming languages (e.g. Python code)"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nMany of the listed benefits of no-code tools can be hypothetically be achieved through conventional language design as well. For example, the \"opportunities for FoC researchers\" that I listed in my previous "
                            },
                            {
                                "type": "channel",
                                "channel_id": "C5T9GPWFL"
                            },
                            {
                                "type": "text",
                                "text": " post focus on how to make LLM-generated code easier to understand, accessible to a wider audience, and less error-prone. Those qualities (amongst others) are major selling points of low-code\/no-code tools. My contention is that we — as FoC researchers — can develop new general-purpose programming languages that continue to close the gap between "
                            },
                            {
                                "type": "text",
                                "text": "no-code",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "code",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " while "
                            },
                            {
                                "type": "text",
                                "text": "embracing",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " LLMs as a valuable tool in our tool belt."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1679959060.869239",
        "client_msg_id": "fcc4b513-4088-4454-a5d1-81cfc70f40bf",
        "text": "<@U0112C10V4Y> You're asking \"what is the value of reading a program that somebody else has written?\", i.e. what is the value of code review. The answer is well-known, and the second half of my post addresses it in detail.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679892669.316079",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "h1M",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0112C10V4Y"
                            },
                            {
                                "type": "text",
                                "text": " You're asking \"what is the value of reading a program that somebody else has written?\", i.e. what is the value of code review. The answer is well-known, and the second half of my post addresses it in detail."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0296ACR13M",
        "type": "message",
        "ts": "1679982392.919849",
        "edited": {
            "user": "U0296ACR13M",
            "ts": "1679982748.000000"
        },
        "client_msg_id": "a7da686f-ae0b-4e00-bc61-33fc77ddbb00",
        "text": "Very good points. Yes, certainly there are other FoC projects than low-code\/no-code tools and I'm very interested in involving them in this discussion. I just happened to phrase the prompts like that..\n\nValidation is certainly a good aspect to focus on. LLMs can help with validation as well, but the question is whose validation do we trust. It will be a long road to build the trust even after LLMs have the capability to (never?) make mistakes and somehow always understand our intent from ambiguous natural language.. However, the level of validation we currently require for purely human written code varies case by case. I guess it must be the same for AI written code. For a hobby game project you might be fine if the AI generated game just appears to work, for a medical\/military\/aviation device not so much. So I think that if efficiency of validation is the competitive advantage your FoC project relies on, make sure that your project targets domains in which correctness is important.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "59de929720a2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-09-08\/4075674207584_59de929720a2fe0a13d8_72.jpg",
            "first_name": "",
            "real_name": "Jarno Montonen",
            "display_name": "Jarno Montonen",
            "team": "T5TCAFTA9",
            "name": "jarno.montonen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679902227.016569",
        "parent_user_id": "U0296ACR13M",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oNt1A",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Very good points. Yes, certainly there are other FoC projects than low-code\/no-code tools and I'm very interested in involving them in this discussion. I just happened to phrase the prompts like that..\n\nValidation is certainly a good aspect to focus on. LLMs can help with validation as well, but the question is whose validation do we trust. It will be a long road to build the trust even after LLMs have the capability to (never?) make mistakes and somehow always understand our intent from ambiguous natural language.. However, the level of validation we currently require for purely human written code varies case by case. I guess it must be the same for AI written code. For a hobby game project you might be fine if the AI generated game just appears to work, for a medical\/military\/aviation device not so much. So I think that if efficiency of validation is the competitive advantage your FoC project relies on, make sure that your project targets domains in which correctness is important."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0296ACR13M",
        "type": "message",
        "ts": "1679982547.990119",
        "client_msg_id": "c3f2e0d8-aedc-4824-b49c-04ce2b56358a",
        "text": "In one of these LLM threads someone wrote about the room for improvement in some interface (text interface?) and felt confident working on that problem regardless the onslaught of LLMs. I can't find the message anymore, but if someone could point the person this way, I would love to hear more :slightly_smiling_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "59de929720a2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-09-08\/4075674207584_59de929720a2fe0a13d8_72.jpg",
            "first_name": "",
            "real_name": "Jarno Montonen",
            "display_name": "Jarno Montonen",
            "team": "T5TCAFTA9",
            "name": "jarno.montonen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679902227.016569",
        "parent_user_id": "U0296ACR13M",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4M1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In one of these LLM threads someone wrote about the room for improvement in some interface (text interface?) and felt confident working on that problem regardless the onslaught of LLMs. I can't find the message anymore, but if someone could point the person this way, I would love to hear more "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]