<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2018-09-11/433781465829_7c31dc735c6c1257fe1f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Krouse</b>
<span style="margin:2em; color:#606060">2018-11-23 14:27</span><br/>
New experiment... <span style="background-color:#ccf">@Kartik Agaram</span> and I just chatted for the first time. It was quite fun! And we recorded it! I'm curious if anyone watches it and finds value. If so, maybe we'll do it again, and maybe I'll convince others to go on the air with me in casual chats. Thanks Kartik for going out on a limb and trying this with me. Really amazing to finally chat! <a href="https://www.youtube.com/watch?v=DuMdDXCMDk0">https://www.youtube.com/watch?v=DuMdDXCMDk0</a><br/><br/>For reference on what we talked about, here are the notes I took from the convo:<br/><pre style="white-space:pre-wrap"><br/>* first computer experience when he was 18<br/>* studying engineering in India in college<br/>* before he found computers, he was going to do MBA and be business guy<br/>* UT Austin PhD in computer systems (compiler and micro architecture)<br/>  * wanted to re-think *all* the assumptions from the ground up based on what we know about compilers<br/>  * as well as the other direction, redesigning compilers based on ISA architectures<br/>  * it was all very theoretical because nobody was going to use it, because backwards-compatibility has force. who's going to invest in a new processor?<br/>  * we're in a x86-mono culture<br/>* and then Bay area ever since<br/>* my idea of convervatism is don't change things because we don't know why they work: Chesterton's fence. You can't tear it down until you tell me why it was erected in the first place.<br/>  * threading the needle: refactoring a legacy code base with tests and refactoring slowly, incrementalism<br/>* legacy is code no person on your team understands<br/>* he's not an IDE programmer, just a text editor guy... love how he says this outright up front<br/>* all the things you do to see if your code works after you right it is lost unless you encode as a test<br/>* joined Google in 2010 and was disheartening to see how the meat was made<br/>* the code at Google was shit despite great engineers, because it was passed through hands<br/>* law of software: suckage increases over time<br/>* all langauges (python 3, perl 6) go through period of backwards incompatible changes<br/>* big course corrections are a sign of a big mistake<br/>* also applies to countries: USA, Rome<br/>  * coleen mccoulogh historical fiction novels about rome: the first man in Rome<br/>* but the decay in software is not entropy<br/>  * it's more like complexity creep, which is quite similar to law creep<br/>* the deepness in the sky - one of his favorite sci fi books with real programmers<br/>* code runs on the trunk but there should be lot more forking activity....<br/></pre>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543012482.057500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543012482.057500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-23 14:34</span><br/>
The passage I mentioned at the end: <a href="http://akkartik.name/post/deepness">http://akkartik.name/post/deepness</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543018006.058100"></a>
      <img src="https://avatars.slack-edge.com/2018-07-13/399377633206_43873346f949174e340e_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543018006.058100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Felix Kohlgrüber</b>
<span style="margin:2em; color:#606060">2018-11-23 16:06</span><br/>
The notes sound interesting. I'll check the video out tomorrow
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543054999.058500"></a>
      <a href="../share-your-work/1543012054.056800.html#1543054999.058500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Vladimir Gordeev</b>
<span style="margin:2em; color:#606060">2018-11-24 02:23</span><br/>
I like this thought from video that everything eventually gonna suck no matter how perfectly designed it was. And it sounds natural -- designer is a limited human being and can't predict the future.<br/><br/>So support of legacy code and eventual compatability break are inevitable pain.<br/><br/>How can we minimize this pain, make transitions between different generations of code more smooth?<br/><br/>One idea is than we should focus on developing proper interface for building blocks. Independent building blocks allow to migrate code slowly, without painful total rewrite.<br/><br/>Good example of such building block is docker. As long as container communicates through sockets in same way, we can totally rewrite what's inside.<br/><br/>Should we invent a convenient building block, similar to docker container, but smaller? Something easier to compose. Library with C FFI is somewhat similar, but they are unsafe to use.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543069776.062400"></a>
      <img src="https://avatars.slack-edge.com/2018-07-13/399377633206_43873346f949174e340e_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543069776.062400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Felix Kohlgrüber</b>
<span style="margin:2em; color:#606060">2018-11-24 06:29</span><br/>
Really interesting conversation! From time to time, it was hard for me to understand Steve, especially when both of you were talking simultaneously. But that wasn’t a big issue and overall, I really enjoyed listening to your conversation and would like to see more of these.<br/>I wanted to share some of my thoughts on the topics you discussed, but when I started writing them down I realized that they're to many to fit into a slack response. I'll try to organize them into a blog post and post it here once it's ready.<br/>In the meantime, I can share the parts I found most interesting (as a teaser for others to watch the video):<br/>- "Things suck over time. They start out great and they gradually suck more and more over time." (Kartik, 30:30)<br/>- Entropy and decay don’t apply to software like they do to bridges for example (Kartik, 36:30).<br/>- “We need to find a way to periodically reduce complexity …” (Kartik, 36:45)<br/>- “Software is not really like anything we’ve seen before” (Kartik, 39:30)<br/>- “No matter what better system I come up with or you come up with, it’ll have to go through breaking changes and eventually someone will come up with something so much better that it will die.” (Steve, 41:45)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543079558.063300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543079558.063300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-24 09:12</span><br/>
<span style="background-color:#ccf">@Vladimir Gordeev</span> You're right that interfaces are part of the solution. They're the well-understood half, and we certainly can't do without them. They help when the change you want to make is on one side or the other. But what if you want to change the interface itself? If you can't make arbitrary changes to it, it becomes a vector for complexity creep. I think most of the bloat in modern stacks comes from interfaces growing monotonically more complex. Any ideas on how we can stack that problem? :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543082603.063800"></a>
      <img src="https://avatars.slack-edge.com/2019-12-15/861537614034_222a2870915d24ec10cc_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543082603.063800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Vladimir Gordeev</b>
<span style="margin:2em; color:#606060">2018-11-24 10:03</span><br/>
No idea)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543084173.064000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543084173.064000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-24 10:29</span><br/>
Yeah, it's a hard problem. Let me know if you think of anything. Hopefully you're convinced that it's an important problem. (I think it's <em>the</em> most important problem in software.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543084578.064200"></a>
      <img src="https://secure.gravatar.com/avatar/96238acad86155c89f7e5324712c7cb5.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543084578.064200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dinesh</b>
<span style="margin:2em; color:#606060">2018-11-24 10:36</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> agreed its a problem. But do you honestly thinks it's a problem that can ever be solved? If the interface has 2 change for some valid reasons, it obviously induces changes to the things that interface with the interface being changed. Can we avoid that really? Without developing a rigid system? 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543085478.064400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543085478.064400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-24 10:51</span><br/>
Yeah, that's the $64,000 question. And maybe you're right and the problem's just hopelessly over-constrained. To confirm that we need to think about all the assumptions baked into the word 'interface'. To throw out a few:<br/><br/>a) The interfaces we currently rely on are isomorphic with the way we've divided up the labor that goes into producing a working system (because <a href="https://en.wikipedia.org/wiki/Conway%27s_law">https://en.wikipedia.org/wiki/Conway%27s_law</a> applies to open source too). Is that the best set of interfaces possible, or can we reorganize to some smaller set of interfaces? That would transfer more of the problem to the 'easy' side.<br/><br/>b) Right now the interfaces on my system are the same as the interfaces on yours. Is that really necessary? Does my laptop <em>really</em> need the latest hyper-optimizations for http added by Google to serve 2% more requests per dollar per watt in their data centers? Even worse, does the software on my laptop really need layers and layers of compatibility for processors it will never ever encounter?<br/><br/>My goal is not a rigid system. My goal is a <em>rewrite-friendly</em> system, one where you don't pay for what you don't use. One where all the pieces are designed to work well together -- and <em>not at all designed to work well with anything outside</em>. (We have protocols for that, if you include things like unicode in that category.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543091012.064800"></a>
      <img src="https://secure.gravatar.com/avatar/96238acad86155c89f7e5324712c7cb5.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543091012.064800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dinesh</b>
<span style="margin:2em; color:#606060">2018-11-24 12:23</span><br/>
If I understand that stmt correctly, your goal is a rewrite friendly system where (even when) changing interfaces is a Non breaking change? Or is, as friendly as possible? IMHO, some of this is a reflection of nature. There is always some amt of  friction and tension at the boundaries (of any two things. 2 persons, 2 teams, 2 components, nations etc. Maybe cuz of diff in purposes). I am genuinely curious to see how this can be solved and how scalable the solution would be. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543091728.065000"></a>
      <img src="https://avatars.slack-edge.com/2018-07-13/399377633206_43873346f949174e340e_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543091728.065000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Felix Kohlgrüber</b>
<span style="margin:2em; color:#606060">2018-11-24 12:35</span><br/>
I would add that interface changes rarely remove support for previously supported use-cases. Most breaking changes are just because you have to do things differently. In these cases, you could use tooling that automatically upgrades your code to use the new interface.<br/>If an interface changes, all uses of it need to change as well. There might be no way around this. But what you could do is to make the upgrade process as smooth as possible. I suspect that given the right tools, 90% of backwards-incompatible changes could be resolved automatically.<br/>Interfaces are a very wide field and it's hard to give a general answer. Do you have specific tricky interfaces in mind?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543098835.070300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543098835.070300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-24 14:33</span><br/>
I should clarify: I actually want to support removing features. I think every system should. Even if you the author care about all the features, someone else may not. It should be easy to fork and remove the feature. Now users can choose which fork to use. That seems like a good thing.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543099997.070500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543099997.070500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-24 14:53</span><br/>
Vim has this nice ability to build vim-tiny or vim-large or even more fine-grained combinations of features. Unfortunately it's done with a rat's nest of <tt>#ifdef</tt>s, so you still pay the comprehension cost for all features. What if Vim wasn't a single repo but a family of lazily created and maintained forks?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543135401.071400"></a>
      <img src="https://avatars.slack-edge.com/2018-07-13/399377633206_43873346f949174e340e_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543135401.071400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Felix Kohlgrüber</b>
<span style="margin:2em; color:#606060">2018-11-25 00:43</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> I agree. The problem I see with forking is that even if you want just a tiny change, you need to fork the whole project and then need to maintain it / update it yourself. What if forking could be done in a more fine-grained manner (e.g. on a per-function basis)? I think that this could make maintaining forks easier and prevent them drifting apart until they cannot be reunited anymore.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543149344.071600"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543149344.071600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-25 04:35</span><br/>
Great question! I'm not sure here, and we need a lot more experimentation, but my current sense is that encouraging forking will tend to create larger units of deployment, not smaller ones. While it increases the effort of creating a fork and may be more inefficient in resource usage as you point out, it actually simplifies <em>selecting</em> and <em>using</em> forks. In the limit, putting together a system becomes a problem of just choosing from N forks of the whole system, rather than choosing from M^N combinations of forks (one per function). Because many combinations will be broken, some very subtly so. Treating the whole system as a unit of forking lets a group with shared usage patterns collaborate on a common system, ironing out issues for each other. Problems become internal rather than external, which seems the preferable kind of problem to have.<br/><br/>But perhaps I'm being insufficiently radical and just unwilling to make the larger conceptual leap :slightly_smiling_face: Maybe we should learn more about the theory for segmenting consumers into markets. Right now we have a handful of consumer segments when it comes to software, called <em>Linux</em>, <em>Windows</em>, etc. The small number isn't sufficiently addressing people's needs. The question is what's the sweet spot.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543161718.071900"></a>
      <img src="https://avatars.slack-edge.com/2018-07-13/399377633206_43873346f949174e340e_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543161718.071900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Felix Kohlgrüber</b>
<span style="margin:2em; color:#606060">2018-11-25 08:01</span><br/>
Ah I see where you're going. That's interesting and I didn't think in that direction. It might really depend on how similar usage patterns in a project / community are.<br/>If you think about data visualization in Python for example, there are dozens of libraries that all create plots in slightly different ways. Most of them are incompatible to each other, and common features have to be implemented individually by each project. That's a waste of effort and I'm not sure whether it's necessary.<br/>You're right that smaller projects might make forming communities more difficult / scattered. That's a human factor that might have a larger influence than I thought.<br/>The most radical thing would be to not make any individual projects at all. I think I've said that before on this slack, but I find Wikipedia's approach interesting. It's just one large community that incrementally improves and extends the knowledge of the system. Because there are no individually-owned projects, it would be easy to identify and refactor duplications etc. Having one large community wouldn't mean that everyone has to understand everything, but it might encourage documenting knowledge about a system such that it's approachable and compatible.<br/>One important difference is of course that other than text, code breaks easily by incompatible changes. I wonder if this could be improved by using tests to decide whether a change is breaking anything and then requiring a manual update. This could prevent non-popular code from breaking by accident.<br/>I don't know what's going to work out. I think that smaller projects / forks allow better reuse, and larger projects / forks might be easier to collaborate on. I'm looking forward to discuss this further :wink:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543183104.072100"></a>
      <img src="https://avatars.slack-edge.com/2021-10-04/2564854327154_7acd71947ea203e9a69b_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543183104.072100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joe Trellick</b>
<span style="margin:2em; color:#606060">2018-11-25 13:58</span><br/>
Just a quick comment to say that I enjoyed the discussion, especially Kartik's idea that failure of knowledge transfer is one of the big factors in making our systems worse as the individuals constituting an organization swap out. (And I also love Vinge's programmer-archeologists.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543184201.072400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543184201.072400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-25 14:16</span><br/>
<span style="background-color:#ccf">@Joe Trellick</span> Yeah, I'm a lot less certain of my ideas for solutions (which I didn't get to in this episode), but I'd like people to think a lot harder about the entire life cycle of a software project, including what happens when new people start contributing.<br/><br/><span style="background-color:#ccf">@Dinesh</span> I'm still thinking about your comment. Basically I'm observing that while we think of interfaces as separating two people, they often have a single <em>user</em> on both sides. And as users our laptops have not just one interface but a honeycomb of interfaces. One way to see my proposal is as a call for more Apple-like integration, where somebody takes charge of the entire stack and makes sure it works well together. However, this is even harder than Apple's case, because Apple focuses only on the exterior/interface of things, whereas the goal here is hackability, for internals to be easy to understand as well. It's pretty much prohibitive to do in a centralized way. All my other ideas kinda stem from this constraint.<br/><br/><span style="background-color:#ccf">@Felix Kohlgrüber</span> Provocative thoughts. A couple of off-the-cuff reactions:<br/><br/>a) Different levels of the stack already work pretty differently. My old laptop has the same Ubuntu distro for six years now, and I can compile Vim from 1997 on it. On the other hand the Rails/Node eco-systems and Chrome are constantly introducing breaking changes. Upper levels seem to have different trade-offs, and that will probably be the same in my ideal world as well.<br/><br/>b) I'm not concerned so much with avoiding breakage as making breakage easy for end users to recover from.<br/><br/>c) Larger projects can be just as easy to collaborate on. Are you seeing any particular areas where they're at a disadvantage? For example, our recent virtualization advances (VMs, jails, containers, etc.) make it easy to try out a new 'version' of one's laptop before committing to it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543185808.072900"></a>
      <img src="https://avatars.slack-edge.com/2018-07-13/399377633206_43873346f949174e340e_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543185808.072900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Felix Kohlgrüber</b>
<span style="margin:2em; color:#606060">2018-11-25 14:43</span><br/>
Not sure I understood b), could you elaborate?<br/>For c), I actually wanted to say that larger projects are easier to collaborate on than really small ones, agreeing with what you've said before. Larger projects -&gt; Fewer projects -&gt; More people working on the same project.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543214939.073400"></a>
      <img src="https://avatars.slack-edge.com/2019-12-15/861537614034_222a2870915d24ec10cc_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543214939.073400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Vladimir Gordeev</b>
<span style="margin:2em; color:#606060">2018-11-25 22:48</span><br/>
&gt; especially Kartik's idea that failure of knowledge transfer is one of the big factors in making our systems worse as the individuals constituting an organization swap out<br/><br/>So when people develop a system they form an image of the system in their head, how it supposed to work. They leave bits of this knowledge in names of the variables and functions, in brief comments. But they don't dump this kind of knowledge into documentation -- for some reason it's very inconvenient and slow. Then they leave, and next people need to rebuild this image of the system again, from little leftover artifacts: names of variables and functions, brief comments, outdated documentation.<br/><br/>What if there was a tool that provided convenient space to describe image of the system? From which parts it consists of, what parts should never communicate, what parts should never depend on each other. Something like knowledge system or structured documentation. Textual documentation is generated from this thing.<br/><br/>Code can be checked against constraints described in this kind of structured documentation. This allows to keep it up to date.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543221206.073800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543221206.073800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-26 00:33</span><br/>
1. You need to describe not just the system but the environment it is expected to operate in. That can get complex, because you may need to create arbitrarily detailed models for slices of the world/universe, depending on what your program does. There's already a fairly decent way we communicate models of the world to each other. It's called language. (While a picture can convey a thousand words, pictures are usually used in fairly narrow ways established by convention (like maps). For describing arbitrary situations, language and text are unparalleled in their breadth and applicability.)<br/><br/>2. How do you ensure the image/knowledge/documentation stays up to date? There's one sorta decent way we know to do this: it's called tests. This is meta code about the program that runs before committing any change; it ensures that the various 'descriptions' of the system are all in sync and internally consistent. (You could also do this with formal methods; perhaps that was what you were referring to as "constraints described in structured documentation"?[1] I'm not aware of broadly applicable systems for theorem proving that do this. But I'm not an expert in this area.)<br/><br/>[1] If they're structured and automatically checked, I'd rather not call them "documentation".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1543224998.076800"></a>
      <img src="https://avatars.slack-edge.com/2019-12-15/861537614034_222a2870915d24ec10cc_72.jpg" style="float:left"/>
      <a href="../share-your-work/1543012054.056800.html#1543224998.076800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Vladimir Gordeev</b>
<span style="margin:2em; color:#606060">2018-11-26 01:36</span><br/>
I don't have clear understanding what I'm describing either.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
