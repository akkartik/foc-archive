[
    {
        "user": "U02QC0PPER3",
        "type": "message",
        "ts": "1748124014.443639",
        "client_msg_id": "8958d938-d934-4590-a572-19a83adf560e",
        "text": "I've read the central paper on Algot: \"<https:\/\/people.inf.ethz.ch\/~sverrirt\/pdf\/syntaxsemanticsgap2022.pdf|Bridging the Syntax-Semantics Gap of Programming>\". Salient points [my opinions bracketed]:\n\nIt's PBDemonstration, where user conveys intent by actions, and not PBExample where intent is inferred from before\/after or input\/output pairs.  They attack the gap _during program construction_, admit it's weak for later comprehension.\n\nState is _graph_ with nodes containing numbers (to be extended in future).  Graph for pedagogical reasons — covers structures they want to teach + visualization is _universally understood_.\n[Target audience not explicitly stated; seems to be for beginning CS students? I'm personally more interested in PBD for end-user programming; but then I wouldn't teach them linked lists or binary search trees...]\n\nIt's showing concrete data when directly-manipulating top-level state. :cake:\nBut when demonstrating a procedure (\"helper\"), in Input stage you denote parameters (+ pattern matching) by adding \"abstract\" nodes. IIUC new nodes created during your hepler are also abstract? Unlike concrete state nodes, you won't see abstracts' value at Action stage :see_no_evil:, only their label letter.  (Also, not all nodes will exist in all executions ⌥)\n[This is serious unsolved gap! Inherent question of how PBD can be parametrized — you don't see _actual_ semantics, but some ≈symbolic approximation.]\nThey aspire to improve this in future by letting you pick example inputs and see actual values [they cite <https:\/\/arxiv.org\/abs\/1902.00549> which is good read and <https:\/\/fermatslibrary.com\/s\/ancient-babylonian-algorithms|wonderfully>-motivated title]\n\nThey believe nested conditionals and loops to be confusing for beginners.\n=&gt; No loops, only recursion.\n=&gt; Boolean checks can only be made in Query stage before procedure starts (pro: order doesn't matter), and then Action stage code is *flat*, with *optional predication* — each step may be conditioned on each query being true\/false\/don't care.  [Heresy #1 :thinking_face: Personally I'm skeptical flatness scales well to complex codebases?]\n  Con: if you need checks and\/or pattern matching depending on prior checks, you'll want to extract a 2nd procedure.  Each procedure has Input+Query stages, so not really as flat as it sounds!   (technically they reduce the need by allowing empty-set pattern matches [?] but they admit guard-before-access is mentally clearer.)\n\n[Most interesting heresy :clap::open_mouth: #2, emphasis mine:]\n&gt; 4.1 State Should Be Relatable, Visible and Editable\n&gt; ... Conventional imperative languages such as C, Java, and C#, also separate state into local variables on the stack and objects living on the heap. This separation can be confusing and lead to misunderstandings.\n&gt; ... Even systems designed for beginners like Scratch tend to scatter state by maintaining variables, position for individual objects, or drawings on screen. *We believe that a scattered state leads to additional cognitive overhead and instead intend to maintain a single central state. Algot avoids variables as separate entities from other state.*\n• Instead of local variables, one is supposed to insert a new (disconnected) node to the global graph, mutate\/grow connections, and remove it from the graph when done.   (you do bind a local name to it, but that's immutable — the state lives in node's content and connections, and cosmetic — you don't really reference by name, you click it)\n• They didn't 100% banish scattered stack state: Procedure parameters get bound (by ref.) to concrete nodes given as arguments — so there are hidden activation records somewhere.\n• The recursive examples given do materialize in global state parts of what'd usually be implicit in stack :+1:.  E.g. fibonacci works with explicit linked list of prior results.  Is this purely stylistic?  No, it's encouraged by IIUC *not having return values!*  [interesting heresy #3! :open_mouth:]  Procedures can \"return\" results by mutating the global state graph (possibly via output parameter pointing there).  Even builtins like \"add\" take assembly-like src1, src2, dest.\n[All in all, my first instinct was to protest, but the goals are interesting and the choices nicely provocative :thinking_face:]",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "90c9108c61f5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-12\/2854686602576_90c9108c61f5d809eb8a_72.jpg",
            "first_name": "Beni",
            "real_name": "Beni Cherniavsky-Paskin",
            "display_name": "Beni Cherniavsky-Paskin",
            "team": "T5TCAFTA9",
            "name": "beni.cherniavsky",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1745928482.524589",
        "parent_user_id": "U02QC0PPER3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oWL9H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've read the central paper on Algot: \""
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/people.inf.ethz.ch\/~sverrirt\/pdf\/syntaxsemanticsgap2022.pdf",
                                "text": "Bridging the Syntax-Semantics Gap of Programming"
                            },
                            {
                                "type": "text",
                                "text": "\". Salient points [my opinions bracketed]:\n\nIt's PBDemonstration, where user conveys intent by actions, and not PBExample where intent is inferred from before\/after or input\/output pairs.  They attack the gap "
                            },
                            {
                                "type": "text",
                                "text": "during program construction",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", admit it's weak for later comprehension.\n\nState is "
                            },
                            {
                                "type": "text",
                                "text": "graph",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with nodes containing numbers (to be extended in future).  Graph for pedagogical reasons — covers structures they want to teach + visualization is"
                            },
                            {
                                "type": "text",
                                "text": " universally understood",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n[Target audience not explicitly stated; seems to be for beginning CS students? I'm personally more interested in PBD for end-user programming; but then I wouldn't teach them linked lists or binary search trees...]\n\nIt's showing concrete data when directly-manipulating top-level state. "
                            },
                            {
                                "type": "emoji",
                                "name": "cake",
                                "unicode": "1f370"
                            },
                            {
                                "type": "text",
                                "text": "\nBut when demonstrating a procedure (\"helper\"), in Input stage you denote parameters (+ pattern matching) by adding \"abstract\" nodes. IIUC new nodes created during your hepler are also abstract? Unlike concrete state nodes, you won't see abstracts' value at Action stage "
                            },
                            {
                                "type": "emoji",
                                "name": "see_no_evil",
                                "unicode": "1f648"
                            },
                            {
                                "type": "text",
                                "text": ", only their label letter.  (Also, not all nodes will exist in all executions ⌥)\n[This is serious unsolved gap! Inherent question of how PBD can be parametrized — you don't see "
                            },
                            {
                                "type": "text",
                                "text": "actual",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " semantics, but some ≈symbolic approximation.]\nThey aspire to improve this in future by letting you pick example inputs and see actual values [they cite "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/arxiv.org\/abs\/1902.00549"
                            },
                            {
                                "type": "text",
                                "text": " which is good read and "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/fermatslibrary.com\/s\/ancient-babylonian-algorithms",
                                "text": "wonderfully"
                            },
                            {
                                "type": "text",
                                "text": "-motivated title]\n\nThey believe nested conditionals and loops to be confusing for beginners.\n=> No loops, only recursion.\n=> Boolean checks can only be made in Query stage before procedure starts (pro: order doesn't matter), and then Action stage code is "
                            },
                            {
                                "type": "text",
                                "text": "flat",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", with "
                            },
                            {
                                "type": "text",
                                "text": "optional predication",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — each step may be conditioned on each query being true\/false\/don't care.  [Heresy #1 "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            },
                            {
                                "type": "text",
                                "text": " Personally I'm skeptical flatness scales well to complex codebases?]\n  Con: if you need checks and\/or pattern matching depending on prior checks, you'll want to extract a 2nd procedure.  Each procedure has Input+Query stages, so not really as flat as it sounds!   (technically they reduce the need by allowing empty-set pattern matches [?] but they admit guard-before-access is mentally clearer.)\n\n[Most interesting heresy "
                            },
                            {
                                "type": "emoji",
                                "name": "clap",
                                "unicode": "1f44f"
                            },
                            {
                                "type": "emoji",
                                "name": "open_mouth",
                                "unicode": "1f62e"
                            },
                            {
                                "type": "text",
                                "text": " #2, emphasis mine:]\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "4.1 State Should Be Relatable, Visible and Editable\n... Conventional imperative languages such as C, Java, and C#, also separate state into local variables on the stack and objects living on the heap. This separation can be confusing and lead to misunderstandings.\n... Even systems designed for beginners like Scratch tend to scatter state by maintaining variables, position for individual objects, or drawings on screen. "
                            },
                            {
                                "type": "text",
                                "text": "We believe that a scattered state leads to additional cognitive overhead and instead intend to maintain a single central state. Algot avoids variables as separate entities from other state.",
                                "style": {
                                    "bold": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Instead of local variables, one is supposed to insert a new (disconnected) node to the global graph, mutate\/grow connections, and remove it from the graph when done.   (you do bind a local name to it, but that's immutable — the state lives in node's content and connections, and cosmetic — you don't really reference by name, you click it)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "They didn't 100% banish scattered stack state: Procedure parameters get bound (by ref.) to concrete nodes given as arguments — so there are hidden activation records somewhere."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The recursive examples given do materialize in global state parts of what'd usually be implicit in stack "
                                    },
                                    {
                                        "type": "emoji",
                                        "name": "+1",
                                        "unicode": "1f44d"
                                    },
                                    {
                                        "type": "text",
                                        "text": ".  E.g. fibonacci works with explicit linked list of prior results.  Is this purely stylistic?  No, it's encouraged by IIUC "
                                    },
                                    {
                                        "type": "text",
                                        "text": "not having return values!",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "  [interesting heresy #3! "
                                    },
                                    {
                                        "type": "emoji",
                                        "name": "open_mouth",
                                        "unicode": "1f62e"
                                    },
                                    {
                                        "type": "text",
                                        "text": "]  Procedures can \"return\" results by mutating the global state graph (possibly via output parameter pointing there).  Even builtins like \"add\" take assembly-like src1, src2, dest."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n[All in all, my first instinct was to protest, but the goals are interesting and the choices nicely provocative "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            },
                            {
                                "type": "text",
                                "text": "]"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1748141330.807539",
        "client_msg_id": "208f1411-ee06-4a86-a75d-690978cce709",
        "text": "What is 'semantics'? It seems to me that 'semantics' is a set of operations which can be composed to explain useful concepts, and\/or perform useful work. 'Semantic' description of some useful concept can be composed of: {opcodes | scripts-composed-of-opcopes | scripts-composed-of-other-scripts}. To me 'syntax' is just a handy notation draped over such opcodes and scripts. For example, Feynman Diagram syntax consists of squiggly lines, software syntax consists of text draped over fundamental opcodes. I'm fooling with using Python as a semantic substrate and using t2t to drape various syntaxes (DPL and TPL (Diagrammatic PLs and Textual PLs)) over the underlying semantics.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747153874.428279",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T97yy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What is 'semantics'? It seems to me that 'semantics' is a set of operations which can be composed to explain useful concepts, and\/or perform useful work. 'Semantic' description of some useful concept can be composed of: {opcodes | scripts-composed-of-opcopes | scripts-composed-of-other-scripts}. To me 'syntax' is just a handy notation draped over such opcodes and scripts. For example, Feynman Diagram syntax consists of squiggly lines, software syntax consists of text draped over fundamental opcodes. I'm fooling with using Python as a semantic substrate and using t2t to drape various syntaxes (DPL and TPL (Diagrammatic PLs and Textual PLs)) over the underlying semantics."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]