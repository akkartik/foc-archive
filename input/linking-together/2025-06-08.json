[
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1749381034.772039",
        "edited": {
            "user": "U07BD7U4S4R",
            "ts": "1749381089.000000"
        },
        "client_msg_id": "89a330ee-67d9-42ce-9bde-f62798099e32",
        "text": "I am looking at *this* (semantic-tree vs lines of text) from the developer pov.\nAnd from where I am right now, and have been during 20+ years of professional programming (languages, tools, communities, companies, projects, news feeds, programming fads and fashions, open source libraries, IDEs) – all I see and experience is lines-of-text centric development, even though some aspects are noticeably tree-manipulation flavored (but those fallback to line-manipulation immediately).\nI understand, that *this* is matter of individual circumstances and perspective, but want to point out that your chances of stumbling into tree-manipulation-centric development environment (idk, e.g. Unison, Smalltalk), as a student, junior or even senior dev, are ~0. And this is, I claim, the consequence of \"<https:\/\/www.oilshell.org\/cross-ref.html?tag=narrow-waist#narrow-waist|narrow waists>\", where \"file of ascii text or json are fine for everything\" first saves you \"how do I slap something together quickly\", but almost immediately cost you \"yeah, I want to do E, but gotta do A B C D steps first *again* because it is just text file.\": parsing for syntax highlight, for layout, for semantics extraction, for find-replace, for rename.\n\nre: \"LISP was always about processing of linked lists\" – this is only A from A B C D etc. steps required for \"complete picture\" provided out the box. As I wrote above, heap of lists of lists of tokens is never enough to know what's up.\n\nre: clojure is not a lisp – from the \"lisp is linkedlists manipulation\" pov, I don't see a difference (and maybe this is main reason I don't see tree-centric development anywhere):\n```(->>\n  \"(if pred (inc 1) (dec 0))\"\n  read-string)\n\n=> (if pred (inc 1) (dec 0))```\n```(->>\n  \"(if pred (inc 1) (dec 0))\"\n  read-string\n  (tree-seq seq? seq)\n  (map (juxt type identity)))\n=>\n([clojure.lang.PersistentList (if pred (inc 1) (dec 0))]\n [clojure.lang.Symbol if]\n [clojure.lang.Symbol pred]\n [clojure.lang.PersistentList (inc 1)]\n [clojure.lang.Symbol inc]\n [java.lang.Long 1]\n [clojure.lang.PersistentList (dec 0)]\n [clojure.lang.Symbol dec]\n [java.lang.Long 0])```\nAgain - this gives me 0 semantic information, like \"either (inc 1) or (dec 0) is executed, but never both\".\nit can inform some of syntax highlighting, but not many interesting ones: which symbol is from stdlib, and which is not; which is defined, and which is not; is it just a list, or is it a call, macro call, or function call? any known side effects during call, or 100% known pure fn call (to a degree anything can be pure in jvm)?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0343f70ca57",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-07-04\/7377091009748_d0343f70ca57c18eeb41_72.png",
            "first_name": "misha",
            "real_name": "misha",
            "display_name": "misha",
            "team": "T5TCAFTA9",
            "name": "misha.akovantsev",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747153874.428279",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hltbv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am looking at "
                            },
                            {
                                "type": "text",
                                "text": "this",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (semantic-tree vs lines of text) from the developer pov.\nAnd from where I am right now, and have been during 20+ years of professional programming (languages, tools, communities, companies, projects, news feeds, programming fads and fashions, open source libraries, IDEs) – all I see and experience is lines-of-text centric development, even though some aspects are noticeably tree-manipulation flavored (but those fallback to line-manipulation immediately).\nI understand, that "
                            },
                            {
                                "type": "text",
                                "text": "this",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is matter of individual circumstances and perspective, but want to point out that your chances of stumbling into tree-manipulation-centric development environment (idk, e.g. Unison, Smalltalk), as a student, junior or even senior dev, are ~0. And this is, I claim, the consequence of \""
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.oilshell.org\/cross-ref.html?tag=narrow-waist#narrow-waist",
                                "text": "narrow waists"
                            },
                            {
                                "type": "text",
                                "text": "\", where \"file of ascii text or json are fine for everything\" first saves you \"how do I slap something together quickly\", but almost immediately cost you \"yeah, I want to do E, but gotta do A B C D steps first "
                            },
                            {
                                "type": "text",
                                "text": "again",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " because it is just text file.\": parsing for syntax highlight, for layout, for semantics extraction, for find-replace, for rename.\n\nre: \"LISP was always about processing of linked lists\" – this is only A from A B C D etc. steps required for \"complete picture\" provided out the box. As I wrote above, heap of lists of lists of tokens is never enough to know what's up.\n\nre: clojure is not a lisp – from the \"lisp is linkedlists manipulation\" pov, I don't see a difference (and maybe this is main reason I don't see tree-centric development anywhere):\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(->>\n  \"(if pred (inc 1) (dec 0))\"\n  read-string)\n\n=> (if pred (inc 1) (dec 0))"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(->>\n  \"(if pred (inc 1) (dec 0))\"\n  read-string\n  (tree-seq seq? seq)\n  (map (juxt type identity)))\n=>\n([clojure.lang.PersistentList (if pred (inc 1) (dec 0))]\n [clojure.lang.Symbol if]\n [clojure.lang.Symbol pred]\n [clojure.lang.PersistentList (inc 1)]\n [clojure.lang.Symbol inc]\n [java.lang.Long 1]\n [clojure.lang.PersistentList (dec 0)]\n [clojure.lang.Symbol dec]\n [java.lang.Long 0])"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Again - this gives me 0 semantic information, like \"either (inc 1) or (dec 0) is executed, but never both\".\nit can inform some of syntax highlighting, but not many interesting ones: which symbol is from stdlib, and which is not; which is defined, and which is not; is it just a list, or is it a call, macro call, or function call? any known side effects during call, or 100% known pure fn call (to a degree anything can be pure in jvm)?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1749385776.534189",
        "client_msg_id": "212c6085-0920-4553-b082-8349c518a630",
        "text": "... trying to better understand ...\n\nOriginally, Lisp did not have \"if\". It only had \"COND\".\n\n`(if pred (inc 1) (dec 0))` would be written as:\n\n```(COND \n  (pred (inc 1))\n  (t        (dec 0)))```\nCOND is _specified_ to work sequentially top-down and fire only the first non-nil 'pred' that it finds.\n\nModern FP techniques try to expunge prioritization among other restrictions. I think that the FP mindset is too limiting.\n\nBTW, as a student, I did write myself a <https:\/\/archive.org\/details\/dr_dobbs_journal_vol_04_201803\/page\/n9\/mode\/2up|tree-oriented editor for pre-Common-Lisp, pre-Scheme lisp> (pages 339-343). I thought in terms of the internal data structure instead of the Gutenberg type-set form.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747153874.428279",
        "parent_user_id": "ULM3U6275",
        "attachments": [
            {
                "image_url": "https:\/\/archive.org\/services\/img\/dr_dobbs_journal_vol_04_201803",
                "image_width": 180,
                "image_height": 233,
                "image_bytes": 14067,
                "from_url": "https:\/\/archive.org\/details\/dr_dobbs_journal_vol_04_201803\/page\/n9\/mode\/2up",
                "service_icon": "https:\/\/archive.org\/favicon.ico",
                "thumb_url": "https:\/\/archive.org\/services\/img\/dr_dobbs_journal_vol_04_201803",
                "thumb_width": 180,
                "thumb_height": 233,
                "id": 1,
                "original_url": "https:\/\/archive.org\/details\/dr_dobbs_journal_vol_04_201803\/page\/n9\/mode\/2up",
                "fallback": "Internet Archive: Dr. Dobb's Journal - Vol 4 : People's Computer Company : Free Download, Borrow, and Streaming : Internet Archive",
                "text": "Collected issues from Volume 4 (1979) of Dr. Dobb’s Journal of COMPUTER Calisthenics &amp; Orthodontia also known as DDJ.A Reference Journal for Users of Home...",
                "title": "Dr. Dobb's Journal - Vol 4 : People's Computer Company : Free Download, Borrow, and Streaming : Internet Archive",
                "title_link": "https:\/\/archive.org\/details\/dr_dobbs_journal_vol_04_201803\/page\/n9\/mode\/2up",
                "service_name": "Internet Archive"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nLV2T",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... trying to better understand ...\n\nOriginally, Lisp did not have \"if\". It only had \"COND\".\n\n"
                            },
                            {
                                "type": "text",
                                "text": "(if pred (inc 1) (dec 0))",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " would be written as:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(COND \n  (pred (inc 1))\n  (t        (dec 0)))"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCOND is "
                            },
                            {
                                "type": "text",
                                "text": "specified",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to work sequentially top-down and fire only the first non-nil 'pred' that it finds.\n\nModern FP techniques try to expunge prioritization among other restrictions. I think that the FP mindset is too limiting.\n\nBTW, as a student, I did write myself a "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/archive.org\/details\/dr_dobbs_journal_vol_04_201803\/page\/n9\/mode\/2up",
                                "text": "tree-oriented editor for pre-Common-Lisp, pre-Scheme lisp"
                            },
                            {
                                "type": "text",
                                "text": " (pages 339-343). I thought in terms of the internal data structure instead of the Gutenberg type-set form."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "fire",
                "users": [
                    "U07BD7U4S4R"
                ],
                "count": 1
            }
        ]
    },
    {
        "text": "but invalid or *missing* paren is a lines-of-text problem, not a tree problem : )",
        "files": [
            {
                "id": "F090VFCCR2M",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "U07BD7U4S4R",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FGbKs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "but invalid or "
                            },
                            {
                                "type": "text",
                                "text": "missing ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "paren is a lines-of-text problem, not a tree problem : )"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1749390162.732289",
        "client_msg_id": "3cad6b34-e382-478b-abcd-caadf5cdb1c6",
        "thread_ts": "1747153874.428279",
        "parent_user_id": "ULM3U6275"
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1749391532.739839",
        "client_msg_id": "41e30e69-e2f5-4b97-b573-69986d5bcb34",
        "text": "Yes, missing parens is a problem with the Gutenbergian text-set representation of trees.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747153874.428279",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TMRcr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, missing parens is a problem with the Gutenbergian text-set representation of trees."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]