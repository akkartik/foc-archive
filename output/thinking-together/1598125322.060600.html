<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2020-08-22 12:42</span><br/>
<b>Imperative programming and math pedagogy:</b><br/>TLDR; converting an algorithm or concept from a research paper into imperative code is often seen as tedious, but I think the process helps with learning and clarifying understanding. This is an underrated advantage of imperative code.<br/><br/>Thoughts? Do you agree or disagree? How can this idea of "reification" of algorithms be extended to other paradigms?<br/><br/><b>The long version:</b><br/>I am a big fan of Coding Adventures by Sebastian Lague. He just release a new video: <a href="https://www.youtube.com/watch?v=DxfEbulyFcY">https://www.youtube.com/watch?v=DxfEbulyFcY</a><br/><br/>He skims over the details (the videos are more edutainment than true in depth education), but a strategy he seems to follow is to look at the top research papers on a subject, take the key equations, and implement those equations as shaders in Unity with HLSL i.e. a C derivative language.<br/><br/>This is a technique I'm very familiar with. I assume many people here are familiar with it as well. It can be tedious work to do this kind of translation, but it's hugely useful. I find that after doing a translation like that, I often have a much stronger understanding of the concept.<br/><br/>The way I truly understood integrals and summations was through implementing them as for loops.<br/><br/>I didn't understand monads and combinators until I implemented a parser combinator in an imperative language. In PHP no less. I was young and naive :stuck_out_tongue:.<br/><br/>Many people in this community are fans of functional programming; there have been quite a few threads about ways to encode algorithms more effectively or "true to their mathematical form:" everything from APL to natural language to category theory.<br/><br/>This is a counterpoint against always looking for the "most efficient way" to encode an algorithm.<br/><br/>There is something about taking something "functional" and reifying it into a series of imperative steps that helps understanding a concept, at least for my personal learning style.<br/><br/>I have very little experience with visual programming, but things like Factorio (mentioned recently), make me think that reification as learning tool can be just as effective in the visual paradigm. How can this idea of "reification" of algorithms be extended to other paradigms, or taken into account more generally?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598128463.060900"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598128463.060900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-08-22 13:34</span><br/>
I'll rewrite your statement slightly: "Implementing an algorithm or concept from a research paper as code that you have written from scratch is a process that helps with learning and clarifying understanding." No need to restrict this to imperative code. One trick I use to understand a difficult research paper is to write out the concepts in my own language (in English, I mean).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598128588.061200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598128588.061200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-08-22 13:36</span><br/>
Of course, when you write code as a way of learning or understanding someone else's ideas, you should code in a language and style that you understand very well, and feel most comfortable in. For many people, that will be imperative code. That may be because the first programming language most people learn is imperative. Whether imperative programming is inherently easier to understand than function programming is a separate issue.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598128706.061400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598128706.061400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-08-22 13:38</span><br/>
Yeah, I agree with Doug. While my personal experience agrees with Ray's, I have to conclude after looking around that the phrase "personal learning style" is key.<br/><br/>There's some overlap between this thread and my pet pedagogical approach of learning things bottom up. I found it easier to learn Haskell by ignoring layout rules and infix operators, and explicitly specifying the bounds of each function call.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598130823.061800"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598130823.061800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2020-08-22 14:13</span><br/>
These are all great points. You are right to emphasize "personal learning style". (Maybe I should have emphasized that more.) The more I contemplate, the more I think that the important part is reification; making a concrete "thing".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598168499.063100"></a>
      <a href="../thinking-together/1598125322.060600.html#1598168499.063100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-08-23 00:41</span><br/>
FWIW, I watched this coding adventure yesterday; I'm a big fan of his and always wonder how he puts together such great videos - he seems to bend Unity to his will for the teaching parts as well as the rendering parts.  I have coincidentally implemented the same approach in the paper he used, as part of a game prototype I was playing with (some eye candy enclosed - must revisit this project at some point!)<br/>My approach is probably slightly different though.  I'm  more of an 'implementer' than a scientist/academic, and I often struggle with hard math.  My approach is typically to iterate towards a goal in very small steps without getting bogged down in the detail; and it can take several days to get through the technical challenge.  I'm in awe of anyone who can read a paper full of Integrals and translate it to code.  That would be highly efficient!  I rely on following my nose and looking at sample code far more than the math.<br/>Part of the reason I'm always messing with visualization tools and visual programming is that they are the only chance I have to understand.<br/>"The way I truly understood integrals and summations was through implementing them as for loops." This + 1000, basically :wink:<br/>And Monads.... I've read a few articles, but until I actually get to use one in a program I won't understand them.<br/>Perhaps Sebastien is just really smart (I'm sure he is), but what intrigues me is, has he got to that place by building a set of tools and technologies around himself, such that he can break any problem up into pieces he understands?  i.e. The fact that he can plot and interact with graphs while building his code gives him a deeper/quicker understanding of each step?  Just more validation of Bret Victor's approach, I guess....
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598170104.064000"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598170104.064000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-08-23 01:08</span><br/>
Quoting Donald Knuth (source: <a href="http://www.jstor.org/stable/2318994">http://www.jstor.org/stable/2318994</a>): "It has often been said that a person does not really understand something until he teaches it to someone else. Actually a person does not really understand something until he can teach it to a computer, i.e. express it as an algorithm. The attempt to formalize things as algorithms leads to a much deeper understanding than if we simply try to comprehend things in the traditional way."
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598182224.064600"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598182224.064600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2020-08-23 04:30</span><br/>
Re: personal style, I find mathematical concepts to be much more naturally expressed using functional programming rather than imperative, but no matter one's preferred style it seems clear to me that programming is <a href="https://www.bootstrapworld.org">a better vehicle for teaching mathematics</a> than the standard mathematical pedagogy. Likewise, I'm in strong agreement with Sussman that traditional mathematical notation is strictly inferior to writing everything down in an <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Classical_Mechanics">unambiguous machine executable notation</a>.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598209565.065600"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598209565.065600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-08-23 12:06</span><br/>
I used to agree with Sussman, but I have changed my mind a bit: unambiguous, yes, but not necessarily executable. Much of what you write down in mathematics and mathematically formulated science is specifications. For example differential equations such as Newton's. You really want to be able to write such specifications without necessarily doing something specific with them.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598221174.065800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598221174.065800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-08-23 15:19</span><br/>
In the 1950's, Kenneth Iverson was a math professor at Harvard. He designed APL as an unambigous, expressive mathematical notation, for teaching math to undergrads, and for his personal use solving research problems and writing books and research papers. Iverson joined IBM as a mathematician, where he used his notation to formalize and specify the instruction sets of the 7090 and 360 computers. Only after that, the project at IBM to implement APL as a programming language.<br/><br/>APL doesn't usually get much credit for its influence on modern programming systems (although Mathematica, NumPy and TensorFlow are APL dialects), and it isn't usually credited as an early functional language, even though it was the first such language (to my knowledge) to have map/reduce primitives (although under different names). APL now seems to be remembered for its syntax.<br/><br/>Finally, my point. Re: Sussman, APL is a much better mathematical notation than Scheme.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598245635.072100"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598245635.072100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-08-23 22:07</span><br/>
Historical note: NumPy started out with a focus on implementing much of APL as a Python library. The function names in Numerical Python (as NumPy was originally called) are the names of APL operators. Later on, there was a movement to make NumPy more Matlab-like to win over Matlab users, so the APL heritage is no longer as clear as it used to be.<br/><br/>As for APL vs. Scheme: that really depends on what aspect of mathematical notation you focus. Sussman comes from a symbolic computation background, with an application focus on calculus (check his "Structure and Interpretation of Classical Mechanics" as the prime example). APL has a focus on numerics and algebra. The only decent attempt I know to unify both perspectives is Mathematica.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598252784.081300"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598252784.081300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2020-08-24 00:06</span><br/>
I have fond feelings for APL. It was the language in which I was taught a range of numerical methods by one of my favorite professors (here's his <a href="http://archive.vector.org.uk/art10007880">one-line APL solution</a> to the N-Queens problem), and I agree completely that it is under-appreciated for its place in CS history. However, I find the syntax leaves a good deal to be desired for work outside of its original niche, whereas the vector nature it embodies can quite naturally be expressed in any other functional programming language. It is for this reason that I prefer "APL-as-library", "PROLOG-as-library", &amp;c.<br/><br/>Regarding the history of Mathematica, it was inspired almost entirely by Wolfram's extensive use of <a href="https://en.wikipedia.org/wiki/Macsyma">Macsyma</a> and written in C rather than Lisp only because <a href="https://writings.stephenwolfram.com/2013/06/there-was-a-time-before-mathematica/">Rob Pike convinced Wolfram</a> that C was "the language of the future" while they were both at Caltech. Wolfram was aware of APL, but to call Mathematica an APL dialect is in no sense correct.<br/><br/>Re: APL v Scheme as notation, I will say first that we disagree and second that even though we've only (virtually) known each other for a few weeks, your habit of expressing your subjective aesthetic opinions about Lisp family languages as if they were objective truths is <em>already</em> quite tiresome.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598339610.110700"></a>
      <img src="https://secure.gravatar.com/avatar/aa31b79adedc3f60547769f1a8971ba6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598339610.110700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Emmanuel Oga</b>
<span style="margin:2em; color:#606060">2020-08-25 00:13</span><br/>
papers alone are not great, is not a matter of functional vs imperative, it is a matter of completeness. 99% of the papers are missing implementation details that could be incredible hard to provide by the uninitiated. Papers with artifacts are great. Start from a running template, play with the parameters, see what happens.. if you really want to start from scratch, you can, but you can always go back to an actual working artifact for reference.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598339811.110900"></a>
      <img src="https://secure.gravatar.com/avatar/aa31b79adedc3f60547769f1a8971ba6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598339811.110900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Emmanuel Oga</b>
<span style="margin:2em; color:#606060">2020-08-25 00:16</span><br/>
my comment taps into the "reproducibility" conversation. See: <a href="https://ctuning.org/ae/">https://ctuning.org/ae/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598383581.111600"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598383581.111600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2020-08-25 12:26</span><br/>
Good paper covering a lot of recent CS edu research in this area: <a href="https://scholarship.tricolib.brynmawr.edu/bitstream/handle/10066/22621/2020LowensteinS.pdf">https://scholarship.tricolib.brynmawr.edu/bitstream/handle/1&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598389425.112000"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598389425.112000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2020-08-25 14:03</span><br/>
<span style="background-color:#ccf">@Emmanuel Oga</span> My thoughts were more in regards to pedagogy than reproducibility, but there is probably overlap here (it's difficult to reproduce what you don't understand).<br/><br/>My thesis is that you gain a deeper understanding by building your own model up from scratch. I learn far more by building from scratch than I do from just "playing with parameters."<br/><br/>That being said, reproducibility is an important goal in itself. I applaud any efforts to improve that area!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598396167.112200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598396167.112200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-08-25 15:56</span><br/>
At least for my personal style, reproducing is often the first step to understanding or learning. Hot take: reproducibility matters more for teaching than research.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598421085.113600"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598421085.113600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-08-25 22:51</span><br/>
Reproducibility matters for learning, which is the common aspect of teaching and research. Learning is attaching new knowledge to an ever-growing edifice of solidly acquired knowledge. Reproducibility is about the solidity of that edifice. You have to be able to question your old knowledge and check if it is as solid as you thought it was, in the light of new knowledge. And that is true as much at the individual level (what we usually call "learning") as at the collective level (research, which is learning at the level of society).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598424964.113800"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598424964.113800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2020-08-25 23:56</span><br/>
This seems to describe making conceptions and discovering misconceptions. Pedagogically, reproducibility would concretely imply using approaches that minimize the appearance or lifespan of misconceptions and minimize time to build conceptions? Research-wise, that would mean cataloging conceptions and misconceptions and measuring their presence over time across large groups? Then, we could compare different pedagogies?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598433284.114900"></a>
      <img src="https://avatars.slack-edge.com/2021-11-13/2722434855730_0c210ee2df74838f8683_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598433284.114900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>nicolas decoster</b>
<span style="margin:2em; color:#606060">2020-08-26 02:14</span><br/>
I agree that implementing something helps understanding/feeling it better. And in fact it is the idea from Seymour Papert with the idea of microworld. Creating microworlds helps understanding some concepts. In the case of LOGO programming the turtle helps children feel (if not understand) concepts like angles.<br/><br/>And I am convinced that this implementing-microworld idea can extend to adults to help them understand better some science, even without great programming knowledge. And as fan of visual programming, I think tools like Scracth are perfect for this: you can implement dynamic/interactive visualisation or microworld to help you grasp some concept.<br/><br/>One example. During a two days workshop where I was teaching Scratch to some teachers (middle school), one wanted to use Scratch to create a small interactive animation to explain some plate tectonics concept. She has never used programming before, but at the end of the workshop she was able to ask her students to implement this concept with Scratch.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598552659.168900"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598552659.168900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2020-08-27 11:24</span><br/>
I think my comment on "reproducibility" needs to be clarified a bit with some definitions.<br/><br/>There is the denotative, dictionary definition of "reproducibility": The ability "reproduce" <b>something</b> (note, this is generic, it can be anything, not just a research paper); to build a copy or simulacrum that exhibits the same behavior or results as the original.<br/><br/>From what I see in the thread, we all basically agree that this is a good and useful thing, particularly for learning and understanding.<br/><br/>But there is a connotative definition of "reproducibility" often associated with scientific research. This definition has more specific context associated with it. In this sense, "reproducibility" is the ability to make a copy or simulacrum that exhibits the same behavior or results of <b>a research paper</b> specifically for the purpose of peer review and validation.<br/><br/>This definition often implies that the reproduction should be created <b>completely independently from original result</b> using only the information found in the paper (and associated references and domain knowledge), but no contact with the original authors.<br/><br/>This second definition is what I believe <span style="background-color:#ccf">@Emmanuel Oga</span> was referring to, based on the context of his post and associated links. My response to that post was an attempt to separate the two concepts. I think I did a bad job initially, and hopefully this is more clear.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598557827.170900"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598557827.170900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-08-27 12:50</span><br/>
Yeah. Even if 99% of papers have reproducibility problems, I suspect the graphics papers that the (excellent!) demo link up top uses don't have that problem.<br/><br/>Perhaps we need a separate thread on the academic notion of reproducibility.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598559488.171200"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598559488.171200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-08-27 13:18</span><br/>
<span style="background-color:#ccf">@Ray Imber</span> The terminology around this topic is a mess. There's people who have written articles just on what should be called what, and of course they disagree. That's life.<br/><br/>One initiative worth mentioning in this context is <a href="https://reproducible-builds.org/">https://reproducible-builds.org/</a>. It's about making (Linux) executables reproducible from source code, so that you can be sure you are actually running the program whose source code you are reading. It's an answer to Ken Thompsons Turing Award speech "Reflections on trusting trust" (<a href="https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf">https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_Ref&hellip;</a>).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1598595636.180900"></a>
      <img src="https://secure.gravatar.com/avatar/aa31b79adedc3f60547769f1a8971ba6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1598125322.060600.html#1598595636.180900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Emmanuel Oga</b>
<span style="margin:2em; color:#606060">2020-08-27 23:20</span><br/>
fwiw I was thinking reproducible more as in "reproducible builds" than as "replicable experiment". The idea is that papers should come with their artifacts: a "one click" implementation that process some provided example inputs and produces some example outputs, as described in the paper.<br/><br/>This is maybe independent of the conversation of whether the learner should build their own version from scratch or not (personally I do think "building from scratch" is the best way to learn). Even when building from scratch, comparing against a reference implementation is incredible useful as a learning tool.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
