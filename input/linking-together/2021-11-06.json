[
    {
        "user": "UK3LH8CF5",
        "type": "message",
        "ts": "1636208488.063900",
        "client_msg_id": "8A4A7AF6-B601-4D8C-A697-2F5F0BCB5775",
        "text": "<@UJBAJNFLK> \n\nI’m not sure how text documents vs images relates here. To me, internal is inside the system. External is outside the system. Of course, we could debate where to draw the bounds, you could try to claim confluence is part of the system, but that seems a bit of a reach.\n\nSo internal documentation in an image based system would be documentation in the image. External would be outside the image. I would still keep my same stance there. In text file based systems with git, I consider git part of that system.\n\nThen there is the question of “inline” documentation vs non-inline. That of course is a distinction based on the interface we use. In an image based format, that can be configurable in a way text tools don’t traditionally expose.\n\n<@UBSMEUXAA>\n&gt; Ultimately if you want to do this right you have to have a documentation team, make documentation review part of code review etc. Otherwise in practice you are relying on arbitrary rules decided by coders in code review, or the converse which is comment happy programmers that write too much.\nYeah, I’m not at all a fan of formalizing these processes. So your otherwise, rephrased, is exactly what I’d advocate for. Let each programmer decide how they want to comment things. Let peer social processes (not power relations) influence and change how that works over time. Uniformity in programming is vastly over-rated, in my view.\n\nIf you have a comment happy programmer writing too much, talk them about it. I mostly find the opposite, code that makes no sense because of lack of comments. By makes no sense, I of course don’t mean I don’t know what the code in fact does. That is independent of the code. I instead don’t know why the code is doing what it is doing, or if what it is doing is what the programmer in fact wanted. \n\nIf that person is no longer at the company, my job is now historical reconstruction. There may in fact be a good reason for the strange behavior the code has. \n\nExternal documentation doesn’t help here, or if it does it requires a lot more effort, because it is disconnected from the timeline of the system. Often times the key to why X works in way a1, is because Y worked in way b1 at time t-1 but no longer works that way.\n\nThis is what external documentation fails to capture, it throws away these time relations, or obscures them at best.\n",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1634856571.005600",
        "parent_user_id": "UBSMEUXAA",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uBXP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " \n\nI’m not sure how text documents vs images relates here. To me, internal is inside the system. External is outside the system. Of course, we could debate where to draw the bounds, you could try to claim confluence is part of the system, but that seems a bit of a reach.\n\nSo internal documentation in an image based system would be documentation in the image. External would be outside the image. I would still keep my same stance there. In text file based systems with git, I consider git part of that system.\n\nThen there is the question of “inline” documentation vs non-inline. That of course is a distinction based on the interface we use. In an image based format, that can be configurable in a way text tools don’t traditionally expose.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UBSMEUXAA"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ultimately if you want to do this right you have to have a documentation team, make documentation review part of code review etc. Otherwise in practice you are relying on arbitrary rules decided by coders in code review, or the converse which is comment happy programmers that write too much."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nYeah, I’m not at all a fan of formalizing these processes. So your otherwise, rephrased, is exactly what I’d advocate for. Let each programmer decide how they want to comment things. Let peer social processes (not power relations) influence and change how that works over time. Uniformity in programming is vastly over-rated, in my view.\n\nIf you have a comment happy programmer writing too much, talk them about it. I mostly find the opposite, code that makes no sense because of lack of comments. By makes no sense, I of course don’t mean I don’t know what the code in fact does. That is independent of the code. I instead don’t know why the code is doing what it is doing, or if what it is doing is what the programmer in fact wanted. \n\nIf that person is no longer at the company, my job is now historical reconstruction. There may in fact be a good reason for the strange behavior the code has. \n\nExternal documentation doesn’t help here, or if it does it requires a lot more effort, because it is disconnected from the timeline of the system. Often times the key to why X works in way a1, is because Y worked in way b1 at time t-1 but no longer works that way.\n\nThis is what external documentation fails to capture, it throws away these time relations, or obscures them at best.\n"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]