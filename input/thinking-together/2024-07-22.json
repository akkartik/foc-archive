[
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1721654626.253929",
        "client_msg_id": "170fae80-9876-47b3-9a2f-3f8dcec834fb",
        "text": "Thanks <@UGWUJUZHT>, that confirms my suspicion. Are you aware of any projects to create such massively asynchronous devices? All I remember having seen in this space is the MIT Connection Machine.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721246911.989019",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HNBRs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": ", that confirms my suspicion. Are you aware of any projects to create such massively asynchronous devices? All I remember having seen in this space is the MIT Connection Machine."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U079M43CQ31",
        "type": "message",
        "ts": "1721664731.239419",
        "client_msg_id": "de4ffff7-6f36-4fee-b7fe-b4ea34717b81",
        "text": "I live for getting into the I’m 14 and this is deep topics personally :joy: - yeah I do think that the physical \/ platonic divide is not something that exists in the real world, It’s only a divide of human concepts not real world stuff in my opinion, but as long as you recognize we are dividing up words and not real things I think it’s useful",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8a7101a82239",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-06-27\/7327139528455_8a7101a8223949a332b4_72.jpg",
            "first_name": "Adam",
            "real_name": "Adam Davidson",
            "display_name": "Adam Davidson",
            "team": "T5TCAFTA9",
            "name": "adam26davidson",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jUTUm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I live for getting into the I’m 14 and this is deep topics personally "
                            },
                            {
                                "type": "emoji",
                                "name": "joy",
                                "unicode": "1f602"
                            },
                            {
                                "type": "text",
                                "text": " - yeah I do think that the physical \/ platonic divide is not something that exists in the real world, It’s only a divide of human concepts not real world stuff in my opinion, but as long as you recognize we are dividing up words and not real things I think it’s useful"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U06BUK2M2RH"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U05UK5T7LPP",
        "type": "message",
        "ts": "1721671249.159899",
        "client_msg_id": "6b474f24-cea8-4caf-bffc-1f6155231641",
        "text": "the argument for 2d representations having more degrees of freedom than 1d representations falls out of first principles, I agree! now I'm suddenly very curious what the process of compiling a 2d representation to an abstract syntax tree looks like, and I'm sure Ivan has been thinking about this",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "87f45e326f3a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-09-30\/5997119242352_87f45e326f3a692ca55c_72.png",
            "first_name": "Jasmine",
            "real_name": "Jasmine Otto",
            "display_name": "Jasmine Otto",
            "team": "T5TCAFTA9",
            "name": "ottojasmine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "081V2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the argument for 2d representations having more degrees of freedom than 1d representations falls out of first principles, I agree! now I'm suddenly very curious what the process of compiling a 2d representation to an abstract syntax tree looks like, and I'm sure Ivan has been thinking about this"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U079M43CQ31",
                    "UCUSW7WVD"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1721673568.772909",
        "client_msg_id": "854d0c60-63e3-4b76-aa2b-519947db7290",
        "text": "<@U05UK5T7LPP> This was one thought I had even in the recent threads on <#C5U3SEW6A|linking-together>:\n• <https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1721317585631879>\n• <https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1721317807883659>\nThe links are talking about things like state diagrams and time sequence diagrams, and it's been on my mind to try compiling down some example state diagram or time sequence diagram.\n\nMy suspicion is that most of the charts those links talk about as being useful in practice are at a high level of detail. You can't generate code based on such a diagram in isolation, because high-level pictures by definition abstract\/hide a lot. So at best the diagram is augmenting the code. In which case how do you refer to stuff in textual code inside diagrams, and (harder) refer to stuff inside diagrams in textual code. Would we say things like, \"find all the edges coming out of the node labeled `Foo`\"? Seems ugly..\n\nPerhaps a cleaner alternative is that the text is authoritative, but we can verify that a diagram is in sync with the text. Or even generate the diagram from text. That was something I was playing with like a month or two ago before I got side-tracked by other things. But I hope to return to it at some point. Have the compiler's output be not just some executable for the computer but also summaries (at multiple levels of detail) that people can look at. I think the challenge here is finding diagrams that are likely to be simple (&lt;20 nodes or so) because anything more complex is a rat's nest when a computer lays it out automatically. So _scale-invariant_ properties of a codebase, that will remain simple even when the codebase grows complex.\n\ncc <@UC2A2ARPT> <@UBKNXPBAB>. I wish there was a way to merge threads.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "duxj9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U05UK5T7LPP"
                            },
                            {
                                "type": "text",
                                "text": " This was one thought I had even in the recent threads on "
                            },
                            {
                                "type": "channel",
                                "channel_id": "C5U3SEW6A"
                            },
                            {
                                "type": "text",
                                "text": ":\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1721317585631879"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1721317807883659"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe links are talking about things like state diagrams and time sequence diagrams, and it's been on my mind to try compiling down some example state diagram or time sequence diagram.\n\nMy suspicion is that most of the charts those links talk about as being useful in practice are at a high level of detail. You can't generate code based on such a diagram in isolation, because high-level pictures by definition abstract\/hide a lot. So at best the diagram is augmenting the code. In which case how do you refer to stuff in textual code inside diagrams, and (harder) refer to stuff inside diagrams in textual code. Would we say things like, \"find all the edges coming out of the node labeled "
                            },
                            {
                                "type": "text",
                                "text": "Foo",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\"? Seems ugly..\n\nPerhaps a cleaner alternative is that the text is authoritative, but we can verify that a diagram is in sync with the text. Or even generate the diagram from text. That was something I was playing with like a month or two ago before I got side-tracked by other things. But I hope to return to it at some point. Have the compiler's output be not just some executable for the computer but also summaries (at multiple levels of detail) that people can look at. I think the challenge here is finding diagrams that are likely to be simple (<20 nodes or so) because anything more complex is a rat's nest when a computer lays it out automatically. So "
                            },
                            {
                                "type": "text",
                                "text": "scale-invariant",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " properties of a codebase, that will remain simple even when the codebase grows complex.\n\ncc "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UBKNXPBAB"
                            },
                            {
                                "type": "text",
                                "text": ". I wish there was a way to merge threads."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U079M43CQ31"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U05UK5T7LPP",
        "type": "message",
        "ts": "1721675068.364759",
        "client_msg_id": "a3d09327-1aea-496e-b4d9-6d8a16e95875",
        "text": "For sure, I'm really excited about both posts. I wonder if we know who is responsible for the dataflow minimap in Observable? For me it's been a killer feature in diagnosing topological execution. (Even then, a length-five cyclic dependency in the update loop of some interactive diagram is still quite a pickle to deal with.)\n\nWe've also been thinking about the value of high-level 'speculative visualizations' (as well as the data-driven kind!) over in technical games research, where there's been a great deal of drift between the game analytics literature and the concerns of narrative design. I'm very glad this problem of the high-level underspecification comes up in (design-minded) developer support tools more generally.\n\nI don't remember if I posted my DendryScope work in its own right? It's an alternative compiler for the Dendry IF authoring language that does the static analysis, basically. After I gave up on box-and-wire digrams to go with heatmaps, I had more trouble with combinatorial explosion than with layout.\n\ndemo: <https:\/\/jazztap.github.io\/DendryScope\/>\npaper: <https:\/\/jazztap.github.io\/dendry-paper\/2023_AIIDE_Dendryscope_Camera_Ready.pdf>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "87f45e326f3a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-09-30\/5997119242352_87f45e326f3a692ca55c_72.png",
            "first_name": "Jasmine",
            "real_name": "Jasmine Otto",
            "display_name": "Jasmine Otto",
            "team": "T5TCAFTA9",
            "name": "ottojasmine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nTbhg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For sure, I'm really excited about both posts. I wonder if we know who is responsible for the dataflow minimap in Observable? For me it's been a killer feature in diagnosing topological execution. (Even then, a length-five cyclic dependency in the update loop of some interactive diagram is still quite a pickle to deal with.)\n\nWe've also been thinking about the value of high-level 'speculative visualizations' (as well as the data-driven kind!) over in technical games research, where there's been a great deal of drift between the game analytics literature and the concerns of narrative design. I'm very glad this problem of the high-level underspecification comes up in (design-minded) developer support tools more generally.\n\nI don't remember if I posted my DendryScope work in its own right? It's an alternative compiler for the Dendry IF authoring language that does the static analysis, basically. After I gave up on box-and-wire digrams to go with heatmaps, I had more trouble with combinatorial explosion than with layout.\n\ndemo: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/jazztap.github.io\/DendryScope\/"
                            },
                            {
                                "type": "text",
                                "text": "\npaper: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/jazztap.github.io\/dendry-paper\/2023_AIIDE_Dendryscope_Camera_Ready.pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U05UK5T7LPP",
        "type": "message",
        "ts": "1721675243.629399",
        "client_msg_id": "22311bf6-1643-42eb-91ca-a62b81045664",
        "text": "I agree that 'compile the DSL to both an executable and a diagram' is perfectly feasible. Going the other way, from a diagram to a DSL? Now there's the golden problem of design engineering, I think.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "87f45e326f3a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-09-30\/5997119242352_87f45e326f3a692ca55c_72.png",
            "first_name": "Jasmine",
            "real_name": "Jasmine Otto",
            "display_name": "Jasmine Otto",
            "team": "T5TCAFTA9",
            "name": "ottojasmine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hYa\/\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree that 'compile the DSL to both an executable and a diagram' is perfectly feasible. Going the other way, from a diagram to a DSL? Now there's the golden problem of design engineering, I think."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1721675377.736579",
        "client_msg_id": "3ce3a94a-f922-45a7-8d1f-90312257301d",
        "text": "I see, so you're imagining that a high-level diagram might compile down to a textual DSL with some interface that lower levels of textual code can hook into as needed? Interesting..\n\nI had not seen your project before! Thank you for sharing it. You should definitely create a thread for it in <#CCL5VVBAN|share-your-work>. I'm going off now to read more about this Dendry thing I'd never heard of :slightly_smiling_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S98ls",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I see, so you're imagining that a high-level diagram might compile down to a textual DSL with some interface that lower levels of textual code can hook into as needed? Interesting..\n\nI had not seen your project before! Thank you for sharing it. You should definitely create a thread for it in "
                            },
                            {
                                "type": "channel",
                                "channel_id": "CCL5VVBAN"
                            },
                            {
                                "type": "text",
                                "text": ". I'm going off now to read more about this Dendry thing I'd never heard of "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "pray",
                "users": [
                    "U05UK5T7LPP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U05UK5T7LPP",
        "type": "message",
        "ts": "1721675930.103509",
        "edited": {
            "user": "U05UK5T7LPP",
            "ts": "1721676082.000000"
        },
        "client_msg_id": "27447fb2-e6d3-42bb-a658-6815f2cc097c",
        "text": "I mean, the trouble isn't really in building the compiler. It's just graphical bindings once someone has got the right diagram-to-DSL fit. Now you're going back and forth between the algebra (an AST) and the geometry (a diagram), so everything is fine.\n\nAll I need to do is articulate what a 'good fit' looks like, and why any given project needs a suitably multi-disciplinary design engineer to go and find it. These people seem to be unicorns, from a management perspective, but also a lot of them are here in this community right now. That will be the subject of a full-on Substack post, I imagine.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "87f45e326f3a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-09-30\/5997119242352_87f45e326f3a692ca55c_72.png",
            "first_name": "Jasmine",
            "real_name": "Jasmine Otto",
            "display_name": "Jasmine Otto",
            "team": "T5TCAFTA9",
            "name": "ottojasmine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Y5nlR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I mean, the trouble isn't really in building the compiler. It's just graphical bindings once someone has got the right diagram-to-DSL fit. Now you're going back and forth between the algebra (an AST) and the geometry (a diagram), so everything is fine.\n\nAll I need to do is articulate what a 'good fit' looks like, and why any given project needs a suitably multi-disciplinary design engineer to go and find it. These people seem to be unicorns, from a management perspective, but also a lot of them are here in this community right now. That will be the subject of a full-on Substack post, I imagine."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1721676875.022789",
        "client_msg_id": "81309667-f772-4159-96c5-353db03443ca",
        "text": "Yeah, I'd be :runner::skin-tone-3: to read it. From where I am now, yes the compiler doesn't seem hard. What seems hard is co-designing the source grammar and the target DSL for some domain..",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HDCn2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I'd be "
                            },
                            {
                                "type": "emoji",
                                "name": "runner",
                                "unicode": "1f3c3-1f3fc",
                                "skin_tone": 3
                            },
                            {
                                "type": "text",
                                "text": " to read it. From where I am now, yes the compiler doesn't seem hard. What seems hard is co-designing the source grammar and the target DSL for some domain.."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1721677469.173799",
        "client_msg_id": "47cfdc77-c070-478f-a657-7c3d97a5b03d",
        "text": "<@U05UK5T7LPP>\n&gt; I wonder if we know who is responsible for the dataflow minimap in Observable?\nI believe <@UTVC3RRHT> worked on it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IXWSB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U05UK5T7LPP"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wonder if we know who is responsible for the dataflow minimap in Observable?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI believe "
                            },
                            {
                                "type": "user",
                                "user_id": "UTVC3RRHT"
                            },
                            {
                                "type": "text",
                                "text": " worked on it."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "pray",
                "users": [
                    "U05UK5T7LPP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1721703969.601949",
        "client_msg_id": "3ce52b0f-09e4-4ebf-8fc1-6c11d2e93161",
        "text": "<@U05UK5T7LPP> a) minor technicality: once compiled, it is no longer an abstract syntax tree, it is a concrete syntax tree ; the compiler uses an AST internally for pattern matching against all possibilities, then spits out a pruned-down CST to represent what was actually found in the input\nb) I believe that attacking low-hanging fruit is a good first strategy. Many 2D editors save out diagrams in XML and JSON format. Once the information has been compacted down to text, albeit ugly to humans, it can easily be parsed by existing text-parser technologies, like XML parser libraries, or my favourite, OhmJS (a descendant of PEG parsing tech). I use <http:\/\/draw.io|draw.io> as a DPL editor. I’ve use yEd and keep eyeing Excalidraw.\nc) parsing is much simpler if you use a technology with backtracking. I use Prolog (SWIPL, to be exact) a lot. I use Nils Holm’s Prolog in Scheme a lot (I’ve ported it to Common Lisp and to Javascript and am working on lifting it upwards to be able to spit out just about any 3GL, like Python, WASM, etc.). PEG is more useful than CFGs and REGEXs, since PEG incorporates backtracking\nd) simple grade-school math, e.g. `(x,y)`, `intersection`, `containment`, goes a long way towards creating useful semantic info that can form relations in relational languages (Prolog, miniKanren, etc.)\ne) do unto DPLs what was done to TPLs - pare down the input language to something that can be parsed. We use only a tiny sliver of English in most PLs, similarly we need to only use a tiny sliver of 2D graphics to form DPLs, e.g. “rectangle”, “arrow”, “text”, “group”. We don’t bother to parse all of War and Peace, likewise, we don’t need to parse Rembrandt.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3Hpc1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U05UK5T7LPP"
                            },
                            {
                                "type": "text",
                                "text": " a) minor technicality: once compiled, it is no longer an abstract syntax tree, it is a concrete syntax tree ; the compiler uses an AST internally for pattern matching against all possibilities, then spits out a pruned-down CST to represent what was actually found in the input\nb) I believe that attacking low-hanging fruit is a good first strategy. Many 2D editors save out diagrams in XML and JSON format. Once the information has been compacted down to text, albeit ugly to humans, it can easily be parsed by existing text-parser technologies, like XML parser libraries, or my favourite, OhmJS (a descendant of PEG parsing tech). I use "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/draw.io",
                                "text": "draw.io"
                            },
                            {
                                "type": "text",
                                "text": " as a DPL editor. I’ve use yEd and keep eyeing Excalidraw.\nc) parsing is much simpler if you use a technology with backtracking. I use Prolog (SWIPL, to be exact) a lot. I use Nils Holm’s Prolog in Scheme a lot (I’ve ported it to Common Lisp and to Javascript and am working on lifting it upwards to be able to spit out just about any 3GL, like Python, WASM, etc.). PEG is more useful than CFGs and REGEXs, since PEG incorporates backtracking\nd) simple grade-school math, e.g. "
                            },
                            {
                                "type": "text",
                                "text": "(x,y)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "intersection",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "containment",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", goes a long way towards creating useful semantic info that can form relations in relational languages (Prolog, miniKanren, etc.)\ne) do unto DPLs what was done to TPLs - pare down the input language to something that can be parsed. We use only a tiny sliver of English in most PLs, similarly we need to only use a tiny sliver of 2D graphics to form DPLs, e.g. “rectangle”, “arrow”, “text”, “group”. We don’t bother to parse all of War and Peace, likewise, we don’t need to parse Rembrandt."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]