<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2022-12-01 13:44</span><br/>
I'm particularly struck by <a href="https://twitter.com/meekaale/status/1597965066938503169">this thread</a> of images of "apps" generated by Mikael Brockman using Midjourney. No, this isn't a link to a parser library or a tech conference or a blog post about concatenative langs. But to me this is just as interesting and relevant when pondering what the future of programming ought to be.<br/><br/>For instance, one could think about borrowing this aesthetic, or <em>an</em> aesthetic. What would it take for a code visualization to make use of detailed geometry and lighting/shading/depth cues and other expressively artistic aspects like the ones on display here? At the moment, code "visualizations" tend to consist of line graphs, grids of numbers, flat little circles with text centred in them, straight lines or simple s-curves, all rendered without light. The way we visualize code isn't even, like, <em>Gourad shaded</em>. And here we see something that crams incredible detail and depth into every pixel. The <em>images</em> themselves aren't of interest — if someone wants to make a programming language out of skulls and leaves and reefs, my god, go as hard as you can! But for my money, it's the way these _semi-_abstract shapes are given an impression of tactility and physicality that interests me most.<br/><br/>Another angle would be to think about the process. Mikael generated these images using an AI. I find myself wondering "what if this aesthetic, but for structured data?" (When I say "structured data", I mean source code, cyclomatics, spreadsheets, pages in a book, ASTs, whatever you want.) Perhaps one way to approach answering that question would be exploring the space with the help of an AI. You don't need to come up with something perfect, just something worth running with. We're programmers, so we have a sense of what structured data is <em>in our bones</em>. That probably limits our thinking. It helps to get someone outside the field, someone whose bones are data-hollow, to <a href="https://github.com/ivanreese/visual-programming-codex/blob/main/impressions/app-store-illustration.md">reflect your thoughts back at you in their own language</a>. I'm sure one of the Oblique Strategies is "Ask an AI to do it".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1669932263.466649"></a>
      <img src="https://avatars.slack-edge.com/2019-12-25/886144219253_4377ee2417eb9eaacd4b_72.jpg" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1669932263.466649" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jimmy Miller</b>
<span style="margin:2em; color:#606060">2022-12-01 14:04</span><br/>
This is something I’ve been thinking about a lot as well. I hate the feel of the visualizations I produce. I would love to produce something this visually interesting. I have to admit, I just lack the artistic ability. I have lots of data and lots of time. If some wants to collaborate on this let me know. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1669947752.324319"></a>
      <img src="https://secure.gravatar.com/avatar/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1669947752.324319" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Andrew F</b>
<span style="margin:2em; color:#606060">2022-12-01 18:22</span><br/>
Shading, or anything that suggests continuous space as opposed to discrete components, is likely to remain surplus to requirements for the most part. :) Continuous/smooth features belong to a world where objects matter proportionally to their size (yes, not always, but the counterexamples are notable for their rarity), which is emphatically not the case for anything close to math or logic. Which is not to say you couldn't employ it for aesthetic purposes, but I can't think of how you would use high-res detail like that for representing the semantics of a program. (There are those digram heatmaps you see in binary analysis and the like, but I'd put those in a different category, certainly more syntactic). To be a little more precise, it will be hard to make small details meaningful in proportion to their visual weight, neither too small (hiding things) or too big (distracting). Similar for 2d topology vs whatever passes for topology in a program.<br/><br/>Maybe that's an angle to approach the question: how do you visually represent something small but impactful like a logical negation? A region with visually changed properties, maybe different color?<br/><br/>You could use visual texture as an information channel in a broadly discrete visualization, in a similar role to color. Definitely needs a careful hand to avoid horrible visual clashing, but if you're really clever you might even be able to weaponize it to make bad patterns look bad.<br/><br/>Organic-looking shapes would be cool, no clarity problem as long as they're distinct. Is there a way to make subtle changes in the outline of an object meaningful? My FSM node is kind of bean-shaped because... something.<br/><br/>Visual media are really high-bandwidth, and programs are pretty low-bandwidth. The way you get lots of data from a small program is by running it, maybe a bunch of times, so maybe incorporating runtime data into the visualization is the key. When you look at the code, you're also looking at all possible runs/outputs. Flame graphs are already in that region, but still resolutely rectangle-based.<br/><br/>Only marginally related: I would like to see a continuous visualization for music/audio creation, where you sort of paint in (time, frequency) space, e.g. chords are parallel lines running along time. I feel like that has to exist, right?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1669996658.311599"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1669996658.311599" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2022-12-02 07:57</span><br/>
Andrew, you make good points about "hard to make small details meaningful in proportion to their visual weight."  The trick with any good visualization is making important features of the domain pop in the diagram.  When you say "[size] emphatically [does not matter] for anything close to math or logic," I can only assume you have in mind the fact that a small change to an expression "like a logical negation" has a big impact.  However, if the visualization <b>is</b> faithful to the effect on, say the shape of possible runs of a program, then a negation can cause part of that shape to change significantly.<br/><br/>As for non-aesthetic smoothing, well the simplest example I can think of is using a line of best fit as a summary for a bunch of datapoints.   In cases of strong correlation, you can mostly ignore underlying points.<br/><br/>I've got a good musical example handy of the interplay of continuity, aesthetics, and emphasized dimensions.  Here <a href="https://www.youtube.com/watch?v=OMtjlaDEMdI">https://www.youtube.com/watch?v=OMtjlaDEMdI</a> smalin diagrams a performance of the Art of Fugue, which has, more or less, one repeating structure subject, primarily using a fancy piano roll with horizontal for time, vertical for pitch, and color for voice.  Sometimes the subject is delimited using a sort of axis L.  Starting at 1:00:46, he tries something a little different.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1669997283.896329"></a>
      <img src="https://secure.gravatar.com/avatar/df13e3ce9dfc39e2f387bd3d6e87b952.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0016-72.png" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1669997283.896329" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jan Ruzicka</b>
<span style="margin:2em; color:#606060">2022-12-02 08:08</span><br/>
<span style="background-color:#ccf">@William Taysom</span> Re: continuous visualisations not being appropriate. I think what <span style="background-color:#ccf">@Andrew F</span> meant was that a function from logical expressions into logical expressions (notably the substitution function) is not continuous (whatever it means, you'd have to provide a metric on logical expressions). Since programming as done today is performed basically only using substitution (everything can be modelled by untyped lambda calculus), there's no point in trying to make visualisations continuous. Therefore, it makes more sense to give the colours more of an "algebraic" meaning, which I think is what he describes in the mid-to-latter part.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1669998832.049739"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1669998832.049739" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2022-12-02 08:33</span><br/>
"There's no point in trying to make visualizations continuous"<br/><br/>Why not? Why limit oneself?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670002403.827139"></a>
      <img src="https://secure.gravatar.com/avatar/df13e3ce9dfc39e2f387bd3d6e87b952.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0016-72.png" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1670002403.827139" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jan Ruzicka</b>
<span style="margin:2em; color:#606060">2022-12-02 09:33</span><br/>
I meant: "Trying to make the function (which visualises program features) continuous." (In the mathematical sense; the function is taken to be from expressions and expression transformations to a 2D space with smooth colours)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670010481.678339"></a>
      <img src="https://secure.gravatar.com/avatar/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1670010481.678339" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Andrew F</b>
<span style="margin:2em; color:#606060">2022-12-02 11:48</span><br/>
To be clear, even if it does turn out that visualizations similar those above don't work out, we should still try to come up with counter examples. :)<br/><br/>Another approach: what kinds of useful information exists about structured data that can be expressed in such a detailed, real-number-oriented way?<br/><br/>Statistical summary is an interesting angle for structured data, like <span style="background-color:#ccf">@William Taysom</span> mentioned with regression. Summary, being inherently lossy but still useful, seems like a good way to get useful fuzzy data from structured data. Like if the representation of a database table gave you a pretty good idea of the distributions of its columns. Can you have a good graphical representation of the row that just stacks in the z-axis (with transparency) to get a passable summary? Can something like that work for less regular structures? (Of course this kind of merges with showing summarized runtime results if it goes far enough.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670020635.437219"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1670020635.437219" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-02 14:37</span><br/>
Question: What do you see this syntax being compiled-to for a digital computer?<br/>Orthogonal brainstorming: Then, there’s the forgotten form of computing called Analogue Computing.  I wonder if this syntax has application to analogue computing?  If so, what operations does this syntax represent?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670051443.571569"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1670051443.571569" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2022-12-02 23:10</span><br/>
Yes!  Analog computing where the essential feature is that features of the mechanism match the domain.  <a href="https://youtu.be/GVsUOuSjvcg">https://youtu.be/GVsUOuSjvcg</a><br/><br/>Rather than connections being symbolic and arbitrary, they have to be intrinsic and, well, analogous.  So I don’t think the essence of analog is the quality of being contiguous rather than discrete.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670078564.467619"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1670078564.467619" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-03 06:42</span><br/>
aside: The Nyquist Sampling Theorem says that you have to sample at at least 2x the speed at which the thing is changing state.  Practically, if the thing changes state much, much faster than you are sampling, the thing looks like it is continuous.  Analogy: a Retina display has many more digital pixels than your wetware can distinguish ; vinyl is better than MP3 because vinyl packs more data into a unit of sound-space (I guess that FLAC is a digital attempt to compete with vinyl).<br/>aside: Ironically, transistors were first used for analog circuitry (e.g. audio amplifiers).  Transistors have a “linear region” which is used in analog circuitry.  If you slam transistors to be ON or OFF, they are said to be operating in their “non-linear” region and you get 1's and 0's
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670208355.684099"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1670208355.684099" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2022-12-04 18:45</span><br/>
Thinking about the kinds of infovis, I like best.  This XKCD nails it.  <a href="https://xkcd.com/2701/">https://xkcd.com/2701/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1670257585.817779"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1669931082.605639.html#1670257585.817779" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-05 08:26</span><br/>
Yes!<br/><br/>Any problem can be viewed from multiple perspectives.<br/><br/>Some views are more fruitful than others.<br/><br/>How do you know which views to use?<br/><br/>You don’t.  Experts, Senior Architects, Senior Engineers know which views to use.<br/><br/>How do Experts know this?<br/><br/>1. Trial-and-error over the years.<br/>2. Apprenticing with Experts who preceded them.<br/>Can a machine figure out which views are the best?<br/><br/>No.<br/><br/>A machine cannot figure out which views are the best.  Only an Expert can tell you which views to use.  A machine is but a tool.  An expert can specify which knobs to put on a machine and how much to turn each knob to achieve the most fruitful perspectives, but, the machine can’t figure out how to do this by itself.<br/><br/>The 2022++ computer medium is like a piece of paper and a pencil.  In the right hands it can convey a great deal of meaning.<br/><br/>In fact, 2022++ computers allow humans - for the first time?- to explore and visualize issues in 4 dimensions - x/y/z/t.  Paper and pencil and clay tablets forced humans to collapse 4D concepts down to 2D for the sake of the written notation.<br/><br/>How does all of this manifest itself in Software and Programming?<br/><br/>For starters, we might use <b>multiple</b> languages for any problem.  Nano-languages - I call them SCNs (Solution Centric Notations).<br/><br/>Examples:<br/>• one view of computers is “everything is a byte” - the notation is C<br/>• one view of computers is “everything is a string” - the notation is Perl, Icon, SNOBOL, Tcl/Tk, etc.<br/>• one view of computers is “everything is a browsable web page” - the notation is HTML<br/>• one view of software is “everything is a hierarchical wrapper” - the notation is Smalltalk (OO)<br/>• one view of software is “everything is a function” - the notation is FP, Lambda Calculus, etc.<br/>• one view of software is “everything has state”  - the notation is StateCharts, Actors<br/>• one view is that “history matters, sequencing matters” - the notation is state machines - the <b>anti</b>-notation for this is functional notation, which outright discards history<br/>• one view of programming is “everything is a sequential set of functions” - the notation is FP and written mathematics<br/>• one view of programming is “everything is an asynchronous Component” - the notation is FBP, Actors, UNIX shell pipelines, ė[^eh], etc.<br/>[^eh]: I happen to be interested in exploring the rathole of asynchronous, pluggable Components.  I am exploring a notation/functionality/IDE/... that I call ė.  I think that I have isolated some sub-atomic particles of concurrency and call the main one “0D”.<br/><br/>Conclusion:<br/><br/>Don’t try to guess, let the Experts <b>tell</b> you which Views to use.<br/><br/>How?<br/><br/>Find a way to allow Experts to create views - SCNs - quickly (in minutes instead of in years).<br/><br/>Recursive Q: what is a fruitful view of the problem of how to let Experts create SCNs easily and quickly? A: Create multiple grammars to drape multiple syntaxes over various paradigms, let Experts reach into a toolbox to let them pull out and use bits and pieces of useful functionality.<br/><br/>Suggestion:<br/>1. use Ohm-JS for creating syntaxes <br/>2. use Lisp as the toolbox[^js]<br/>3. use debuggers, honed by Experts over the years[^debuggers]<br/>4. build software as pluggable Components[^0d]<br/>[^js]: Aside: if you have an allergy to using Lisp, I have found that JavaScript and Python work acceptably, too, as toolbox languages (except for their pesky syntaxes)<br/>[^debuggers]: After all, the Experts in debugging have determined - by trial-and-error, and, by listening to customer demands, and, by learning from others - what works best when debugging and what doesn’t work when debugging.<br/>[^0d]: 0D, IMO, is the secret sauce of Componentizing software<br/><br/>LispWorks is a better debugger than SBCL.  SBCL is a better debugger than VSCODE. Iterative design is better than waterfall design.  Debugging is a better way to design something than just inventing all of it in one fell swoop without a debugger and without iteration. Optimization should be applied only after-the-fact to a working design (i.e. eschew “premature optimization”).  Type checking mainly helps when optimizing (it attempts to guarantee that the optimized code faithfully represents the original design, but, it gets in the way of free-thinking during Design).<br/><br/>Ohm-JS is better than PEG. PEG is better than Language Theoretical compiler generators (e.g. YACC, LR(k), etc., etc.).<br/><br/>Lisp and Assembler share common traits:<br/>• expression language <br/>• easy to bolt pieces together to make bigger pieces<br/>• Assembler pieces are arranged as <b>lines of text</b><br/>• Lisp pieces are arranged as recursive <b>trees of Atoms and trees</b> (<b>tree</b> is also known as <b>list</b>)<br/>• lack of pesky syntax (you don’t want your toolbox language to have an opinion about which syntax/view you need to be using).<br/>Maybe there are other languages that have these traits?  I don’t know.  OTOH Lisp (and Assembler) has been around for looong time and Experts have tuned it to be a good toolbox. And, I am comfortable with Lisp.<br/><br/>FP has been around a loooong time, too, in the form of written mathematics. In fact, Lisp was based on mathematical notation.  Computer hardware goes beyond what can <b>easily</b> be described using written mathematics, e.g. history (sequencing, DAWs, iMovie, robotics, blockchain protocols, IoT, etc.), mutation (RAM), asynchonosity (non-von-Neumann architectures), etc.<br/><br/>It should be noted that FP is simply <b>one notation</b> that can be fruitfully used to describe computer programming.  There are other notations that fruitfully describe non-FP aspects of computers better than FP can describe them.<br/><br/>Claiming that one notation is <b>The Best</b> notation is a common human behaviour.  It is so common, that it has been given a name - “fad”.<br/><br/>IMO, it is fruitless to continue inventing new languages and amazing features as one-shot deals.  We need to invent new ways to invent new languages quickly (i.e. in minutes).  We need to solve problems by inventing multiple SCNs (nano-languages) for the various views of problems.  We need to use multiple SCNs to solve little sub-problems, then bolt the solutions together into larger solutions.<br/><br/>Recursively.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
