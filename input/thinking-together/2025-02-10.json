[
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1739204821.359799",
        "client_msg_id": "ee41f244-a8fd-4f87-8ab1-6fb4208243c2",
        "text": "The programming\/computing difference also feels like the difference between a live system vs a... a... what's the word for regular software?... a preprogrammed one.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1738634283.049249",
        "parent_user_id": "U088999PF62",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A5Lqq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The programming\/computing difference also feels like the difference between a live system vs a... a... what's the word for regular software?... a preprogrammed one."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "Trolling for ideas on which way I should go. I have too many choices in front of me and way too many learning curve(s) to go down. I've got a drawware REPL that uses 3 windows: (1) <http:\/\/draw.io|draw.io>, (2) browser that displays output of run, (3) python glue running in a terminal window that watches the timestamp on the <http:\/\/draw.io|draw.io> file, and spawns a compile\/run cycle when the drawing changes. The python glue creates 2 websockets (1) a 1-way conduit to the browser to send it JSON key\/value objects (strings) and (2) a 1-way conduit from the spawned compiler which sends key\/value messages which get forwarded to the browser. The effect is like `printfs` but in a browser instead of a console (and more useful than `printf` because it doesn't need to be sequentially inserted into the circuit). It knows how to shell-out to command-line commands. This is a VSH - a Visual SHell to replace \/bin\/bash. The whole mess works \"fast enough\" to act as a code development REPL. What's the best way to package the whole thing into a singly-deployable app? (single from users' perspective, maybe retain all processes and windows). Should I dump the browser and go with some local GUI package (what?). Should I be looking at redbean? Should I be looking at Glamorous Toolkit? CLOG? Keeping the browsers and sockets makes it scalable across distributed machines and might result in new ideas. I want to keep <http:\/\/draw.io|draw.io>, since it saves me a lot of work (it's a PITA to use, but better than anything I could build myself). Keeping Python and JS lets me forego actual coding (I just ask AI to build the thingies - AI has been trained on zillions of lines of code in JS and Python). I'm good with Common Lisp, Python and JS (but, hand-written JS usually creates mysterious failures that are hard to debug. Lispworks debugger is the \"best\", next is Python). I'm good with cranking out little nano-DSLs using OhmJS (t2t), so I can generate code instead of writing tricky code.\n\nThis is VSH, using websockets instead of UNIX pipes. Using 2D node-and-arrow drawings instead of 1D text on the command line shell syntax.",
        "files": [
            {
                "id": "F08D19LAW9X",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "UGWUJUZHT",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+xnkx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Trolling for ideas on which way I should go. I have too many choices in front of me and way too many learning curve(s) to go down. I've got a drawware REPL that uses 3 windows: (1) "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/draw.io",
                                "text": "draw.io"
                            },
                            {
                                "type": "text",
                                "text": ", (2) browser that displays output of run, (3) python glue running in a terminal window that watches the timestamp on the "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/draw.io",
                                "text": "draw.io"
                            },
                            {
                                "type": "text",
                                "text": " file, and spawns a compile\/run cycle when the drawing changes. The python glue creates 2 websockets (1) a 1-way conduit to the browser to send it JSON key\/value objects (strings) and (2) a 1-way conduit from the spawned compiler which sends key\/value messages which get forwarded to the browser. The effect is like "
                            },
                            {
                                "type": "text",
                                "text": "printfs",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " but in a browser instead of a console (and more useful than "
                            },
                            {
                                "type": "text",
                                "text": "printf",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " because it doesn't need to be sequentially inserted into the circuit). It knows how to shell-out to command-line commands. This is a VSH - a Visual SHell to replace \/bin\/bash. The whole mess works \"fast enough\" to act as a code development REPL. What's the best way to package the whole thing into a singly-deployable app? (single from users' perspective, maybe retain all processes and windows). Should I dump the browser and go with some local GUI package (what?). Should I be looking at redbean? Should I be looking at Glamorous Toolkit? CLOG? Keeping the browsers and sockets makes it scalable across distributed machines and might result in new ideas. I want to keep "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/draw.io",
                                "text": "draw.io"
                            },
                            {
                                "type": "text",
                                "text": ", since it saves me a lot of work (it's a PITA to use, but better than anything I could build myself). Keeping Python and JS lets me forego actual coding (I just ask AI to build the thingies - AI has been trained on zillions of lines of code in JS and Python). I'm good with Common Lisp, Python and JS (but, hand-written JS usually creates mysterious failures that are hard to debug. Lispworks debugger is the \"best\", next is Python). I'm good with cranking out little nano-DSLs using OhmJS (t2t), so I can generate code instead of writing tricky code.\n\nThis is VSH, using websockets instead of UNIX pipes. Using 2D node-and-arrow drawings instead of 1D text on the command line shell syntax."
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1739223157.101739",
        "client_msg_id": "6473306d-edce-46e6-ac72-81e68a6641d7",
        "thread_ts": "1739223157.101739",
        "reply_count": 3,
        "reply_users_count": 2,
        "latest_reply": "1739285335.435389",
        "reply_users": [
            "UJBAJNFLK",
            "UGWUJUZHT"
        ],
        "replies": [
            {
                "user": "UJBAJNFLK",
                "ts": "1739255884.039529"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1739267834.143229"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1739285335.435389"
            }
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1739255884.039529",
        "client_msg_id": "03612c6f-704d-4db5-bd2d-0248780e53f2",
        "text": "This is really a question about assembling software systems. The answer mostly depends on \"for whom\"? Which platforms, which level of user competence?\n\nHere is what I would do, for the platform I use (Linux) and for users \"like me\", i.e. power users but not software professionals. I'd write <https:\/\/guix.gnu.org\/|Guix> package for the full assembly (where \"<http:\/\/draw.io|draw.io>\" is just a URL of course because you can't run it locally). Guix is made for creating software assemblies, and it can integrate absolutely anything. You can make a package that depends on Python and on a browser, no problem. You can then deploy the assembly as a single command, which you can then put into a shell script for convenience. Or into a .desktop file for launching from Gnome or whatever else.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739223157.101739",
        "parent_user_id": "UGWUJUZHT",
        "attachments": [
            {
                "from_url": "https:\/\/guix.gnu.org\/",
                "service_icon": "https:\/\/guix.gnu.org\/themes\/initial\/img\/icon.png",
                "id": 1,
                "original_url": "https:\/\/guix.gnu.org\/",
                "fallback": "GNU Guix transactional package manager and distribution — GNU Guix",
                "text": "Guix is a distribution of the GNU operating system.\n Guix is technology that respects the freedom of computer users.\n You are free to run the system for any purpose, study how it\n works, improve it, and share it with the whole world.",
                "title": "GNU Guix transactional package manager and distribution — GNU Guix",
                "title_link": "https:\/\/guix.gnu.org\/",
                "service_name": "guix.gnu.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3YcyF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is really a question about assembling software systems. The answer mostly depends on \"for whom\"? Which platforms, which level of user competence?\n\nHere is what I would do, for the platform I use (Linux) and for users \"like me\", i.e. power users but not software professionals. I'd write "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/guix.gnu.org\/",
                                "text": "Guix"
                            },
                            {
                                "type": "text",
                                "text": " package for the full assembly (where \""
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/draw.io",
                                "text": "draw.io"
                            },
                            {
                                "type": "text",
                                "text": "\" is just a URL of course because you can't run it locally). Guix is made for creating software assemblies, and it can integrate absolutely anything. You can make a package that depends on Python and on a browser, no problem. You can then deploy the assembly as a single command, which you can then put into a shell script for convenience. Or into a .desktop file for launching from Gnome or whatever else."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    }
]