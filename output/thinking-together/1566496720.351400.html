<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1566496720.351400.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-08-22 10:58</span><br/>
Almost every program of any complexity has multiple finite state machines, that carry state data and do computations during the transitions. Only in textbooks where they boil things down to the simplest possible explanations do they omit these. That is why shared mutable state is so prevalent. In most languages you create some variables, and either use a switch statement or have a bunch of functions in some kind of array structure that dispatches to the logic for the state on each event. In my Beads language i included a finite state syntax to make it much clearer to the reader about the logic, as it centralizes the state transition logic, but that is a nicety and not essential. Most computer games are gigantic state machines with fancy artwork. Most experienced programmers do state machines in their sleep, they are so common. Business products typically have fewer, and more boring states, like paying on time, 30 days late, 90 days late. That's about as exciting as it gets in accounting, state-wise.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
