[
    {
        "text": "",
        "files": [
            {
                "id": "F04PZH4EKME",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": true,
        "user": "UGWUJUZHT",
        "display_as_bot": false,
        "type": "message",
        "ts": "1676278129.929629",
        "client_msg_id": "b15b7126-6ea1-4d18-8226-2395ede62768",
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT"
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1676278268.593209",
        "client_msg_id": "c5d5c7b2-14c6-464a-84fc-f7b09669b911",
        "text": "I agree.  Thanks for the link.\n\nI find it fruitful to think of a “computer” as but a little machine...\n\nI tend to think of “computers” as “machines”.  Small electronic machines, that take a bunch of low-power electrical inputs (3V-5V, milli-amps) and produce low-power electrical outputs, and, contain some “state” (aka RAM).  The machines are controlled by scripts, instead of, say, mechanical gears, mechanical pulleys, mechanical ratchets, etc..",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pk5P",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree.  Thanks for the link.\n\nI find it fruitful to think of a “computer” as but a little machine...\n\nI tend to think of “computers” as “machines”.  Small electronic machines, that take a bunch of low-power electrical inputs (3V-5V, milli-amps) and produce low-power electrical outputs, and, contain some “state” (aka RAM).  The machines are controlled by scripts, instead of, say, mechanical gears, mechanical pulleys, mechanical ratchets, etc.."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1676278407.969789",
        "client_msg_id": "5980f757-b106-4437-8a0d-c3cb2550d317",
        "text": "You can hook low-power generalized electronic machines to “amplifiers” to control higher-power dumb devices (110V, 220V, amps ; motors, steppers, etc.).\n\nFor now, I will call “generalized electronic machines” GEMs instead of using the word “computers”.  I think of a “computer” as a raisin-sized rPI (Raspberry PI, Arduino, etc.).  I call that a GEM to emphasize the fact that it can do more than just compute.\n\nCan GEMs compute?  Yep.\n\nIs that all that GEMs can do?  Nope.\n\nYou can write scripts by hand (“Assembler”).\n\nYou can write scripts using other apps (“compilers”).\n\n“Scripts” are for GEMs. “Programming Languages” are for other humans.\n\n“Compilers” transpile “programming languages” to “scripts for GEMs”\n\nThere are ways to write specifications for scripts in a way that allows you to reuse parts of scripts for new scripts and that allows you to have less trouble when building scripts (“DRY” (Don’t Repeat Yourself), type checking, so-called “computer science”, etc.).\n\nCurrently, we are focused on writing specifications in call-stack-based, textual programming languages, but, that’s not the only way to write script specs.\n\nCall-stack-based programming languages have the side-effect that they restrict you to thinking only about calculation.\n\nIf you want to use a GEM to build a sequencer, you are out of luck, or worse, you have to invent epicycles that allow you to use calculator-only methods to specify sequencers (e.g. “control theory”, “operating systems”)\n\nAside: Control Theory was well documented in the 1950s, using things called “resistors” and “capacitors” and “inductors” and “Maxwell’s Equations”.  Note that Maxwell’s Equations do not describe Electricity, they only describe a 2D subset of Electricity that we can use to calculate how to build a limited number of useful electronic things.  Electricity is - at least - a 4D effect (x\/y\/z\/t).\n\nAside: Concurrency can be *faked out* through the use of Operating Systems.  To have True Concurrency, all you need to do is to use multiple rPIs (GEMs), each running single-threaded apps, connected by packets (“messages”) sent to each other through wires.  To keep out of trouble, you simply need to invent the equivalent of Structured Programming for messaging - I call that “Structured Message Passing” (it may surprise you that I have opinions about that, too :-).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VPlR=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You can hook low-power generalized electronic machines to “amplifiers” to control higher-power dumb devices (110V, 220V, amps ; motors, steppers, etc.).\n\nFor now, I will call “generalized electronic machines” GEMs instead of using the word “computers”.  I think of a “computer” as a raisin-sized rPI (Raspberry PI, Arduino, etc.).  I call that a GEM to emphasize the fact that it can do more than just compute.\n\nCan GEMs compute?  Yep.\n\nIs that all that GEMs can do?  Nope.\n\nYou can write scripts by hand (“Assembler”).\n\nYou can write scripts using other apps (“compilers”).\n\n“Scripts” are for GEMs. “Programming Languages” are for other humans.\n\n“Compilers” transpile “programming languages” to “scripts for GEMs”\n\nThere are ways to write specifications for scripts in a way that allows you to reuse parts of scripts for new scripts and that allows you to have less trouble when building scripts (“DRY” (Don’t Repeat Yourself), type checking, so-called “computer science”, etc.).\n\nCurrently, we are focused on writing specifications in call-stack-based, textual programming languages, but, that’s not the only way to write script specs.\n\nCall-stack-based programming languages have the side-effect that they restrict you to thinking only about calculation.\n\nIf you want to use a GEM to build a sequencer, you are out of luck, or worse, you have to invent epicycles that allow you to use calculator-only methods to specify sequencers (e.g. “control theory”, “operating systems”)\n\nAside: Control Theory was well documented in the 1950s, using things called “resistors” and “capacitors” and “inductors” and “Maxwell’s Equations”.  Note that Maxwell’s Equations do not describe Electricity, they only describe a 2D subset of Electricity that we can use to calculate how to build a limited number of useful electronic things.  Electricity is - at least - a 4D effect (x\/y\/z\/t).\n\nAside: Concurrency can be "
                            },
                            {
                                "type": "text",
                                "text": "faked out",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " through the use of Operating Systems.  To have True Concurrency, all you need to do is to use multiple rPIs (GEMs), each running single-threaded apps, connected by packets (“messages”) sent to each other through wires.  To keep out of trouble, you simply need to invent the equivalent of Structured Programming for messaging - I call that “Structured Message Passing” (it may surprise you that I have opinions about that, too :-)."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U017TE5R09M"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1676284952.600019",
        "client_msg_id": "b4b7cca1-a352-43a8-8749-459191677969",
        "text": "“For the first time I thought of the whole as the entire computer and wondered why anyone would want to divide it up into weaker things called data structures and procedures. Why not divide it up into little computers, as time sharing was starting to? But not in dozens. Why not thousands of them, each simulating a useful structure?”  — Alan Kay, <http:\/\/worrydream.com\/EarlyHistoryOfSmalltalk\/|The Early History of Smalltalk>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3wQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "“For the first time I thought of the whole as the entire computer and wondered why anyone would want to divide it up into weaker things called data structures and procedures. Why not divide it up into little computers, as time sharing was starting to? But not in dozens. Why not thousands of them, each simulating a useful structure?”  — Alan Kay, "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/worrydream.com\/EarlyHistoryOfSmalltalk\/",
                                "text": "The Early History of Smalltalk"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1676286086.501359",
        "edited": {
            "user": "U017TE5R09M",
            "ts": "1676286105.000000"
        },
        "client_msg_id": "d420f16f-5ca1-450a-a52b-2b1e6e6eddfb",
        "text": "And yes, it is really interesting that you cannot actually have concurrency in the call\/return architectural style, you have to go to some outside mechanism like the operating system to fake it for you.  Hence we get the “blocking call”.  What on earth is a “blocking call”?  It’s the OS allowing you to pretend that call\/return is workable, because it would be _really_ convenient if it were workable.\n\nAsync\/await, “FRP” and the so-called “reactive” UI frameworks are similar:  they try to map things that aren’t call\/return into call\/return, because that makes them convenient.  But they fall down because the mismatch is just too great.  And why is it convenient?  Because our languages are call\/return.  If we can map the problem onto a call\/return problem, we can write it down directly.  That _is_ convenient and powerful.  But it breaks down horribly when the things we want to do aren’t really call\/return.\n\nWhat’s the alternative?  Make it possible to directly write down non-call\/return things.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ES42",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And yes, it is really interesting that you cannot actually have concurrency in the call\/return architectural style, you have to go to some outside mechanism like the operating system to fake it for you.  Hence we get the “blocking call”.  What on earth is a “blocking call”?  It’s the OS allowing you to pretend that call\/return is workable, because it would be "
                            },
                            {
                                "type": "text",
                                "text": "really",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " convenient if it were workable.\n\nAsync\/await, “FRP” and the so-called “reactive” UI frameworks are similar:  they try to map things that aren’t call\/return into call\/return, because that makes them convenient.  But they fall down because the mismatch is just too great.  And why is it convenient?  Because our languages are call\/return.  If we can map the problem onto a call\/return problem, we can write it down directly.  That "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " convenient and powerful.  But it breaks down horribly when the things we want to do aren’t really call\/return.\n\nWhat’s the alternative?  Make it possible to directly write down non-call\/return things."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02A6KG76NP",
        "type": "message",
        "ts": "1676288350.622239",
        "client_msg_id": "16d79de7-9176-435a-b3e3-0e5732809254",
        "text": "Fun! You might also enjoy this piece I wrote awhile back: <https:\/\/www.theatlantic.com\/technology\/archive\/2016\/05\/the-magic-of-code\/478794\/>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1c1e48bc1226",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-08-04\/2370114177104_1c1e48bc1226f6354e6f_72.png",
            "first_name": "Sam",
            "real_name": "Sam Arbesman",
            "display_name": "Sam Arbesman",
            "team": "T5TCAFTA9",
            "name": "sam.arbesman",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675942474.033099",
        "parent_user_id": "U03GBV8B58V",
        "attachments": [
            {
                "from_url": "https:\/\/www.theatlantic.com\/technology\/archive\/2016\/05\/the-magic-of-code\/478794\/",
                "ts": 1462287715,
                "image_url": "https:\/\/cdn.theatlantic.com\/thumbor\/ENV-uNBHtSOk4xOp0vv_5CZI4zU=\/0x247:3494x2067\/1200x625\/media\/img\/mt\/2016\/04\/RTX28XH3\/original.jpg",
                "image_width": 480,
                "image_height": 250,
                "image_bytes": 137901,
                "service_icon": "https:\/\/cdn.theatlantic.com\/_next\/static\/images\/apple-touch-icon-default-b504d70343a9438df64c32ce339c7ebc.png",
                "id": 1,
                "original_url": "https:\/\/www.theatlantic.com\/technology\/archive\/2016\/05\/the-magic-of-code\/478794\/",
                "fallback": "The Atlantic: Why Code Is So Often Compared to Magic",
                "text": "It's not quite sorcery yet, but it could be.",
                "title": "Why Code Is So Often Compared to Magic",
                "title_link": "https:\/\/www.theatlantic.com\/technology\/archive\/2016\/05\/the-magic-of-code\/478794\/",
                "service_name": "The Atlantic"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KiG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Fun! You might also enjoy this piece I wrote awhile back: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.theatlantic.com\/technology\/archive\/2016\/05\/the-magic-of-code\/478794\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U02FYPLHU67"
                ],
                "count": 1
            }
        ]
    }
]