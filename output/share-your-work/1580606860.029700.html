<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-12-12/870368572213_57dceb337de9d471d315_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Eddy Parkinson</b>
<span style="margin:2em; color:#606060">2020-02-01 17:27</span><br/>
Idea - use software applications to design programming languages.  I think we should be taking existing software applications and working backward to work out how to create better programming languages and development tool. So the output of a programming language is a software application, it is easy to find valuable software applications. So if we were to work backward from a collection of software applications to create new programming languages, we could measure if the new language was better or not. We could measure the number of code statements, we could estimate code complexity and development time of different languages. I feel we have the Microsoft Excel problem at the moment, we spend a lot of time arguing about different language innovations, developers in Microsoft famously got distracted by spending a lot of time talking about feature ideas they could add to Excel. Microsoft eventually solved this problem by watching people use Excel. They discovered that most of the debates they had been having were a waste of time and often of near zero value to end users. Microsoft, almost overnight, switched to assessing innovation ideas against current end user solutions. ... Interestingly, we already have current end user solutions available to us, in the form of software applications.  ...  This is a random idea I had, have not spent much time checking the feasibility. ... Thoughts, feedback welcome.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580609689.029800"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580609689.029800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2020-02-01 18:14</span><br/>
On measurement, see <a href="https://twitter.com/brianhempel/status/1098617985768570883">https://twitter.com/brianhempel/status/1098617985768570883</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580609705.030100"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580609705.030100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2020-02-01 18:15</span><br/>
and <a href="https://twitter.com/brianhempel/status/1163807830031425536">https://twitter.com/brianhempel/status/1163807830031425536</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580610756.030400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580610756.030400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-01 18:32</span><br/>
Yeah this feels well known. For example, a stated reason for implementing languages in themselves is dogfooding. A compiler may not seem realistic, but it's at least showing that people care about testing on real programs.<br/><br/>Arc Lisp was built like this, coevolved with HN.<br/><br/>On this group <span style="background-color:#ccf">@magicmouse94937</span> seems to be evaluating his language with simple apps on an ongoing basis.<br/><br/>The challenge is to avoid over-training on the first few programs you and your initial community happen to build. That is kinda why programming seems to have an in-group.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580610997.030600"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580610997.030600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2020-02-01 18:36</span><br/>
on in-group formation: it’s also the OS problem that all programming systems are walled gardens because the OS makes interop so difficult
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580619088.031300"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580619088.031300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-01 20:51</span><br/>
On the visual languages front, a few people seem to be taking an approach that <em>rhymes</em> with what you're asking for, <span style="background-color:#ccf">@Eddy Parkinson</span> — looking at the kind of user interaction/experience they want to have, and working backward from that toward the language. In my case, I want programming to feel like a video game, so I'm working backward from that feeling to the GUI of my visual language, and then working backward from the GUI to the language constructs itself. Similar to "documentation driven development", and some of the [in]famous stories out of Apple (like Steve Jobs walking into a planning meeting for their DVD burning software — full of people who were apparently excited about making a very full-featured product — drawing a single window with a single "Burn" button on the whiteboard, and telling the team "build that" and walking out.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580629277.031800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580629277.031800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-02-01 23:41</span><br/>
<span style="background-color:#ccf">@Eddy Parkinson</span> Working backwards from an existing set of applications to a syntax is a very effective way of designing something. To that end, I have been building a progression of sample programs, starting from the humble clock, through the classic easy games of tic-tac-toe, snake, leading up to chess. Have tried to get people to implement the same program in a variety of languages like Red, Beads, Python, etc. Then you can compare the two languages closely, and see the difference. I am working on much larger examples now which are an even better test. The people who claim PL can't be measured effectively are being dogmatic/pedantic, and dodging a critical issue. Within a fixed range of application types, one can certainly compare languages quantitatively. You can measure word count, depth of nesting, number of IF statements used, percentage of punctuation vs words, # of API calls used, # of API's that could have been used, number of variables, ability to adapt to different screen sizes, availability of sample code, documentation quantity/quality, ability to recreate customer reported problems, etc.<br/><br/>On projects with a very small team size, i seek the maximum productivity out of the language/toolchain. For those projects i don't care about how many other people are using the language; i want leverage, and lesser known but powerful languages are how a small team can compete against larger entities with vast resources.<br/><br/>Every language has its platform limitations (embedded / realtime / mobile / desktop/ bigdata / 2D vs 3D, etc.), so one must qualify the evaluation for the range of applications one is pursuing.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580691203.033400"></a>
      <img src="https://avatars.slack-edge.com/2019-12-12/870368572213_57dceb337de9d471d315_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580691203.033400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Eddy Parkinson</b>
<span style="margin:2em; color:#606060">2020-02-02 16:53</span><br/>
<span style="background-color:#ccf">@Brian Hempel</span> <span style="background-color:#ccf">@magicmouse94937</span> - The calculator example in <a href="http://ppig.org/sites/ppig.org/files/2017-PPIG-28th-lewis.pdf">http://ppig.org/sites/ppig.org/files/2017-PPIG-28th-lewis.pdf</a> is good. It is a good example of assessing value add using your end uses current solution. The end users current solution was algebraic notation. Most users would have been using algebraic notation, very few end users would have been using  Polish notation. The calculator offered a value add the end users current solution.<br/><br/>I understand that end users could have learned polish notation, but the size of the value add would have been very small. As we know the size of the value add impacts innovation adoption. Working from a current end user solutions give a useful way of comparing different value adds.<br/><br/>Microsoft used to spend a lot of time debating innovations. They did not have a good way to assess value adds. But when they started to use current user solutions as a way to  assess different ideas, most of the debate stopped. This suggests that, despite the difficulty of assessing value adds, the method does work,
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580709547.033600"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580709547.033600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-02-02 21:59</span><br/>
Microsoft had a very different philosophy than Apple. MS used Wizards extensively in both the OS and in their Apps. It is still true to this day. Apple would just dump you into a document and give you a tool palette, because they would try to simplify the process to fewer steps, and reduce the number of options. Sometimes Apple would strip away features that gave more customization, but MS would typically have more features, and organize the process into a multi-screen system. MS was shooting for a larger audience (appropriate given their 90%+ marketshare), and i think it worked pretty well. Interestingly, i don't see a lot of guided wizard programming tools in the FoC project lists. Almost all of the node and wire tools give you a blank screen, and don't walk you through it. I think there is an unconscious expectation that some kind of guiding wizard will appear for programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580710310.033800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580710310.033800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-02-02 22:11</span><br/>
As for why RPN has all but disappeared from calculators, RPN was designed around the limitations of the HP calculator keyboard, which did not have sufficient keys to devote to parentheses characters. The HP calculator had a 4 level deep register stack, and operations like 2 3 4 + * would add 3 and 4 then multiply by 2. This chaining operation allows you to store intermediate results without having to name them, which would also require buttons to store/retrieve temporary results. Basically RPN was a compromise caused by hardware limitations of the day, and a wish to use fewer keystrokes for the operations of entering programs, as stored programs was the "power feature" of the HP calculator that made it so revolutionary. Once you add an alphabetic keyboard and can name variables, you are way beyond HP's simplistic language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580710322.034000"></a>
      <a href="../share-your-work/1580606860.029700.html#1580710322.034000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>magicmouse94937</b>
<span style="margin:2em; color:#606060">2020-02-02 22:12</span><br/>
HP keyboard
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580710779.034400"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580710779.034400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-02-02 22:19</span><br/>
by adding twice as many buttons (and using each button 3 times via 2 different SHIFT keys), TI blew HP out of the market with easier programming, and larger feature set. RPN is like FORTH; once you know it, it is actually preferable as it is elegant, not needing parentheses; but it requires more mental gymnastics to be performed. So it isn't hard to imagine the unwashed masses loving TI.  Interestingly PostScript also uses RPN.  And one can see that PostScript is not used much as an explicit programming language today, so one could say that the public has voted with their feet, and rejected RPN as requiring too much short term memory, as one cannot read RPN code unless you mentally track what is on the stack. FORTRAN/Algol wins again, because it more closely matches traditional algebraic notation.  One can also say that the programming public has rejected excessive parenthetical notations like LISP uses. I believe it is also rejecting syntaxes that require the reader to know how many arguments are used by a function. There are some languages where you say func x y z but you don't know how many are going to be absorbed by the function. This implies memorization of each functions argument list number; that is a burden for those in the audience that cannot easily remember arbitrary things like parameter lists.  How much one has to memorize to program in a language is a major factor in usability. In some languages like Java, there is a staggering burden related to the API's that are available. Just knowing which of the 10,000 API library routines you could call is probably the largest area sub-section in its learning curve.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580754693.040400"></a>
      <img src="https://secure.gravatar.com/avatar/a52d221ae708f36674644a348005633a.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580754693.040400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Janne Aukia</b>
<span style="margin:2em; color:#606060">2020-02-03 10:31</span><br/>
Interesting topic! I think Ruby on Rails could be an example of this, it was created based on code/needs from implementing Basecamp. <a href="https://en.wikipedia.org/wiki/Ruby_on_Rails#History">https://en.wikipedia.org/wiki/Ruby_on_Rails#History</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580786771.042700"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1580786771.042700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2020-02-03 19:26</span><br/>
<span style="background-color:#ccf">@Janne Aukia</span> as an old school Rubyest, I'll second that.  I think the biggest difference actually is that before Rails, <tt>require</tt> was used in really random ways.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581710426.101600"></a>
      <img src="https://avatars.slack-edge.com/2020-09-24/1392332871012_8d5fa305f272f9d0c9e3_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1581710426.101600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Roben Kleene</b>
<span style="margin:2em; color:#606060">2020-02-14 12:00</span><br/>
<span style="background-color:#ccf">@Eddy Parkinson</span> (or others) I'd love to hear more about the story of Microsoft and Excel, and how they switched to watching people use Excel. Do you have any good sources for this? E.g., books or articles about it? Thanks!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581716865.102000"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1581716865.102000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-02-14 13:47</span><br/>
The big companies can afford focus group testing, where they have one-way mirrors and watch groups of people wrestle with their products. This kind of intense consumer-oriented testing is very common in advertising, politics, etc.; it costs a fair bit of money to do properly, and you can learn a lot from it. The cheaper way to do it, which is how i did it with my previous products Flying Colors and Discus, was to pass out the home phone number of the developer to the users as the tech support line, and see what comes up. When you have "skin in the game" and have to take the calls for easy questions, you rename things, make thing easier so that question doesn't come up. With enough elapsed time and strong feedback, you can polish your product to a very high degree. I believe all development teams should be forced to man the support lines at least one day out of 5 so that they learn first hand how dumb their users are in terms of computers, and how easily gone astray they go. The best software design is done iteratively, and when you are designing for people you need feedback from the actual users. When you get a call from one person, you can bet that 100 people have that same question, just one of them was diligent enough to call.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1582041928.108000"></a>
      <img src="https://secure.gravatar.com/avatar/a52d221ae708f36674644a348005633a.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1582041928.108000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Janne Aukia</b>
<span style="margin:2em; color:#606060">2020-02-18 08:05</span><br/>
To watch people use a product with a low overhead there is also a concept called “Guerrilla UX/usability testing”,<br/><a href="https://www.uxbooth.com/articles/the-art-of-guerrilla-usability-testing/">https://www.uxbooth.com/articles/the-art-of-guerrilla-usability-testing/</a><br/><br/>See also “The User Experience Team of One: A Research and Design Survival Guide”<br/><a href="https://www.amazon.co.uk/User-Experience-Team-One-Research/dp/1933820187/ref=cm_cr_arp_d_pdt_img_top?ie=UTF8">https://www.amazon.co.uk/User-Experience-Team-One-Research/d&hellip;</a><br/><br/>And in some cases, services like <a href="http://usertesting.com">usertesting.com</a> can be useful, too:<br/><a href="https://www.usertesting.com">https://www.usertesting.com</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1582687482.008900"></a>
      <img src="https://avatars.slack-edge.com/2019-12-12/870368572213_57dceb337de9d471d315_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1582687482.008900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Eddy Parkinson</b>
<span style="margin:2em; color:#606060">2020-02-25 19:24</span><br/>
<span style="background-color:#ccf">@Roben Kleene</span><br/>For value add measurement -  I like these 3 books:- The Mom Test, Microsoft secrets, Competing Against Luck.<br/><br/>For example: Rob Fitzpatrick, bankrupted 3 businesses. Because he did not know how assess the value add of an idea. Also Microsoft had similar problems in the 1990's. People have learned from these failures, and there are now better processes that help with idea validation.<br/><br/>The main idea is to measure the value add of an idea. These 3 books do this in slightly different ways, but they all assess the "value add" by comparing to the current solution. You take the current solution and use that to evaluate new ideas.<br/><br/>Some people call the current solution "As Is" and the proposed solution "To Be".<br/><br/>- Microsoft secrets - It covers many topics and has a chapter or two on idea validation and product road map processes. Some of the product road map processes are aimed at improving existing solutions and large budget project. That said the core lesson is more or less the same.<br/><br/>- Rob Fitzpatrick - book "The Mom Test". Video of him talking about the problem and solution. He describes how to create "as is" user stories so developers can design good "to be" stories. Watch how he picks features. (45 Min) <a href="https://www.youtube.com/watch?v=0LwbFZkyRKk">https://www.youtube.com/watch?v=0LwbFZkyRKk</a><br/><br/>- Clayton Christensen - Competing Against Luck: The Story of Innovation and Customer Choice - is related, the book review I have seen suggest his process is mostly the same, but I have not read it.<br/><br/>Focus groups/user testing/UX - as described by <span style="background-color:#ccf">@magicmouse94937</span> above is also discussed in Microsoft secrets. - In my view, value add and ease of use are not the same. For example, word processors have become easy to use, you don't need an instruction manual or training course these days, but I remember word perfect and having to memorise key combinations for bold and centre etc.   ....  With the problem of value add, you can create a reasonable estimate of the value add of a new feature idea long before you write any code. The 3 books describe ways to do this.<br/><br/>Excel story ... "Over the next two weeks we visited dozens of Excel customers, and did not see anyone using Excel to actually perform what you would call “calculations.” Almost all of them were using Excel because it was a convenient way to create a table."<br/>From  <a href="https://www.joelonsoftware.com/2012/01/06/how-trello-is-different/">https://www.joelonsoftware.com/2012/01/06/how-trello-is-different/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1582854215.017700"></a>
      <img src="https://avatars.slack-edge.com/2020-09-24/1392332871012_8d5fa305f272f9d0c9e3_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1582854215.017700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Roben Kleene</b>
<span style="margin:2em; color:#606060">2020-02-27 17:43</span><br/>
Great list thanks for putting this together! I'm familiar with The Mom Test, but MIcrosoft Secrets is new to me. Others who find this thread might also be interested in another one that I heard about recently "Sweating Bullets: Notes about Inventing PowerPoint" by Robert Gaskins, the inventor of PowerPoint.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1582857800.017900"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1582857800.017900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-02-27 18:43</span><br/>
Microsoft is an excellent example of how to spend enormous amounts of money making very slow progress.  Both Apple and Microsoft, given their R&amp;D budgets seem paralyzed in terms of making new products. It's been many years since they added something new, even by acquisition. I think there is a certain size above which companies become like dinosaurs, where the signals take too long to travel inside the organization, and there are too many layers.  I think the only idea worth much from Microsoft Research in the last 10 years was the Hololens, which i think has great future potential.  But in terms of R&amp;D divided by money spent, a pretty bad equation at both companies. With Jobs gone, Apple has perfected their production and refinement of existing products, but they couldn't even get a two device charging pad out the door recently.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1585004552.083800"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1580606860.029700.html#1585004552.083800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2020-03-23 16:02</span><br/>
Hi Eddy, I think the idea of working backwards from the desired result is an awesome idea! Much of the problems that the software industry has are do to working with some complex mechanism (language, tool, pattern, etc.) and then trying to "emerge" the human model out of it -- which is completely backwards to what makes sense! That's why the human model becomes an afterthought, and software does things people don't expect, and nobody knows what to even look for to fix the situation: they're working from the wrong end!<br/><br/>Anyway, I talked at length in another thread about my thoughts on this, and how I'm approaching the problem of getting rigid mechanism or of the way by making it possible to freely scult whatever it means to design / code / model whatever it is that one is trying to do, rather than starting with a broken model and going the other way.<br/><br/>It's a lot to reformulate on this context, so here's a link to that post / thread: <a href="../thinking-together/1584235196.324400.html#1584764693.467400">../thinking-together/1.584764.html&hellip;</a>
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
