<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-04-16/610501525696_590662e8a2ae7b2c73e9_72.jpg" style="float:left"/>
      <a href="../thinking-together/1556667294.396700.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Priestley</b>
<span style="margin:2em; color:#606060">2019-04-30 16:34</span><br/>
The topic of the interplay between the "expected" and "emergent" behavior of the system, reminds me a lot of Dijkstra's famous GOTO essay. The point he made in that essay was that GOTO was harmful because it prevented you from making inferences about the dynamic behavior of the program from its static syntax, whereas structured programming allowed you to relate the dynamic state of the system to a "coordinate system" derived from the control structures.<br/><br/>I think that appeals to human intuition are often misplaced when it comes to this aspect of code specifically, because code complexity experiences exponential blowup. No matter how well you represent a boolean expression in terms of naming, code formatting, or organization, for instance, there is the fundamental fact that boolean satisfiability is NP-complete; at some point your brain will be unable to scale that cliff. This remark doesn't apply to code that isn't of an NP-complete flavor, like say a flat list of drawing instructions.<br/><br/>I think "composability" is what is important for code, but "composability" is a somewhat vague word. More precisely, there should be a way to determine specific properties of the system by systematic logical deduction from the components of the system, and without simulating the whole dynamic trace of the system's execution. Composability can only be defined relative to the properties you are interested in: SQL is "composable" if you want to know if an element is in the relation defined by the SQL statement, but is not so "composable" if you want to know how long the statement will take to run.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1556668191.396800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1556667294.396700.html#1556668191.396800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-04-30 16:49</span><br/>
<em>“The principle of compositionality has been the subject of intense debate. Indeed, there is no general agreement as to how the principle is to be interpreted, although there have been several attempts to provide formal definitions of it. (Szabó, 2012)“</em> — <a href="https://en.wikipedia.org/wiki/Principle_of_compositionality">https://en.wikipedia.org/wiki/Principle_of_compositionality</a> :smile:<br/><br/>This also seems useful: <a href="https://plato.stanford.edu/entries/compositionality">https://plato.stanford.edu/entries/compositionality</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1556668275.397200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1556667294.396700.html#1556668275.397200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-04-30 16:51</span><br/>
But yes, better to hew to a vague idea than a misleading one.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1556709132.442100"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1556667294.396700.html#1556709132.442100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-05-01 04:12</span><br/>
Have always liked that essay.  The problem we have now as I see it is that structured step-by-step plans aren't a good model for many programs.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557338440.228800"></a>
      <img src="https://avatars.slack-edge.com/2018-09-11/433781465829_7c31dc735c6c1257fe1f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1556667294.396700.html#1557338440.228800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Krouse</b>
<span style="margin:2em; color:#606060">2019-05-08 11:00</span><br/>
I really like this:<br/><br/>&gt; Composability can only be defined relative to the properties you are interested in: SQL is "composable" if you want to know if an element is in the relation defined by the SQL statement, but is not so "composable" if you want to know how long the statement will take to run.<br/><br/>Functional programming is quite good for reasoning about eqautional properties of values but not as much runtime
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557361982.230800"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1556667294.396700.html#1557361982.230800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-05-08 17:33</span><br/>
<span style="background-color:#ccf">@Steve Krouse</span> are you saying this because functions opaque in the sense that the same function can be defined in two ways which may have different runtime characteristics?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557364077.231000"></a>
      <img src="https://avatars.slack-edge.com/2018-09-11/433781465829_7c31dc735c6c1257fe1f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1556667294.396700.html#1557364077.231000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Krouse</b>
<span style="margin:2em; color:#606060">2019-05-08 18:07</span><br/>
Yes. The way I'd put it is: you can reason informally (or prove if you had the time and inclination) that two functions (or expressions) are equivalent in some mathematical/denoational sense but their runtime characteristics can be very different. For example, various definitions of fibbonacci.<br/><br/>I'm also interested in what it would look like for performance characteristics to be composible, if that'd even make sense. So that you could reason about performance of an expression by it's constituent parts and their combining forms. <br/><br/>Maybe like this <a href="https://granule-project.github.io/index.html">https://granule-project.github.io/index.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557371000.231300"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1556667294.396700.html#1557371000.231300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-05-08 20:03</span><br/>
In general terms for "same in some ways but different in others" questions, I find a categorical mindset helpful.  I guess in the verbiage of Granule, you use different type-systems to pull out different information.  The trick (and I think it's absolutely on their radar) is constructing the type-systems as to accommodate composition and refinement.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
