<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2021-04-20/1975289475446_adf09dea9be29fa422a0_72.png" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Andrew Reece</b>
<span style="margin:2em; color:#606060">2019-02-05 13:17</span><br/>
Some of the strengths and (common) weaknesses of declarative programming: <a href="https://www.toptal.com/software/declarative-programming">https://www.toptal.com/software/declarative-programming</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549432834.880400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549432834.880400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-02-05 22:00</span><br/>
The author has an interesting manifesto: <a href="https://altocode.nl">https://altocode.nl</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549433670.880800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549433670.880800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-02-05 22:14</span><br/>
I think that Federico only addressed one kind of declarative language, that of a domain specific language. PROLOG is an example of a deductive language that is declarative in nature; you don't move the execution pointer down a sequential list of instructions, instead you declare a series of facts, and the runtime magically does the logical implication steps for you so that then you can ask questions given your facts. The computer does a lot of tricky work for you in PROLOG, and it is an unfortunate fact of history that at the time the french labs invented PROLOG, there was a huge battle for funding between the AI people using LISP (primarily at Project MAC at MIT), and the MIT team won, got the funding for "automatic programming", and then proceeded to fail miserably to deliver on any of the promises of computer-aided programming, and it tarnished the term "AI" for over 20 years.  Now that the old episode has been forgotten AI is now new and shiny again, and getting massive funding all over the place (and for good reason, the latest AI techniques are fantastic and make the old stuff look extremely crude). Anyway PROLOG was taken up by the Japanese, in their ill-fated "5th generation language" project which burned hundreds of millions. So that buried PROLOG as a failure of that magnitude doesn't go unnoticed. But PROLOG has some unique aspects that are worth considering. Using deduction is a very powerful technique.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549447568.888000"></a>
      <img src="https://avatars.slack-edge.com/2018-12-12/502004543669_540fc50d2192cc8aba20_72.jpg" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549447568.888000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Marcel Goethals</b>
<span style="margin:2em; color:#606060">2019-02-06 02:06</span><br/>
Isn't he just describing leaky abstractions?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549452931.890100"></a>
      <img src="https://avatars.slack-edge.com/2019-01-20/529811744742_ca63ca2aa38fa658cc4f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549452931.890100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Woods</b>
<span style="margin:2em; color:#606060">2019-02-06 03:35</span><br/>
The critique about DSL and the complexity gap ring true. I'd much prefer good libraries not some half baked yaml/xml/json DSL. I'm looking at you Ansible, Gulp, Ant etc.).<br/><br/>However the real essence of a declarative approach is defining an end state and not instructions for how to get there.<br/><br/>IMHO the actual problem with declarativeness in that in the general case, you just can't omit "how to get there" because you can't eliminate pathological performance cases. I'll call the declarative run-time a <tt>solver</tt> from here on because that is what we are really talking about.<br/><br/>I don't believe you can have a solver that can analytically determine the best method to tackle a problem because it suffers from multiple types of halting-problem-esq regresses e.g..<br/>- the "methods to determine the method" which can also be pathological<br/>- the solver would need to implement every possible execution strategy<br/><br/>The work-around tends to be ways to hint to your solver about it's approach to avoid pathology but I think it can only ever be a partial workaround. The general case requires a "complete hint" i.e. the explicit list of instructions to perform.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549453053.890300"></a>
      <img src="https://avatars.slack-edge.com/2019-01-20/529811744742_ca63ca2aa38fa658cc4f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549453053.890300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Woods</b>
<span style="margin:2em; color:#606060">2019-02-06 03:37</span><br/>
<span style="background-color:#ccf">@Phil Jones</span> read your comment - Yes! Thinking along the same lines. IMHO prolog is a textbook of example of how declarativeness is impossible at the general level. The language writes a check that the solver can't pay.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549461269.891700"></a>
      <img src="https://secure.gravatar.com/avatar/42bcec88b9653a5c34e35a2be102e115.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549461269.891700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Max Desiatov</b>
<span style="margin:2em; color:#606060">2019-02-06 05:54</span><br/>
I think Prolog didn't ever lose, it was subsumed by strongly-typed languages. Every time you use type inference you trigger a unification algorithm in the type checker. Program domain codified in the type system is a proof that some aspects of your runtime code is valid and the type checker verifies that through unification. <a href="https://en.wikipedia.org/wiki/Curry–Howard_correspondence">https://en.wikipedia.org/wiki/Curry–Howard_correspondence</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549461429.892000"></a>
      <img src="https://secure.gravatar.com/avatar/42bcec88b9653a5c34e35a2be102e115.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549461429.892000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Max Desiatov</b>
<span style="margin:2em; color:#606060">2019-02-06 05:57</span><br/>
My point is that when we write in strongly-typed languages (even those that are commonly perceived as "imperative"), we're using declarative logic programming on the level of types regardless of what we think of usefulness of declarative programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549463931.892300"></a>
      <img src="https://avatars.slack-edge.com/2019-01-20/529811744742_ca63ca2aa38fa658cc4f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549463931.892300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Woods</b>
<span style="margin:2em; color:#606060">2019-02-06 06:38</span><br/>
&gt; strongly-typed languages (even those that are commonly perceived as "imperative"), we're using declarative logic programming on the level of types<br/><br/>I like that.<br/><br/>I don't think it redeems Prolog as a general purpose programming language. It says something different: declarativeness works for constrained problems. Given various type-systems are turing-complete I guess the problems are only really constrained by practice not power.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549466823.892700"></a>
      <img src="https://secure.gravatar.com/avatar/42bcec88b9653a5c34e35a2be102e115.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549466823.892700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Max Desiatov</b>
<span style="margin:2em; color:#606060">2019-02-06 07:27</span><br/>
yep, it also helps to perceive most strongly-typed languages as 2 separate languages: one for "actual programming", be it imperative or declarative; and another declarative logical language on top of that in which you can write additional "type specifications" for a language "below". So when people say "these type systems are ridiculously complex" it's fair to answer that most type systems are just separate languages for declarative logic programming that help you write a "proof" for a "lower-level" language. Btw, this is what makes dependent types so fascinating to me: they make it possible to "bundle" a "formal verification" for your program if you put enough effort in making type signatures detailed and expressive enough.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549466995.892900"></a>
      <img src="https://secure.gravatar.com/avatar/42bcec88b9653a5c34e35a2be102e115.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549466995.892900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Max Desiatov</b>
<span style="margin:2em; color:#606060">2019-02-06 07:29</span><br/>
as far as I understand dependent types allow having proper declarative "languages" on the type system level, here's how vector concatenation looks in Idris, the type signature part is the most interesting to me. I don't have much experience with Prolog, but I wonder if it's as powerful as dependent types in Idris<br/><pre style="white-space:pre-wrap"><br/>(++) : Vect n a -&gt; Vect m a -&gt; Vect (n + m) a<br/>(++) Nil       ys = ys<br/>(++) (x :: xs) ys = x :: xs ++ ys<br/></pre>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549603257.943600"></a>
      <img src="https://avatars.slack-edge.com/2018-09-30/445630960161_85ee3dacef95dd5617e4_72.png" style="float:left"/>
      <a href="../thinking-together/1549401459.878200.html#1549603257.943600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tim Swast</b>
<span style="margin:2em; color:#606060">2019-02-07 21:20</span><br/>
His main point seems to be that external DSLs are bad, but writing declarative style code can be good and composable. The embedded HTML example he gives reminds me a lot of how the HTML module works in Elm. <a href="https://package.elm-lang.org/packages/elm-lang/html/latest/Html">https://package.elm-lang.org/packages/elm-lang/html/latest/Html</a>
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
