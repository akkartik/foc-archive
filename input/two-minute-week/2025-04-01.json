[
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1743516946.198309",
        "client_msg_id": "44B34CE9-8725-4058-A5EB-28B0F0C0F4D1",
        "text": "Would be nice if the environment we were working in made the \"easy\" thing the \"right\" thing. ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1743284789.331059",
        "parent_user_id": "U02E4DAQGSZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OoQYY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Would be nice if the environment we were working in made the \"easy\" thing the \"right\" thing. "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "thread_broadcast",
        "user": "U02E4DAQGSZ",
        "thread_ts": "1743284789.331059",
        "root": {
            "text": "I am back to bug hunting. Reactive live coding is great when it works but the bugs can be devilishly difficult. The best methodology I have is plotting all the transitions on a timeseries and zooming RIGHT IN. Its a technique I keep coming back to and it has fixed quite a few subtle issues. I used to think the dependancy graph would be useful but actually a lot of the reactivity bugs occur via hidden event coupling occurring outside the programming model, for example, mouse events, url events, local storage events. They can cause different cells to trigger each other but not through the normal notification mechanisms.",
            "files": [
                {
                    "id": "F08L02FE6LT",
                    "mode": "hidden_by_limit"
                }
            ],
            "upload": false,
            "user": "U02E4DAQGSZ",
            "display_as_bot": false,
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "j\/fVv",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "I am back to bug hunting. Reactive live coding is great when it works but the bugs can be devilishly difficult. The best methodology I have is plotting all the transitions on a timeseries and zooming RIGHT IN. Its a technique I keep coming back to and it has fixed quite a few subtle issues. I used to think the dependancy graph would be useful but actually a lot of the reactivity bugs occur via hidden event coupling occurring outside the programming model, for example, mouse events, url events, local storage events. They can cause different cells to trigger each other but not through the normal notification mechanisms."
                                }
                            ]
                        }
                    ]
                }
            ],
            "type": "message",
            "ts": "1743284789.331059",
            "client_msg_id": "08753ecc-a69f-41ee-9c93-888146170a2a",
            "thread_ts": "1743284789.331059",
            "reply_count": 6,
            "reply_users_count": 3,
            "latest_reply": "1743577503.308309",
            "reply_users": [
                "UC2A2ARPT",
                "U02E4DAQGSZ",
                "U71PMQ1V0"
            ],
            "replies": [
                {
                    "user": "UC2A2ARPT",
                    "ts": "1743488093.771509"
                },
                {
                    "user": "U02E4DAQGSZ",
                    "ts": "1743490126.019959"
                },
                {
                    "user": "UC2A2ARPT",
                    "ts": "1743516946.198309"
                },
                {
                    "user": "U02E4DAQGSZ",
                    "ts": "1743528430.942399"
                },
                {
                    "user": "U71PMQ1V0",
                    "ts": "1743572777.539859"
                },
                {
                    "user": "U02E4DAQGSZ",
                    "ts": "1743577503.308309"
                }
            ],
            "is_locked": false,
            "subscribed": false
        },
        "type": "message",
        "ts": "1743528430.942399",
        "client_msg_id": "5418010c-e4fd-4c6d-88be-c8fb4cff0ba4",
        "text": "Yeah I do think often \"what are the rules of reactivity to avoid these situations?\". I think one risky problem class is joining async streams via different paths, it often ends up double triggering the common one, in a non-deterministic way because of the async tasks in the middle, whereas in normal programming you would join with `await Promise.all([task1, task2])` . In Rx this is a <https:\/\/www.learnrxjs.io\/learn-rxjs\/operators\/combination\/zip|zip>. Observable went for limited stream combine operators, but even in Rx world, if you zip and then accidentally go out of sync, you get a different type of reactivity bug, so zip is not really the correct answer either, coz there is nothing enforcing the streams are publishing at the same rate.\n\nI look at Rust borrow checker and that it does some kind of resource counting in the type system, so that seems kinda like it might be the right path, but its not \"easy\", either to develop or for people to use. So I dunno. Its an outstanding problem with reactive systems: joining streams in a non-fragile way. When you visualize it at least the problem sometimes becomes apparent, and visualization also catches the unintended coupling that occurs as well in impure systems. So thats my best workable solution for now.\n\n```            Parent\n           \/     \\\n async task1     async task2\n            \\   \/\n           common```\n",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QjKbQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah I do think often \"what are the rules of reactivity to avoid these situations?\". I think one risky problem class is joining async streams via different paths, it often ends up double triggering the common one, in a non-deterministic way because of the async tasks in the middle, whereas in normal programming you would join with "
                            },
                            {
                                "type": "text",
                                "text": "await Promise.all([task1, task2])",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " . In Rx this is a "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.learnrxjs.io\/learn-rxjs\/operators\/combination\/zip",
                                "text": "zip"
                            },
                            {
                                "type": "text",
                                "text": ". Observable went for limited stream combine operators, but even in Rx world, if you zip and then accidentally go out of sync, you get a different type of reactivity bug, so zip is not really the correct answer either, coz there is nothing enforcing the streams are publishing at the same rate.\n\nI look at Rust borrow checker and that it does some kind of resource counting in the type system, so that seems kinda like it might be the right path, but its not \"easy\", either to develop or for people to use. So I dunno. Its an outstanding problem with reactive systems: joining streams in a non-fragile way. When you visualize it at least the problem sometimes becomes apparent, and visualization also catches the unintended coupling that occurs as well in impure systems. So thats my best workable solution for now.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "            Parent\n           \/     \\\n async task1     async task2\n            \\   \/\n           common"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U05UK5T7LPP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U71PMQ1V0",
        "type": "message",
        "ts": "1743572777.539859",
        "client_msg_id": "8cbaa704-cb78-4df8-8bd1-f9ccacd7f75d",
        "text": "I'll just leave <https:\/\/www.scattered-thoughts.net\/writing\/internal-consistency-in-streaming-systems\/> lying around here...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "acf65c259768",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-12-09\/6320751143555_acf65c259768ce3a90a4_72.jpg",
            "first_name": "",
            "real_name": "Jamie Brandon",
            "display_name": "jamii",
            "team": "T5TCAFTA9",
            "name": "jamie",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1743284789.331059",
        "parent_user_id": "U02E4DAQGSZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bysgc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'll just leave "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.scattered-thoughts.net\/writing\/internal-consistency-in-streaming-systems\/"
                            },
                            {
                                "type": "text",
                                "text": " lying around here..."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "ok_hand",
                "users": [
                    "U02E4DAQGSZ"
                ],
                "count": 1
            }
        ]
    }
]