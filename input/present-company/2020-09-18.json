[
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1600416208.000800",
        "client_msg_id": "814831b4-44e2-426b-8c77-cd3cbc2c0217",
        "text": "Good abstractions are helpful, bad abstractions are an obstacle. I don't expect much opposition to this statement. So the real question is how to deal with experimental abstractions, when working in a domain you don't understand very well. Is it better to abstract early or abstract late?\n\nI like <@U5STGTB3J>'s idea of exploring how various communities deal with this, but I think it would be even more instructive to extend this exploration beyond programming. We (in the sense of human societies) have a lot more experience with mathematical and engineering abstractions, for example.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X5L",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good abstractions are helpful, bad abstractions are an obstacle. I don't expect much opposition to this statement. So the real question is how to deal with experimental abstractions, when working in a domain you don't understand very well. Is it better to abstract early or abstract late?\n\nI like "
                            },
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": "'s idea of exploring how various communities deal with this, but I think it would be even more instructive to extend this exploration beyond programming. We (in the sense of human societies) have a lot more experience with mathematical and engineering abstractions, for example."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1600416369.001100",
        "client_msg_id": "5a825a19-1043-42ae-b513-21463fd02fec",
        "text": "Live programming systems have been doing this for decades. Smalltalk is probably the best example to study. When you change a class, all its instances get updated. Common Lisp has such a mechanism as well, but it's not automatic.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FQFn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Live programming systems have been doing this for decades. Smalltalk is probably the best example to study. When you change a class, all its instances get updated. Common Lisp has such a mechanism as well, but it's not automatic."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1600419529.001400",
        "client_msg_id": "b56d4e61-db95-4564-a560-f026b1bf4f81",
        "text": "Picked up and propagated is the trick.  There are a few different senses of propagation.  In Smalltalk and Lisp usually, adding a field or whatever will work with existing objects, but the new field won't have a value.  So there might be a bit of migration involved.  In other cases (Ruby sometimes), you might rebind the name MyRecord to something new so now the old my records refer to a class, or whatever, that isn't called MyRecord anymore.  A third thing you might want to do (what I often do) is you make a change and now you want to go back and rerun (over some scope) with that change replacing the objects with the new alternative.  And then, of course, you want to compare to see what the knock-on effects are of the change are between patched and unpatched possible worlds.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WWdD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Picked up and propagated is the trick.  There are a few different senses of propagation.  In Smalltalk and Lisp usually, adding a field or whatever will work with existing objects, but the new field won't have a value.  So there might be a bit of migration involved.  In other cases (Ruby sometimes), you might rebind the name MyRecord to something new so now the old my records refer to a class, or whatever, that isn't called MyRecord anymore.  A third thing you might want to do (what I often do) is you make a change and now you want to go back and rerun (over some scope) with that change replacing the objects with the new alternative.  And then, of course, you want to compare to see what the knock-on effects are of the change are between patched and unpatched possible worlds."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1600443720.001600",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1600446152.000000"
        },
        "client_msg_id": "48716137-bf8e-4cc5-a626-f9ab15764b33",
        "text": "Yeah, I'm coming at this from my explorations of linguistics and my recently improved understanding of Christopher Alexander's pattern languages. It seems that an overlooked property of ~regular~ human language is that we are perfectly fine in communicating in abstract concepts all the time and there is no need to go and define everything all the way down to the nitty-gritty details as long as we roughly understand the words we use in the same way.\n\nA form of applying this more or less directly to programming is to try to stay on that abstract level where a list is just that, and you go as long as you can without saying what's actually in the list. Of course, with programming languages you'll have to eventually provide some real specific values, if you want to see your program running and doing something. But if you did the generic part properly and your language supports it, it should be as easy as picking a few concrete values for a test case, stick them in, and it should just work (even if it doesn't verify the complete range of possible types\/values), because your program is defined for all lists of any type, whatever type you end up using.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5HKP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I'm coming at this from my explorations of linguistics and my recently improved understanding of Christopher Alexander's pattern languages. It seems that an overlooked property of "
                            },
                            {
                                "type": "text",
                                "text": "regular",
                                "style": {
                                    "strike": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " human language is that we are perfectly fine in communicating in abstract concepts all the time and there is no need to go and define everything all the way down to the nitty-gritty details as long as we roughly understand the words we use in the same way.\n\nA form of applying this more or less directly to programming is to try to stay on that abstract level where a list is just that, and you go as long as you can without saying what's actually in the list. Of course, with programming languages you'll have to eventually provide some real specific values, if you want to see your program running and doing something. But if you did the generic part properly and your language supports it, it should be as easy as picking a few concrete values for a test case, stick them in, and it should just work (even if it doesn't verify the complete range of possible types\/values), because your program is defined for all lists of any type, whatever type you end up using."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1600444211.001900",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1600446289.000000"
        },
        "client_msg_id": "394e5540-f157-4f12-acf4-2893232ff459",
        "text": "What I'm looking at here though, is *not* the benefit of having more generic algorithms which can be reused (which is usually the motivation), but the benefit of not having to (and not being able to) define specifics before you have to. This is much closer to what Alexander has in mind when he talks about \"unfolding\", I think, and it is what I misunderstood about pattern languages — they weren't meant for reusable components, as _Design Patterns_ will make you think — they were meant as a design technique that keeps you focused on the _whole_ and leads you through a process of progressive refinement, step by step adding more details transforming, but never replacing or destroying the structure you have built thus far.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oJ6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What I'm looking at here though, is "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the benefit of having more generic algorithms which can be reused (which is usually the motivation), but the benefit of not having to (and not being able to) define specifics before you have to. This is much closer to what Alexander has in mind when he talks about \"unfolding\", I think, and it is what I misunderstood about pattern languages — they weren't meant for reusable components, as "
                            },
                            {
                                "type": "text",
                                "text": "Design Patterns",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " will make you think — they were meant as a design technique that keeps you focused on the "
                            },
                            {
                                "type": "text",
                                "text": "whole",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and leads you through a process of progressive refinement, step by step adding more details transforming, but never replacing or destroying the structure you have built thus far."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UPMFG2571",
        "type": "message",
        "ts": "1600453456.002800",
        "client_msg_id": "f993f404-d478-4b6c-8d1f-3dee41ce1105",
        "text": "<@UJBAJNFLK> <@UA14TGLTC> Thanks, could you point me to any references or papers I could have a look at specifically about this?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "9c42167d8bfa",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-19\/1070853245589_9c42167d8bfa4cbf26ad_72.png",
            "first_name": "Nuno",
            "real_name": "Nuno Leiria",
            "display_name": "Nuno Leiria",
            "team": "T5TCAFTA9",
            "name": "omniparagon",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3N8i",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " Thanks, could you point me to any references or papers I could have a look at specifically about this?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1600495339.004100",
        "client_msg_id": "484D3F31-9B31-4598-B987-F6D11B4E6A36",
        "text": "<@UPMFG2571> Sorry, no references. I know these systems as a user, not as an academic.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IcB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UPMFG2571"
                            },
                            {
                                "type": "text",
                                "text": " Sorry, no references. I know these systems as a user, not as an academic."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1600495725.009300",
        "client_msg_id": "1B08838E-809B-4095-9027-0DC04614485D",
        "text": "Humans communicate in a context of shared abstractions. In programming we create formalizations for abstractions. Not sure this is comparable.\nThis reminds me of a long-ago discussion with colleagues about teaching mathematical concepts in physics. Is it better to start from examples and then develop abstractions, or start with the abstract and then introduce examples for illustration? There were good arguments on both sides.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "61mEr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Humans communicate in a context of shared abstractions. In programming we create formalizations for abstractions. Not sure this is comparable.\nThis reminds me of a long-ago discussion with colleagues about teaching mathematical concepts in physics. Is it better to start from examples and then develop abstractions, or start with the abstract and then introduce examples for illustration? There were good arguments on both sides."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1600497414.009500",
        "client_msg_id": "86d43dd9-8aa0-4096-a3e7-feca49d25c49",
        "text": "Curiously, no particular paper stands out in my mind.  The only academic insight that I have is that the semantics of how state responds to a change in definition corresponds to an ordering of monads.  And I only remember this faintly as a good example of how monads don't commute (as a rule) and why one shouldn't be too disappointed.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6vFT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Curiously, no particular paper stands out in my mind.  The only academic insight that I have is that the semantics of how state responds to a change in definition corresponds to an ordering of monads.  And I only remember this faintly as a good example of how monads don't commute (as a rule) and why one shouldn't be too disappointed."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]