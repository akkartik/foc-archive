<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-02-14/551655871797_2624b1e78c0a9eaed529_72.jpg" style="float:left"/>
      <a href="../linking-together/1609244173.423500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Knott</b>
<span style="margin:2em; color:#606060">2020-12-29 04:16</span><br/>
I really like this paper which has a clear and simple reference counting system for a functional language, which ends up being surprisingly performant.<br/><br/><a href="https://microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf">https://microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf</a><br/><br/>The key point is that it is fairly easy for the programmer to anticipate when memory will be freed and then immediately refused, allowing for code that effectively mutates memory in place.<br/><br/>For example if you say;<br/><pre style="white-space:pre-wrap">X = f(10)<br/>Y = f(X)<br/></pre><br/>Then you know (assuming it fits) that Y will take the place of X in memory.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1609260569.423600"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1609244173.423500.html#1609260569.423600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-12-29 08:49</span><br/>
Since they can make this guarantee, they can largely use immutable references without giving up performance. And it's clear to the programmer where any cycles could be: in the mutable references. Very cool paper!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1609890045.448200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1609244173.423500.html#1609890045.448200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2021-01-05 15:40</span><br/>
This is the memory management strategy I've chosen for Curv, but I didn't think it was new. I thought I was stealing the idea from APL. Nice paper, it lays out the ideas very clearly. <a href="https://aplwiki.com/wiki/Performance#Reference_counting_and_data_reuse">https://aplwiki.com/wiki/Performance#Reference_counting_and_data_reuse</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1609891998.448400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1609244173.423500.html#1609891998.448400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2021-01-05 16:13</span><br/>
So maybe the PLD community is balkanized. APL has been refcounted since the very beginning in the mid 1960s. APL implementors have been sweating the details on how to make a ref counted functional language fast for 55 years.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
