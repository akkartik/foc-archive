[
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1650218325.226179",
        "client_msg_id": "0c4f651a-5f44-4d2b-b2b5-34ff8f3530ac",
        "text": "I'm more interested in the idea of an abstraction around slots (instance variable name and value) that manages meta data and computation related to it than a particular feature of this general area (such as decorators). Yes, we can implement decorators with macros etc, but that's just one small feature related to this area.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Sny",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm more interested in the idea of an abstraction around slots (instance variable name and value) that manages meta data and computation related to it than a particular feature of this general area (such as decorators). Yes, we can implement decorators with macros etc, but that's just one small feature related to this area."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1650220237.257529",
        "client_msg_id": "5cc8c709-88e7-4544-966e-416e2930354a",
        "text": "clojure supports metadata for any datastructure <https:\/\/clojuredocs.org\/clojure.core\/with-meta>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gsh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "clojure supports metadata for any datastructure "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/clojuredocs.org\/clojure.core\/with-meta"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "ULM3U6275"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1650225472.567519",
        "client_msg_id": "B80B76B1-0C12-4BEF-829A-78EF683461B2",
        "text": "<@ULM3U6275> Pharo Smalltalk has something like that, see <https:\/\/hal.inria.fr\/hal-00641716\/document|https:\/\/hal.inria.fr\/hal-00641716\/document>. Slots can be defined by classes, making them almost objects themselves. I have used this myself only once, to trace and record slot accesses. It’s surprisingly straightforward to use.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ESYEE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " Pharo Smalltalk has something like that, see "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/hal.inria.fr\/hal-00641716\/document",
                                "text": "https:\/\/hal.inria.fr\/hal-00641716\/document"
                            },
                            {
                                "type": "text",
                                "text": ". Slots can be defined by classes, making them almost objects themselves. I have used this myself only once, to trace and record slot accesses. It’s surprisingly straightforward to use."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1650230086.026869",
        "client_msg_id": "b7567d03-eddf-42cd-8a60-aa3dcaafc4e5",
        "text": "Was thinking about this more and JS async\/await can't be used to provide coroutines because there are effective yield points on every call boundary. This destroys the whole point of coroutines, which is to allow the programmer to choose when to yield.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ke0p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Was thinking about this more and JS async\/await can't be used to provide coroutines because there are effective yield points on every call boundary. This destroys the whole point of coroutines, which is to allow the programmer to choose when to yield."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1650230192.007289",
        "client_msg_id": "a80d9fbe-fac4-4ed9-a775-f7463538aa37",
        "text": "That said, if some API was added to allow the programmer to control the ordering of events\/callbacks, that could be used to effectively eliminate those yield points (by always ordering the most recent call first, unless it's an explicitly declared yield point).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "B+7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That said, if some API was added to allow the programmer to control the ordering of events\/callbacks, that could be used to effectively eliminate those yield points (by always ordering the most recent call first, unless it's an explicitly declared yield point)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01661S9F34",
        "type": "message",
        "ts": "1650231527.300709",
        "client_msg_id": "ada7cf7a-e92e-477c-a522-2087791b48e4",
        "text": "Yup. That's why coroutines require async\/await + iterators. It's yield points + a scheduler. The scheduler in JS can be provided via iterators.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fLbdr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yup. That's why coroutines require async\/await + iterators. It's yield points + a scheduler. The scheduler in JS can be provided via iterators."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1650231735.142669",
        "client_msg_id": "a6f7d963-fd22-4e47-ac2c-3242fbdb28ea",
        "text": "I don't follow how iterators prevent switching between promise chains on call boundaries. Can you explain?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WTlL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't follow how iterators prevent switching between promise chains on call boundaries. Can you explain?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01661S9F34",
        "type": "message",
        "ts": "1650232943.900469",
        "client_msg_id": "e114c212-ea05-4368-a01f-fbdf8f90aabf",
        "text": "Let me take a step back. I might not understand your comment. What makes you think there are effective yield points on call boundaries? Or inversely, what makes you think there are not yield points on call boundaries of other coroutine implementations? Why is that a problem? Isn't that controllable by the scheduler? I.e the scheduler (iterator) controls the order of execution and the switching of promise chains.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "19925410efa8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-06-28\/1196019819111_19925410efa8da86ae13_72.jpg",
            "first_name": "",
            "real_name": "Ray Imber",
            "display_name": "Ray Imber",
            "team": "T5TCAFTA9",
            "name": "rayimber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1647422642.414839",
        "parent_user_id": "U02M6PM725T",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9I0p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Let me take a step back. I might not understand your comment. What makes you think there are effective yield points on call boundaries? Or inversely, what makes you think there are not yield points on call boundaries of other coroutine implementations? Why is that a problem? Isn't that controllable by the scheduler? I.e the scheduler (iterator) controls the order of execution and the switching of promise chains."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1650255045.149519",
        "client_msg_id": "71e0d20f-e6cb-44c8-9bc6-f36f9b244daf",
        "text": "Rubyist checking in.  At some point (probably a decade or two ago), the method definition construct was made to return the method name so that you can easily write your own decorators.  This means that when you write `synchronize memoize def calculate(something); ...; end`, the interpreter:\n1. defines the `calculate` method,\n2. sends the symbol `:calculate` to the `memoize` class method, which will presumably define a new version of `calculate` and return `:calculate`, so that the interpreter\n3. again sends the symbol `:calculate` to the `synchronize` class method, which will presumably wrap `calculate` again.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gSc7r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Rubyist checking in.  At some point (probably a decade or two ago), the method definition construct was made to return the method name so that you can easily write your own decorators.  This means that when you write "
                            },
                            {
                                "type": "text",
                                "text": "synchronize memoize def calculate(something); ...; end",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", the interpreter:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "defines the "
                                    },
                                    {
                                        "type": "text",
                                        "text": "calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " method,"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "sends the symbol "
                                    },
                                    {
                                        "type": "text",
                                        "text": ":calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " to the "
                                    },
                                    {
                                        "type": "text",
                                        "text": "memoize",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " class method, which will presumably define a new version of "
                                    },
                                    {
                                        "type": "text",
                                        "text": "calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " and return "
                                    },
                                    {
                                        "type": "text",
                                        "text": ":calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": ", so that the interpreter"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "again sends the symbol "
                                    },
                                    {
                                        "type": "text",
                                        "text": ":calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " to the "
                                    },
                                    {
                                        "type": "text",
                                        "text": "synchronize",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " class method, which will presumably wrap "
                                    },
                                    {
                                        "type": "text",
                                        "text": "calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " again."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1650255215.281449",
        "client_msg_id": "0df3c0d5-bfa3-4afb-8aa8-98579e1d4b75",
        "text": "In Ruby, `public`, `protected`, and `private` annotations are all methods that one could (and should not) override.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rY\/8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Ruby, "
                            },
                            {
                                "type": "text",
                                "text": "public",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "protected",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", and "
                            },
                            {
                                "type": "text",
                                "text": "private",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " annotations are all methods that one could (and should not) override."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "exploding_head",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    }
]