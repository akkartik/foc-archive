[
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1752939930.744589",
        "client_msg_id": "93ba9ccd-34bd-4948-ac1a-2f87d79f7eb1",
        "text": "And yet, most software I have personally looked at and worked with does not adopt FP as its dominant style. But scientific software is probably a special case.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1752759391.595909",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jAvQs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And yet, most software I have personally looked at and worked with does not adopt FP as its dominant style. But scientific software is probably a special case."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1752977103.082229",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1753005419.000000"
        },
        "client_msg_id": "0e65112c-9c97-4c00-9b00-08fc678f8780",
        "text": "Yes. I'm struggling to find words  to express my observation. If I use the phrase \"function-based\", no one understands what I mean, if I switch to using \"FP\", everyone understands what they *think* I mean, but, miss my point). Before C, programming languages talked about \"subroutines\" (or, \"procedures\") and \"functions\", where \"function\" meant pure function in a mathematical-y sense. C conflated the two terms and just called everything a \"function\". This - psychologically - seemed to infer that CPUs were supposed to be used as function-machines. Early languages, like Prolog, Forth, etc. were invented before this mindset took over - the inventors allowed themselves to build little engines using opcodes. The engines supported various - very different - paradigms for thought. It is my belief that, today, programmers try to solve every problem using only one paradigm for thought (the function-based paradigm) and push themselves into unseemly corners in cases where the function-based paradigm is an unsuitable choice. Stuff like \"concurrency\", \"asynchrony\", \"robotics\" should be solved, IMO, in paradigms other than than the function-based one (and, without the attendant \"operating system\" that is needed by the function-based paradigm).\n\nSmalltalk was infected with this cognitive dissonance and began misusing the phrase \"message passing\" when in fact it only implemented function-calling (blocking) with named parameters {correction: functions (aka \"methods\") named by inclusion of parameter keywords}. IMO, an \"object\" should be a whole CPU and a \"message\" is a blob of data sent along a wire from one CPU to another CPU. There is a deep difference between the idea of synchronous machines \/ objects and free-running, asynchronous, distributed machines. We couldn't afford to build this properly in the early days, but, we could afford to do this, properly, today (using cheapo CPUs, Arduinos, RPis, etc.) if we wanted.\n\nIMO, if you're using Python, Javascript, Smalltalk, CLOS, C++, etc. then you are implicitly using the function-based paradigm.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1752759391.595909",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AVCJ4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes. I'm struggling to find words  to express my observation. If I use the phrase \"function-based\", no one understands what I mean, if I switch to using \"FP\", everyone understands what they "
                            },
                            {
                                "type": "text",
                                "text": "think",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " I mean, but, miss my point). Before C, programming languages talked about \"subroutines\" (or, \"procedures\") and \"functions\", where \"function\" meant pure function in a mathematical-y sense. C conflated the two terms and just called everything a \"function\". This - psychologically - seemed to infer that CPUs were supposed to be used as function-machines. Early languages, like Prolog, Forth, etc. were invented before this mindset took over - the inventors allowed themselves to build little engines using opcodes. The engines supported various - very different - paradigms for thought. It is my belief that, today, programmers try to solve every problem using only one paradigm for thought (the function-based paradigm) and push themselves into unseemly corners in cases where the function-based paradigm is an unsuitable choice. Stuff like \"concurrency\", \"asynchrony\", \"robotics\" should be solved, IMO, in paradigms other than than the function-based one (and, without the attendant \"operating system\" that is needed by the function-based paradigm).\n\nSmalltalk was infected with this cognitive dissonance and began misusing the phrase \"message passing\" when in fact it only implemented function-calling (blocking) with named parameters {correction: functions (aka \"methods\") named by inclusion of parameter keywords}. IMO, an \"object\" should be a whole CPU and a \"message\" is a blob of data sent along a wire from one CPU to another CPU. There is a deep difference between the idea of synchronous machines \/ objects and free-running, asynchronous, distributed machines. We couldn't afford to build this properly in the early days, but, we could afford to do this, properly, today (using cheapo CPUs, Arduinos, RPis, etc.) if we wanted.\n\nIMO, if you're using Python, Javascript, Smalltalk, CLOS, C++, etc. then you are implicitly using the function-based paradigm."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]