<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #devlog-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-16 18:43</span><br/>
I <a href="https://mastodon.social/@spiralganglion/112282956696254310">shared</a> some <a href="https://mastodon.social/@spiralganglion/112284014138207711">thoughts</a> about <em>my personal definition of</em> reversible computing over on Mastodon today. (Yeah, I slightly mangled the example of a surjective function — should have said <em>nonnegative</em> integers.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713318301.099399"></a>
      <a href="../devlog-together/1713318208.682589.html#1713318301.099399" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-16 18:45</span><br/>
Images here, in case you dun wan go to Masto.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713319111.937689"></a>
      <img src="https://avatars.slack-edge.com/2024-03-28/6866700980471_7b3bc9e878d663396caf_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713319111.937689" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joshua Horowitz</b>
<span style="margin:2em; color:#606060">2024-04-16 18:58</span><br/>
Not to be a total nerd about this, but what you want sorta feels like a “homotopy equivalence”.<br/><br/>f : X → Y and g : Y → X form a homotopy equivalence if g(f(x)) is “pretty much” like x and f(g(y)) is “pretty much” like y.* So it’s a weakening of the typical definition of inverse functions.<br/><br/>A reason I don’t think this is a great metaphor for you: It actually says something pretty interesting about the relationship between X and Y for there to be any homotopy equivalence at all between them. (We call X and Y “homotopy equivalent” in this situation.) I think you want to be able to reverse functions between very dissimilar / arbitrary domains. So IDK.<br/><br/><li> It’s actually not that g(f(x)) is “pretty much” like x for every x; it’s that the function g ∘ f is, holistically, “pretty much” like the identity function. (Homotopic.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713319549.627229"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713319549.627229" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-16 19:05</span><br/>
You'll have to hold my hand a bit here — I'm way beyond my comfort zone wrt properties n shit — but I'm really interested here in terminology, theory, prior art, etc.<br/><br/>How does this homotopy equivalence work if f and/or g are non-injective, non-surjective, partial, multivalued, etc.? In other words, how close to bijective do these functions need to be for this property of homotopy equivalence to hold? Do f and g both need to be equally "close" to bijective? Or can one of them be made, say, only injective, and the other made multivalued? (Hopefully I said that correctly, or at least that you can intuit my questions)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713319705.525409"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713319705.525409" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-16 19:08</span><br/>
&gt; I think you want to be able to reverse functions between very dissimilar / arbitrary domains.<br/>Yeah, this exactly. I want to largely disregard the relationship between X and Y (in either direction) if that allows me to achieve something that <em>feels</em> reversible in more situations.<br/><br/>Like, for the cases where X and Y are 1-to-1 in f and g, then the reversibility is trivial. But what about the cases where they're not? I want to fake it, with as convincing a fake as I can manage with low-to-medium effort ;)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713320124.991859"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2508698086192_565c54a4fa91a0c8c75a_72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713320124.991859" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Lieber</b>
<span style="margin:2em; color:#606060">2024-04-16 19:15</span><br/>
What makes this your favorite definition of reversible computing?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713320395.683039"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713320395.683039" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-16 19:19</span><br/>
I'm looking for ways to make "reversible" versions of, basically, everything in JavaScript. So I'm trying to figure out what properties would enable the best-feeling version of this.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713322524.776679"></a>
      <img src="https://avatars.slack-edge.com/2024-03-28/6866700980471_7b3bc9e878d663396caf_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713322524.776679" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joshua Horowitz</b>
<span style="margin:2em; color:#606060">2024-04-16 19:55</span><br/>
Yeah sounds like you’re interested so I’m happy to elaborate!<br/><br/>All this homotopy equivalence stuff is coming from topology. Hopefully you know some of the basic topology spiel: we’re talking about squishy squashy spaces where we don’t care about exact shape, just sorta the way the spaces are connected. So a doughnut is the same as a coffee mug (with a handle).<br/><br/>The classic example of a homotopy equivalence, as far as I’m concerned, is the equivalence between a circle C (like points in the plane distance 1 from the origin) and an annulus A (like points in the plane distance 0.9 to 1.1 from the origin).<br/><br/>These two objects are topologically different! For instance: Removing a single point from C will “cut” it, producing something that you can unwrap to turn it into a little line segment. But removing a single point from A just gives you, like, an annulus with an extra tiny extra hole in it.<br/><br/>But there’s a looser sense in which C and A have the same structure — they’re both things with a hole in them — and that sameness is captured by the fact that there’s a homotopy equivalence connecting them.<br/><br/>Making a map f: C → A is easy — C is already a subset of A, so you just map it in there. This is an injective function.<br/><br/>Making a map g: A → C is less obvious, but still pretty straightforward. For instance, you can map each point of the annulus to the point of the circle at the same angle. Which is also the closest point of the circle, FWIW. This is a surjective function.<br/><br/>Interestingly, in this situation, f and g are inverses of each other in one of the two directions. If I start on the circle, do f, and then do g, I get back to my original point. But no way are they going to be inverses of each other the other way around. You lose information going from A to C. So if I start with a point a ∈ A, do g, and do f, I’m going to (generally speaking) end up at a different place in A.<br/><br/>But it turns out (and this is where I’m gonna get very sketchy), that f ∘ g (the map that takes a to f(g(a))) is not that far off from the identity function. In particular, it’s “homotopic” to the identity: it can be continuously deformed to the identity. So that’s what makes f &amp; g a special homotopy equivalence pair.<br/><br/>Now that I’ve given you the whole spiel, let me look more carefully at what you wrote there…
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713322684.191979"></a>
      <img src="https://avatars.slack-edge.com/2024-03-28/6866700980471_7b3bc9e878d663396caf_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713322684.191979" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joshua Horowitz</b>
<span style="margin:2em; color:#606060">2024-04-16 19:58</span><br/>
Ok so you were curious about how close f &amp; g have to be to being bijective. The example I gave above was a very classic sort of example, in which neither are bijective, but one is injective and the other is surjective. The image is that you have two spaces, one of which sits inside the other, and there’s a “projection” operator that sends the larger space down onto the smaller space.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713322730.046299"></a>
      <a href="../devlog-together/1713318208.682589.html#1713322730.046299" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joshua Horowitz</b>
<span style="margin:2em; color:#606060">2024-04-16 19:58</span><br/>
This is related to the idea of “deformation retraction”, illustrated here.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713322774.480529"></a>
      <img src="https://avatars.slack-edge.com/2024-03-28/6866700980471_7b3bc9e878d663396caf_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713322774.480529" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joshua Horowitz</b>
<span style="margin:2em; color:#606060">2024-04-16 19:59</span><br/>
(That’s from Allen Hatcher’s textbook, which is free online, very good, and well-illustrated, tho it is almost certainly impenetrable without a lot more preparation: <a href="https://pi.math.cornell.edu/~hatcher/AT/AT.pdf.">https://pi.math.cornell.edu/~hatcher/AT/AT.pdf.</a>)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713322823.630219"></a>
      <img src="https://avatars.slack-edge.com/2024-03-28/6866700980471_7b3bc9e878d663396caf_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713322823.630219" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joshua Horowitz</b>
<span style="margin:2em; color:#606060">2024-04-16 20:00</span><br/>
But homotopy equivalences themselves don’t require this structure; they’re much more general. You can come up with homotopy equivalences where neither map is injective or surjective, they’re just two sloppy mappings that happen to sort of almost invert each other in this sloppy topological way.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713322905.143559"></a>
      <img src="https://avatars.slack-edge.com/2024-03-28/6866700980471_7b3bc9e878d663396caf_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713322905.143559" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joshua Horowitz</b>
<span style="margin:2em; color:#606060">2024-04-16 20:01</span><br/>
As for multi-valued maps: Mathematicians basically don’t fuck with multi-valued maps. Anything you’d want to represent as a multi-valued map from X to Y, mathematicians prefer to see as a single-valued map from X to P(Y) (the power set, consisting of all subsets of Y).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713322960.738919"></a>
      <img src="https://avatars.slack-edge.com/2024-03-28/6866700980471_7b3bc9e878d663396caf_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713322960.738919" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joshua Horowitz</b>
<span style="margin:2em; color:#606060">2024-04-16 20:02</span><br/>
Ok that’s definitely enough gotta go. :pray:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713326275.312469"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2508698086192_565c54a4fa91a0c8c75a_72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713326275.312469" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Lieber</b>
<span style="margin:2em; color:#606060">2024-04-16 20:57</span><br/>
I just lol’d working out how to sloppy-reverse <tt>sin(x) &gt; 0</tt> evaluating to <tt>true</tt>. glhf, man, this is gonna be wild.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713329565.009479"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713329565.009479" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-16 21:52</span><br/>
Yeah, that's a great example <span style="background-color:#ccf">@Tom Lieber</span>. I'd be perfectly happy if that produced, say, <tt>1</tt> when reversed — even if the original <tt>x</tt> was something totally different — because <tt>1</tt> gets you another <tt>true</tt> when you go forward again.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713330013.443849"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2508698086192_565c54a4fa91a0c8c75a_72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713330013.443849" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Lieber</b>
<span style="margin:2em; color:#606060">2024-04-16 22:00</span><br/>
Does it matter to what you’re working on that <tt>x</tt> might be used in another expression that doesn’t have <tt>1</tt> in its domain? Is rocking forward after a rock backward going to be sloppy too?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713330253.154719"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713330253.154719" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-16 22:04</span><br/>
Yes, potentially! In addition to non-injective, non-surjective, and multivalued, I'm also interested in a notion of "reversible function" that is loose enough to cover partial functions. But I don't have any strong examples yet to help me feel out sensibilities for how I'd like them to behave.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713330394.188529"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713330394.188529" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-16 22:06</span><br/>
Like, the reverse of a non-surjective function is very likely a partial function, so I feel like one answer might be to treat a forward partial function with similar techniques (so that you can meaningfully reverse it and get something useful back).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713423835.628819"></a>
      <img src="https://secure.gravatar.com/avatar/df6784b7d6d97fb67dec89320cc88a84.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0007-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713423835.628819" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dany</b>
<span style="margin:2em; color:#606060">2024-04-18 00:03</span><br/>
Can't you just use matrices? I think of a matrix as basically a couple of transform (functions) put into a neat grid. Inverting them is possible, albeit costly. So couldn't you use a really high order matrix and fit your function as close as possible. Than invert it. This coming from an armchair math expert. :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713444561.751939"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713444561.751939" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-18 05:49</span><br/>
I'm interested in functions on other data types too. Also, non-affine math functions. So matrices are a great example of a bijective function, but I can't see how they'd apply to, say, array.splice()
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713586666.762849"></a>
      <img src="https://avatars.slack-edge.com/2023-08-15/5729371230167_3b2f7aa271abae44baef_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713586666.762849" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Elliot</b>
<span style="margin:2em; color:#606060">2024-04-19 21:17</span><br/>
I'm working on a similar, more manual approach to the problem of reversing functions with my <a href="https://vezwork.github.io/polylab/dist/demo/bidirectionalParse/">https://vezwork.github.io/polylab/dist/demo/bidirectionalParse/</a> bidirectional language project. My approach, up until this point, has been to manually write the reverses of JS functions, and pair them up to form isomorphisms/multidirectional functions. i.e. I manually write three cases for plus: c = a + b, a = c - b, b = c - a. I was going to continue this approach with other data types like array.splice etc.<br/>I like this approach because it is quite doable, and while the simple multidirectional functions themselves are not so expressive to use, once you start composing a bunch of them, you can pretty quickly build up some pretty interesting multidirectional functions, and you kind of get it for free because you can write code as if it were just normal functions, but then call them forward and sideways and backwards.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713587032.295439"></a>
      <img src="https://avatars.slack-edge.com/2023-08-15/5729371230167_3b2f7aa271abae44baef_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713587032.295439" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Elliot</b>
<span style="margin:2em; color:#606060">2024-04-19 21:23</span><br/>
While I was learning about bidirectionality, I tried out MiniKanren. Its really cool because everything you write in it is a relation, which is incredibly powerful -- for example, given an output to a relation, you can get back ALL the possible inputs -- but at the cost of anything complex being hella slow. even something with a relatively simple definition like relational multiplication can get slow for reasonable size numbers I seem to remember.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713588712.852449"></a>
      <img src="https://avatars.slack-edge.com/2023-08-15/5729371230167_3b2f7aa271abae44baef_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713588712.852449" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Elliot</b>
<span style="margin:2em; color:#606060">2024-04-19 21:51</span><br/>
Relating in concept to what <span style="background-color:#ccf">@Joshua Horowitz</span> talked about: I think one thing to check your intuition on is <b>continuity.</b> What I mean is, it might be worth asking yourself these questions:<br/>do you have some sense of "closeness" of input values to your function?<br/>• numbers have an obvious sense of closeness that we learn in school. |a - b| is the distance between a and b.<br/>• you can have a sense of closeness of strings by an "edit distance" such as "<a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a>".<br/>• arrays also could have an edit distance. Maybe array distance is sort of defined in terms of the distance of its entries? Is ['a',1,2] close to ['ab',1,2]? It probably depends on what array modifications you expect.<br/>• git diffs are a sort of measure of the difference between source files.<br/>• etc.<br/>and do you have a sense of closeness of output values to your function?<br/><br/>if a function is continuous, that means that if you "move" your original input value to a new close input value, then the new output of your function should also be close to your original output.<br/>Is the function you are trying to reverse continuous?<br/>The reverse of your function is also a function, is the reverse function continuous?<br/>• For an example, what about a reverse of the square function? the square of 4 could be 2 or -2, and generally the square root of any positive number could be positive or negative. If you want the reverse to be continuous and be single-valued then (I'm pretty sure) maybe you should definite square root to always be positive or always be negative OR you can make square root return a pair of both positive and negative and imagine that the pair lives in a 2d space. Both of these options make for a continuous reverse of the square function:<br/>    ◦ example 1: <br/>    ◦ 4 -sqrt-> 2<br/>    ◦ 4.1 -sqrt-> 2.02 :white_check_mark: 4.1 is close to 4 and 2.02 is close to 2 by number distance<br/>    ◦ example 2: <br/>    ◦ 4 -sqrt-> [-2,2]<br/>    ◦ 4.1 -sqrt-> [-2.02,2.02] :white_check_mark: 4.1 is close to 4 and  [-2.02,2.02] is close to [-2,2] by distance of 2d points<br/>Continuity is useful for thinking about user experience because as time slowly changes, or user input slowly changes, or values slowly change, continuity says that related things don't "jump around".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713590248.138629"></a>
      <img src="https://avatars.slack-edge.com/2023-08-15/5729371230167_3b2f7aa271abae44baef_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713590248.138629" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Elliot</b>
<span style="margin:2em; color:#606060">2024-04-19 22:17</span><br/>
Continuity could be helpful for automating reversal of functions too. If you define some sense of closeness on a datatype, then given an original input and ouput, and given a new output thats close to the original output (maybe assuming the user nudged the output value or something) then you can search only close around the original input value to find a new input.<br/>This could potentially narrow down the search space a lot.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713590303.938349"></a>
      <img src="https://avatars.slack-edge.com/2023-08-15/5729371230167_3b2f7aa271abae44baef_72.jpg" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713590303.938349" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Elliot</b>
<span style="margin:2em; color:#606060">2024-04-19 22:18</span><br/>
This is still pretty theoretical though. I'll try to think about more concrete ways to approach this in JS. I'll also try to think about more concepts that can help constrain or reason about bidirectionality.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1713591339.411189"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../devlog-together/1713318208.682589.html#1713591339.411189" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-04-19 22:35</span><br/>
That idea of manually writing bidirectional versions of functions actually lines up with what I have in mind. Like, my plan is to start with the simplest / dumbest thing that'll work, then gradually (likely manually) add better behaviour where it's most useful. So for instance, the "automatic" reverse version of a math function could just return 0 (or 1, or NaN), for string functions return empty string, etc. Just return values that are likely to be a fixed point, even if it's totally wrong. It'll be a useful (and quick) enabler for what I want to explore.<br/><br/>And then yeah, on top of that I can begin layering in different improvements. A little gradient descent here, maybe minikanren there, maybe sprinkle some GPT bullshit on top. Anything will be an improvement. The suggestions you have about nudging values and treating the error as a point on 2D space are appreciated, since that's the fuzzy frontier of my understanding for how to do a good job of this. Like, my gut says that making x + y = z reversible could be done nicely by creating a special pair of values for x and y that preserve the constraint that they must add to z. But exactly how to do that, I'm not sure yet.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
