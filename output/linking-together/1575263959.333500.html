<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-12-01 21:19</span><br/>
> My motivation was always to create a general-purpose programming language that would solve all problems and be interpreted, but fast.<br/>> <br/>> I much preferred implementing and coding in LISP, but once I was dealing with big data sets and then having to do fairly simple calculations, APL just seemed to have the better vocabulary.<br/>> <br/>> It had to come up one level. Common LISP even then had about 2,000 primitives. I didn't like that. What I liked was the original LISP, which had car, cdr, cons, and cond, but that was too little. Common LISP was way too big, but a stripped-down version of APL was in the middle with about 50 operations. It's about the same size as C. But the thing about the languages that I implement is that <b>there are no libraries: those 50 operations are it. Everybody builds from there, and the resulting programs are extremely short.</b><br/>-- Arthur Whitney, creator of J and K (<a href="https://queue.acm.org/detail.cfm?id=1531242">https://queue.acm.org/detail.cfm?id=1531242</a>)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575281967.334300"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575281967.334300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-02 02:19</span><br/>
an interesting idea I read somewhere about APL/J/K is that sometimes the name of a function is longer than it's definition and since the definition is so declarative it acts as it's own name, so people just rewrite it in place instead of giving it a name
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575293004.334600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575293004.334600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-12-02 05:23</span><br/>
Arthur Whitney's current company is Shakti, and his current language is Shakti K. Here's the tutorial: <a href="https://shakti.com/tutorial/">https://shakti.com/tutorial/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575341084.336200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575341084.336200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-12-02 18:44</span><br/>
K is an evolution of Iverson's APL. I was fortunate enough to speak with Iverson before he passed. He was a completely brilliant mathematician/programmer, and it took him a long time to realize that his invented alphabet was a major hindrance. Coming from a math background, which exults in using greek letters which are a foreign alphabet to most us, he didn't realize the obstacle it created. The beauty of having a verb expressed in a single symbol is similar to the compression one gets out of Chinese, but to a learner, Chinese is well known to be the hardest language to learn (followed by Japanese, which is tough because it contains 2000 Chinese characters!). Anyway K doesn't solve the ease of learning and use problem, because you have to read it right to left, which is foreign to all normal people. We learn to read left to right, and the habit of reading right to left is so unnatural, that i fear that K will only be the choice of highly disciplined minds, and thus not going to be widely popular. However it is fantastically compact, and is forward progress in the APL lineage IMHO.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575363339.336900"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575363339.336900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-03 00:55</span><br/>
I agree with you, but a particular part of what you said applies to at most a half of the world "We learn to read left to right, and the habit of reading right to left is so unnatural" emphasis on "unnatural". The idea that triggered that (eurocentric :P) word is the space of unexplored "natural" programming languages for people that read right to left and chinese and chinese-like languages :slightly_smiling_face: do chinese learn APL faster? can they build an APL with chinese characters and spare the need to learn new symbols? do APL symbols translate directly to the meanings of the greek letters? do greeks enjoy APL? what other programming languages would appear if designed in places with a different language/alphabet/writing system?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575363423.337100"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575363423.337100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-03 00:57</span><br/>
For example, I have read APL tutorials but never wrote more than a line on it, but the idea of having adverbs was really interesting to me, what other concepts  from languages other than english and western ones can we use on new programming languages?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575408335.338400"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575408335.338400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-12-03 13:25</span><br/>
Chinese is a cumbersome language, and several times in the last century the govt. considered dropping it entirely. Unfortunately it is not a 1 symbol is 1 word language; most words are made out of at least 2 symbols next to each other, and the ambiguity in the language is therefore rather intense, because they don't use spaces between words, so one has to guess which pairs go together. Learning Chinese is the equivalent of learning 5 european languages. Ezra Pound wrote a great essay on why Chinese is so superior for Poetry, which it is; no language is more poetic and capable of subtlety. No question that knowing pictographic languages makes APL seem like child's play; once you have learned thousands of Chinese symbols that are often only slightly different, APL with its very distinct symbol set of under 100 characters is baby stuff.  And don't forget that APL written in Arabic style would be typed in right to left, but executed left to right, the reverse of that language's normal order, so this is not a Eurocentric issue; you write APL in your normal word order, but it is executed in reverse. Same problem with LISP, which you read from the inside out, which is also highly unnatural, and is often referred to as an "insidious parenthetical notation".  APL was so perverse in its conception that he even included overstruck characters, which one can imagine all the editing complexities that introduces for a tiny gain. Mathematicians frankly delight in obscurity, I wonder how the Parisian mayoral candidate is doing; he is a Field medal mathematician, the first one to run for a major office to my knowledge.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575419535.338700"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575419535.338700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-12-03 16:32</span><br/>
&gt; the idea of having adverbs was really interesting to me<br/>"verb" and "adverb" are just non-standard terminology for standard concepts. In functional programming, a verb is a function, and an adverb is a combinator (a function that takes a function as an argument, and returns another function as a result. For example, in functional languages, "map" is a combinator, which is exactly equivalent to the "each" adverb in APL.<br/><br/>But if you look at the actual syntax of APL (or K), you see something interesting, which might relate to natural language. I don't think that left-to-right vs right-to-left evaluation order is a big deal. Almost every language has right-associative infix operators, APL just has more of them. What I find more interesting is that identifiers and operator symbols are treated the same way: they can be interpreted either as infix operators, or as arguments to an adverb. I don't see that in any other language family. APL classifies each named object as a noun, verb or adverb, and that classification affects how expressions are parsed. An adverb takes one or two verbs as arguments, and a verb takes one or two nouns as arguments. And that's interesting.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575420019.339000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575420019.339000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-12-03 16:40</span><br/>
One thing that's frustrated me about APL and descendants is that tutorials never discuss the grammar. As you point out, there <em>is</em> a grammar. It's not just all associating the same way.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575421303.339200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575421303.339200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-12-03 17:01</span><br/>
APL has nothing to do with Chinese. APL is extended mathematical notation. The idea of using symbols for mathematical operations comes from math. As for the number of symbolic operators, it's comparable to other math-based programming languages. I believe that Haskell (a math-inspired language) has more symbolic operators than any of the languages in the APL family. K is at the low end of this scale, with 26 distinct symbolic operator names. K uses identifiers like 'sin', 'cos', 'tan' for additional operators outside the core set. Even C has more: 28 symbolic operator names, not including the compounds +=, -=, etc. For another comparison, I looked at Julia, which is another math-oriented programming language. I stopped counting at 40, and I didn't include compound operators like += and .^, but there are a lot.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575423123.339400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575423123.339400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-12-03 17:32</span><br/>
> you have to read it right to left, which is foreign to all normal people<br/>In standard mathematical notation, function call notation is read right to left:<br/><pre style="white-space:pre-wrap">   h(g(f(x)))</pre><br/>In languages from the APL family, you use exactly the same notation, but the parentheses are optional, so you can also write:<br/><pre style="white-space:pre-wrap">   h g f x</pre><br/>If you really believe that the problem with the above notation is that it is read right to left, then you should change Beads to have left-to-right function call notation.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575425130.339900"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1575263959.333500.html#1575425130.339900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-12-03 18:05</span><br/>
Also related to right-to-left evaluation:<br/>My language, Curv, is a pure functional language, and programs often consist of deeply nested function calls. A single expression can be spread over many lines. Reading such programs bottom-to-top and right-to-left is a problem, so I introduced left-to-right function call notation, which in my case looks like this:<br/><pre style="white-space:pre-wrap">x &gt;&gt; f &gt;&gt; g &gt;&gt; h    is the same as    h(g(f(x))</pre><br/>In practice, programs written in this style feel just like pipelines in the Unix shell. It's nice. Many other functional languages also have a left-to-right pipeline operator.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
