<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2018-08-13/414472553296_f3eb3ca69d86feb77929_72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gregg Tavares</b>
<span style="margin:2em; color:#606060">2018-11-08 21:53</span><br/>
I'm going to guess this question has been brought up before and maybe you have some links to some great talks on this kind of stuff but ...<br/><br/>I'm watching an Alan Kay talk and sometimes I can't help but wonder if maybe the reason everyone isn't use Smalltalk or Lisp or Haskell or some Visual programming Environment is not because they are all stupid but because those systems actually have other problems.<br/><br/>I can give the example of my experience of Lisp. I wrote some incredible macros that would sort data at compile time to be cache friendly but that also meant anyone who wanted to use my code had to understand my macros. Maybe that's not fair since to use anything you have to understand it but it just got me wondering, like I know I feel more productive in JavaScript (usually) than say C# but I think that's probably because I'm writing relatively small things that are all in my head. As soon as I was on a team I'd want a typed language since it would help spread the knowledge of how things work?<br/><br/>Smalltalk often mentions the entire environment is written in smalltalk and modifiable live. That sounds great for experimenting but horrible for every day use. Imaging running <tt>stpm</tt> (smalltalk package manager) and having no idea how much of your environment was just modified.<br/><br/>To make this topic too big, have any of you written an algorithm in a visual programming environment? For example A* or some rectangle packing algorithm.<br/><br/>Anyway, just curious if you know papers on why not lisp, why not smalltalk, why not VLPs, why not haskell, etc..
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541745642.094900"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541745642.094900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-08 22:40</span><br/>
Yes, I've had the problem of ruining a Smalltalk and Lisp images.  A practical problem, not a fundamental one.  There's nothing preventing OS-type isolation or good checkpointing.  In practice, we would pass around images like most people pass around Word documents with all the attendant advantages and disadvantages.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541745858.097200"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541745858.097200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-08 22:44</span><br/>
It's also true that people, at least in the past, would customize their own Lisps rather than use other people's libraries.  Doesn't help that Common Lisp was everything except the kitchen sink so to speak.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541746002.097600"></a>
      <img src="https://avatars.slack-edge.com/2019-12-15/861537614034_222a2870915d24ec10cc_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541746002.097600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Vladimir Gordeev</b>
<span style="margin:2em; color:#606060">2018-11-08 22:46</span><br/>
&gt; Imaging running <tt>stpm</tt> (smalltalk package manager) and having no idea how much of your environment was just modified.<br/><br/>If we introduce strict versioning of all changes, then it gonna be less chaotic, more practical
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541746091.097800"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541746091.097800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-08 22:48</span><br/>
It's been a long, long time since I used Smalltalk much.  And then there was kind of a patch format that people would send around.  (This was before version control as we know it.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541746270.098000"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541746270.098000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-08 22:51</span><br/>
The one lesson is that objects were more central than their code.  Adding a bunch of methods to a class was a not a big deal, but changing fields was because you might have old instances of that class.  Sometimes you'd get weird ad hoc versioning, a path to migrating old objects to the new format.  Lots of experiments.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541749229.098200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541749229.098200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-08 23:40</span><br/>
&gt; Smalltalk often mentions the entire environment is written in smalltalk and modifiable live. That sounds great for experimenting but horrible for every day use. Imaging running <tt>stpm</tt> (smalltalk package manager) and having no idea how much of your environment was just modified.<br/><br/>Here on Linux, I have no idea how much of my system is modified even when I run <tt>apt</tt> or any other package manager, for that matter :smile:.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541749828.098400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541749828.098400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-08 23:50</span><br/>
But yes, a single global mutable live image doesn't sound great for everyday use. As others mentioned, it seems possible to add on isolation, versioning, snapshots, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541750031.098700"></a>
      <img src="https://avatars.slack-edge.com/2018-08-13/414472553296_f3eb3ca69d86feb77929_72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541750031.098700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gregg Tavares</b>
<span style="margin:2em; color:#606060">2018-11-08 23:53</span><br/>
I knew someone would bring that up. The difference is arguably one of culture. Culturally it's not normal for a language's package manager to modify your system but in many Smalltalk lectures it's considered a feature that the entire smalltalk stack is modifiable from anywhere which suggests that modifying it is encouraged vs say most language package managers where it's not encouraged.<br/><br/>it also seems like smalltalk is trying to monolithic. Make everything smalltalk and you all the benefits of smalltalk which is probably true but I think am happy with the present situation of lots of variety than in some alternate reality where smalltalk one and 100% of code is smalltalk because the entire system is smalltalk. Of course I don't know what I'm missing so I can't really compare that reality with the current one.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541750072.098900"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541750072.098900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-08 23:54</span><br/>
Images can work out surprisingly well.  My team's been doing it with Rails for 10+ years (in lieu of a ActiveRecord) and haven't been able to kick the habit yet.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541750326.099100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541750326.099100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-08 23:58</span><br/>
On a slight tangent, <span style="background-color:#ccf">@Gregg Tavares</span> this statement has me wondering which universe you inhabit:<br/><br/>&gt; ..to use anything you have to understand it..<br/><br/>Isn't <em>all</em> of modern software development based on using things without understanding them? I'm constantly feeling like a throwback for saying people should try to understand what they use, but this is the first time I've heard someone state it like it's a physical law.<br/><br/>Anyway, I can see where you're coming from in the rest of your comment, and Steve Yegge has written before about the different kinds of programmer personalities: <a href="https://plus.google.com/u/0/110981030061712822816/posts/KaSKeg4vQtz">https://plus.google.com/u/0/110981030061712822816/posts/KaSKeg4vQtz</a>. But it's definitely not true that you have to understand a Lisp macro to be able to use it. Macros are often <em>easy</em> to understand, and they reward curiosity. But understanding their internals is not mandatory.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541750429.099600"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541750429.099600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 00:00</span><br/>
In fact, a sign of a good abstraction (in contrast to a leaky one) is that you don't have to understand its internals: it just works!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541750597.099900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541750597.099900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-09 00:03</span><br/>
The extreme malleability, even at core levels (e.g. modifying core classes on the fly) is an important feature for fast feedback and live programming - why require rebuild/deploy/restart when you can just reach in and fiddle with the knob you want directly? Of course, the next question there should be around can we get verification, safety, versioning/rollback etc. in this live image model.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541750691.100100"></a>
      <img src="https://avatars.slack-edge.com/2018-08-13/414472553296_f3eb3ca69d86feb77929_72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541750691.100100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gregg Tavares</b>
<span style="margin:2em; color:#606060">2018-11-09 00:04</span><br/>
I think I've read people describe using lisp as everytime writing a DSL for the problem at hand. So in that sense you need to learn a new DSL for every project which is one more step up from languages that don't support effectively writing a compile time DSL.  In other words if I read a C# program I see C# plus API calls. If I read lisp I see lisp + AP calls + DSL<br/><br/>Now maybe that DSL makes it easier to understand the code in general but wonder if like my experience with JavaScript, that it really only makes it easier for the person that designed the DSL, not everyone else.<br/><br/>Just in case my analogy wasn't clear i find JS easier to use when it's just me but would find it harder on a team. Is it possible lisp has the same issue that it's better for single programmers who have the entire state of their program in their head vs a team of 30+ who don't?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541750946.100300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541750946.100300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-09 00:09</span><br/>
There's no reason 100% code has to be Smalltalk. Smalltalk could just be the 'glue system' (replacing the idea of Unix filesystems and pipes). In theory you could program each object in a Smalltalk like world using a different syntax or UI. Diversity can still emerge.<br/><br/>Smalltalk is often compared to other programming languages but to me it should really be compared to the dominant OS paradigm of Unix/Win/Mac.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541751054.100500"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541751054.100500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 00:10</span><br/>
On the other hand, I'm thinking of "patterns" in Java (circa 1.3ish) where the abstraction ceiling would mean that you were always stuck writing a bunch of boilerplate.  I was enlightened when seeing a master at IntelliJ, a single keystroke would write five lines here, ten lines there, a 100 line subclass, tab, tab, tab, fill in the blanks.  The code was a husk, the real life was in the IDE.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541751118.100700"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541751118.100700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 00:11</span><br/>
<span style="background-color:#ccf">@Shalabh</span> Smalltalk is the IDE too.  I remember a blank stare when I asked what the syntax for a class definition was.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541751303.100900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541751303.100900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-09 00:15</span><br/>
<span style="background-color:#ccf">@William Taysom</span> Isn't Unix an IDE in some sense too? (What's the syntax for creating a file?) Would you still call it an IDE if a computer booted into it, or would it just be the desktop?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541751562.101200"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541751562.101200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 00:19</span><br/>
Waxing philosophical.  The shell is textual, so <tt>touch hello.c</tt> is sort of a syntax for creating a file — more so than click here, click there.  I guess the desktop is an IDE if you know, you develop in it and it's kind of integrated.  :thinking_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541752132.101400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541752132.101400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-09 00:28</span><br/>
Hmm could you create a class in Smalltalk by something like <tt>Object subclass: #myclass ...</tt>. After all those clicks are invoking some method somewhere..
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541752401.101600"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541752401.101600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 00:33</span><br/>
Yes!  And it's interesting that the clickish part of the UI and the textish part of the UI are not at all obviously connected.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541752444.101800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541752444.101800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-09 00:34</span><br/>
Unix slices the system into files, processes, pipes etc. Smalltalk slices it into objects, messages etc. Both impose a system 'world view'. Since we grew up in Unix, perhaps it seems more normal, but really all of these are virtual abstractions to help us make use of the circuitry underneath for our purpose.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541752569.102000"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541752569.102000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 00:36</span><br/>
And the kids now use "app" as a verb!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541752572.102200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541752572.102200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-09 00:36</span><br/>
Not sure I got the 'not connected' part.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541752763.106800"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541752763.106800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 00:39</span><br/>
I just mean that CLI and GUI tend to be pretty different worlds.  Not always, mind you e.g. I just command+clicked in the shell to jump to a line of a file.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541753360.108300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541753360.108300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-09 00:49</span><br/>
Ah I see. The jump-to comment reminds me of a video I saw demoing a Symbolics lisp machine, where I think such a feature would be trivial and automatic (it has to be implemented on top of Unix).<br/><br/>Going back to the original question by <span style="background-color:#ccf">@Gregg Tavares</span>, I don't really know why Smalltalk and Lisp machines didn't catch on but Unix did. I don't think people are stupid, I think they're pretty smart. It may have to do with various market forces, positive feedback loops, entrenchment and so on but that's just my speculation. I would hope at least the research community would pick these up but they seem under explored in research as well.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541757390.113700"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541757390.113700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 01:56</span><br/>
ACME probably had the most integrated text-mouse interface.  If you wanted a menu of commands, for example, you would type a list of them and middle click to run one.  Modern editors work a like this more or less, but adding macros or whatever has more ceremony to it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541778159.114500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-08/681438296241_88eacb7e65edebc579ab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541778159.114500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Aidan Cunniffe</b>
<span style="margin:2em; color:#606060">2018-11-09 07:42</span><br/>
As a more meta response -- I just want to say how thrilled I was to see this questions and all the answers posted here. It's important to study the past attempts, but to stay objective and move forward that must be done w/o undue reverence. Being able to question our influencers is perhaps one of the most important skill this community has developed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541782941.115400"></a>
      <img src="https://avatars.slack-edge.com/2023-04-26/5176774456644_bc46d9e86f7dc3780301_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541782941.115400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Corey Montella</b>
<span style="margin:2em; color:#606060">2018-11-09 09:02</span><br/>
I wrote A* in Eve once. I wish I had it to show you, but it was really easy since A* lends itself to a visual type solution
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541783212.116000"></a>
      <img src="https://avatars.slack-edge.com/2023-04-26/5176774456644_bc46d9e86f7dc3780301_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541783212.116000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Corey Montella</b>
<span style="margin:2em; color:#606060">2018-11-09 09:06</span><br/>
Here's a prototype I did when we were playing around with how it would work
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541784367.116200"></a>
      <img src="https://avatars.slack-edge.com/2023-04-26/5176774456644_bc46d9e86f7dc3780301_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541784367.116200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Corey Montella</b>
<span style="margin:2em; color:#606060">2018-11-09 09:26</span><br/>
I think to understand "Why not smalltalk, lisp, etc" you really need to look at the history of how we got to where we are today. I think the explanation lies not so much in the merits of the technology, but in the momentum and network effects of the others. Way back when computing was new, no one knew at all how to program, or even what it should look like, so there was an amazing effort to explore that design space. That's what gave us languages like smalltalk that look so different from what we use today -- they didn't have any preconceptions about what they were doing, so they were not pigeonholed into a certain design.<br/><br/>BUT, and this is a big one, computing hardware was slow and very expensive. Doing things like making "objects" in the Kay sense which have a lot overhead in message passing was expensive on single threaded sequential processors. It was much more efficient to write languages that loosely mirrored the way the hardware worked. This was especially true considering Moore's law, which was in full effect back then. For every 18 months you spent making your language faster through more efficient algorithms, IBM or Intel or whoever had just doubled their transistor count and made languages like C twice as fast.<br/><br/>So event though a language like Smalltalk had all these amazing human considerations, a language like C kept getting faster and faster, which was really all we wanted out of computers back then. Then you start getting businesses interested, who start paying imperative programmers money. The operating systems are written in C, the applications are written in C, everyone knows C,  so the languages that come after resemble it, and the mindset required to use them are similar to a C mindset. This breeds a monoculture and languages like Smalltalk are just forgotten in time, as the old guard simply isn't large enough to teach the new guard. Eventually people are self-teaching themselves and they have no concept of what came before, no matter how mind-blowingly good it might be.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541784586.116500"></a>
      <img src="https://avatars.slack-edge.com/2023-04-26/5176774456644_bc46d9e86f7dc3780301_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541784586.116500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Corey Montella</b>
<span style="margin:2em; color:#606060">2018-11-09 09:29</span><br/>
What happened is we as a group picked one direction (imperative programming), and we explored all the possibilities in that direction to make it faster and optimize it. The cost of this was leaving behind all these other possibilities. Now that Moore's law has hit some physical limitations, and the topological nature of our programs has changed from single threaded on one machine to a loosely-coupled network of processes, we can't squeeze anymore blood from this stone. I think this is why now you see a renewed interest into dead languages from the before time.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541790646.118500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541790646.118500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-11-09 11:10</span><br/>
<span style="background-color:#ccf">@Shalabh</span>:<br/>&gt; I don't really know why Smalltalk and Lisp machines didn't catch on but Unix did.<br/><br/>This question has been debated to death, of course. Besides the horse's mouth at <a href="https://www.jwz.org/doc/worse-is-better.html">https://www.jwz.org/doc/worse-is-better.html</a>, a good (top 10 maybe) thread is <a href="http://lambda-the-ultimate.org/node/4510">http://lambda-the-ultimate.org/node/4510</a>.<br/><br/>---<br/><br/><span style="background-color:#ccf">@Gregg Tavares</span>, this question of yours is very valid:<br/>&gt; ..people describe using lisp as everytime writing a DSL for the problem at hand. So you need to learn a new DSL for every project..<br/><br/>It was heavily discussed on the ll1 mailing list, back when gods and dinosaurs walked on the earth. One possible starting point is <a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg02030.html">http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg02030.html</a>, though it takes time sampling the whole list to build a more complete picture of the trade-offs.<br/><br/>One clear conclusion is that there are other ways to get the benefits of macros, and that macros don't make sense for all languages. Smalltalk doesn't need them, for example.<br/><br/>Beyond that, I think a lot of the disagreement around Lisp ends up being about people's experience in different domains and situations. I haven't experienced different Lisp programs having whole new DSLs. The most useful macros tend to be pretty general-purpose (see <em>"On Lisp"</em>), and it seems worth learning macros just to get them. It seems a relatively minor issue that different Lisp dialects may use different names for the same macros. Beyond that, if you run into a DSL then things depend on whether the domain benefits from a DSL or it's just gratuitous over-engineering, how well it's designed, etc. But these human/incentive factors exist regardless of language anyway. In my opinion, more powerful languages don't end up with worse over-engineering under the same forces of incentives.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541793400.120200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541793400.120200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-11-09 11:56</span><br/>
Agree with a lot of what <span style="background-color:#ccf">@Corey Montella</span> said. One aspect is that market forces might further strengthen the C/Unix mindset because chip manufacturers and system designs will optimize for the mainstream model. Alan Kay mentions the the B5000 which had a tagged memory architecture - where memory is not just addresseable bytes but instead has support for &lt;tag&gt; and &lt;data&gt; at the hardware level. Almost all high level languages today emulate this in software via object headers.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541793716.120700"></a>
      <img src="https://avatars.slack-edge.com/2023-04-26/5176774456644_bc46d9e86f7dc3780301_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541793716.120700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Corey Montella</b>
<span style="margin:2em; color:#606060">2018-11-09 12:01</span><br/>
I think the market is actually going to come around to our side. You see this already with how GPUs are being used for machine learning, and Intel is adding FPGAs now onto their chips. Alternative architectures are being explored because the Von Neumann arch we've been using this whole time is hitting a wall. The VN bottle neck is really holding things back, and languages designed essentially to conform to that model won't be very helpful in expressing programs that span thousands of machines. I don't even think the idea of a "thread" is very helpful in this context.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541810269.131100"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541810269.131100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 16:37</span><br/>
<span style="background-color:#ccf">@Corey Montella</span> couldn't agree more about C and CPUs and the accedents of history.  Was helping with some homework this week using C for the same reasons that one might use Latin.  Was reminded of how well C is suited for a certain memory and execution model and how tedious it is for everything else.  Of course by the end, I was using function pointers and passing contexts so as to stack allocate memory 'cus who has time to malloc and free.  Got me thinking of Jonathan Blow's Jai language, which, born from his constraints in game programming, differs from what you might see elsewhere.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541826865.131400"></a>
      <img src="https://avatars.slack-edge.com/2018-08-13/414472553296_f3eb3ca69d86feb77929_72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541826865.131400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gregg Tavares</b>
<span style="margin:2em; color:#606060">2018-11-09 21:14</span><br/>
I definitely agree that domains change impressions. I come from games too and I've written some on highly memory constrained systems (NES 10k ram) and so I often hear language people talk about features that were unfathomable to me at the time. For example Rob Pike once suggested GO's compiler was so fast he considered there was no reason to distributed executables, just always compile and I'm sure in his world of servers that made sense. In my world of games that made zero sense. Artists always use all available memory. There's no memory for a compiler or AST in memory (or at least didn't use to be)<br/><br/>Some of you have probably seen Mike Acton presentation about perf. if nothing else it shows that some language ideas while making it easier to code end up making poorly performing code. It's fast enough for word processors and web forms but not for domains that require speed.<br/><br/>I'm not suggesting that lisp or haskell or smalltalk are slow. Only pointing out the obvious that domains can change the discussion a lot.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541827274.136200"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541827274.136200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-09 21:21</span><br/>
I was thinking about other recent examples.  Swift strikes me as a language for compiler writers fed up with C limitations.  Rust seems born of memory leaks.  And of course Go is born is channels and C++ compiler errors/slowness.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541849531.146900"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541849531.146900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2018-11-10 03:32</span><br/>
<span style="background-color:#ccf">@William Taysom</span> Can you help me connect the dots for your Swift example?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541849781.147100"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541849781.147100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-10 03:36</span><br/>
I don't have anything deep to say.  Only read the Swift book when it first came out and got the distinct impression that Swift is a language designed by a frustrated C compiler writer.  Just the semantics of structs and such.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541850951.163300"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541850951.163300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2018-11-10 03:55</span><br/>
<span style="background-color:#ccf">@William Taysom</span> I was just curious. It’s an interesting observation. I don’t really know where the “frustrated compiler writer” storyline emerged from, and maybe I was just shielded from it by not having an outside view on the moment when Swift was announced and released, but from what I can tell the Swift team is everything but motivated by frustration, and rather by a very specific vision of getting rid of the problems of C-style languages that encourage programmer errors and creating an easier to learn language along the way, that still has all the expressivity developers want for low-level stuff.<br/><br/>By the metric of how many iOS apps got rejected for crashing / exhibiting serious bugs from the before-Swift era to today, the team has already succeeded.<br/><br/>If anything, there might be a few exceptionally good C++ developers on that team, who might be driven a little by frustration of how complex C++ has gotten who are now able to make a new attempt at a language that’s at least as safe if not safer and way easier to learn.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541852259.171300"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541852259.171300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-10 04:17</span><br/>
In fairness then, I should elaborate.  As I read through the Swift book (version 1), I kept thinking, "well if you do it that way, you can optimize the hell out of it.  This seems like a language designed for compiler writers." My other main impression was that the genetics didn't seem quite finished.  And that I'd be glad to write for iOS again after Swift stabilized.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541852954.179100"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541852954.179100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2018-11-10 04:29</span><br/>
<span style="background-color:#ccf">@William Taysom</span> I’d say that’s a very accurate description of Swift 1. You should look at it again when Swift 5 is released early next year. :-)<br/><br/>Sometimes I wonder how much of our programming future is shaped by people like us, who think a lot about it and sometimes create awesome projects and prototypes that demonstrate potential vs. people who work on a big project like Swift (or pick any other popular open source language), who are more driven by very practical concerns (e.g. finally shipping an ABI or optimizing compile time) where the bright future is nothing more than a North Star in the night sky providing some loose direction.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1541854857.183600"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1541854857.183600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-10 05:00</span><br/>
Swift 5!  Looking forward to it.  What with the new iPad, I'll just have to convince myself that the most important thing I can do with my time is make an intuitive computer algebra system for my wife.<br/><br/>I've always liked how the Ruby community marries wimsey with practicality.  Soundness seems to be the only compromise.  :stuck_out_tongue_winking_eye:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1542008176.206400"></a>
      <img src="https://avatars.slack-edge.com/2018-08-13/414472553296_f3eb3ca69d86feb77929_72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1542008176.206400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gregg Tavares</b>
<span style="margin:2em; color:#606060">2018-11-11 23:36</span><br/>
<span style="background-color:#ccf">@Corey Montella</span>, thank for your powerpoint on A* but it's pretty incomprehensible to me. It doesn't appear to be a visual programming language in the traditional sense where a visual programming language is clear at a glance to a non-programmer how things are working. Maybe that's not the definition of a visual programming language for others though.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1542008318.206600"></a>
      <img src="https://avatars.slack-edge.com/2018-08-13/414472553296_f3eb3ca69d86feb77929_72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1542008318.206600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gregg Tavares</b>
<span style="margin:2em; color:#606060">2018-11-11 23:38</span><br/>
As for Swift, can someone tell me what makes it special? At a glance it seemed to fit in the Java/C#/Kotlin category. Nothing stuck out that made it seem like more then that to me except it's by apple and so will get attention regardless of merit. (Not saying it's not full of merits, only that even if it wasn't it would be praised by apple fans :stuck_out_tongue: )
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1542008636.206800"></a>
      <img src="https://avatars.slack-edge.com/2018-08-13/414472553296_f3eb3ca69d86feb77929_72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1542008636.206800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gregg Tavares</b>
<span style="margin:2em; color:#606060">2018-11-11 23:43</span><br/>
One random thought that stuck out to me lately related to this. Many years ago Joel Spolsky wrote this article, Making Wrong code look Wrong<br/><br/><a href="https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/">https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/</a><br/><br/>I always loved that article and thought I should apply it but I never did and I never met anyone else that applied it. I wonder if the reasons are similar to the reasons some of the ideas in this thread are less applied.<br/><br/>The part about apps hungarian is arguably manually making types, the same type of types that something like F# or haskell give you for almost free. I'm not sure F# or haskell actually make the reasons for that type of naming entirely irrelevant. Of course the compiles will catch all the errors but when writing the code will I know the type at a glance or do I have to scan up and down the code to figure out what type this things is or rely on some ide to pop up the type somewhere.<br/><br/>Still, it's interesting that the idea seemed great and I still didn't do it. What's wrong me?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1542009036.207100"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1542009036.207100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-11-11 23:50</span><br/>
In Haskell, I think people generally annotate often enough that they don't get confused, soft of a vector for factoring functions.  More often it's the compiler that gets "confused" trying to unify a typo in the most majestic of ways.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544497169.231700"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1544497169.231700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2018-12-10 18:59</span><br/>
You are correct that Smalltalk and Lisp have serious problems that cause them to stay at near zero usage rate. Smalltalk's only contribution to modern languages is the use of named parameters, which makes it easier to skip args if a function has many optional parameters. Otherwise it has almost nothing to add to FORTRAN, and its perverse methodology of sending the plus operator to the number 3 is very counterintuitive for someone trained in algebra. We are used to calling functions with numeric arguments like sine(30) not sending the function sin to the number 30. I could give you 100 reasons why smalltak is useless, but it would offend the nostalgists out there. Lisp is like a bad coin, it just gets recirculated over and over. The main reason LISP is so abhorred in the business world is that it can be considered a "write only" language, where nobody but the author can understand or improve an existing program. Maintainability is a major concern for businesses that run programs for decades. In the hands of an expert LISP is supremely powerful, so it will never go away, but it represents the ultimate in non-reusable parts!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544510580.233100"></a>
      <img src="https://avatars.slack-edge.com/2019-12-15/861537614034_222a2870915d24ec10cc_72.jpg" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1544510580.233100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Vladimir Gordeev</b>
<span style="margin:2em; color:#606060">2018-12-10 22:43</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> I think you're too extreme in your reasoning, in some parts right though.<br/><br/>If I'm not mistaken, it was Smalltalk that brought very idea of IDE. As for sending '+' to a number -- it was done to make language design more orthogonal. That was a reasonable pursuit.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544514766.233300"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1541742837.092100.html#1544514766.233300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-12-10 23:52</span><br/>
And we do spend a few years drilling operator precedence into our youth, so it's not exactly intrinsic.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
