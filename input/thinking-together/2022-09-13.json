[
    {
        "user": "U013ZLJARC7",
        "type": "message",
        "ts": "1663075177.554009",
        "client_msg_id": "c6eac62d-1314-42ea-8f79-4b69f5e8d200",
        "text": "<@U02U0AS3J49> The way you'd do this in semweb terms is to create an ontology that admits the possibility of a negation value and then assert a triple containing that negation. The way you've outlined your various truth values above makes it slightly unclear what semantics you want for your reasoner, but that's downstream from modeling.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8ea58fc41bd6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-10-13\/6057269405632_8ea58fc41bd6baa7dda6_72.png",
            "first_name": "",
            "real_name": "Jack Rusher",
            "display_name": "Jack Rusher",
            "team": "T5TCAFTA9",
            "name": "jack529",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1662837680.940839",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gQL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U02U0AS3J49"
                            },
                            {
                                "type": "text",
                                "text": " The way you'd do this in semweb terms is to create an ontology that admits the possibility of a negation value and then assert a triple containing that negation. The way you've outlined your various truth values above makes it slightly unclear what semantics you want for your reasoner, but that's downstream from modeling."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1663096995.067709",
        "client_msg_id": "ede26ce7-cbf5-42ea-9fed-b739b40c0ff5",
        "text": "The reasoner is s(CASP). Stable model goal directed answer set programming with constraints. Each predicate `p(X)` has a logically negated opposite `-p(X)`. And you can force at least one to be true in every model with `-p(X) :- not p(X). p(X) :- not -p(X).`, which has a shorthand `#abducible p(X).` , which is what I mean by \"maybe\". So similar to the semweb approach (mutually exclusive opposites), but I  maybe not with regard to multiple world semantics, or even loops over negation, etc? Not sure. If what I'm trying to model is what the user knows, I need to be able to model \"I know it is either true or false, but I don't know which\". Which is why I think of the \"maybe\" as part of the model, not part of the reasoning. Does that make sense, or am I missing something.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1662837680.940839",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AN37n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The reasoner is s(CASP). Stable model goal directed answer set programming with constraints. Each predicate "
                            },
                            {
                                "type": "text",
                                "text": "p(X)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " has a logically negated opposite "
                            },
                            {
                                "type": "text",
                                "text": "-p(X)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". And you can force at least one to be true in every model with "
                            },
                            {
                                "type": "text",
                                "text": "-p(X) :- not p(X). p(X) :- not -p(X).",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", which has a shorthand "
                            },
                            {
                                "type": "text",
                                "text": "#abducible p(X).",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " , which is what I mean by \"maybe\". So similar to the semweb approach (mutually exclusive opposites), but I  maybe not with regard to multiple world semantics, or even loops over negation, etc? Not sure. If what I'm trying to model is what the user knows, I need to be able to model \"I know it is either true or false, but I don't know which\". Which is why I think of the \"maybe\" as part of the model, not part of the reasoning. Does that make sense, or am I missing something."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]