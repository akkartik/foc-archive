<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #of-end-user-programming</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-10-07/786673147216_cad501b70b26e7666ed0_72.png" style="float:left"/>
      <a href="../of-end-user-programming/1565827095.063300.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tim Babb</b>
<span style="margin:2em; color:#606060">2019-08-14 16:58</span><br/>
yeah, that precise thing is a high value for me: it seems like template-y things/WYSIWYG editors rather inescapably confine themselves to the tasks/usages that the platform designers have foreseen, so those things feel like cul-de-sacs of utility. same thing for platforms which confine themselves to certain kinds/shapes of dataâ€” how crazy would it be if you had to pick a different programming language if you wanted to work on tables, and a different one for images, and a different one for trees, and so on? that is weirdly the case right now, especially for node-based editors (which is the world I am in right now).<br/><br/>It makes a lot more sense to me to offer the same basic primitives that "real" programming languages offer, and vet that those primitives/concepts are well designed/received. Then "interesting" functionality comes by implementing/exposing interesting APIs over those primitives.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565846591.069200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../of-end-user-programming/1565827095.063300.html#1565846591.069200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-08-14 22:23</span><br/>
You are quite correct that many no-code and low-code systems are actually a collection of pre-built modules, which can be combined into certain space of variations, but that when you lack the fundamental underlying primitives, you bump into what some refer to as the "brick wall" of the walled garden that one lives inside with that tool. I see 2 key challenges for the next gen winning language, which is to permit the era of interchangeable parts, and to allow code transfer between people, as many existing languages make it very hard to understand someone else's program, particularly as the programs grow in size. There is an exponential increase to the difficulty of understanding programs; not sure if it is N to the 1.2, N squared, but it is somewhere in that range by my intuition. I would love to see a scientific study establishing this exponent.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
