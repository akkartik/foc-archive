<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-05-28 04:46</span><br/>
Here's another research track: software permanence. Modern software bitrots quickly. You spend years creating a large program, maybe 50,000 lines. It becomes very popular for a niche audience. Then your goals change, you have very little time to maintain it, and all of your dependencies bit-rot. Your programming language bit-rots: features you depend on are deprecated and removed. Library dependencies bit-rot: no longer maintained, the old versions are insecure, aren't compatible with Wayland, won't compile with new compilers, and so on. New library versions are incompatible with your code, missing features you require that were dropped from the (e.g.) Wayland rewrite due to being too niche.<br/><br/>If we are software revolutionaries, then how do we re-invent the software stack to support software that still runs and is still usable 100 years from now? It's a big topic.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559044359.141700"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559044359.141700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-05-28 04:52</span><br/>
guix is one part of the answer
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559044374.141900"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559044374.141900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-05-28 04:52</span><br/>
immutable content addressable dependency management is another
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559044444.142100"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559044444.142100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-05-28 04:54</span><br/>
a p2p package registry based on ipfs + guix would be nice
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559044599.142300"></a>
      <img src="https://secure.gravatar.com/avatar/24ac39488e9c4f2833d087a1343707dc.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559044599.142300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Yair Chuchem</b>
<span style="margin:2em; color:#606060">2019-05-28 04:56</span><br/>
A few answers:<br/>• Reproducible build (the world’s already getting towards there)<br/>• Modularity - when software isn’t a monolithic chunk of stuff then less parts of it break / need to change<br/>• Safer foundations (the dependencies will have less security problems when they are not implemented in a low level buffer overflows language)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559046372.142600"></a>
      <img src="https://avatars.slack-edge.com/2021-11-13/2722434855730_0c210ee2df74838f8683_72.png" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559046372.142600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>nicolas decoster</b>
<span style="margin:2em; color:#606060">2019-05-28 05:26</span><br/>
WebAssembly as an "universal" compilation target has desirable properties to help achieve "software permanence". First of it is a web standard. A wasm binary will run as long as the browsers support the standard. Then it focuses on security (along with the incoming WASI).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559046622.143000"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559046622.143000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-05-28 05:30</span><br/>
This is a big topic in computational science. Search for "reproducible research". Unfortunately that community is mostly disconnected from the reproducible builds community, although the issues are mostly the same.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559046661.143200"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559046661.143200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-05-28 05:31</span><br/>
BTW, I have written an article about this problem in the context of computational science: "Dealing with Software Collapse" <a href="https://hal.archives-ouvertes.fr/hal-02117588">https://hal.archives-ouvertes.fr/hal-02117588</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559047170.143600"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559047170.143600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-05-28 05:39</span><br/>
<span style="background-color:#ccf">@Mariano Guerra</span> The technical solutions you cite are promising indeed, but they all come down to freezing the dependencies. Which is fine as long as the bottom layer (language, virtual machine, etc.) remain stable and as long as running the old software stack is safe (no critical security bugs).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559047527.144100"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559047527.144100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-05-28 05:45</span><br/>
In my opinion, we also need to work on social solutions. Better conventions, better communication about a library's/language's policy with respect to breaking changes. There's a video by Rich Hickey (the creator of Clojure) where he outlines simple rules that permit library evolution without breakage. For example, you can add functions but never remove them, nor change their interface.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559047626.144300"></a>
      <img src="https://secure.gravatar.com/avatar/deb6636f344e6071fd9fe70724825ac6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559047626.144300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Sébastien</b>
<span style="margin:2em; color:#606060">2019-05-28 05:47</span><br/>
Minimum dependencies and statically compiling/linking are ways to ensure stuff can run. DOS program still run today, but good luck to run a Linux binary from the late 90s. From a language &amp; tooling perspective if we had the ability to re-express/transpile/transform our programs using a fully introspectable program model then we could at least partially automate the porting/translation to a new platform.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559048358.144500"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559048358.144500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-05-28 05:59</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> guix would also freeze the bottom layer. it's true that it won't solve security problems
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559061107.146400"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559061107.146400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-05-28 09:31</span><br/>
<span style="background-color:#ccf">@Mariano Guerra</span> Even Guix (more precisely GuixSD) has an external bottom layer: PC hardware plus BIOS. BTW, Guix also has an interesting mechanism for backwards compatibilty: it can run older copies of itself as a subprocess. Whether this will work on in real life remains to be seen, it's a pretty new feature (see <a href="https://www.gnu.org/software/guix/manual/en/html_node/Inferiors.html">https://www.gnu.org/software/guix/manual/en/html_node/Inferiors.html</a>).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1559071320.153400"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../thinking-together/1559043999.141600.html#1559071320.153400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-05-28 12:22</span><br/>
If the software is fully self-contained (the language, interpreter, and/or compiler is built-in). Like how a living cell contains all its own machinery and can sustain itself. Most software is more like a virus, which has instructions (RNA) that can be injected into &amp; executed by a living entity, but is not itself a living entity.<br/><br/>Such a "living" thing can endure through change, because rather than being <em>part</em> of a changing system, it <b>is</b> the changing system, and thus remains a single coherent whole through change.<br/><br/>(Side note: this is what Christopher Alexander calls "unfolding wholeness" and "structure preserving transformations")
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
