[
    {
        "user": "UM7034QUQ",
        "type": "message",
        "ts": "1682247693.303849",
        "client_msg_id": "e73524ef-0ba0-4015-b14b-c1066e31a66b",
        "text": "<@UGWUJUZHT> have you given nodysseus a go? Here's a tutorial showing a bit more of the autolayout behaviour. <https:\/\/youtu.be\/SluO4uVrRaM|https:\/\/youtu.be\/SluO4uVrRaM>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5e9f304f291",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/05e9f304f29113e7155df3ab1f1d21e8.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png",
            "first_name": "",
            "real_name": "Ulysses Popple",
            "display_name": "Ulysses Popple",
            "team": "T5TCAFTA9",
            "name": "ulysses.popple",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682132551.628689",
        "parent_user_id": "UCUSW7WVD",
        "attachments": [
            {
                "from_url": "https:\/\/youtu.be\/SluO4uVrRaM",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/SluO4uVrRaM\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/SluO4uVrRaM?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen title=\"Creating reusable graphs\"><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "id": 1,
                "original_url": "https:\/\/youtu.be\/SluO4uVrRaM",
                "fallback": "YouTube Video: Creating reusable graphs",
                "title": "Creating reusable graphs",
                "title_link": "https:\/\/youtu.be\/SluO4uVrRaM",
                "author_name": "Ulysses Popple",
                "author_link": "https:\/\/www.youtube.com\/@UlyssesPopple",
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KFNtN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " have you given nodysseus a go? Here's a tutorial showing a bit more of the autolayout behaviour. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/youtu.be\/SluO4uVrRaM",
                                "text": "https:\/\/youtu.be\/SluO4uVrRaM"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UM7034QUQ",
        "type": "message",
        "ts": "1682247794.544089",
        "client_msg_id": "79c7340b-adcb-4221-b912-03ea954b9465",
        "text": "I agree that spacial layout is only useful for human readers - and autolayout means that no spacial information is saved in the data structure of the graph.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5e9f304f291",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/05e9f304f29113e7155df3ab1f1d21e8.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png",
            "first_name": "",
            "real_name": "Ulysses Popple",
            "display_name": "Ulysses Popple",
            "team": "T5TCAFTA9",
            "name": "ulysses.popple",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682132551.628689",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OjD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree that spacial layout is only useful for human readers - and autolayout means that no spacial information is saved in the data structure of the graph."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UM7034QUQ",
        "type": "message",
        "ts": "1682248292.811819",
        "edited": {
            "user": "UM7034QUQ",
            "ts": "1682248608.000000"
        },
        "client_msg_id": "162b183b-58e1-4863-9c4b-0894403ab5f4",
        "text": "In my experience, relayout when adding nodes is confusing if it cuts from layout A to layout B (like autolayout in touchdesigner or houdini). However, using d3-force for graph layout means that nodes can (somewhat) organically transition from layout A to layout B. The main layout problem I haven't solved yet is that between refreshes the graph can sometimes be laid out differently. It's usually fairly similar, especially if the graph stays the same as randomness is seeded by graph structure, but sometimes after editing a bunch and refreshing subtrees swap places. In those cases it takes a sec to orient to the different parts of the graph, but search is there to help. I'd argue the time\/brain power spent regroking the layout is less than the time and brain power spent creating a meaningful layout manually (I and many other TD\/Houdini\/unity devs I know spent countless hours rearranging graphs where \"power assist\" autolayout hurt more than it helped), and for sure more human-centric than a large text file.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5e9f304f291",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/05e9f304f29113e7155df3ab1f1d21e8.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png",
            "first_name": "",
            "real_name": "Ulysses Popple",
            "display_name": "Ulysses Popple",
            "team": "T5TCAFTA9",
            "name": "ulysses.popple",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682132551.628689",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lpGft",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In my experience, relayout when adding nodes is confusing if it cuts from layout A to layout B (like autolayout in touchdesigner or houdini). However, using d3-force for graph layout means that nodes can (somewhat) organically transition from layout A to layout B. The main layout problem I haven't solved yet is that between refreshes the graph can sometimes be laid out differently. It's usually fairly similar, especially if the graph stays the same as randomness is seeded by graph structure, but sometimes after editing a bunch and refreshing subtrees swap places. In those cases it takes a sec to orient to the different parts of the graph, but search is there to help. I'd argue the time\/brain power spent regroking the layout is less than the time and brain power spent creating a meaningful layout manually (I and many other TD\/Houdini\/unity devs I know spent countless hours rearranging graphs where \"power assist\" autolayout hurt more than it helped), and for sure more human-centric than a large text file."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1682260602.386219",
        "client_msg_id": "9900bc05-2f8f-448c-803d-81aa68fc31e5",
        "text": "There's nothing intrinsic to autolayout that requires layout to change every time you add\/remove a node. As an obvious example, you could add the existing positions of all existing nodes as constraints to the solver. Perhaps this over constrains the problem, but I think it's under studied.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682132551.628689",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1IHWc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's nothing intrinsic to autolayout that requires layout to change every time you add\/remove a node. As an obvious example, you could add the existing positions of all existing nodes as constraints to the solver. Perhaps this over constrains the problem, but I think it's under studied."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1682314437.051729",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1682314581.000000"
        },
        "client_msg_id": "e27c37d6-dc7b-41c5-97c7-a18dde41c220",
        "text": "Where does the string \"hello world\" come from when you run the program?\n\nI went back and reread your earlier writings (seeing running code often causes me to focus on a thing). Some reactions:\n• Components include two concerns: what code runs inside them, and what queues are wired up to them. I think having to duplicate the code inside every time you clone a component is a non-starter. You say, \"deduplicating code is a compiler concern\" (<https:\/\/publish.obsidian.md\/programmingsimplicity\/2023-01-24-0D+Ideal+vs.+Reality>) which feels handwavy. Compilers are rocket science, and if we don't have the compilers to do this (we don't have compilers to do a lot, and it isn't obvious to me that compilers can deduplicate arbitrary code without risking lots of performance _regressions_) then somebody still has to do it.\n• As a consequence it seems to me that components are strictly higher level than functions. You don't want to put raw code inside components. Stick a function call into the component, and now copying the component is cheap and you don't need a complicated compiler to make it cheap. This is fine. I wouldn't get too hung up on this. Like you said, use both. The interesting question here is when we should wrap a function in a component abstraction.\n• Calling these things zero-dependency is not quite accurate. As you define it, hardwiring the name of a function call is a dependency. But you have names of components like `echo` hard-wired into your example. Again, this is fine. I wouldn't get too hung up on this. The technical idea is sound. You just need a better name and positioning to avoid these distracting quibbles and focus the audience's attention on the core idea.\n• Request for example #1: How might you perform dependency injection with components? Pass something into a port that causes a component with that name to be invoked? Does this help make things more decoupled? Dependency injection does help decouple functions.\n• Request for example #2: Check out the example of run-length encoding at <https:\/\/www.chiark.greenend.org.uk\/~sgtatham\/coroutines.html>. I'm curious how this program would look with your approach. Might you need coroutines? A component can have multiple inputs and outputs in parallel. Can it have multiple outputs _in series_? So that pumping in one input results in multiple outputs? Then this question has me wondering if it should have multiple inputs in series as well. What might that mean?\n• You've mentioned before that this looks like hardware. One challenge with designing hardware circuits is getting just right the timing of signals coming into a piece of combinatorial circuit, and debugging the weird errors when we don't. We need the sequential latches just so to make the circuit more robust. But the latches add latency. I wonder if your approach shares this problem. What are the semantics of a component with two inputs that receives a signal\/value on only one of them? You could block and wait for the other, or not. Both seem to have trade-offs, and I think I can construct subtle bugs both ways.\n• There are still some gaps before this can be the notation for concurrency. As you said, you need both functions and components to coexist. And you need a way to go between them: wrap a series of function calls in some queues to turn it into a component, or wrap a set of components into a function so you can give it a name\/address to combine with multiple sets of queues. Functions provide abstraction. Copying components does not.\nOn the whole, this needs a whole lot more examples. I'd forget the tooling initially and just hand-write a bunch of examples. Do they seem clear? Are there notational changes that might make them clearer? Etc.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1681811012.388819",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kr7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Where does the string \"hello world\" come from when you run the program?\n\nI went back and reread your earlier writings (seeing running code often causes me to focus on a thing). Some reactions:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Components include two concerns: what code runs inside them, and what queues are wired up to them. I think having to duplicate the code inside every time you clone a component is a non-starter. You say, \"deduplicating code is a compiler concern\" ("
                                    },
                                    {
                                        "type": "link",
                                        "url": "https:\/\/publish.obsidian.md\/programmingsimplicity\/2023-01-24-0D+Ideal+vs.+Reality"
                                    },
                                    {
                                        "type": "text",
                                        "text": ") which feels handwavy. Compilers are rocket science, and if we don't have the compilers to do this (we don't have compilers to do a lot, and it isn't obvious to me that compilers can deduplicate arbitrary code without risking lots of performance "
                                    },
                                    {
                                        "type": "text",
                                        "text": "regressions",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": ") then somebody still has to do it."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "As a consequence it seems to me that components are strictly higher level than functions. You don't want to put raw code inside components. Stick a function call into the component, and now copying the component is cheap and you don't need a complicated compiler to make it cheap. This is fine. I wouldn't get too hung up on this. Like you said, use both. The interesting question here is when we should wrap a function in a component abstraction."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Calling these things zero-dependency is not quite accurate. As you define it, hardwiring the name of a function call is a dependency. But you have names of components like "
                                    },
                                    {
                                        "type": "text",
                                        "text": "echo",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " hard-wired into your example. Again, this is fine. I wouldn't get too hung up on this. The technical idea is sound. You just need a better name and positioning to avoid these distracting quibbles and focus the audience's attention on the core idea."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Request for example #1: How might you perform dependency injection with components? Pass something into a port that causes a component with that name to be invoked? Does this help make things more decoupled? Dependency injection does help decouple functions."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Request for example #2: Check out the example of run-length encoding at "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https:\/\/www.chiark.greenend.org.uk\/~sgtatham\/coroutines.html"
                                    },
                                    {
                                        "type": "text",
                                        "text": ". I'm curious how this program would look with your approach. Might you need coroutines? A component can have multiple inputs and outputs in parallel. Can it have multiple outputs "
                                    },
                                    {
                                        "type": "text",
                                        "text": "in series",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "? So that pumping in one input results in multiple outputs? Then this question has me wondering if it should have multiple inputs in series as well. What might that mean?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "You've mentioned before that this looks like hardware. One challenge with designing hardware circuits is getting just right the timing of signals coming into a piece of combinatorial circuit, and debugging the weird errors when we don't. We need the sequential latches just so to make the circuit more robust. But the latches add latency. I wonder if your approach shares this problem. What are the semantics of a component with two inputs that receives a signal\/value on only one of them? You could block and wait for the other, or not. Both seem to have trade-offs, and I think I can construct subtle bugs both ways."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "There are still some gaps before this can be the notation for concurrency. As you said, you need both functions and components to coexist. And you need a way to go between them: wrap a series of function calls in some queues to turn it into a component, or wrap a set of components into a function so you can give it a name\/address to combine with multiple sets of queues. Functions provide abstraction. Copying components does not."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nOn the whole, this needs a whole lot more examples. I'd forget the tooling initially and just hand-write a bunch of examples. Do they seem clear? Are there notational changes that might make them clearer? Etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    }
]