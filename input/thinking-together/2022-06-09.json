[
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1654790065.838769",
        "client_msg_id": "5e963590-7b4d-4d27-a1ec-ef1055cba38e",
        "text": "<https:\/\/liveblocks.io\/blog\/how-to-build-undo-redo-in-a-multiplayer-environment>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1653663004.176149",
        "parent_user_id": "U03GBV8B58V",
        "attachments": [
            {
                "from_url": "https:\/\/liveblocks.io\/blog\/how-to-build-undo-redo-in-a-multiplayer-environment",
                "image_url": "https:\/\/liveblocks.io\/images\/blog\/social-images\/multiplayer-undo-redo.png",
                "image_width": 469,
                "image_height": 250,
                "image_bytes": 221618,
                "service_icon": "https:\/\/liveblocks.io\/apple-touch-icon.png",
                "id": 1,
                "original_url": "https:\/\/liveblocks.io\/blog\/how-to-build-undo-redo-in-a-multiplayer-environment",
                "fallback": "How to build undo\/redo in a multiplayer environment -  Liveblocks blog",
                "text": "Notoriously tough to build, undo\/redo in a multiplayer environment is even more fraught with difficulty. In this article, we will take you on a behind-the-scenes exclusive, explaining one of the most complex developer issues for multiplayer apps.",
                "title": "How to build undo\/redo in a multiplayer environment -  Liveblocks blog",
                "title_link": "https:\/\/liveblocks.io\/blog\/how-to-build-undo-redo-in-a-multiplayer-environment",
                "service_name": "liveblocks.io"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iNTqT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/liveblocks.io\/blog\/how-to-build-undo-redo-in-a-multiplayer-environment"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03GBV8B58V",
                    "UJ6LDMMN0"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U03DNFDFYDA",
        "type": "message",
        "ts": "1654790807.626299",
        "client_msg_id": "79ad45c4-8569-4ae2-bdb8-281e650b492c",
        "text": "Stumbled on this, somewhat relevant <https:\/\/arxiv.org\/pdf\/2003.07438.pdf>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "f58a6508f111",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-04-29\/3447576657367_f58a6508f11105e0d0be_72.png",
            "first_name": "Alex",
            "real_name": "Alex Cruise",
            "display_name": "Alex Cruise",
            "team": "T5TCAFTA9",
            "name": "alex867",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kKN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Stumbled on this, somewhat relevant "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/arxiv.org\/pdf\/2003.07438.pdf"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "",
        "files": [
            {
                "id": "F03JKK2T3BR",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "U03DNFDFYDA",
        "display_as_bot": false,
        "type": "message",
        "ts": "1654790846.396449",
        "client_msg_id": "41c59204-d2bd-41ce-8755-397c5bcc0f79",
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49"
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1654831932.698139",
        "client_msg_id": "3c32434d-2468-4f40-9673-680f53f12f06",
        "text": "My parser failed on your original question and on the rephrasing, but there's probably something interesting here.  So on the rephrasing, it's the second half.  How can there be \"other inputs\" not included in the list of \"all inputs\"?  (I mean there is more than one way to try to interpret \"other\" here.)  What follows doesn't \"the same result as if you had asked the original program whether the inputs were valid\" help.  Here \"the\" is ambiguous since we're talking about all the ones that led to a given output *and* other inputs too.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BcCn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My parser failed on your original question and on the rephrasing, but there's probably something interesting here.  So on the rephrasing, it's the second half.  How can there be \"other inputs\" not included in the list of \"all inputs\"?  (I mean there is more than one way to try to interpret \"other\" here.)  What follows doesn't \"the same result as if you had asked the original program whether the inputs were valid\" help.  Here \"the\" is ambiguous since we're talking about all the ones that led to a given output "
                            },
                            {
                                "type": "text",
                                "text": "and",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " other inputs too."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1654833095.129749",
        "client_msg_id": "aee04b90-1572-41ef-947b-51cb39df7a8b",
        "text": "Fair. I neglected to mention that the answers from the first question are abstract, expressed as constraints. For example, if your code is the rules of Rock Paper Scissors, your first abstract query might be \"how can someone win a two player game\", and the abstract answers are in the form \" the first player throws rock, and the second player throws scissors, and the first player wins\". That would be one of the three possible abstract models that answer the hypothetical query. Now I know William and Jason played a game, and I know William threw rock. If what I want to know is who won a game, I have two options. I can run the same query again against the rules, with the concrete facts I have, and ask it to presume only that Jason threw something. Or, I can attempt to unify against the abstract models returned by the first query. Either way, the same two results will be returned. The one where Jason threw scissors, and the one where Jason threw paper. The complexity of the first query is exponential with regard to the complexity of the rules and the number of hypothetical inputs. The complexity of the second query is linear with the number of models I got from the first one, and exponential with the number of hypothesized inputs only. All the complexity that comes from the rules is avoided. I think. Maybe. :joy:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LEi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Fair. I neglected to mention that the answers from the first question are abstract, expressed as constraints. For example, if your code is the rules of Rock Paper Scissors, your first abstract query might be \"how can someone win a two player game\", and the abstract answers are in the form \" the first player throws rock, and the second player throws scissors, and the first player wins\". That would be one of the three possible abstract models that answer the hypothetical query. Now I know William and Jason played a game, and I know William threw rock. If what I want to know is who won a game, I have two options. I can run the same query again against the rules, with the concrete facts I have, and ask it to presume only that Jason threw something. Or, I can attempt to unify against the abstract models returned by the first query. Either way, the same two results will be returned. The one where Jason threw scissors, and the one where Jason threw paper. The complexity of the first query is exponential with regard to the complexity of the rules and the number of hypothetical inputs. The complexity of the second query is linear with the number of models I got from the first one, and exponential with the number of hypothesized inputs only. All the complexity that comes from the rules is avoided. I think. Maybe. "
                            },
                            {
                                "type": "emoji",
                                "name": "joy",
                                "unicode": "1f602"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]