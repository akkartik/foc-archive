<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 09:11</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> "Nowadays with gigantic memory stores, worrying about how big a box to store is of minor importance for 99% of programs" I've heard some variant of this statement for 25+ years now ("computers are / will be faster so maximum efficiency is less important"), and it always turns out to be wrong. For one, as computers grow in ability, we simply want to do more complex things with them. Give programmers space, and they will fill it up until things get slow. A more efficient language gives more room to grow. More deeply, a faster language can be said to be more "high level" than a slower language since the programmer doesn't need to worry about performance consequences so much. My simple, brute force C++ algorithm may be smaller, simpler and faster than your complex Python algorithm :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561139912.187300"></a>
      <img src="https://avatars.slack-edge.com/2018-08-13/414472553296_f3eb3ca69d86feb77929_72.png" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561139912.187300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gregg Tavares</b>
<span style="margin:2em; color:#606060">2019-06-21 10:58</span><br/>
&gt; "Nowadays with gigantic memory stores, worrying about how big a box to store is of minor importance for 99% of programs" I've heard some variant of this statement for 25+ years now ("computers are / will be faster so maximum efficiency is less important"),<br/><br/>Is it wrong? The majority of apps in the world run in JavaScript in browsers or webviews which fits the description of "99% of programs". Maybe quibble with 99% to just "the majority of programs"<br/><br/>I'm a game programmer so I generally hate inefficiency and am super sensitive to how inefficient things are but here I am in this app called slack that is written in JavaScript (the client side at least) running in a browser on my desktop or a webview on my phone. I use gmail, google docs, google sheets, all the time. I use VSCode also written in a browser in JavaScript. The majority of games today are written in managed C# (Unity) so while it's true we could get 5x to 25x more efficiency if we used the right techniques it still seems true that for "most software" those things don't matter.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561140650.196600"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561140650.196600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:10</span><br/>
we're now getting into definition territory, but I would argue that the amount of apps that could benefit from more speed / a faster language is waaaay more than that 1%, and that includes many web apps.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561140768.196800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561140768.196800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:12</span><br/>
And the majority of games are not written in C#, only the gameplay code part is. Let's rewrite all the C++ in the Unity engine into C# also and see what games are still playable afterwards.. I predict it will be a very sad situation :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561142718.201300"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561142718.201300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2019-06-21 11:45</span><br/>
These environments\platforms\engines (Unity, browser, electron) are now focusing on making it possible (if not easy) to get the extra 5x-25x more efficiency by adding new low level constructs that are more efficient
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561142748.201500"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561142748.201500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2019-06-21 11:45</span><br/>
DOTS\Burst Compiler, Webassembly, Web Workers, Web GPU, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561142860.201900"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561142860.201900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2019-06-21 11:47</span><br/>
so it might be true that 90% the time 99% of programs don't need that efficiency, sometimes you either unlock new use cases if you get it, or just make the user experience better
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561143073.205000"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561143073.205000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2019-06-21 11:51</span><br/>
all the web applications you mentioned are document editors btw, and although there are benefits to less resource hungry and lower latency document editors, they mostly need to display text.  Yes it'd be great if I could scroll to the beginning of a channel's history instantly on Slack, but its not a deal breaker.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561143135.206300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561143135.206300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-06-21 11:52</span><br/>
Most of those technologies you mention are actually arguments FOR needing faster languages :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561143645.208500"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561143645.208500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2019-06-21 12:00</span><br/>
oh yeah that was my point :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561143719.209100"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561143719.209100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2019-06-21 12:01</span><br/>
even though I went on an unrelated tangent about not needed it for a lot of popular web applications, there are applications that people aren't making because they need better performance and existing tools don't enable it
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561182924.221700"></a>
      <img src="https://avatars.slack-edge.com/2018-08-13/414472553296_f3eb3ca69d86feb77929_72.png" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561182924.221700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gregg Tavares</b>
<span style="margin:2em; color:#606060">2019-06-21 22:55</span><br/>
I don't feel like claiming a game engine written in C# would suck is an example of anything really. There was a game engine written in C# though, XNA, and plenty of games shipped with it.<br/><br/>In any case we optimize the parts that are too slow. Tons of scientists use python and numpy to do science. Does the fact that their python code would use less memory and run faster mean they should be programming in assembly language instead? No, they get stuff done by using what they consider to be a productive language, python, and having it call out to custom more optimized solutions when they need to (numpy). This is arguably the same for most apps. They don't need ultimate efficiency. In fact I'd argue if they prioritized efficiency of CPU execution and efficiency of memory they'd lose on efficiency of developer time which would effectively make software less useful. Lowering developer efficiency means less features, less bug fixes, etc...
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561967427.088800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1561133507.167500.html#1561967427.088800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-07-01 00:50</span><br/>
In my Discus labeling product, which sold a million copies, it was written in a very efficient medium level language called Modula-2. But after profiling it, i found that certain operations were sluggish because it involved triple loops, with per-pixel calculations. Those operations were rewritten in assembler for that 4x speedup which only comes with hand tuning which registers hold which values, and taking advantage of the many weird quirks of the i386 architecture. So i say use the most efficient for programmer time language you have available, and only after the product is in testing do you run benchmarks, identify the slow parts, replace them. A huge fraction of a program is not performance sensitive, and the programming cost especially in elapsed time, is often of great importance. People are way too harsh about performance, and way too liberal with their time. There is undisputed evidence that a person writes about the same number of lines per day of debugged code regardless of the language, so leverage is applied by using a higher level, more powerful language. If you work for Adobe and are in charge of the Gaussian blur function, you will spend man years making it work on 20 core machines, but for most of us regular folk, getting our product out the door with few to no bugs is the overriding goal.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
