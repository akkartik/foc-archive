<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2022-09-08/4075674207584_59de929720a2fe0a13d8_72.jpg" style="float:left"/>
      <a href="../thinking-together/1679902227.016569.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jarno Montonen</b>
<span style="margin:2em; color:#606060">2023-03-27 00:30</span><br/>
On the heels of the "LLMs and the future of programming" discussion (<a href="1679642239.661619.html">1679642239.661619.html</a>, <a href="1679892669.316079.html">1679892669.316079.html</a>), I'd like to start a more concentrated discussion around their effect on Future of Coding projects. There was already some sentiment that LLMs are going to kill FoC projects. Some yes, but certainly not all. So what kind of FoC projects LLMs will not kill?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1679903697.650859"></a>
      <img src="https://avatars.slack-edge.com/2022-09-08/4075674207584_59de929720a2fe0a13d8_72.jpg" style="float:left"/>
      <a href="../thinking-together/1679902227.016569.html#1679903697.650859" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jarno Montonen</b>
<span style="margin:2em; color:#606060">2023-03-27 00:54</span><br/>
To kick off the discussion I did the only logical thing and asked ChatGPT.<br/><br/><em>what are the strengths of low-code and no-code tools against programming with the help of an LLM?</em>:<br/><br/><tt>Low-code and no-code tools, as well as Language Models (LLMs) like GPT-4, each have their own strengths in software development. Here, we will focus on the strengths of low-code and no-code tools when compared to programming with the help of an LLM.</tt><br/>1. <tt>Accessibility: Low-code and no-code platforms are designed to be accessible to non-technical users, enabling more people to create software applications without needing extensive programming knowledge. LLMs, while powerful, still require a basic understanding of programming concepts to be used effectively.</tt><br/>2. <tt>Visual Interface: Low-code and no-code tools often provide a visual, drag-and-drop interface, making it easy to design applications and see the structure of the application. This can be more intuitive than using an LLM, which generally requires text-based communication and code editing.</tt><br/>3. <tt>Standardization: Low-code and no-code platforms typically enforce standardized coding practices and patterns, which can result in more maintainable and organized code. On the other hand, LLMs might generate code with different styles and conventions depending on the input.</tt><br/>4. <tt>Integration: Low-code and no-code platforms often provide pre-built integrations with popular services, databases, and APIs. While LLMs can also help generate code to interact with various services, they might require more manual work to integrate and configure the connections.</tt><br/>5. <tt>Speed of Development: Low-code and no-code tools can significantly speed up the development process, as they automate repetitive tasks and allow users to focus on the overall application design. LLMs can also speed up development, but the improvement might not be as dramatic, especially for simpler applications.</tt><br/>6. <tt>Collaboration: Low-code and no-code platforms often have built-in collaboration features, allowing multiple team members to work on the same project simultaneously. While it's possible to collaborate using LLMs, it might not be as streamlined as using dedicated low-code/no-code tools.</tt><br/>7. <tt>Predictability: Low-code and no-code platforms provide a more predictable development environment, as they consist of predefined components and actions. LLMs can sometimes generate unexpected or inconsistent code, depending on the input and training data.</tt><br/><tt>While low-code and no-code tools have these strengths, it's important to remember that they also have limitations, such as less flexibility in terms of customization, and potential issues with scaling or performance. The choice between using low-code/no-code tools and an LLM depends on the specific project requirements, the technical expertise of the team, and the desired level of customization.</tt><br/><br/><em>How about if we expand the scope to the whole process of software development</em><br/><br/><tt>Expanding the scope to the entire software development process allows us to compare low-code/no-code tools and LLMs across various aspects of the development lifecycle. The following comparison highlights the strengths of low-code/no-code tools in the broader context of software development.</tt><br/>1. <tt>Requirement gathering and prototyping: Low-code/no-code platforms excel at quickly creating prototypes and mockups, which can help in gathering and refining requirements. LLMs can be used for generating code snippets, but they might not provide a complete solution for creating interactive prototypes.</tt><br/>2. <tt>Development and implementation: Low-code/no-code tools can speed up the development process by automating repetitive tasks and providing pre-built components. However, they may lack the flexibility needed for highly customized or complex applications. LLMs can help generate code, but developers still need to manage the overall application structure and logic.</tt><br/>3. <tt>Testing: Low-code/no-code platforms often include built-in testing tools or features, making it easy to validate the application's functionality. While LLMs can help generate test cases or test code, they are not a complete solution for software testing.</tt><br/>4. <tt>Deployment and maintenance: Low-code/no-code platforms usually have straightforward deployment and maintenance processes, often with built-in support for continuous integration and delivery. LLMs can help automate parts of the deployment process, but developers still need to manage the overall infrastructure and maintenance.</tt><br/>5. <tt>Documentation: Low-code/no-code tools often automatically generate documentation based on the application's structure and components. LLMs can be used to generate code comments or external documentation, but they might require more manual effort to ensure that the documentation is accurate and comprehensive.</tt><br/>6. <tt>Collaboration and project management: Low-code/no-code platforms often include collaboration and project management features, allowing teams to work together more efficiently. While LLMs can be used in a collaborative context, they may not provide the same level of support for project management.</tt><br/>7. <tt>Training and onboarding: Low-code/no-code tools generally have a lower learning curve, enabling new team members to become productive more quickly. LLMs can be helpful for generating code samples or answering programming-related questions, but they might not be as effective for onboarding new developers who are not familiar with programming concepts.</tt><br/><tt>While low-code and no-code tools have these strengths in the software development process, they also have limitations. For example, they might not be suitable for highly customized applications or for situations where performance is critical. Moreover, they might result in vendor lock-in, which can limit flexibility and long-term scalability.</tt><br/><tt>Ultimately, the choice between using low-code/no-code tools and an LLM depends on the specific project requirements, the technical expertise of the team, and the desired level of customization and flexibility. In some cases, a combination of low-code/no-code tools and LLMs might be the most effective approach to software development.</tt><br/><br/><em>so, if I'm working on a low-code/no-code tool and I'm worried that LLMs will make the tool obsolete or significantly decrease it's market potential, what should I concentrate on?</em><br/><br/><tt>If you're working on a low-code/no-code tool and concerned about the impact of LLMs on your market potential, you should focus on several aspects that can help differentiate your product and provide value to users beyond what an LLM can offer:</tt><br/>1. <tt>User Experience: Create a user-friendly, intuitive, and visually appealing interface that makes it easy for users to build applications without prior programming knowledge. This will help your tool stand out from LLM-based solutions, which often require more programming expertise to use effectively.</tt><br/>2. <tt>Integrations and Ecosystem: Offer seamless integrations with popular third-party services, databases, and APIs. By providing a rich ecosystem of pre-built connectors and integrations, you can save users time and effort, making your tool more attractive than working with LLMs alone.</tt><br/>3. <tt>Collaboration Features: Build in features that facilitate collaboration and communication among team members, making it easier for them to work together on projects. This can provide a significant advantage over LLMs, which may not inherently support collaborative development.</tt><br/>4. <tt>Customization and Extensibility: While low-code/no-code tools are often associated with less flexibility, you can differentiate your product by offering customization options and extensibility features that cater to various use cases and industries. This could include allowing users to create custom components, use scripting languages, or integrate with external code.</tt><br/>5. <tt>Education and Support: Provide comprehensive documentation, tutorials, and support to help users get the most out of your tool. By offering exceptional customer service and resources, you can create a loyal user base and distinguish your product from LLM-based solutions.</tt><br/>6. <tt>Performance and Scalability: Focus on optimizing your platform for performance and scalability, ensuring that it can handle the demands of larger and more complex applications. This will help attract users who require high-performance solutions that might not be achievable with LLM-generated code.</tt><br/>7. <tt>Security and Compliance: Address security and compliance concerns by incorporating features that ensure data privacy, secure user authentication, and adherence to industry-specific regulations. This can be an essential differentiator for customers in regulated industries.</tt><br/>8. <tt>Target Niche Markets: Identify specific industries or use cases where your low-code/no-code tool can provide unique value, and tailor your features and marketing efforts towards those niches. By becoming a specialized solution, you can carve out a market segment less affected by LLMs.</tt><br/>9. <tt>Community Building: Foster a community around your low-code/no-code tool, encouraging users to share their experiences, tips, and best practices. A strong community can help drive user adoption and increase your product's visibility.</tt><br/><tt>By focusing on these aspects, you can create a competitive low-code/no-code tool that offers value beyond what an LLM can provide, ensuring that your product remains relevant and successful in the market.</tt><br/><br/>I would like to add that programming using LLMs still suffers from all of the possible pain points of the chosen programming language, beyond the act of writing code. Such as debugging experience and compilation or deployment times. This is where live programming tools excel for example.<br/><br/>Of course, some of the LLM weaknesses will be fixed. Which ones will be fixed first? Which ones last or never? Are there niches (user groups, industries or domains) in which the strengths of LLMs don't apply or are decreased? Are there domains in which LLMs can't/will not be utilized for some (political, financial, social, security, emotional, ..) reason?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1679958556.634899"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1679902227.016569.html#1679958556.634899" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2023-03-27 16:09</span><br/>
The points that ChatGPT produced above are quite reasonable. However, the comparison being made is between:<br/>• Low-code/no-code tools<br/>• LLMs that generate code in traditional programming languages (e.g. Python code)<br/>Many of the listed benefits of no-code tools can be hypothetically be achieved through conventional language design as well. For example, the "opportunities for FoC researchers" that I listed in my previous #thinking-together post focus on how to make LLM-generated code easier to understand, accessible to a wider audience, and less error-prone. Those qualities (amongst others) are major selling points of low-code/no-code tools. My contention is that we — as FoC researchers — can develop new general-purpose programming languages that continue to close the gap between <b>no-code</b> and <b>code</b> while <em>embracing</em> LLMs as a valuable tool in our tool belt.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1679982392.919849"></a>
      <img src="https://avatars.slack-edge.com/2022-09-08/4075674207584_59de929720a2fe0a13d8_72.jpg" style="float:left"/>
      <a href="../thinking-together/1679902227.016569.html#1679982392.919849" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jarno Montonen</b>
<span style="margin:2em; color:#606060">2023-03-27 22:46</span><br/>
Very good points. Yes, certainly there are other FoC projects than low-code/no-code tools and I'm very interested in involving them in this discussion. I just happened to phrase the prompts like that..<br/><br/>Validation is certainly a good aspect to focus on. LLMs can help with validation as well, but the question is whose validation do we trust. It will be a long road to build the trust even after LLMs have the capability to (never?) make mistakes and somehow always understand our intent from ambiguous natural language.. However, the level of validation we currently require for purely human written code varies case by case. I guess it must be the same for AI written code. For a hobby game project you might be fine if the AI generated game just appears to work, for a medical/military/aviation device not so much. So I think that if efficiency of validation is the competitive advantage your FoC project relies on, make sure that your project targets domains in which correctness is important.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1679982547.990119"></a>
      <img src="https://avatars.slack-edge.com/2022-09-08/4075674207584_59de929720a2fe0a13d8_72.jpg" style="float:left"/>
      <a href="../thinking-together/1679902227.016569.html#1679982547.990119" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jarno Montonen</b>
<span style="margin:2em; color:#606060">2023-03-27 22:49</span><br/>
In one of these LLM threads someone wrote about the room for improvement in some interface (text interface?) and felt confident working on that problem regardless the onslaught of LLMs. I can't find the message anymore, but if someone could point the person this way, I would love to hear more :slightly_smiling_face:
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
