<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #introduce-yourself</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../introduce-yourself/1543869198.036500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-03 12:33</span><br/>
My first love language as an undergrad was Smalltalk. My weapon of choice today is Clojure. I generally like the stuff that I'm sure most people like : Lisps, Smalltalk, Parc, HARC.<br/><br/>My current thinking on new languages / areas of investigation / demands in my manifesto are these :<br/><br/>1) expressing computation is a solved problem. We have Lambda calculus, Lisp-like functions, Smalltalk-like messages. These are fine. We don't need to worry about these.<br/><br/>The areas we need to explore further are in expressing complex data-structures, "architecture" and constraints. My recent thinking on OO is that what makes OO "hard" is that we don't have good ways of expressing larger scale assemblages of objects. And there's too much focus on the individual class, rather than the collective of how classes or objects act together.<br/><br/>2) A second problem is that programming languages make us do the work in an order that suits them. Our job as programmers is to give a number of constraints to the computer that define a program. The problem is that the computer makes us give the constraints in the order and format that is convenient for it. Often requiring us to fit into architectural restrictions that we don't, in fact, care about but which are part of the fussy housekeeping of the system ... eg. why am I jumping between different files to fill in information about model, about view, about database, about client UI? Etc? Why can't I express what's important to me, in one place, in the order that suits me, and have the computer go back and wire these together?<br/><br/>The first of these thoughts is making me interested in grammars. And the way that ML or Haskell define complex data-schema with algebraic data-types in an almost Backus-Naur style. Can we use something like this to declare assemblages of objects? (See a discussion here : <a href="https://www.quora.com/q/qqylyzqgpwisoecc/Whats-wrong-with-OO">https://www.quora.com/q/qqylyzqgpwisoecc/Whats-wrong-with-OO</a> )<br/><br/>The second of these thoughts has me looking into logic programming in Prolog and Minikanren where we "flatten" our program into a sequence of facts and rules which can be added in more or less any order, leaving the inference engine running around drawing out the implications. (See my discussion with Alexander Tchitchigin in the comments of this : <a href="https://www.quora.com/What-is-the-programming-language-you-are-looking-for-and-why/answer/Phil-Jones">https://www.quora.com/What-is-the-programming-language-you-a&hellip;</a> )
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544525745.049600"></a>
      <img src="https://secure.gravatar.com/avatar/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png" style="float:left"/>
      <a href="../introduce-yourself/1543869198.036500.html#1544525745.049600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Antranig Basman</b>
<span style="margin:2em; color:#606060">2018-12-11 02:55</span><br/>
+1 for "expressing computation is a solved problem, the areas we need to explore further are expressing architecture and constraints"
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1544568924.065600"></a>
      <img src="https://avatars.slack-edge.com/2018-12-02/494422849847_eea3d64ffa95a60795eb_72.png" style="float:left"/>
      <a href="../introduce-yourself/1543869198.036500.html#1544568924.065600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonathan Conway</b>
<span style="margin:2em; color:#606060">2018-12-11 14:55</span><br/>
Regarding that last paragraph, do you think ‘behavioural programming’ might be a step toward addressing that?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1545393644.001800"></a>
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../introduce-yourself/1543869198.036500.html#1545393644.001800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-21 04:00</span><br/>
<span style="background-color:#ccf">@Jonathan Conway</span> on first glance, that Behavioural Programming, as far as I can grok it from a quick skim, is a version of what I'm getting at, yes.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1545393760.002000"></a>
      <img src="https://secure.gravatar.com/avatar/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../introduce-yourself/1543869198.036500.html#1545393760.002000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Phil Jones</b>
<span style="margin:2em; color:#606060">2018-12-21 04:02</span><br/>
It looks a bit like Aspect Oriented Programming to me ... something that tries to kludge what you want into an older way of programming. I think I'd like a new language that is completely built around the principle, rather than a library or framework.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1545415368.004200"></a>
      <img src="https://avatars.slack-edge.com/2018-12-02/494422849847_eea3d64ffa95a60795eb_72.png" style="float:left"/>
      <a href="../introduce-yourself/1543869198.036500.html#1545415368.004200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonathan Conway</b>
<span style="margin:2em; color:#606060">2018-12-21 10:02</span><br/>
Yeah it seems kinda similar to AOT, now you mention it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550366974.005200"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../introduce-yourself/1543869198.036500.html#1550366974.005200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-02-16 17:29</span><br/>
"1) expressing computation is a solved problem. We have Lambda calculus, Lisp-like functions, Smalltalk-like messages. These are fine. We don't need to worry about these."<br/><br/>I'm not sure.... if it were a solved problem, couldn't we all agree about how to do it?<br/><br/>Every language seems to express even basic computation a little differently. What is 0x4000'0000 + 0x9000'0000? In some languages it's a syntax error, in some it's +0xD000'0000, in some -805'306'368, and in some you get a runtime exception. There are seemingly legitimate reasons why each language made the choice it did, and I don't think we've done a good job at standardizing any of the basic decisions that go into our languages. We certainly haven't specified things in a way that would make it practical to convert code between programming languages, and so everybody picks one language in which to write a library and if the language from which you'd like to use the library isn't the same language, you're sh*t out of luck.<br/><br/>That's why one of my big interests is on standardizing this stuff without belittling any of the popular semantic choices - I mean, it's easy for comp-sci types, for example, to say "+0xD000'0000 is obviously the right answer, we just need our systems to use that as the answer", but no, in reality -805'306'368 or an OverflowException might be a better answer in a particular situation.<br/><br/>"The second of these thoughts has me looking into logic programming in Prolog and Minikanren where we "flatten" our program into a sequence of facts and rules which can be added in more or less any order, leaving the inference engine running around drawing out the implications."<br/><br/>My thinking on this is that this is something I definitely want my programming environment to be <b>able</b> to do, but I think the Prolog lovers were mistaken in thinking that in the future all programming would basically be like Prolog programming. I believe there should be a programming language/environment that lets you do <b>everything</b> fairly seamlessly - everything from low-level-but-very-fast hand-written vectorized code with mod-2^32 arithmetic, up to theorem proving and prolog-style stuff where the computer magically finds the solution for you (this code may also be fast, eventually, when the underlying algorithms are both optimized and use dynamic codegen). As a consequence I think that the foundation for such an environment must be somehow imperative in its nature, even though functional / declarative / constraint-based / domain-specific ways of programming would be preferred most of the time.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
