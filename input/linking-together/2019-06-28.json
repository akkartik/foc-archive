[
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1561724860.126100",
        "client_msg_id": "03ec4666-54ef-4e00-9b95-41ec7485cb17",
        "text": "A young aspiring programmer asks you as an expert and mentor:\n&gt;\"I want to understand the most important programming paradigms and learn about the broadest set of language features out there. What is the minimal set of programming languages I should look at? Popularity and how widely used these languages are doesn't matter, I just want the highest :exploding_head:::nerd_face: ratio to maximize my learning.\"\n\nHere's what I think:\n• *C* — for a simple, pragmatic, influential, and still widely used procedural language and to understand memory management\n• *Smalltalk* — for a highly dynamic language and environment, message passing and the origins of OOP\n• *Lisp* — because you wouldn't take me seriously if I left it off such a list\n• *Haskell* — for a pure functional, strongly typed language with laziness and strong compiler support (error checking, synthesis, etc.)\n• *Forth* — for an even simpler, but still highly expressive, extensible, and dynamic language\n• *Datalog* — for logic programming and constraint solvers (or maybe _Prolog_ instead?)\n• *Erlang* — for actor model and concurrent programming\n\nWhat would you respond?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1561724860.126100",
        "reply_count": 14,
        "reply_users_count": 10,
        "latest_reply": "1562786014.211700",
        "reply_users": [
            "UJK8MKYAZ",
            "U78TZ437S",
            "UC2A2ARPT",
            "UEQ6M68H0",
            "UJN1TAYEQ",
            "UJFN50C00",
            "UA14TGLTC",
            "U5STGTB3J",
            "UGWUJUZHT",
            "UHDQ62M4P"
        ],
        "replies": [
            {
                "user": "UJK8MKYAZ",
                "ts": "1561725941.126200"
            },
            {
                "user": "U78TZ437S",
                "ts": "1561726149.126400"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1561742894.126700"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1561747973.126900"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1561774907.127200"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1561837006.127500"
            },
            {
                "user": "UJFN50C00",
                "ts": "1561838495.128300"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1561863900.128500"
            },
            {
                "user": "U5STGTB3J",
                "ts": "1561933384.132100"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1561936456.132600"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1561966417.132800"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1561966766.133000"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1562785902.211500"
            },
            {
                "user": "UHDQ62M4P",
                "ts": "1562786014.211700"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QAP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A young aspiring programmer asks you as an expert and mentor:"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"I want to understand the most important programming paradigms and learn about the broadest set of language features out there. What is the minimal set of programming languages I should look at? Popularity and how widely used these languages are doesn't matter, I just want the highest "
                            },
                            {
                                "type": "emoji",
                                "name": "exploding_head",
                                "unicode": "1f92f"
                            },
                            {
                                "type": "text",
                                "text": ":"
                            },
                            {
                                "type": "emoji",
                                "name": "nerd_face",
                                "unicode": "1f913"
                            },
                            {
                                "type": "text",
                                "text": " ratio to maximize my learning.\""
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nHere's what I think:\n• "
                            },
                            {
                                "type": "text",
                                "text": "C",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — for a simple, pragmatic, influential, and still widely used procedural language and to understand memory management\n• "
                            },
                            {
                                "type": "text",
                                "text": "Smalltalk",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — for a highly dynamic language and environment, message passing and the origins of OOP\n• "
                            },
                            {
                                "type": "text",
                                "text": "Lisp",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — because you wouldn't take me seriously if I left it off such a list\n• "
                            },
                            {
                                "type": "text",
                                "text": "Haskell",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — for a pure functional, strongly typed language with laziness and strong compiler support (error checking, synthesis, etc.)\n• "
                            },
                            {
                                "type": "text",
                                "text": "Forth",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — for an even simpler, but still highly expressive, extensible, and dynamic language\n• "
                            },
                            {
                                "type": "text",
                                "text": "Datalog",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — for logic programming and constraint solvers (or maybe "
                            },
                            {
                                "type": "text",
                                "text": "Prolog",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " instead?)\n• "
                            },
                            {
                                "type": "text",
                                "text": "Erlang",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — for actor model and concurrent programming\n\nWhat would you respond?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJK8MKYAZ",
        "type": "message",
        "ts": "1561725941.126200",
        "client_msg_id": "9a2a5a3c-cbbb-47c4-b236-ee48ad6dccc8",
        "text": "I end up taking a lot of 3-4 hour introductory courses on PluralSight or <http:\/\/Lynda.com|Lynda.com>. I’ve taken those for Haskell, Elixir, and C. While I’ve never programmed in them, the courses have been invaluable to understand the different paradigms, and I’ve found this range (anywhere between 3 and 8 hours) of pretty nice optimization of value vs time invested. I’ve spent much much more time learning Lisp in the form of Scheme (SICP is amazing) and Clojure, and I feel Clojure specifically has improved my taste in languages beyond what it otherwise would be.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g191fa9e3260",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png",
            "first_name": "",
            "real_name": "Daniel Hines",
            "display_name": "Daniel Hines",
            "team": "T5TCAFTA9",
            "name": "d4hines",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1561724860.126100",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ElDC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I end up taking a lot of 3-4 hour introductory courses on PluralSight or "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/Lynda.com",
                                "text": "Lynda.com"
                            },
                            {
                                "type": "text",
                                "text": ". I’ve taken those for Haskell, Elixir, and C. While I’ve never programmed in them, the courses have been invaluable to understand the different paradigms, and I’ve found this range (anywhere between 3 and 8 hours) of pretty nice optimization of value vs time invested. I’ve spent much much more time learning Lisp in the form of Scheme (SICP is amazing) and Clojure, and I feel Clojure specifically has improved my taste in languages beyond what it otherwise would be."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UEQ7QL15F"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U78TZ437S",
        "type": "message",
        "ts": "1561726149.126400",
        "client_msg_id": "450c4ff9-8212-4a3c-ad29-d25025f0a9c2",
        "text": "Nice list :slightly_smiling_face:\n\nI'd add:\n* *Assembly* - to understand the low-level.\n* *Rust* - Enforcable patterns for safe memory use\n* *Agda*\/*Idris* - To glimpse at the power of dependent types\n* *Coq* - To dive deeper into formal logic",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ga3a20a76a69",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/da3a20a76a69532fa83e790e89cb4c6c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png",
            "first_name": "Eyal",
            "real_name": "Eyal Lotem",
            "display_name": "eyal",
            "team": "T5TCAFTA9",
            "name": "eyal.lotem",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1561724860.126100",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oirKh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Nice list "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI'd add:\n* "
                            },
                            {
                                "type": "text",
                                "text": "Assembly",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - to understand the low-level.\n* "
                            },
                            {
                                "type": "text",
                                "text": "Rust",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - Enforcable patterns for safe memory use\n* "
                            },
                            {
                                "type": "text",
                                "text": "Agda",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\/"
                            },
                            {
                                "type": "text",
                                "text": "Idris",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - To glimpse at the power of dependent types\n* "
                            },
                            {
                                "type": "text",
                                "text": "Coq",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - To dive deeper into formal logic"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1561742894.126700",
        "client_msg_id": "62ec1adf-3031-4581-8a2c-262d248b2d85",
        "text": "• Max\/MSP — It's probably the most polished visual programming language.\n• Notations for things that aren't programming — It's worth seeing how other domains have solved the problem of \"process communication\". I'm thinking various notations for music, weaving &amp; patterning, semaphore, electrical schematics, etc\n• SpaceChem, Factorio, Opus Magnum, etc — Video games that take the act of programming and permute into a different kind of joyful experience.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1561724860.126100",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oGM3N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "• Max\/MSP — It's probably the most polished visual programming language.\n• Notations for things that aren't programming — It's worth seeing how other domains have solved the problem of \"process communication\". I'm thinking various notations for music, weaving & patterning, semaphore, electrical schematics, etc\n• SpaceChem, Factorio, Opus Magnum, etc — Video games that take the act of programming and permute into a different kind of joyful experience."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1561747973.126900",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1561837132.000000"
        },
        "client_msg_id": "0662ce97-0879-48e6-a9af-18b930f40be4",
        "text": "For the broadest possible range, i would suggest the following languages to look at\n\n• Modula2 (highly superior to C, free compiler at the ADW website) for how to do separate compilation and modules properly (JS modules are a bad copy)\n• skip smalltalk, it was a cumbersome language whose only enduring contribution is named optional parameters on function calls. But the IDE for smalltalk, called Pharo is among the most advanced of any language.\n• Mathematica - the only commercially successful symbolic language, and has a  sensible business model where schools and big companies pay for the staff of 700+ workers via license fees while students get it for free.\n• Icon - the evolution of Spitbol, one of the best text processing languages\n• Forth - the most compact language ever devised. Almost completely unreadable like Lisp, but it shows the power of stack based languages (of which Postscript is another more commercially successful example).\n• Skip APL, study J instead, Iverson's successor language which ditched the crazy alphabet. Another almost impossible to read language, but very compact.\n• Elixir (skip Erlang, as it has a very ugly syntax for the same runtime). The only runtime that can handle hundreds of thousands of threads no problem; has a unique memory approach by giving each thread its own stack and heap.\n• Delphi (or VB6) for an example of how an integrated product delivers terrific productivity and a marketplace of interchangeable parts). Delphi gets no love from academics but it is incredibly productive.\n• Filemaker Pro for an example of how to make a terrific user interface for screens and forms (and how not to make a scripting language, because its scripting language is archaic and painful to use)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1561724860.126100",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Olcc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For the broadest possible range, i would suggest the following languages to look at\n\n• Modula2 (highly superior to C, free compiler at the ADW website) for how to do separate compilation and modules properly (JS modules are a bad copy)\n• skip smalltalk, it was a cumbersome language whose only enduring contribution is named optional parameters on function calls. But the IDE for smalltalk, called Pharo is among the most advanced of any language.\n• Mathematica - the only commercially successful symbolic language, and has a  sensible business model where schools and big companies pay for the staff of 700+ workers via license fees while students get it for free.\n• Icon - the evolution of Spitbol, one of the best text processing languages\n• Forth - the most compact language ever devised. Almost completely unreadable like Lisp, but it shows the power of stack based languages (of which Postscript is another more commercially successful example).\n• Skip APL, study J instead, Iverson's successor language which ditched the crazy alphabet. Another almost impossible to read language, but very compact.\n• Elixir (skip Erlang, as it has a very ugly syntax for the same runtime). The only runtime that can handle hundreds of thousands of threads no problem; has a unique memory approach by giving each thread its own stack and heap.\n• Delphi (or VB6) for an example of how an integrated product delivers terrific productivity and a marketplace of interchangeable parts). Delphi gets no love from academics but it is incredibly productive.\n• Filemaker Pro for an example of how to make a terrific user interface for screens and forms (and how not to make a scripting language, because its scripting language is archaic and painful to use)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1561774907.127200",
        "client_msg_id": "f750e9b4-f61d-4a9c-8513-5cbd5ff62de9",
        "text": "APL had a huge impact on how I think about programming. Array programming is one part of it. The other part is the incredible compactness of the notation. You asked for a \"minimal set\": I'd consider swapping Forth for APL, because they both convey the idea of writing programs as a string of combinators, but APL has more depth and embodies a more radical way of thinking about programming.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1561724860.126100",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6LdBN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "APL had a huge impact on how I think about programming. Array programming is one part of it. The other part is the incredible compactness of the notation. You asked for a \"minimal set\": I'd consider swapping Forth for APL, because they both convey the idea of writing programs as a string of combinators, but APL has more depth and embodies a more radical way of thinking about programming."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]