[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1723111690.648469",
        "client_msg_id": "bdee3224-7f09-452a-b69f-29bc52607fbd",
        "text": "<@U5STGTB3J> Thanks, I did’t watch this video until I saw your recommendation.\n\nWe seem to reach the same conclusion.\n\nHis final moto is:\n\n“Unlock their potential by rethinking programming systems”.\n\nI think we get to the conclusion by following very different paths, though:\n\nBy “their” he means hardware.\n\nBy “their” I mean FoCers and programmers.\n\nIn my mind, over-use synchronization doesn’t just slow hardware down but, also, slows down programmers. My gut says that there is no “Moore’s Law” for software because of the over-user of synchronization.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722636399.108109",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iSQ+q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " Thanks, I did’t watch this video until I saw your recommendation.\n\nWe seem to reach the same conclusion.\n\nHis final moto is:\n\n“Unlock their potential by rethinking programming systems”.\n\nI think we get to the conclusion by following very different paths, though:\n\nBy “their” he means hardware.\n\nBy “their” I mean FoCers and programmers.\n\nIn my mind, over-use synchronization doesn’t just slow hardware down but, also, slows down programmers. My gut says that there is no “Moore’s Law” for software because of the over-user of synchronization."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1723113653.530899",
        "client_msg_id": "5F6EC12C-C7EA-47DE-9173-4CF57CD7B3CF",
        "text": "<@UGWUJUZHT> I think we’re getting somewhere. I was hoping this presentation would enable us to “spiral to the center” of what you mean.\n\nI still think your “function-based” criticism is a red herring. Functions (in the mathematical sense) have nothing to do with parallel or sequential execution. Just like you said they “deny”, or like I said they “don’t need”, either for the model to be sound. That historically we chose to double down on sequential execution is a different story, and certainly that has impacted how we think about computation — which I believe is closer to the core of what you’re criticizing. Or mental model of execution is certainly biased towards unnecessary synchronization and sequentialism. Down with the sequentionalists! ;)\n\nBut I also want to appreciate that you seem to talk about more than just that. I don’t know what a “Moore’s Law for software” would measure and state exactly, but I share your frustration with software being needlessly limited and hopelessly complicated, partly because of sequential execution bias, but also because of other things. For me all these things can be summed up under “complexity”, but that’s not really helpful either, I guess.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722636399.108109",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pKIez",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " I think we’re getting somewhere. I was hoping this presentation would enable us to “spiral to the center” of what you mean.\n\nI still think your “function-based” criticism is a red herring. Functions (in the mathematical sense) have nothing to do with parallel or sequential execution. Just like you said they “deny”, or like I said they “don’t need”, either for the model to be sound. That historically we chose to double down on sequential execution is a different story, and certainly that has impacted how we think about computation — which I believe is closer to the core of what you’re criticizing. Or mental model of execution is certainly biased towards unnecessary synchronization and sequentialism. Down with the sequentionalists! ;)\n\nBut I also want to appreciate that you seem to talk about more than just that. I don’t know what a “Moore’s Law for software” would measure and state exactly, but I share your frustration with software being needlessly limited and hopelessly complicated, partly because of sequential execution bias, but also because of other things. For me all these things can be summed up under “complexity”, but that’s not really helpful either, I guess."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1723115815.334479",
        "client_msg_id": "8d1c7c7a-a78a-45e7-aff3-5b0da6fd180d",
        "text": "<@U5STGTB3J> Hmm, there’s a definite distinction between “functions” in the mathematical sense and “functions” implemented in hardware. The things called “functions” in programming languages have different properties than “functions” in mathematics. Functions in programming languages are just mathematical-function wannabes, but, aren’t mathematical-functions because of issues of physical reality and sequencing. Maybe by using the term “function-based” I really mean that “using the name ‘function’ in programming is a bad idea and gives the wrong impression of what’s really going on”. We’ve spent 50+ years fumbling around bumping into gotchas caused by this naming. This needs more shower time...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722636399.108109",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FzdHI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " Hmm, there’s a definite distinction between “functions” in the mathematical sense and “functions” implemented in hardware. The things called “functions” in programming languages have different properties than “functions” in mathematics. Functions in programming languages are just mathematical-function wannabes, but, aren’t mathematical-functions because of issues of physical reality and sequencing. Maybe by using the term “function-based” I really mean that “using the name ‘function’ in programming is a bad idea and gives the wrong impression of what’s really going on”. We’ve spent 50+ years fumbling around bumping into gotchas caused by this naming. This needs more shower time..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1723124562.492659",
        "client_msg_id": "a73ae0ac-5733-4cb0-943b-006dd473da56",
        "text": "<@UGWUJUZHT> I didn’t mean that your distinction is wrong or doesn’t exist, I’m just trying to point out that it’s maybe not helpful for what you are trying to achieve, because I think it creates more confusion than it helps you make your point.\n\nYes, the distinction exists, but in functional programming for instance there is at least a recognition to aspire to the mathematical meaning, knowing very well that this can only be an approximation that ultimately is constrained by its implementation.\n\nAnd then there is a long history of debate of what to call these things, and if further distinctions between different kinds need to be made: functions, procedures, subroutines, methods, etc. Even though there are some patterns around use in context of OOP or pure functions vs. side effects, it’s inconsistent across languages. And now you come along and try to tag something else on top of this already confusing and incoherent mess. I’d be in favor of throwing around the term “function” more carefully, but it is what it is and the point you’re trying to make seems to be more important than risking it to disappear in the noise of historical inconsistencies.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722636399.108109",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IEphS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " I didn’t mean that your distinction is wrong or doesn’t exist, I’m just trying to point out that it’s maybe not helpful for what you are trying to achieve, because I think it creates more confusion than it helps you make your point.\n\nYes, the distinction exists, but in functional programming for instance there is at least a recognition to aspire to the mathematical meaning, knowing very well that this can only be an approximation that ultimately is constrained by its implementation.\n\nAnd then there is a long history of debate of what to call these things, and if further distinctions between different kinds need to be made: functions, procedures, subroutines, methods, etc. Even though there are some patterns around use in context of OOP or pure functions vs. side effects, it’s inconsistent across languages. And now you come along and try to tag something else on top of this already confusing and incoherent mess. I’d be in favor of throwing around the term “function” more carefully, but it is what it is and the point you’re trying to make seems to be more important than risking it to disappear in the noise of historical inconsistencies."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1723125133.832199",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1723125388.000000"
        },
        "client_msg_id": "512ea310-1f25-4459-85e3-62eec69fc0e0",
        "text": "There’s another aspect of your idea that I’m trying to wrap my head around: What about function\/subroutine’s capability to contain arbitrary complexity and expose it as just a symbol? Is that a feature or a bug in your book? Of course, it’s probably not a simple either\/or question, really. I wonder if <https:\/\/stefanlesser.substack.com\/p\/on-simplicity-5-hiding-complexity|my rant about additive design and cultivated ignorance> resonates with what you’re saying, or if I’m just reading into it what I want to read into it…?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722636399.108109",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x+rZw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There’s another aspect of your idea that I’m trying to wrap my head around: What about function\/subroutine’s capability to contain arbitrary complexity and expose it as just a symbol? Is that a feature or a bug in your book? Of course, it’s probably not a simple either\/or question, really. I wonder if "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/stefanlesser.substack.com\/p\/on-simplicity-5-hiding-complexity",
                                "text": "my rant about additive design and cultivated ignorance"
                            },
                            {
                                "type": "text",
                                "text": " resonates with what you’re saying, or if I’m just reading into it what I want to read into it…?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1723125247.997229",
        "client_msg_id": "8ece8fe4-c8a7-4e9b-9ab4-55f7b202fbeb",
        "text": "Ha, I just noticed I start that article with yet another meaning of the word _functional_… :zany_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722636399.108109",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ztAc1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ha, I just noticed I start that article with yet another meaning of the word "
                            },
                            {
                                "type": "text",
                                "text": "functional",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "… "
                            },
                            {
                                "type": "emoji",
                                "name": "zany_face",
                                "unicode": "1f92a"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1723171775.246519",
        "client_msg_id": "651dae3b-d240-446a-ba6b-af36ece6be93",
        "text": "<@U5STGTB3J> The word “function” means something in math, but, is mis-applied to software, where it is more of a wish than a reality. The mis-application of the word “function” to software things causes researcher \/ programmers to mis-believe that they are dealing with math when, in reality, they are not dealing with math, they are dealing with something different and new.\n\nAside: to me, mathematics is 2 things:\n1. Deep thought\n2. A notation for expressing the conclusions arising from deep thought.\nComputer programming is about issue #2. The medium is different. In traditional math, the medium is papyrus, graphite, clay tablets, cave walls. Computers provide a new “medium”. Using concepts and words derived from papyrus-based notations is not appropriate for this new medium. Language affects thought, hence, using familiar concepts to describe new territory is inappropriate for the new medium - and, this practice is downright misleading and wasteful.\n\nI agree that mathematical functions contain complexity and expose it as just a symbol. But, I don’t agree that it is the *only* way to do this kind of thing. Imagine a non-programmer walking up to a white-board. The non-programmer draws a rectangle on the whiteboard. That rectangle contains arbitrary complexity, too. (Aside, in Javascript, we draw a rectangle using the two ASCII characters “{ and “}”). The rules for containing arbitrary complexity using textual, mathematical, programming notation are onerous (“no side-effects”, “no mutation”, etc. in opposition to the reality of CPUs attached to RAM). The rules for using a rectangle on a whiteboard are less onerous. The difference is “isolation” - we don’t care if the innards of the stuff contained in the rectangle use side-effects or mutation, as long as those effects are not allowed to leak out beyond the borders of the rectangle. Hardware ICs contain arbitrary complexity by encasing circuits in black epoxy. The rules for such hardware ICs are much less onerous than the rules for using FP.\n\nBusiness people already know how to contain arbitrary complexity - they call this technique “Org Charts”. Org Charts allow asynchrony, whereas mathematical notation does not allow asynchrony. Org Charts for successful, scalable businesses, has rules that forbid “micro-management”. Function-based programming, though, is all about “micro-management”. The goal of computer science should be to find many ways to add rigour to notations that encourage isolation, and, not to apply just only one form of rigour. The implied goals of FP are good, but, it is not the case that FP is the *only* way to achieve those goals.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722636399.108109",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WsQgs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " The word “function” means something in math, but, is mis-applied to software, where it is more of a wish than a reality. The mis-application of the word “function” to software things causes researcher \/ programmers to mis-believe that they are dealing with math when, in reality, they are not dealing with math, they are dealing with something different and new.\n\nAside: to me, mathematics is 2 things:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Deep thought"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A notation for expressing the conclusions arising from deep thought."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nComputer programming is about issue #2. The medium is different. In traditional math, the medium is papyrus, graphite, clay tablets, cave walls. Computers provide a new “medium”. Using concepts and words derived from papyrus-based notations is not appropriate for this new medium. Language affects thought, hence, using familiar concepts to describe new territory is inappropriate for the new medium - and, this practice is downright misleading and wasteful.\n\nI agree that mathematical functions contain complexity and expose it as just a symbol. But, I don’t agree that it is the "
                            },
                            {
                                "type": "text",
                                "text": "only",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " way to do this kind of thing. Imagine a non-programmer walking up to a white-board. The non-programmer draws a rectangle on the whiteboard. That rectangle contains arbitrary complexity, too. (Aside, in Javascript, we draw a rectangle using the two ASCII characters “{ and “}”). The rules for containing arbitrary complexity using textual, mathematical, programming notation are onerous (“no side-effects”, “no mutation”, etc. in opposition to the reality of CPUs attached to RAM). The rules for using a rectangle on a whiteboard are less onerous. The difference is “isolation” - we don’t care if the innards of the stuff contained in the rectangle use side-effects or mutation, as long as those effects are not allowed to leak out beyond the borders of the rectangle. Hardware ICs contain arbitrary complexity by encasing circuits in black epoxy. The rules for such hardware ICs are much less onerous than the rules for using FP.\n\nBusiness people already know how to contain arbitrary complexity - they call this technique “Org Charts”. Org Charts allow asynchrony, whereas mathematical notation does not allow asynchrony. Org Charts for successful, scalable businesses, has rules that forbid “micro-management”. Function-based programming, though, is all about “micro-management”. The goal of computer science should be to find many ways to add rigour to notations that encourage isolation, and, not to apply just only one form of rigour. The implied goals of FP are good, but, it is not the case that FP is the "
                            },
                            {
                                "type": "text",
                                "text": "only",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " way to achieve those goals."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1723172141.205639",
        "client_msg_id": "13cecb1f-9699-4ea2-9a58-a9de915010e9",
        "text": "Hmm, something about this conflation of concepts \"..function\/subroutine’s...\" indicates that I haven't said something clearly enough ...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722636399.108109",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mruY3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hmm, something about this conflation of concepts \"..function\/subroutine’s...\" indicates that I haven't said something clearly enough ..."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]