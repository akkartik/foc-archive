<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/74791f7f49bc26afa271eced90cda37c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0010-72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ian Bicking</b>
<span style="margin:2em; color:#606060">2019-05-14 11:58</span><br/>
Just a random thought: I was looking at Bret Victor’s old Learnable Programming, and it had a little note about how programming consists of decomposing problems, and I realized: that’s not what I do these days. I spend all my time thinking about messaging and communication between systems, and “decomposition” feels like a luxury. I don’t know if that’s a general change in programming, or just the nature of my work or professional stage… but it feels like a real change to me.<br/><br/>That is, I spend a lot of time thinking about these things:<br/>1. What are the entities in my system? These could be as simple as objects, but might be remote services, or different processes, browser tabs, etc.<br/>2. Who knows what?<br/>3. Who needs to keep track of what?<br/>4. From any given context, how do I get access to the other entities?<br/>5. How do I communicate with them? The push/pull of functions or RPC? Pub/sub? Some wonky event system?<br/>6. Where does a particular change originate, and which entities are simply reactive?<br/><br/>This all is where a lot of modern language development leaves me cold. Types don’t offer much here. Going further, I think there really is a kind of modernist/postmodernist break here (ala <a href="http://homepages.mcs.vuw.ac.nz/~kjx/papers/nopp.pdf">http://homepages.mcs.vuw.ac.nz/~kjx/papers/nopp.pdf</a>): modern approaches attempt to create self-consistent and robust systems, and postmodernist approaches accept that we operate in a diverse systems where a lot of important things happen at the intersection of incompatible modernist systems.<br/><br/>I don’t have any conclusion in mind, but I’d be interested in people’s thoughts.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557860866.364500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557860866.364500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-14 12:07</span><br/>
Modernist/postmodernist seems a really fertile distinction alongside pro-evolution/anti-evolution (my favored framing for what used to be west-coast vs east coast: <a href="http://yosefk.com/blog/what-worse-is-better-vs-the-right-thing-is-really-about.html">http://yosefk.com/blog/what-worse-is-better-vs-the-right-thi&hellip;</a>) and liberal/conservative (<a href="https://gist.github.com/cornchz/3313150">https://gist.github.com/cornchz/3313150</a>).<br/><br/>(I’ve been thinking about these categorizations lately after reading <a href="https://josephg.com/blog/3-tribes">https://josephg.com/blog/3-tribes</a>, which feels less general but still wrong in a constructive way.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557860968.364800"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557860968.364800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-05-14 12:09</span><br/>
That reminds me of the explanation that Gerald Sussman has give for MIT's switch from Scheme to Python as their introductory language (it was in some video, I don't have the reference at hand unfortunately). He said that programming had changed, basic algorithms and data structures were less important now gluing stuff together. Python was a better fit for that kind of work.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557860976.365000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557860976.365000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-14 12:09</span><br/>
I’m probably pretty batshit modernist:<br/><br/><a href="http://akkartik.name/about">http://akkartik.name/about</a><br/><a href="http://akkartik.name/post/libraries">http://akkartik.name/post/libraries</a><br/><a href="http://akkartik.name/post/libraries2">http://akkartik.name/post/libraries2</a><br/><a href="http://akkartik.name/post/readable-bad">http://akkartik.name/post/readable-bad</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557861224.365300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557861224.365300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-14 12:13</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> I’ve seen that as well. It’s mentioned in <a href="http://wingolog.org/archives/2009/03/24/international-lisp-conference-day-two">http://wingolog.org/archives/2009/03/24/international-lisp-conference-day-two</a> so perhaps there was never a permalink for it. I’ve always found this argument tendentious and a rationalization. Even if the world turns out to be post-modernist (a big if), there’s value in the first few stages of learning being modernist.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557862461.366100"></a>
      <img src="https://secure.gravatar.com/avatar/74791f7f49bc26afa271eced90cda37c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0010-72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557862461.366100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ian Bicking</b>
<span style="margin:2em; color:#606060">2019-05-14 12:34</span><br/>
I don’t particularly like the term “glue”. It makes it seem like people are just slapping things together. IMHO the modernist work, encapsulated into a single process running a well-defined language, is the easy part. That’s why I spend all my time on the interprocess part… because it’s so much harder! And it tears down my attempts to create good programming language abstractions, because those abstractions don’t apply widely enough. Ideas and goals are spread out across many systems.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557864999.367000"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557864999.367000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-05-14 13:16</span><br/>
Sussman didn't have the guts to admit that LISP is a tired dead horse, that should have been abandoned a long time ago. It has one of the lowest readability-by-other scores of of the known languages. I can think of only 2 languages worse than LISP for readability, and those are FORTH and APL. In Sussman's heyday there were only a few hundred computers in existence, and now that computers are everywhere, and there are millions of programmers, it is extremely important to be able to read and use other people's code. Take some random chunk of LISP and good luck trying to fit that. You can't determine the data structures being used in LISP unless you mentally execute the program in your head, and we all know that chess masters can play multiple games in their heads blindfolded, but that is not a widely distributed skill...
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557867147.367300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557867147.367300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-14 13:52</span><br/>
<span style="background-color:#ccf">@Ian Bicking</span> I definitely empathize, happy to stop using “glue”. It didn’t have negative connotations in my mind.<br/><br/>The recent thread on distributed computing may be relevant if you hadn’t already seen it: <a href="1557434052.245400.html">1557434052.245400.html</a><br/><br/>I’m trying to be cognizant of my modernist bias, but there are levels of questions here:<br/>• How much of the difficulty creating abstractions that work across systems is due to design failures in individual systems?<br/>• Is it possible to cross the chasm to new, equally diverse systems that don’t suffer from those foundational design flaws?<br/><br/>Valid answers:<br/>• No matter what you do, the complexity of integrating across system boundaries will dominate. (In all domains?)<br/>• Maybe there’s a perfect world somewhere, but there’s no way for us to get there. We’re locked in by past decisions.<br/>• Change all the things!<br/><br/>I think the answer depends on domain. Games, for example, often don’t have to deal with multiple platforms, and where they do they can polyfill the heck out of them to make integration plug and play. But that’s of course just one tiny end of the spectrum.<br/><br/>One may also be able to get away with modernism at lower layers of the stack. My background is in systems programming, and that maybe explains something.<br/><br/>Anyways, just trying to throw out ideas that someone else can maybe run with to show me the limitations of my worldview:<br/>• Yes, we can and should change all the things.<br/>• Good fences make good neighbors. Good components simplify integration problems.<br/>• It will take a long time. Probably longer than a lifetime.<br/>• Nobody will ever have all the answers, so above all make foundational design decisions open to revision (with less effort than it will take with the current stack).<br/>• Lots of respect for people who have to live with and deal with the current state of the world in the meantime. (Like me in my day job.)<br/><br/>Bonus link if you read this far: <a href="http://akkartik.name/post/deepness">http://akkartik.name/post/deepness</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557867912.368900"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557867912.368900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-14 14:05</span><br/>
Paraphrasing from the above link <a href="http://homepages.mcs.vuw.ac.nz/~kjx/papers/nopp.pdf">http://homepages.mcs.vuw.ac.nz/~kjx/papers/nopp.pdf</a> (section 5):<br/><br/>&gt; It doesn’t make sense to say a Bovine object is an abstraction of a real cow.. or that the object in the program is “implemented by” a cow in reality.. or that the <tt>Cow</tt> class is a Platonic ideal of the immutable, eternal form of a cow.. Instead, the object in the program can be seen as a sign of the object in the world. Unlike abstractions, which can be reasoned about using deduction (from causes to effects), signs are effectively implications, and are modelled using abduction (reasoning from effects to causes).<br/><br/>:heart: :heart:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557868947.381300"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557868947.381300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-14 14:22</span><br/>
<span style="background-color:#ccf">@Ian Bicking</span> I don't want to self-promote too much but your pain points here are too in-line with what I'm trying to do to hold myself back.  <a href="https://strat.world/">https://strat.world/</a> Strat's whole purpose is to provide language abstractions over what you've laid out up there.  It's still pretty early in development but it can deploy arbitrarily complex systems.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557869598.382100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557869598.382100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-05-14 14:33</span><br/>
&gt; This all is where a lot of modern language development leaves me cold. Types don’t offer much here.<br/><br/>Absolutely. A lot of 'system design' happens outside the scope of a usual programming language. In the end languages are employed in the service of the system, but there seem to be a sharp contrast in the models of composition 'in-language/in-process' vs 'cross-process'.<br/><br/>&gt;  I spend all my time thinking about messaging and communication between systems, and “decomposition” feels like a luxury.<br/><br/>Yes. There is an incredible amount of model duplication in the way we build systems today. Each part is like an island where you define, from the ground up, each of the entities you wish to deal with in that island. The description of the larger system-wide entities and processes is shredded into little pieces, glued together with implementation details such as messaging libraries, and separated into various such islands.<br/><br/>(From the linked paper)<br/>&gt; We consider that the term “program” is both too big and too little for post modern computer science.<br/>&gt; “Program” is too small because often we are  working on multiple programs.<br/>I suppose I heavily lean towards post-modern in this regard. "Programs" aren't interesting to me anymore and any model where you first compose programs (~processes) and then compose them into systems doesn't scale up well. Instead what's interesting is the whole lifecycle of the system, inspecting and updating the higher level processes that it embodies. Can we work with these directly? Update them, see the inspect the hypothetical effect on other processes, etc.? I wrote a bit here: <a href="1557508482.325700.html">1557508482.325700.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557884793.388700"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557884793.388700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-05-14 18:46</span><br/>
<span style="background-color:#ccf">@Ian Bicking</span> not just you.  To me it seems that the operating systems are what have mostly failed to raise to the occasion.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557895760.418200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557895760.418200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-14 21:49</span><br/>
After reading the paper, I find I actually have a reasonable ‘post-modern component’ to my belief system:<br/>• Section 6: I think ‘requirements’ are not a good way to frame collaboration on software.<br/>• Section 7: I have no bias between ‘high’ and ‘low’ computing culture. Mostly because I’m too dense for these ideas to even register. (However, being blase about “faults in construction” is hard to stomach.)<br/>• Section 7: I love the idea of “ancient programs living in connection with programs not yet written”. Here’s my original introduction post from last year: <a href="https://futureprogramming.slack.com/archives/CC2JRGVLK/p1536962970000100">https://futureprogramming.slack.com/archives/CC2JRGVLK/p1536962970000100</a><br/>• Section 8: I’ve written about our over-reliance on modules: <a href="http://akkartik.name/post/modularity">http://akkartik.name/post/modularity</a>. I care primarily about encouraging outsiders to read source code, and there’s a fundamental tension there: abstractions help authors manage a codebase but initially hinder outsiders in understanding the codebase.<br/><br/>Alright, I’m done navel-gazing.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557938276.425700"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1557938276.425700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-05-15 09:37</span><br/>
Yeah I can't fit myself in either category either. I definitely like grand narratives, though less detailed and more abstract than those described in the paper. Also yay for modularity and uniformity in some sense, and many metaphors.<br/><br/>I think the paper fails to note that underlying the great heterogeneity is deep homogeneity that makes the diversity possible. TCP/IP, DNS under the various higher protocols. The standard web browser under the diverse web sites. Perhaps the question is where we wish to draw the modern/post-modern boundary in our systems.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1558039584.432200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1558039584.432200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-05-16 13:46</span><br/>
When you write a program, does it contain more than one function, or more than one class, or more than one object? If so, you are decomposing the problem. Perhaps in your case, the "decomposing" part of your work is sufficiently rote and automatic that you don't consciously focus on it anymore.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568241117.287100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1568241117.287100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-09-11 15:31</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> only just now got to read the 3 links in your first comment, and they're all rather interesting. Looks like I am mostly a Camp 2 conservative who embraces evolution, though I have aspects of all sides I think :slightly_smiling_face: Unlike the 3 articles, I am afraid I do not follow how Post-Modernism relates to software, so no idea there.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568241236.287300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1568241236.287300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-09-11 15:33</span><br/>
If anything, seems like this Slack has a vast majority of "camp 1" people, which in turn seems to overlap with "The Right Thing" and being anti-evolutional (instead of making existing programming tools better, want the world to jump to their new vision of programming).. that would, at least from the perspective of those 3 links, not bode well for this Slack :wink:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568924362.391800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1568924362.391800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-19 13:19</span><br/>
<span style="background-color:#ccf">@Wouter van Oortmerssen</span> do you think a 'new vision' could be arrived at in an evolutionary way as well? One example is 'buiding airplanes' vs 'making locomotives faster'. Almost none of infrastructure overlaps, and in the early days it's not clear air travel is even viable, but today both modes co-exist. This doesn't seem anti-evolution to me, but more of a fork at a lower level in our stack of concepts.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568959040.398700"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1568959040.398700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-09-19 22:57</span><br/>
<span style="background-color:#ccf">@Shalabh</span> I have nothing against attempting clean sheet revolutionary ideas, I was merely reflecting on the implications of those articles.. and yes, there is a lot of power in an evolutionary approach (assuming it means iterative, with lots of feedback from actual use). It certainly has the advantage that you can pull lots of people along, whereas revolutionary ideas initially meet mostly resistance :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568959213.398900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1568959213.398900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-09-19 23:00</span><br/>
And nothing in this space even looks remotely like the revolution of airplanes to me. A lot of people here seem to look to Brett Victor for a revolution. You know what would be a revolution? If he demonstrated his ideas by implementing a complex piece of software, like a compiler, game engine, whatever, which would be remarkably simpler to create thanks to  new techniques. Instead, we're not even remotely close to such a revolution.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568959828.399100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1568959828.399100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-19 23:10</span><br/>
Yeah I mostly agree with you. I imagine us as being in a pre-wright-flyer phase. We have some ideas of success criteria (e.g. 'would be remarkably simpler to create thanks to new techniques') and some guesses around what perspectives to pursue (this may vary quite a bit between us) but no real breakthrough.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569796242.080200"></a>
      <a href="../thinking-together/1557860308.364300.html#1569796242.080200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-29 15:30</span><br/>
I just found the best 1-sentence summary of "worse is better" ever. And it's by the author:<br/><br/><em>"It is far better to have an under-featured product that is rock solid, fast, and small than one that covers what an expert would consider the complete requirements."</em><br/><br/>(<a href="https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf">https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf</a>, pg 219)<br/><br/>Talk about burying the lede.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569821270.091300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569821270.091300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-09-29 22:27</span><br/>
One reason I've not seen mentioned why "worse is better" is better is compositionality: choosing a simple implementation with a possibly suboptimal API composes efficiently, whereas doing "the right thing" across multiple levels produces extreme inefficiency and impedance mismatch. Imagine a CPU-emulator written in Python running a Ruby interpreter :stuck_out_tongue:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569822496.095400"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569822496.095400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-09-29 22:48</span><br/>
Ruby APIs: always a semantic mess yet usually easy to get good stuff done: quicker, easier, more seductive.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569852705.107100"></a>
      <img src="https://avatars.slack-edge.com/2019-08-07/719033961125_50ee467d13114e4314c2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569852705.107100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gary Trakhman</b>
<span style="margin:2em; color:#606060">2019-09-30 07:11</span><br/>
can't handle a culture that thinks stacked layers of metaprogramming is the way to go at the framework level.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569852719.107300"></a>
      <img src="https://avatars.slack-edge.com/2019-08-07/719033961125_50ee467d13114e4314c2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569852719.107300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gary Trakhman</b>
<span style="margin:2em; color:#606060">2019-09-30 07:11</span><br/>
Some of us want to actually understand the code.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569861076.114300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569861076.114300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-09-30 09:31</span><br/>
What's a concrete example of better compositionality via 'worst is better'? I've generally considered those two ideas unrelated.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569861461.114500"></a>
      <img src="https://avatars.slack-edge.com/2019-08-07/719033961125_50ee467d13114e4314c2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569861461.114500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gary Trakhman</b>
<span style="margin:2em; color:#606060">2019-09-30 09:37</span><br/>
there's one in the essay around interrupts: <a href="https://www.jwz.org/doc/worse-is-better.html">https://www.jwz.org/doc/worse-is-better.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569896553.122900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569896553.122900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-09-30 19:22</span><br/>
<span style="background-color:#ccf">@Shalabh</span> I guess it is more that "the right thing" has worse compositionality, since such systems tend to have a lot of translation between what the implementation is doing and the idealized API. Layer multiple such systems and you end up with many unnecessary translations that affect performance and robustness. A "worse is better" tends to be more barebones, such that if you compose them, whatever glue you need will be the minimum necessary
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569910996.127500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569910996.127500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-09-30 23:23</span><br/>
<span style="background-color:#ccf">@Wouter van Oortmerssen</span> I absolutely agree with your sentiment, but your definition of compositionality is confusing. Usually I think of compositionality as a purely functional matter without taking performance into account. For example, <a href="https://www.youtube.com/watch?v=5l2wMgm7ZOk">https://www.youtube.com/watch?v=5l2wMgm7ZOk</a> discusses how compositionality tends to break down once performance constraints enter the picture (rather than that compositionality causes bad performance).<br/><br/>So I'm with Shalabh that the two ideas seem orthogonal. A bare-bones design can very easily be non-composable. A great design can seem <em>very</em> composable, particularly within its area of control (i.e. if people only do what the designer anticipated).<br/><br/>In the end, the knife-edge the designer has to walk is between good design and totalizing design. You have to provide a good environment for use. But if you <em>take control</em> of the environment you'll eventually hamstring yourself.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569914902.128400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569914902.128400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-10-01 00:28</span><br/>
I finally got around to watching this talk after citing it here multiple times, and..<br/><br/>Worse is better is indirectly referenced ~25 minutes in.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569915641.128900"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569915641.128900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-01 00:40</span><br/>
Composition in algebra, which is where you do f(g(h(j(k))))), is what LISP's power emanates from. However, it is hard to read, as one must execute it in your head from the inside, outwards. It's just a hard to read syntax, regardless of how it inherits traditional algebraic notation.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569928703.136300"></a>
      <img src="https://avatars.slack-edge.com/2019-08-07/719033961125_50ee467d13114e4314c2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569928703.136300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Gary Trakhman</b>
<span style="margin:2em; color:#606060">2019-10-01 04:18</span><br/>
That's the job of a formatter (hopefully not the programmer).<br/>When indentation is consistent, the parens fall away.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569931281.136500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569931281.136500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-01 05:01</span><br/>
Composition is the general idea of building up a complex object from parts. It isn't a syntax. In Curv, f(g(h(j(k)))) can be written as <tt>k &gt;&gt; j &gt;&gt; h &gt;&gt; g &gt;&gt; f</tt>, which is just like a Unix pipeline, with data flowing from left to right. Most functional languages have an equivalent syntax, and of course the Unix shell has pipelines.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569940995.136900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1569940995.136900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-10-01 07:43</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> maybe I used the wrong word, I am talking about what happens when you layer several larger systems. I agree that compositionality is usually defined in how easy it is to compose, but that is not even that a desirable quality, if it doesn't also entail efficiency, robustness, non-leakyness and many others
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570003743.141300"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557860308.364300.html#1570003743.141300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-02 01:09</span><br/>
The pipelining approach pioneered by APL proved very powerful, but in the end fairly obscure. Your pipeline example presumes a single input to each function, which is almost never the case. Functions have many options, and external conditions that they reference. There is a very good reason why languages that are based primarily on composition as the "power tool" of the language  ultimately become obscure.<br/><br/>It is commendable that Curv uses a much nicer syntax with the pipelining, but in zero of my sample programs in beads did pipelining occur. APL was very good at unraveling 2D matrices into 1D so that the pipelining would be more usable, and to this day APL is one of most compact languages ever devised. Unfortunately a function name does not disclose the mapping of what the function does, and  the sequence k &gt;&gt; j &gt;&gt; etc. would require deep study to understand, particularly if the data is structured, and not merely an array. I can see why Haskell splits out the mapping of data types of a function away from the field names, but I don't like it one bit; it creates a double declaration of the function which i find wasteful. But i see why they did it.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
