[
    {
        "user": "U06SS0DHZD1",
        "type": "message",
        "ts": "1740128465.615429",
        "client_msg_id": "bdee83bf-b737-49b3-aa92-06a6ede71825",
        "text": "At the end you mentioned something called 0D. Could you elaborate on that?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "287ba5559ee1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-04-04\/6922823105585_287ba5559ee1cedd6b98_72.png",
            "first_name": "Marek",
            "real_name": "Marek Rogalski",
            "display_name": "maf",
            "team": "T5TCAFTA9",
            "name": "mafikpl",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739811561.420359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QaZsu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At the end you mentioned something called 0D. Could you elaborate on that?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1740146643.095549",
        "client_msg_id": "760980be-c1f4-481e-b62c-44489485ef1b",
        "text": "50,000 foot view: 0D is a minimum viable VPL that avoids implicit synchronousity and sequentialism. It _looks_ like just a run-of-the-mill node-and-arrow diagramming thing, but goes down the path of everything-is-concurrent-by-default and layers-instead-of-infinite-canvases and multiple-inputs-and-multiple-outputs and data-flow as events. There are no basic restrictions on mixing diagrams and text to express programs.\nI think that the combination of these ideas simplifies programming by more than 10x. The ideas are in production at <http:\/\/Kagi.com|Kagi.com>.\n\nThis week, I'm calling it PBP (Parts Based Programming).\n\nThe connection to this video is that I was pondering about maybe going back to a simpler hardware model by not using virtual memory and not using preemptive context-switching. Parts would be a natural fit for what I was writing about. One should be able to have 1000s of Parts sitting inside a simple machine - and - one should be able to program the whole thing using the current manifestation of computers. I'm building things like code transpilers with it, and that happens to be useful in its own right. Among other things, I've written a VHLL using <http:\/\/draw.io|draw.io> and \"compile\" the drawings to running Python, Javascript and, Common Lisp, (I used to successfully target Odin as well) and, the basics of a visual shell.\n\nIf you continue to be interested, I am willing to supply endless detail, including pointers to code repos.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739811561.420359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BQmgJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "50,000 foot view: 0D is a minimum viable VPL that avoids implicit synchronousity and sequentialism. It "
                            },
                            {
                                "type": "text",
                                "text": "looks",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " like just a run-of-the-mill node-and-arrow diagramming thing, but goes down the path of everything-is-concurrent-by-default and layers-instead-of-infinite-canvases and multiple-inputs-and-multiple-outputs and data-flow as events. There are no basic restrictions on mixing diagrams and text to express programs.\nI think that the combination of these ideas simplifies programming by more than 10x. The ideas are in production at "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/Kagi.com",
                                "text": "Kagi.com"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nThis week, I'm calling it PBP (Parts Based Programming).\n\nThe connection to this video is that I was pondering about maybe going back to a simpler hardware model by not using virtual memory and not using preemptive context-switching. Parts would be a natural fit for what I was writing about. One should be able to have 1000s of Parts sitting inside a simple machine - and - one should be able to program the whole thing using the current manifestation of computers. I'm building things like code transpilers with it, and that happens to be useful in its own right. Among other things, I've written a VHLL using "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/draw.io",
                                "text": "draw.io"
                            },
                            {
                                "type": "text",
                                "text": " and \"compile\" the drawings to running Python, Javascript and, Common Lisp, (I used to successfully target Odin as well) and, the basics of a visual shell.\n\nIf you continue to be interested, I am willing to supply endless detail, including pointers to code repos."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06SS0DHZD1",
        "type": "message",
        "ts": "1740158096.127949",
        "client_msg_id": "ea7a8769-7e15-4be7-bc70-405aface4dc9",
        "text": "Oh, I dislike virtual memory as well. After program memory became \"private by default\" we got fewer bugs - true, but it also made it a cultural taboo to access memory of other programs... The non-preemptive context switching bit sounds interesting - how are rogue processes handled then? For instance a buggy component that entered an infinite loop and user wants to stop it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "287ba5559ee1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-04-04\/6922823105585_287ba5559ee1cedd6b98_72.png",
            "first_name": "Marek",
            "real_name": "Marek Rogalski",
            "display_name": "maf",
            "team": "T5TCAFTA9",
            "name": "mafikpl",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739811561.420359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ivd7r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh, I dislike virtual memory as well. After program memory became \"private by default\" we got fewer bugs - true, but it also made it a cultural taboo to access memory of other programs... The non-preemptive context switching bit sounds interesting - how are rogue processes handled then? For instance a buggy component that entered an infinite loop and user wants to stop it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1740160410.833659",
        "client_msg_id": "a435dca4-d561-4aee-8178-db355d5a83a9",
        "text": "Non-context-switching is essentially green-threading or coroutining within an app.\n\nI have the view that there are 2 kinds of computers (1) for non-programmers (2) for developers. Non-programmers should never have rogue programs delivered to them (that's not what happens today, except in cartridge-y gaming systems). Developers should be the only ones who would need preemption. Let 'em have preemption, just don't deliver code to non-programmers that needs preemption.\n\nOTOH, just _thinking _this way leads to (IMO) simpler ways to construct programs. Developers use the current manifestation of dev operating systems like Linux. Non-programmers can continue to use operating systems like MacOS and Windows, until they no longer need to do so (years, decades?). The win of making all memory private is exacerbated by making all programs be composed of Parts. Not just memory, but control-flow, too, must be private. Aside: FP does not isolate control flow except through the use of preemptive operating systems and lots of baggage. Today, we know how to build closures and how to build queues and we now how to copy data and later GC it. That's enough to re-think all of the complication that has led up to this point. This isn't anything new, we see the seeds of it in UNIX pipelines, but, UNIX pipelines come with too much FP-ish baggage (in fact, UNIX processes got the idea mostly right, it's \/bin\/sh that over-constrained the idea. Well, then there is the problem that UNIX pipelines have exactly 1 in and exactly 1 out. This was painful to unconstrain using C, but can easily be unconstrained today.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739811561.420359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wy2Ug",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Non-context-switching is essentially green-threading or coroutining within an app.\n\nI have the view that there are 2 kinds of computers (1) for non-programmers (2) for developers. Non-programmers should never have rogue programs delivered to them (that's not what happens today, except in cartridge-y gaming systems). Developers should be the only ones who would need preemption. Let 'em have preemption, just don't deliver code to non-programmers that needs preemption.\n\nOTOH, just _thinking _this way leads to (IMO) simpler ways to construct programs. Developers use the current manifestation of dev operating systems like Linux. Non-programmers can continue to use operating systems like MacOS and Windows, until they no longer need to do so (years, decades?). The win of making all memory private is exacerbated by making all programs be composed of Parts. Not just memory, but control-flow, too, must be private. Aside: FP does not isolate control flow except through the use of preemptive operating systems and lots of baggage. Today, we know how to build closures and how to build queues and we now how to copy data and later GC it. That's enough to re-think all of the complication that has led up to this point. This isn't anything new, we see the seeds of it in UNIX pipelines, but, UNIX pipelines come with too much FP-ish baggage (in fact, UNIX processes got the idea mostly right, it's \/bin\/sh that over-constrained the idea. Well, then there is the problem that UNIX pipelines have exactly 1 in and exactly 1 out. This was painful to unconstrain using C, but can easily be unconstrained today."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1740161071.485669",
        "edited": {
            "user": "U02E4DAQGSZ",
            "ts": "1740161090.000000"
        },
        "client_msg_id": "a6e5a35e-a98d-4d3b-9c69-661db7aac769",
        "text": "the Javascript event loop is a cooperative multitasker, and it is indeed easy to work with because you never need to worry about concurrency inside function blocks and everything was designed with cooperative multitasking in mind so you sorta get pretty high IO performance without really thinking about it. Lots of other things are bad for performance in the language (e.g. no integer type) but the event loop is actually pretty great to work with, and indeed you can hang the whole app by doing a busy loop but that only seems to happen during development of a recursive function :thinking_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739811561.420359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PHkqh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the Javascript event loop is a cooperative multitasker, and it is indeed easy to work with because you never need to worry about concurrency inside function blocks and everything was designed with cooperative multitasking in mind so you sorta get pretty high IO performance without really thinking about it. Lots of other things are bad for performance in the language (e.g. no integer type) but the event loop is actually pretty great to work with, and indeed you can hang the whole app by doing a busy loop but that only seems to happen during development of a recursive function "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1740163773.488859",
        "client_msg_id": "e8e1e0ae-c626-4beb-95a6-dd84c41b39fd",
        "text": "&gt; you never need to worry about concurrency inside function blocks\nAgreed,,, but I think that there is a high cost to doing this. Current hardware hides this cost. Can we gain back some chip real-estate if we eliminate all of these extra doo-dads that are scaffolding for no-worry function blocks?\n\nAnd, we really _should_ be thinking about concurrency. Especially when faced with asynchronous, distributed things like internet, robotics, IoT. Concurrency has a bad name in function-based programming circles. I suggest that concurrency is easy, except when you try to express it in terms of functions. By not-thinking about concurrency, we end up with gotchas like callback hell, await, etc. Harel showed a syntax, in 1986, \"StateCharts\" for dealing with concurrency that eliminated the really-bad aspects of the approach, i.e. \"state explosion\". Before even that, EEs were successfully using concurrency on a grand scale. (I count at least 100 concurrent, parallel components in the Atari Pong 1972 circuit. The circuit did not contain a CPU nor any sequential code).\n\nIn 1986, our hardware could not - easily - handle Statechart notation. Today's hardware can.\n\nI believe that PBP is an advancement over Statecharts. I haven't needed to use a Statechart for ages. And, I'm able to do things that I previously thought were very hard - like building \"compilers\". The quotes are there because I use some cheats that aren't directly related to PBP. Thinking in terms of PBP, though, helped me think up these cheats and not be afraid of implementing them.\n\nAn observation about the main-loop thing. The big win is to isolate control-flow, as well as data. Functions look good on paper, but when implemented on a computer, you get hidden, low-level coupling which leads to hidden uses of context-switching and virtual memory (e.g. the callstack, which is a data structure constructed dynamically at runtime and causes unpredictable, unstructured blocking and calcifies routing decisions in a non-networky way). The main loop is a (potentially) big lump of code. What if you chopped it up into smaller lumps of code, each with their own \"main loops\"?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1739811561.420359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "m\/Q0s",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "you never need to worry about concurrency inside function blocks"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAgreed,,, but I think that there is a high cost to doing this. Current hardware hides this cost. Can we gain back some chip real-estate if we eliminate all of these extra doo-dads that are scaffolding for no-worry function blocks?\n\nAnd, we really "
                            },
                            {
                                "type": "text",
                                "text": "should",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " be thinking about concurrency. Especially when faced with asynchronous, distributed things like internet, robotics, IoT. Concurrency has a bad name in function-based programming circles. I suggest that concurrency is easy, except when you try to express it in terms of functions. By not-thinking about concurrency, we end up with gotchas like callback hell, await, etc. Harel showed a syntax, in 1986, \"StateCharts\" for dealing with concurrency that eliminated the really-bad aspects of the approach, i.e. \"state explosion\". Before even that, EEs were successfully using concurrency on a grand scale. (I count at least 100 concurrent, parallel components in the Atari Pong 1972 circuit. The circuit did not contain a CPU nor any sequential code).\n\nIn 1986, our hardware could not - easily - handle Statechart notation. Today's hardware can.\n\nI believe that PBP is an advancement over Statecharts. I haven't needed to use a Statechart for ages. And, I'm able to do things that I previously thought were very hard - like building \"compilers\". The quotes are there because I use some cheats that aren't directly related to PBP. Thinking in terms of PBP, though, helped me think up these cheats and not be afraid of implementing them.\n\nAn observation about the main-loop thing. The big win is to isolate control-flow, as well as data. Functions look good on paper, but when implemented on a computer, you get hidden, low-level coupling which leads to hidden uses of context-switching and virtual memory (e.g. the callstack, which is a data structure constructed dynamically at runtime and causes unpredictable, unstructured blocking and calcifies routing decisions in a non-networky way). The main loop is a (potentially) big lump of code. What if you chopped it up into smaller lumps of code, each with their own \"main loops\"?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U02E4DAQGSZ"
                ],
                "count": 1
            }
        ]
    }
]