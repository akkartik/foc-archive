[
    {
        "user": "UJ6LDMMN0",
        "type": "message",
        "ts": "1599998624.069400",
        "client_msg_id": "fd0d4712-53d5-47c4-b776-f281fb26caf4",
        "text": "Do you have done some programming in any way? With Scratch maybe? Did you enjoy it? What make you want to learn CS?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c210ee2df74",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-11-13\/2722434855730_0c210ee2df74838f8683_72.png",
            "first_name": "nicolas",
            "real_name": "nicolas decoster",
            "display_name": "ogadaki",
            "team": "T5TCAFTA9",
            "name": "nicolas.decoster",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1599081626.041200",
        "parent_user_id": "U016FKP45HT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "co8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Do you have done some programming in any way? With Scratch maybe? Did you enjoy it? What make you want to learn CS?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1600003546.069600",
        "client_msg_id": "2c5e380e-0895-4f46-a626-0d8ab29dba06",
        "text": "<@U01AD80KMLK> Read that arXiv paper. Really interesting ideas. An ambitious project, but as you say it's doable with today's technology. What I can't see from that technical paper is: who needs to be convinced to make it happen?\n\nThe core task of Wikilambda is rendering knowledge in various languages, and that part is well described. There are occasional hints at other use cases, which seem to imply that you end up creating a new programming language, although I don't see it said explicitly. It isn't very clear either what features that language will have, other than that it's purely functional. The example on page 9 suggests that it will have a type system that allows the type \"positive_integer\". Which in turn suggests that type checking will be dynamic, as you can rarely ever prove statically that the result of a computation is positive. But none of that is explicit.\n\nWhat caught my attention in particular is: \"Wikilambda would also offer a place where scientists and analysts could create models together, and share specifications, standards, or tests for functions.\" That happens to be the domain of my own \"Future of Coding\" project (<https:\/\/github.com\/khinsen\/leibniz>), so I'd love to learn more about this. In particular, sharing specifications requires a specification language, not just a programming language, but nothing else in the paper hints at this being an objective. Since the most powerful scientific models we have are specifications rather than algorithms, it's an important point.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1599681751.047400",
        "parent_user_id": "U01AD80KMLK",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "khinsen\/leibniz",
                "title_link": "https:\/\/github.com\/khinsen\/leibniz",
                "text": "A Digital Scientific Notation. Contribute to khinsen\/leibniz development by creating an account on GitHub.",
                "fallback": "GitHub: khinsen\/leibniz",
                "thumb_url": "https:\/\/avatars1.githubusercontent.com\/u\/94934?s=400&v=4",
                "from_url": "https:\/\/github.com\/khinsen\/leibniz",
                "thumb_width": 157,
                "thumb_height": 157,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/github.png",
                "id": 1,
                "original_url": "https:\/\/github.com\/khinsen\/leibniz"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eiTL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U01AD80KMLK"
                            },
                            {
                                "type": "text",
                                "text": " Read that arXiv paper. Really interesting ideas. An ambitious project, but as you say it's doable with today's technology. What I can't see from that technical paper is: who needs to be convinced to make it happen?\n\nThe core task of Wikilambda is rendering knowledge in various languages, and that part is well described. There are occasional hints at other use cases, which seem to imply that you end up creating a new programming language, although I don't see it said explicitly. It isn't very clear either what features that language will have, other than that it's purely functional. The example on page 9 suggests that it will have a type system that allows the type \"positive_integer\". Which in turn suggests that type checking will be dynamic, as you can rarely ever prove statically that the result of a computation is positive. But none of that is explicit.\n\nWhat caught my attention in particular is: \"Wikilambda would also offer a place where scientists and analysts could create models together, and share specifications, standards, or tests for functions.\" That happens to be the domain of my own \"Future of Coding\" project ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/khinsen\/leibniz"
                            },
                            {
                                "type": "text",
                                "text": "), so I'd love to learn more about this. In particular, sharing specifications requires a specification language, not just a programming language, but nothing else in the paper hints at this being an objective. Since the most powerful scientific models we have are specifications rather than algorithms, it's an important point."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1600018183.069900",
        "client_msg_id": "e0f29a6e-ac34-40b5-9ea7-f16d2c8c752c",
        "text": "<@UJBAJNFLK> thanks for the links to Leibniz! That looks very interesting. I hope to avoid to create a new programming language, but to get away with composition of existing functions. The functions themselves can be implemented in any programming language the system supports, and whereas we will start only with one or two languages, we hope to considerably expand that.\nTypes such as positive integer would be defined by the community, just as functions are. But no, it doesn't require dynamic checks, and in fact I expect most checks to be static - it just means that you'd either have underflows and overflows, or that you define your functions accordingly (i.e. natural subtract instead of subtraction). So, no new programming language, but yes to composition. The prototype implementation at <https:\/\/github.com\/google\/abstracttext\/> might be helpful to dive further.\nRegarding the scientists to share models together, the thinking is more about \"here's an executable version of that function we defined here\", less about actually doing reasoning over the models itself. I am also not very sure how well this would work with an infrastructure as Wikilambda - probably something that is more geared towards such use cases such as leibniz would fare better. If I understand it right, you are doing a slightly different, higher level work of actually capturing and working with the whole model, whereas Wikilambda only wants to execute functions with specific inputs. Having said that, I would love to see how these two spaces could interact, I sense there is a lot of potential there - but it's not an area I have fully thought through.\nThose are great comments and pointers, thank you! If I didn't ask a question properly, fee free to ask again. Or if you have more questions.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a07cdcb6d037",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-09\/1376906509376_a07cdcb6d037bf7b6a5e_72.jpg",
            "first_name": "",
            "real_name": "Denny Vrandečić",
            "display_name": "Denny Vrandečić",
            "team": "T5TCAFTA9",
            "name": "dvrandecic",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1599681751.047400",
        "parent_user_id": "U01AD80KMLK",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "google\/abstracttext",
                "title_link": "https:\/\/github.com\/google\/abstracttext\/",
                "text": "MediaWiki extension to handle multilingual abstract content - google\/abstracttext",
                "fallback": "GitHub: google\/abstracttext",
                "thumb_url": "https:\/\/avatars0.githubusercontent.com\/u\/1342004?s=400&v=4",
                "from_url": "https:\/\/github.com\/google\/abstracttext\/",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/github.png",
                "id": 1,
                "original_url": "https:\/\/github.com\/google\/abstracttext\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7y5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " thanks for the links to Leibniz! That looks very interesting. I hope to avoid to create a new programming language, but to get away with composition of existing functions. The functions themselves can be implemented in any programming language the system supports, and whereas we will start only with one or two languages, we hope to considerably expand that.\nTypes such as positive integer would be defined by the community, just as functions are. But no, it doesn't require dynamic checks, and in fact I expect most checks to be static - it just means that you'd either have underflows and overflows, or that you define your functions accordingly (i.e. natural subtract instead of subtraction). So, no new programming language, but yes to composition. The prototype implementation at "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/google\/abstracttext\/"
                            },
                            {
                                "type": "text",
                                "text": " might be helpful to dive further.\nRegarding the scientists to share models together, the thinking is more about \"here's an executable version of that function we defined here\", less about actually doing reasoning over the models itself. I am also not very sure how well this would work with an infrastructure as Wikilambda - probably something that is more geared towards such use cases such as leibniz would fare better. If I understand it right, you are doing a slightly different, higher level work of actually capturing and working with the whole model, whereas Wikilambda only wants to execute functions with specific inputs. Having said that, I would love to see how these two spaces could interact, I sense there is a lot of potential there - but it's not an area I have fully thought through.\nThose are great comments and pointers, thank you! If I didn't ask a question properly, fee free to ask again. Or if you have more questions."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]