<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2018-09-11/433781465829_7c31dc735c6c1257fe1f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Krouse</b>
<span style="margin:2em; color:#606060">2019-02-14 01:44</span><br/>
Just published my conversation with <span style="background-color:#ccf">@Tudor Girba</span>. Excited to see the discussion it sparks <a href="https://futureofcoding.org/episodes/036">https://futureofcoding.org/episodes/036</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550137828.011000"></a>
      <img src="https://secure.gravatar.com/avatar/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550137828.011000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tudor Girba</b>
<span style="margin:2em; color:#606060">2019-02-14 01:50</span><br/>
Thanks a lot for putting this together! I feel like I already need to apologize. It's 2:52 long! I can only imagine the patience Steve needed to exercise on this one :slightly_smiling_face:.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550166086.012300"></a>
      <img src="https://avatars.slack-edge.com/2018-09-30/445630960161_85ee3dacef95dd5617e4_72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550166086.012300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tim Swast</b>
<span style="margin:2em; color:#606060">2019-02-14 09:41</span><br/>
Thanks for sharing! I'm enjoying the conversation. Something that didn't come across yet (I'm about halfway through) is what is gtoolkit an editor for? It sounds like it requires migrating to a new language?<br/><br/>Have you considered how some of these ideas (for different kinds of code visualizations, treating code as queryable data) could apply to existing languages?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550166361.012500"></a>
      <img src="https://secure.gravatar.com/avatar/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550166361.012500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tudor Girba</b>
<span style="margin:2em; color:#606060">2019-02-14 09:46</span><br/>
First of all, thanks for listening!<br/>Glamorous Toolkit is an IDE built in Pharo. Pharo is a language, and its history goes back some 2 decades :slightly_smiling_face:. The first target language is Pharo itself. However, GT is also a platform that can tackle other languages or technologies.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550166503.012800"></a>
      <img src="https://secure.gravatar.com/avatar/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550166503.012800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tudor Girba</b>
<span style="margin:2em; color:#606060">2019-02-14 09:48</span><br/>
Prior to GT, I also led the work on the Moose analysis platform that shows how all these principles can be applied to all sorts of other languages and technologies. That code is directly combinable with the new GT we are now building.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550199403.013400"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550199403.013400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-02-14 18:56</span><br/>
Ah Moose!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550306112.013900"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550306112.013900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-02-16 00:35</span><br/>
Glamorous Toolkit has so much work behind it to make all those wonderful little windows and graphs. I see problems ahead however, as the OOP paradigm underlying Pharo has some inherent aspects that make it extremely difficult to achieve interchangeable parts, which is what i believe is one of the main pillars of the future. I think that one should design from the standpoint of interchangeable parts, and then calculate backwards what a language must look like to allow such a phenomenon to exist.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550306176.014100"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550306176.014100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-02-16 00:36</span><br/>
John Backus who invented FP around 1970 was very much striving to create an era of interchangeable parts, but it doesn't exist yet.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550310577.014300"></a>
      <img src="https://secure.gravatar.com/avatar/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550310577.014300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tudor Girba</b>
<span style="margin:2em; color:#606060">2019-02-16 01:49</span><br/>
Thanks for taking a look. I am not sure what you mean by interchangeable parts. Would you like to detail your concern?<br/><br/>In any case, while the graphical stack has interesting properties, Glamorous Toolkit puts forward the concept of a moldable development environment. We see the IDE as a language that combines and extends the host language. Reusability of components is secondary to programmability because we believe that the development experience must be contextual. To this end, when practicing moldable development, we create tools for each of our problems. When working like that, the inner workings of systems become explainable and approachable even by less technical people. So, the key aspect is moldability and Glamorous Toolkit is a specific instantiation of that.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550391048.014700"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550391048.014700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-02-17 00:10</span><br/>
In my work experience, I've observed a situation where "modularity" had replaced coherent system design, and got worse and worse over time as others continued to believe that we'd achieve scalability once we achieved some perfect modular system; but what I observed was the exact opposite.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550391970.014900"></a>
      <img src="https://secure.gravatar.com/avatar/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550391970.014900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tudor Girba</b>
<span style="margin:2em; color:#606060">2019-02-17 00:26</span><br/>
That is an interesting observation. I'd be curious to learn more about how "modularity" came to be at odds with coherent system design. Would it be possible to provide more details?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550395229.015200"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550395229.015200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-02-17 01:20</span><br/>
<span style="background-color:#ccf">@Dan Cook</span> please share your horror story.  In my experience, it's when modules are drawn with the wrong bounds so you get tight coupling plus communication overhead.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550476186.017100"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550476186.017100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-02-17 23:49</span><br/>
<span style="background-color:#ccf">@William Taysom</span> - That's essentially what happened.<br/><br/>Let's say the product was a UI widget, with multiple similar but highly customized variations.<br/><br/>Version 1 had inconsistencies and unclear boundaries between features, which made it difficult to share (or even identify) features across different code-bases. Each feature was developed in whatever code-base needed it at the time, and then copied ad-hoc to others as needed. Let's say the code was 10 Smurfs in size.<br/><br/>Version 2 included <b>all</b> features in a single "I can be anything" code-base (single repository). Each feature was factored nicely into it's own "module"; but there was a lot of complex mechanism to dynamically load or enable/disable modules on the fly. This code was 30 Smurfs in size.<br/><br/>Version 3 allowed you to statically include <b>just</b> the modules you need, from the start. However, each module now lived in it's own repository, had its own version, it's own CI/CD system, and was built on top of a swarm of the latest tools/technologies/frameworks/etc. The modules would listen to each other's events and monitor each other's state, and proactively try to cause their own behavior(s) to happen at the right time and/or trigger each other to pick up the next step. Many of these modules equated to tiny steps (one-liners) before, but had become full-fledged modules with their own state &amp; events, and watching the state &amp; events of others, and also with all the configuration files that each module then came with (new retirement imposed by the new technology stack). The whole thing had undergone changes &amp; refactorings across all modules over time. The typical size of one of these (after combining all modules used for a given instance of the widget) was 400 Smurfs.<br/><br/>So sure, it only included the modules you needed, BUT:<br/><li> The code was MUCH larger and more complicated to follow (especially being split across MANY repositories)<br/><li> Most instances needed most of the modules, anyway<br/><li> There was CONSTANT breakages and build errors related to not having the right combination of modules (or incompatible versions of different modules).<br/><li> ... I won't go on any further.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550480711.020000"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550480711.020000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-02-18 01:05</span><br/>
<span style="background-color:#ccf">@Tudor Girba</span> - I agree that true modularity is not at odds with coherent systems (although too much of it can be -- I forget who says it, but "code should be as simple as possible, but no simpler").<br/><br/>So, granted, the real problem there was actually a lack of critical thinking &amp; proper analysis (e.g. asking the right questions).<br/><br/>But it does seem that many people don't understand the difference (hence the quotes), and my experience has caused me to see excessive focus on "modularity" as a red flag / as something commonly (mis)used as a "silver bullet"
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550487572.022000"></a>
      <img src="https://avatars.slack-edge.com/2019-01-20/529811744742_ca63ca2aa38fa658cc4f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550487572.022000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Woods</b>
<span style="margin:2em; color:#606060">2019-02-18 02:59</span><br/>
<span style="background-color:#ccf">@Dan Cook</span> Super interesting, thanks!<br/>There is something very relaxing about reading about <em>other</em> dev's terrible experiences :stuck_out_tongue:<br/><br/>With increasing age I think I am a bit of a simplicity pessimist because there is a similar story to be told about most types of approach. We often feel like there is some type of inner simplicity waiting to get out that we are missing but real work so often turns out to be a messy impendance filled PITA. I fear that when we do get a simple elegant implementation, it's actually luck that the problem allowed it and didn't throw up assumption-breakers rather than virtues of our approach. Try a successful approach on a different problem and it can spin out of control.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550496138.022800"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550496138.022800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-02-18 05:22</span><br/>
Well said <span style="background-color:#ccf">@Duncan Woods</span>.  Perhaps accidental complexity abounds in software projects because an abundance of the desired behavior is in fact accidental.  Brings to mind a recent project where one tiny corner of a country required an exceptional case that touched every part of the system.  Some 50 if-statements later we had it in hand.  No idea how I could have handled that particular cross-cutting concern better.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550510474.023000"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550510474.023000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-02-18 09:21</span><br/>
I strongly disagree with the view that software is just inescapably messy and unfixable. Most accidental complexity is an <b>objective</b> matter that can be dealt with through basic composition &amp; decomposition -- skills that any professional software developer should have, and which are foundational to coherent code design. This goes hand-in-hand with understanding &amp; designing software (first and foremost) in terms of the <b>human</b> model (i.e. the terms that matter).<br/><br/>If these things are lacking to begin with, then adding more technology &amp; frameworks &amp; patterns (etc.) is not going to change that -- in fact it will often make this problem even worse!<br/><br/>Sadly, <b>most</b> software is much more complex than it needs to be, largely due to the wide-spread lack / misunderstanding of these <b>foundational</b> things. That is the status quo of professional software, which is just dismal.<br/><br/>It's a real shame because it's not hard -- any competent developer can grasp these things. But because of that gap, we (as an industry) chase or own tails and hop from fad to fad, and eventually "accept" that it's hopeless ("it never works out") and attribute simplicity to luck. <br/><br/>...<br/><br/>Perhaps the bigger problem, then, is what to do about this culture / gap? If one cannot get the team on board or to stop barking up the wrong tree (or if we cannot change the industry at large), then we are stuck with having to deal with these problems regardless.<br/><br/>For example, it seems impossible to challenge the view that the software industry knows what's best, so if you do what everyone else is doing (e.g. use the latest greatest frameworks and follow the standards), then you're doing it "right". When in reality, the industry is a pop culture based on fads and popularity. One is professional because they do all the things that other professional software vendors do. But others are professional because they do too.<br/><br/>Jim Coplien describes the level of professionalism / maturity of the industry in the following, and my experience has matched his description:<br/> <a href="https://www.infoq.com/interviews/coplien-dci-architecture">https://www.infoq.com/interviews/coplien-dci-architecture</a><br/>(You can listen to it, or read the transcript)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550542174.025100"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550542174.025100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-02-18 18:09</span><br/>
<span style="background-color:#ccf">@Dan Cook</span> indeed!  Why are we missing really any objective complexity measure – beyond Lines of Code?  In as much as we optimize what we can measure, why don't we measure this!?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550560822.026700"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550560822.026700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-02-18 23:20</span><br/>
<span style="background-color:#ccf">@Duncan Woods</span> - I agree about no one-size-fits-all solutions. Each problem has its own context and it's own space, and needs it's own solution -- heck, even defines its own "shape" and therefore its own architecture (C.A.'s "Notes on the synthesis of form" is an excellent book on that topic).<br/><br/>That's also why I think there is a lot of potential in the Glamorous Toolkit that <span style="background-color:#ccf">@Tudor Girba</span> is working on
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550561251.027000"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550561251.027000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-02-18 23:27</span><br/>
<span style="background-color:#ccf">@William Taysom</span> - Maybe, but I don't know how helpful an actual metric would be here.<br/><br/>What I'm talking about is usually obvious: either the code speaks for itself, or it doesn't. There are patterns that you can learn to look for, but the effect is essentially that the code either makes sense in human terms &amp; matches the human model(s) (1:1 if possible), or it does not. It's not about statistics, but whether the code is sane to understand and work with.<br/><br/>Now it might sound like I'm taking about two different things: objective simplicity, and matching the human model. But I've discovered that these things coalesce to the same ideal of code.<br/><br/>Let me explain:<br/><br/>What would it look like if you could reduce a program (code) down to its simplest form possible? By definition, it would be nothing more or less than the pure semantics -- stated in the most simple &amp; direct way possible -- of what the program is and what it does. And what is that, other than the human model? That is, if you could explain the program to another person, as simply as possible (but with enough detail when detail matters), how concisely can that be explained? ... And if <b>that</b> is enough information for someone to go code it up, then that's also the minimum info needed in the program. The code would read just like the human description.<br/><br/>For example: There is bounded paying area, a ball, and two paddles. The ball moves across the field with a certain velocity. When it hits a wall or a paddle, it changes direction. etc. The ball is of this size and that color, etc. I can picture code that reads like this.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550562863.027400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550562863.027400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-02-18 23:54</span><br/>
Agree with <span style="background-color:#ccf">@Dan Cook</span> here about most software being much more complex than it needs to be. I also share the feeling that the problem is in some foundational things. Consider some everyday software development concerns that have nothing to do with the nature of the end user 'human' problem it is trying to solve: impedance mismatch between DBs, programming languages and UI models; managing versions of disparate libraries and dependencies across different source control and build systems; tedium around parsing, serializing, persisting and verifying similar messages all over the place; consistency in the face of concurrency and synchrony (from multi-threading to large distributed processes). Add the constraint that most introspection of the system is via mentally simulating and piecing together scattered low level information gathered via primitive mechanisms (text logs), instead of an ability to ask the system high level questions.<br/><br/> <span style="background-color:#ccf">@William Taysom</span>’s example about the cross cutting concern is telling. Is it possible to have a decomposition where no cross cutting concern might arise? Perhaps not. When we adopt a single model that decomposition must be along one dimension only. But for any large system we might want multiple simultaneous perspectives - each relevant in a different context.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550563985.027700"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550563985.027700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-02-19 00:13</span><br/>
I'm not sure how to speak to cross-cutting stuff, aside from that the "code commit" (e.g. in a source control repository) has become my favorite "code construct" -- maybe I'll explain more if needed.<br/><br/>As for the lower level concerns, sometimes the "human" in the "human model" is the programmer. There is a way to state, in plain human terms, what your are trying to do with the DB and how/where that fits into the bigger picture or use-case. And either the code matches that, or it does not. That still all comes down to basic decomposition and abstraction skills.<br/><br/>There is still the non-functional requirements, though maybe abstraction done right can separate that from the other stuff.<br/><br/>As for threading issues, maybe we cannot get away entirely, or maybe there are other options. See the following video at 1:06:00 for about 5 minutes: <a href="https://youtu.be/nrVIlhtoE3Y">https://youtu.be/nrVIlhtoE3Y</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550564078.027900"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550564078.027900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-02-19 00:14</span><br/>
For simplicity being objective, watch Rich Hickey's "Simple Made Easy":<br/><br/><a href="https://www.infoq.com/presentations/Simple-Made-Easy">https://www.infoq.com/presentations/Simple-Made-Easy</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550564853.028300"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550564853.028300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-02-19 00:27</span><br/>
<span style="background-color:#ccf">@Shalabh</span> well said.  I may just like parsing, but it seems that the most tedious code I write has the feel of a parsing problem – especially if I view UI events as token streams.  I suppose distributed processes are the other kind of tedium that I encounter.  (Might even be rewriting my six year old background task system in sort order.)  Data ferrying is the least tricky part.  The tedious part is monitoring progress and recovering from failure.  (Given my particular constraints no off the shelf solution has proven the least bit helpful – except Redis as a foundation I suppose.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550565157.028500"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550565157.028500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-02-19 00:32</span><br/>
As for crosscutting concerns and decomposition dimensions, I've always found insight in seeing solutions to the expression problem.  Interacting things often form a sort of lumpy product space where one perspective or another might be clearer depending.  Guess I just wish more was done with Aspect Oriented Programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550568151.029000"></a>
      <img src="https://secure.gravatar.com/avatar/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550568151.029000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tudor Girba</b>
<span style="margin:2em; color:#606060">2019-02-19 01:22</span><br/>
<span style="background-color:#ccf">@Dan Cook</span> I enjoy your observations. I do believe that already now and even more so in the future, the key problem to solve is how to deal with existing software, how to make software approachable by other humans. The focus on pure semantics is certainly important. However, what we observed over the past decade is that the specification and the explanation do not have to coincide. For example, we have many ways to explain the same mathematical concepts to kids. Similarly, there can be many ways to explain the same software part to someone else.<br/><br/>Furthermore, software is highly contextual and you can look at the same part from different perspectives, each of these having specific needs. For example, there are coarser points of view such as looking the same part to understand its meant functionality, or to reason about its performance. But, there are finer grained concerns as well. For example, when we look at a graphical object, we might want to understand its shape, but we might also want to be able to understand how it is composed out of smaller objects, and how all these handled and propagated events. Each of these points of view benefit from dedicated explanatory views.<br/><br/>That is the main motivation behind moldability. We think that moldability is orthogonal with the other software engineering concerns, such as language expressivity, and we also think it is a fundamental concept.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1550568726.029200"></a>
      <img src="https://secure.gravatar.com/avatar/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../share-your-work/1550137467.010900.html#1550568726.029200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tudor Girba</b>
<span style="margin:2em; color:#606060">2019-02-19 01:32</span><br/>
<span style="background-color:#ccf">@William Taysom</span><br/>&gt;Why are we missing really any objective complexity measure – beyond Lines of Code?  In as much as we optimize what we can measure, why don't we measure this!?<br/>In software analysis and software evolution research fields lots of effort was spent to come up with the metric, or at least the metrics. I actually spent significant time doing that. I am now convinced that it cannot work due to the contextual nature of software. I believe that there is no one size fits all. We can predict classes of problems, but not specific problems that people have. I believe that we need to focus on context and I think there is a science behind it, too.<br/><br/>I like a talk of Malcolm Gladwell that provides an interesting story related to contextual measurements. In this story, he talks about Howard Moskowitz, a statistician that wanted to convince the world that there is no perfect Pepsi, and that there are only perfect Pepsis. <a href="https://www.ted.com/talks/malcolm_gladwell_on_spaghetti_sauce?language=en">https://www.ted.com/talks/malcolm_gladwell_on_spaghetti_sauce?language=en</a><br/><br/>I think this perspective matches our field as well.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
