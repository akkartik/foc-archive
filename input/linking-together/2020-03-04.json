[
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1583315248.025900",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1583315413.000000"
        },
        "client_msg_id": "604198c6-1557-43e9-865a-d111fc0072c3",
        "text": "When you have 3 values stored in a Boolean variable as in JS, you have 9 combinations for each operator. In Excel\/Beads there are 16 different combinations that have to be considered. There is no question that moving away from the hardware's simplistic 4 combinations you pay a dear price in efficiency, but the additional robustness is quite salutary. If you look deeply into the history of programming, you will see that in the beginning with Assembler, people ignored errors. Then in FORTRAN, people used to write code to validate the inputs to their functions at the beginning of the function, and every function would typically have an error return code, usually some big unique number, that you might look up in a big manual. Then people got tired of all that error checking, and in C often ignored checking parameters for validity (i'm talking about you MS!), and maybe just had an error code which was often just success or failure. In Java errors are blithely ignored until you get 50 levels deep and finally hit a null pointer exception. In the JS word people don't seem to check anything any more, probably because they have so little experience, and as a result I find web software to be the flakiest software ever built. The beauty of the web is you just reboot the page and the V8 super duper just in time compiler fixes it all fresh. We are in an era where computers are so fast people don't care much about reliability or robustness. However, i find this sloppiness intolerable, and i want to align programming with the logicians who are striving so hard to prove programs have no errors in them. To that end we must eliminate sources of intermittent\/undefined behavior, and that means going back to the bottommost arithmetical operations and ensuring they are airtight, and don't leak.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iBM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When you have 3 values stored in a Boolean variable as in JS, you have 9 combinations for each operator. In Excel\/Beads there are 16 different combinations that have to be considered. There is no question that moving away from the hardware's simplistic 4 combinations you pay a dear price in efficiency, but the additional robustness is quite salutary. If you look deeply into the history of programming, you will see that in the beginning with Assembler, people ignored errors. Then in FORTRAN, people used to write code to validate the inputs to their functions at the beginning of the function, and every function would typically have an error return code, usually some big unique number, that you might look up in a big manual. Then people got tired of all that error checking, and in C often ignored checking parameters for validity (i'm talking about you MS!), and maybe just had an error code which was often just success or failure. In Java errors are blithely ignored until you get 50 levels deep and finally hit a null pointer exception. In the JS word people don't seem to check anything any more, probably because they have so little experience, and as a result I find web software to be the flakiest software ever built. The beauty of the web is you just reboot the page and the V8 super duper just in time compiler fixes it all fresh. We are in an era where computers are so fast people don't care much about reliability or robustness. However, i find this sloppiness intolerable, and i want to align programming with the logicians who are striving so hard to prove programs have no errors in them. To that end we must eliminate sources of intermittent\/undefined behavior, and that means going back to the bottommost arithmetical operations and ensuring they are airtight, and don't leak."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UUB7RA7PF"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UUB7RA7PF",
        "type": "message",
        "ts": "1583336510.026300",
        "edited": {
            "user": "UUB7RA7PF",
            "ts": "1583336685.000000"
        },
        "client_msg_id": "50bb7864-1534-4ba2-89fd-00333e1d06e0",
        "text": "<@UJN1TAYEQ> thanks for this extra explanation! In Haskell idea is to avoid using partial functions like head, but as you say, it is not enforced in any way, so there are no guarantees some third party library is not using them. Thank you both <@UEQ6M68H0> and <@UJN1TAYEQ> for explaining this, this is certainly some food for thought!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2fdcf29b225b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-02-26\/971836171367_2fdcf29b225b02e66825_72.png",
            "first_name": "Martin",
            "real_name": "Martin Sosic",
            "display_name": "Martin",
            "team": "T5TCAFTA9",
            "name": "sosic.martin",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SJ9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " thanks for this extra explanation! In Haskell idea is to avoid using partial functions like head, but as you say, it is not enforced in any way, so there are no guarantees some third party library is not using them. Thank you both "
                            },
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " for explaining this, this is certainly some food for thought!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1583337019.026600",
        "client_msg_id": "91c7a9b9-fbd5-4b73-8a51-b77cc00ee89a",
        "text": "Doug, I'm not an expert on type systems, but I'm going to need a citation on \"Haskell's type system is unsound.\" Best I can find from Googling is <http:\/\/okmij.org\/ftp\/Haskell\/types.html#unsound-typeable|http:\/\/okmij.org\/ftp\/Haskell\/types.html#unsound-typeable> which refers to a much more arcane feature than `head`.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "attachments": [
            {
                "title": "Haskell Programming: Types",
                "title_link": "http:\/\/okmij.org\/ftp\/Haskell\/types.html#unsound-typeable",
                "text": "Less-than-traditional uses of types: dependent, higher-ranked, existential, etc. types and logical type programming",
                "fallback": "Haskell Programming: Types",
                "from_url": "http:\/\/okmij.org\/ftp\/Haskell\/types.html#unsound-typeable",
                "service_name": "okmij.org",
                "id": 1,
                "original_url": "http:\/\/okmij.org\/ftp\/Haskell\/types.html#unsound-typeable"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "G5uy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Doug, I'm not an expert on type systems, but I'm going to need a citation on \"Haskell's type system is unsound.\" Best I can find from Googling is "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/okmij.org\/ftp\/Haskell\/types.html#unsound-typeable",
                                "text": "http:\/\/okmij.org\/ftp\/Haskell\/types.html#unsound-typeable"
                            },
                            {
                                "type": "text",
                                "text": " which refers to a much more arcane feature than "
                            },
                            {
                                "type": "text",
                                "text": "head",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1583337537.026900",
        "client_msg_id": "444a3248-d894-4d63-9451-d8489c436549",
        "text": "Edward, checking for errors is orthogonal to the number of states a Boolean has. Your comments suggest more states are always better, which is obviously wrong: adding the null state caused Hoare's famous billion-dollar mistake. And the third state in JavaScript booleans that you seem to like so much is the much maligned `undefined` if I'm interpreting you correctly. These are not good ideas.\n\nBooleans have 2 states. Variables that need more than two states are absolutely a good idea. They shouldn't use booleans.\n\nIn general, the problem of type modeling is to have a Goldilocks number of states for each variable: not too many so some states are rare and programmers don't test for them, and not too few so programmers _can't_ test for some. All this has absolutely nothing to do with booleans.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uP15v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Edward, checking for errors is orthogonal to the number of states a Boolean has. Your comments suggest more states are always better, which is obviously wrong: adding the null state caused Hoare's famous billion-dollar mistake. And the third state in JavaScript booleans that you seem to like so much is the much maligned "
                            },
                            {
                                "type": "text",
                                "text": "undefined",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " if I'm interpreting you correctly. These are not good ideas.\n\nBooleans have 2 states. Variables that need more than two states are absolutely a good idea. They shouldn't use booleans.\n\nIn general, the problem of type modeling is to have a Goldilocks number of states for each variable: not too many so some states are rare and programmers don't test for them, and not too few so programmers "
                            },
                            {
                                "type": "text",
                                "text": "can't",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " test for some. All this has absolutely nothing to do with booleans."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1583338581.027100",
        "client_msg_id": "fce1c459-704c-48c5-a06b-c3aa102b604c",
        "text": "<@UCUSW7WVD> The term \"sound type system\" has a general meaning, which applies to formal mathematical systems as well as programming languages. Here's a nice definition: <https:\/\/eschew.wordpress.com\/2009\/08\/31\/sound-and-complete\/>\n\nTo apply the concept of \"sound type system\" to Haskell, you need to make a choice about the kinds of programs you consider unsound. <http:\/\/okmij.org|okmij.org> is only concerned with excluding programs that will cause a segmentation fault\/corrupt memory\/etc, and you have to look deep into Haskell to find such unsafe features. In Haskell, the case expression doesn't require you to specify all the cases, and aborts the program if an unhandled case is encountered at runtime, while in safe languages like Rust, you have to explicitly handle all the cases. I think this comparison makes Haskell look bad, and it is reasonable by modern standards to classify this as unsound. Standards of soundness have gone up since 1998. There are a few languages that take an even stricter stance on soundness, and require the type system to reject any function that isn't total. \"Total\" means: the function is guaranteed to return a value: it can't throw an exception and it can't go into an infinite loop. This usually means that recursive functions are not allowed, because they could go into an infinite loop. \"Dhall\" is a currently trendy language that guarantees totality.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "attachments": [
            {
                "service_name": "eschew it all",
                "service_url": "http:\/\/eschew.wordpress.com",
                "title": "Sound and Complete",
                "title_link": "https:\/\/eschew.wordpress.com\/2009\/08\/31\/sound-and-complete\/",
                "author_name": "eschew",
                "author_link": "https:\/\/eschew.wordpress.com\/author\/eschew\/",
                "thumb_url": "https:\/\/i0.wp.com\/eschew.org\/images\/permanent\/sound-and-complete.png?fit=200%2C150",
                "thumb_width": 94,
                "thumb_height": 150,
                "text": "A jury reaches a verdict: guilty! But was she, in fact, innocent after all?\nThroughout life, we must make decisions: evaluate, then accept or reject.  Life being what it is, there are more ways to screw up than not. The field of formal logic gives us two properties we can use to describe any evaluation procedure, such as the jury above: soundness and completeness. A sound jury will never send a guilty person free, while a complete jury will never send an innocent person to jail. (As an aside, I think the concrete example of a jury and its verdicts is much easier to grok than Wikipedia&rsquo;s treatment, which says &ldquo;Informally, a soundness theorem for a deductive system expresses that all provable sentences are true. Completeness states that all true sentences are provable.&rdquo;) Intuitively, soundness and completeness are orthogonal: you can have any combination of (non-) soundness and (non-) completeness. \nThe ideal, of course, is sound and complete: the perfect justice system that will never exist. What we have is neither sound nor complete: innocent people are sent to jail, and guilty people go free.\nAnyways, soundness and completeness are also pervasively used in static analysis and programming language type theory, each of which are close siblings to formal logic. Well, type theory is more like a mirrored reflection of formal logic, but that&rsquo;s neither here nor there. A sound type system (or analysis) is one that rejects all erroneous programs, and a complete system accepts all correct programs.\nNow, the interesting question is: which is more important? Is it better to have a complete but unsound static analysis, which will report every error that exists, and then maybe some errors that don&rsquo;t exist? Or better to have the opposite, sound and incomplete, where every error that it reports is an actual error, but it might not find all the issues in the program? I happen to think sound and incomplete is better: first, because sound analyses compose, and second, because many of the properties you really want to have verified (such as &ldquo;does this rendering look right?&rdquo;) don&rsquo;t fall in the scope of the verification system. Complete and unsound certainly has its appeal: after working through all the reported errors (and dealing with the wild goose chases), you&rsquo;ll know that your program is free of all the bugs that the analysis is capable of finding. Of course, completeness is unachievable for many of the most interesting and critical problems, whereas sound-but-incomplete is more within reach.\nWhat about for type systems? A sound type system is one that is not lenient, in that it rejects all invalid programs plus some number of valid programs. A complete type system accepts all valid programs, and some invalid ones to boot. Which to pick?\nThe situation isn&rsquo;t quite as obvious as with a static analysis, for two reasons. The first difference is that a programming language with a complete and unsound (static) type system has a fallback in the form of dynamic typing. In fact, one of the most powerful type system features, dependent typing, is not statically verifiable unless carefully restricted. Dependent type systems therefore blur the distinction between compile-time type checking and runtime type checking, and thus between static and dynamic typing. The second complication is that the arithmetic mean programmer tends to value expressiveness rather more than compile-time verification. Programmers dislike having the computer reject a program that would have run fine, simply because the computer couldn&rsquo;t make sure it would run fine without actually running it. In short, restrictive type systems drive programmers to more flexible environments. Consider how Mozilla Firefox is designed: a core of statically-typed C++ to do heavy lifting, with dynamically-typed JavaScript running the user interface. Not coincidentally, this static core\/dynamic shell is shared by many large video games (like World of WarCraft: C++ and Lua).\nThe target domain matters, of course. One hopes that the language for a program controlling an airliner&rsquo;s fuel supply preferred soundness over completeness. And type inference raises another issue: there exist type systems that are sound and complete, but are not amenable to type inference.\nDecisions, decisions&hellip;\np.s. Since I&rsquo;m a visual learner, I created a reference chart:\nChart of soundness and completeness properties",
                "fallback": "eschew it all Link: Sound and Complete",
                "from_url": "https:\/\/eschew.wordpress.com\/2009\/08\/31\/sound-and-complete\/",
                "service_icon": "https:\/\/secure.gravatar.com\/blavatar\/2935275ef440c3e71c1ca881ddcd86ac?s=114",
                "id": 1,
                "original_url": "https:\/\/eschew.wordpress.com\/2009\/08\/31\/sound-and-complete\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hj=D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " The term \"sound type system\" has a general meaning, which applies to formal mathematical systems as well as programming languages. Here's a nice definition: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/eschew.wordpress.com\/2009\/08\/31\/sound-and-complete\/"
                            },
                            {
                                "type": "text",
                                "text": "\n\nTo apply the concept of \"sound type system\" to Haskell, you need to make a choice about the kinds of programs you consider unsound. "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/okmij.org",
                                "text": "okmij.org"
                            },
                            {
                                "type": "text",
                                "text": " is only concerned with excluding programs that will cause a segmentation fault\/corrupt memory\/etc, and you have to look deep into Haskell to find such unsafe features. In Haskell, the case expression doesn't require you to specify all the cases, and aborts the program if an unhandled case is encountered at runtime, while in safe languages like Rust, you have to explicitly handle all the cases. I think this comparison makes Haskell look bad, and it is reasonable by modern standards to classify this as unsound. Standards of soundness have gone up since 1998. There are a few languages that take an even stricter stance on soundness, and require the type system to reject any function that isn't total. \"Total\" means: the function is guaranteed to return a value: it can't throw an exception and it can't go into an infinite loop. This usually means that recursive functions are not allowed, because they could go into an infinite loop. \"Dhall\" is a currently trendy language that guarantees totality."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1583338849.027400",
        "client_msg_id": "905e3979-33c2-4008-aa30-d703ec3e5726",
        "text": "Certainly, Rust's core type system is more rigorous than Haskell's. I just want to use words the way their experts defined them. I'll subside now. Ping me when others agree with you that runtime error = unsound.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fN\/us",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Certainly, Rust's core type system is more rigorous than Haskell's. I just want to use words the way their experts defined them. I'll subside now. Ping me when others agree with you that runtime error = unsound."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1583340404.027600",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1583340629.000000"
        },
        "client_msg_id": "39553da1-7119-4512-b2d5-e090d3f58116",
        "text": "Here's part of an email thread where well known Haskell expert Conor McBride is attempting to argue that Haskell has an unsound type system. I can't find his original post, just followups that quote his statement. Conor said \"As an obvious consequence, Haskell type system would be unsound.\"\n<https:\/\/mail.haskell.org\/pipermail\/haskell\/2004-April\/013979.html>\n<https:\/\/mail.haskell.org\/pipermail\/haskell\/2004-April\/013995.html>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FjO4l",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here's part of an email thread where well known Haskell expert Conor McBride is attempting to argue that Haskell has an unsound type system. I can't find his original post, just followups that quote his statement. Conor said \"As an obvious consequence, Haskell type system would be unsound.\"\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/mail.haskell.org\/pipermail\/haskell\/2004-April\/013979.html"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/mail.haskell.org\/pipermail\/haskell\/2004-April\/013995.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1583375497.028200",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1583375625.000000"
        },
        "client_msg_id": "22ee8edb-3b8d-43ba-83ec-2ffdf5c05701",
        "text": "<@UCUSW7WVD> sorry, but if you assume that your input data is perfect, your program will malfunction in unpredictable ways the minute some data isn't perfect. As software changes over time, programmers tend to add more fields to records, and the existing data doesn't have values for these new fields, and are therefore best stored as \"missing\" or \"unknown\" or \"undefined\" or whatever word you prefer. To have any chance at provably correct, robust software one must consider the cases where the input data is either unspecified or known to be in error, which are two different states in Excel. Just because George Boole 1815-1864 didn't consider these extra states in his theory (which was fairly useless until Turing and Von Neumann dusted it off 100 years later), doesn't mean that in the 2000's we can't finally admit that erroneous and missing inputs should not result in some undesired outcome.\n\nVisicalc\/Quattro\/Lotus123\/Multiplan\/Excel has proven with overwhelming popularity and usage that protected arithmetic is the preferred solution, and unfortunately language designers which keep looking in the historical tradition of logic which ignores such impurities as beneath them, are doomed to repeat the same mistakes.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "s9d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " sorry, but if you assume that your input data is perfect, your program will malfunction in unpredictable ways the minute some data isn't perfect. As software changes over time, programmers tend to add more fields to records, and the existing data doesn't have values for these new fields, and are therefore best stored as \"missing\" or \"unknown\" or \"undefined\" or whatever word you prefer. To have any chance at provably correct, robust software one must consider the cases where the input data is either unspecified or known to be in error, which are two different states in Excel. Just because George Boole 1815-1864 didn't consider these extra states in his theory (which was fairly useless until Turing and Von Neumann dusted it off 100 years later), doesn't mean that in the 2000's we can't finally admit that erroneous and missing inputs should not result in some undesired outcome.\n\nVisicalc\/Quattro\/Lotus123\/Multiplan\/Excel has proven with overwhelming popularity and usage that protected arithmetic is the preferred solution, and unfortunately language designers which keep looking in the historical tradition of logic which ignores such impurities as beneath them, are doomed to repeat the same mistakes."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1583375839.028500",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1583376371.000000"
        },
        "client_msg_id": "aba5172e-767c-4198-aa03-b96c0003d99e",
        "text": "That is a valid concern, and the solution is to not use boolean types to model booleans in input data. But boolean types are still useful for internals. Adding a state to all boolean types is excessive and imprecise. The term means something, and what it means is useful. JavaScript violating the meaning isn't sufficient reason to ditch it entirely. In fact, JavaScript illustrates that just adding extra states doesn't actually solve anything. The onus is still on the programmer to _use_ them wisely.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k5Da",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That is a valid concern, and the solution is to not use boolean types to model booleans in input data. But boolean types are still useful for internals. Adding a state to all boolean types is excessive and imprecise. The term means something, and what it means is useful. JavaScript violating the meaning isn't sufficient reason to ditch it entirely. In fact, JavaScript illustrates that just adding extra states doesn't actually solve anything. The onus is still on the programmer to _use_ them wisely."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1583376835.028800",
        "client_msg_id": "bdcd94d4-8faa-4f6b-9b39-ba94f629abd0",
        "text": "For including a third state I like `Optional&lt;Boolean&gt;`. The nice thing about it is that it's impossible to forget about the third state,  a problem JavaScript has in spades.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CuAi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For including a third state I like `Optional<Boolean>`. The nice thing about it is that it's impossible to forget about the third state,  a problem JavaScript has in spades."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1583385146.029200",
        "client_msg_id": "3e532f48-185d-4737-8c50-3391319772e4",
        "text": "<@UCUSW7WVD> I think you are mistaken that there are only 3 states. There are 4 states for a Boolean quantity: true, false, undefined, and error. If you evaluate an expression using real numbers such as `val = sqrt(-1) &lt; 0`, then the result is neither `true`, nor `false`, nor `undefined`, but as Excel would calculate it, `#ERROR`.  There is no undefined or missing quantity, but rather the operation is erroneous. This is the fourth state which is necessary to be able to store. Perhaps your program will halt on an error or undefined quantity in debug mode, but in production may propagate the error value (as does Excel) so that it never crashes. People see the red `ERROR` cells quickly, and the propagation effect means that all derived quantities based on the original error value are also flagged. This is of great value in long chains of dependencies. It is neither excessive nor imprecise. In fact it is more precise because no information is being destroyed or made up. That a boolean value would take 4 bits instead of 2 to store is a trivial additional cost. There is no additional cost to have the fourth state given that you needed at least 2 bits to store it anyway.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pKDNa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I think you are mistaken that there are only 3 states. There are 4 states for a Boolean quantity: true, false, undefined, and error. If you evaluate an expression using real numbers such as "
                            },
                            {
                                "type": "text",
                                "text": "val = sqrt(-1) < 0",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", then the result is neither "
                            },
                            {
                                "type": "text",
                                "text": "true",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", nor "
                            },
                            {
                                "type": "text",
                                "text": "false",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", nor "
                            },
                            {
                                "type": "text",
                                "text": "undefined",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but as Excel would calculate it, "
                            },
                            {
                                "type": "text",
                                "text": "#ERROR",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  There is no undefined or missing quantity, but rather the operation is erroneous. This is the fourth state which is necessary to be able to store. Perhaps your program will halt on an error or undefined quantity in debug mode, but in production may propagate the error value (as does Excel) so that it never crashes. People see the red "
                            },
                            {
                                "type": "text",
                                "text": "ERROR",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " cells quickly, and the propagation effect means that all derived quantities based on the original error value are also flagged. This is of great value in long chains of dependencies. It is neither excessive nor imprecise. In fact it is more precise because no information is being destroyed or made up. That a boolean value would take 4 bits instead of 2 to store is a trivial additional cost. There is no additional cost to have the fourth state given that you needed at least 2 bits to store it anyway."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1583385687.029400",
        "client_msg_id": "22a830d1-e430-4b34-971c-f6743ad5a053",
        "text": "This is an exceedingly stupid debate. If you need 4 states, use 4 states! My argument doesn't care if you have 3 or 4 or 6 (because 5 is right out). Meanwhile, if you unilaterally change what a word means and call everyone who disagrees 'uninformed' -- well, good luck with that.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PL3p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is an exceedingly stupid debate. If you need 4 states, use 4 states! My argument doesn't care if you have 3 or 4 or 6 (because 5 is right out). Meanwhile, if you unilaterally change what a word means and call everyone who disagrees 'uninformed' -- well, good luck with that."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]