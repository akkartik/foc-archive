<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-07-08/681438296241_88eacb7e65edebc579ab_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Aidan Cunniffe</b>
<span style="margin:2em; color:#606060">2018-10-21 11:44</span><br/>
Hey all -- I spent a lot of time the last few months thinking about how to make it easier to connect applications together. I think with the advent of microservices and the abundance of 3rd party APIs for just about everything has created a need to make it easier to automatically connect software.<br/><br/>I wrote up this abstract this morning for a programming language that'd make this easier out of the box -- it's probably not super novel but I thought I'd share. Thanks in advance for feedback. I'm not at all possessive of this idea so feel free to remix the best parts if you want :slightly_smiling_face:  <a href="https://gist.github.com/acunniffe/031caf85261a790b7406e1c0f5658605">https://gist.github.com/acunniffe/031caf85261a790b7406e1c0f5658605</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540151189.000100"></a>
      <img src="https://avatars.slack-edge.com/2018-09-11/433781465829_7c31dc735c6c1257fe1f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540151189.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Krouse</b>
<span style="margin:2em; color:#606060">2018-10-21 12:46</span><br/>
I agree with the problem you identify (low level imperitive code) and the solution (higher level declarative abstractions). It's a great point that the documentation spec should serve as the code itself, not an added description. I wonder if an executable spec language already exists to do something similar. It feels similar in spirit to graphQL in some ways
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540162680.000100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-08/681438296241_88eacb7e65edebc579ab_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540162680.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Aidan Cunniffe</b>
<span style="margin:2em; color:#606060">2018-10-21 15:58</span><br/>
Yeah there are definitely some that create some documentation but it’s not very reliable. <br/><br/>I think the main idea I’d love to see further explored is a compiler that’s behavior changes based on which other project graphs you consume. <br/><br/>I like graphQL in some cases but I feel like there’s still tremendous value in having a simpler strict input/output structure to an API. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540166399.000100"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540166399.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2018-10-21 16:59</span><br/>
Regarding what’s been done: OpenAPI and AsyncAPI are two projects that provide a language to specify the interface between actors (REST and Pub/Sub APIs respectively). And researchers of Session Types are investigating how to statically type communications between actors.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540178534.000100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-08/681438296241_88eacb7e65edebc579ab_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540178534.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Aidan Cunniffe</b>
<span style="margin:2em; color:#606060">2018-10-21 20:22</span><br/>
<span style="background-color:#ccf">@Nick Smith</span> Re: session types do you know if they are doing this in a polyglot way? Something like protobuff maybe... 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540256832.000100"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540256832.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2018-10-22 18:07</span><br/>
Session types are an abstract theory
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540258111.000100"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540258111.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2018-10-22 18:28</span><br/>
My feedback: there’s two thrusts in the proposal. One is declaring an API interface in a tool-enforceable way, the second is defining a distributed computation model. Declaring API interfaces in a machine-readable and tool-enforceable way is :100:. Such APIs schemas could yield big benefits for the web ecosystem (I started work on a version of this based around ADTs, but it’s tabled because I simply don’t write APIs these days). But note you don’t need to tie this interface schema to a particular language. As for the language itself, I’m a little confused. “Sort of” pure functions? Only per-client state? I’m not sure what the goal is: is it supposed to simplify full-stack dev? Or is it supposed to be a way of representing app pieces as microservices? Can you clarify what the aim is here?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540261942.000100"></a>
      <img src="https://secure.gravatar.com/avatar/53e20180f0c292fcb589f77f738ed402.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540261942.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jesse Aldridge</b>
<span style="margin:2em; color:#606060">2018-10-22 19:32</span><br/>
Not sure I grasped everything you wrote, but here are some random thoughts after a quick read-through:<br/><br/>- You should call it Service-Oriented-Language or SOL, because that’s what anyone who tries to use this language will be (just kidding)<br/>- Reading that made me think of WSDL and WSGI (neither of which I am at all familiar with)<br/>- I think a system which accepts http requests and can serve as an intermediary between any two web services on the internet could be very exciting. I can see some sort of service description language being a critical part of such a system.<br/>- Working with Go recently has led me to think strong typing is annoying and unnecessary.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540318843.000100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540318843.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-10-23 11:20</span><br/>
Thought provoking write-up. I think 'there is something there' to be explored further. The problems identified are very real.<br/>Some existing solutions let you specify 'glue like' service APIs (e.g. protobuf, thrift, etc.) and generate client or server stubs in your language that give you language internal support for APIs. It might be useful to contrast those with this idea.<br/><br/>One different is this<br/>&gt; Each glue program would publish this graph on some predetermined port ie :5555.<br/>I really like this - pushing stuff into the runtime, live system right next to the service. IOW, the objects/services/apis should publish their properties (rather than storing them offline in some source control system).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540318962.000100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540318962.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-10-23 11:22</span><br/>
Also. the paradox IIUC, is a key observation - programming within a program/language/environment is much more fluent and cohesive than when programming to connect different programs together. Why?<br/><br/>Are there other ways to solve/avoid this? E.g. how much of the types/schema models should be provided by the programming languages vs the system itself?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1540328769.000100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-08/681438296241_88eacb7e65edebc579ab_72.jpg" style="float:left"/>
      <a href="../share-your-work/1540147440.000100.html#1540328769.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Aidan Cunniffe</b>
<span style="margin:2em; color:#606060">2018-10-23 14:06</span><br/>
Sorry for the delay all. Was heads down on a release yesterday.<br/><br/><span style="background-color:#ccf">@Brian Hempel</span>  -- I agree there are some big benefits &amp; ideally you wouldn't tie the representation to a specific language. OpenAPI is pretty great so I'd imagine targeting that or a similar spec. It does get more difficult to do this across language but I think Optic can help w/ that.<br/><br/>Re: State management. This is just an unrelated idea I tried to jam in there. I've always thought that global state  creates a huge surface area for bugs to flow across. A per-client actor model puts all the important state info for each consumer in the same place.<br/><br/><span style="background-color:#ccf">@Jesse Aldridge</span> lol on the name. Agree re strong typing. I really like strong types w/inference. Best of both worlds. Scala, Rust &amp; Swift shine here.<br/><br/><span style="background-color:#ccf">@Shalabh</span> thanks man! I will write something up to contrast the two approaches for sure -- will be helpful research. I totally agree that runtimes are underused. Anything live should also explain itself to other things that are live. I imagine compilers reading in these descriptions constantly and running validations on the connecting code.<br/><br/>Re: paradox -- One idea I've had is to add a method to the base class for Object in every lang called toDescription(). It could serialize the object into a higher level concept conforming to a shared schema for an API endpoint or anything else you might want. The compiler collects every instance of these descriptions, throws them in a graph and publishes them so other services can consume them. Maybe this is just a library someone makes and not a lang, but it should exist.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
