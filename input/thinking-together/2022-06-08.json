[
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1654673529.758939",
        "client_msg_id": "b2ee55fe-b1f3-43e2-8a32-a4c52e671c7b",
        "text": "Interesting.  In my mind, a feature is most aspect appropriate when you can turn it on or off without conceptually affecting the semantics of the code being advised.  Otherwise you're implementing the concern rather than some tangentially related cross-cutting concern.  So validation, error recovery, logging, especially logging are my idea of typical aspects.  I mean sometimes the aspect is essential like it's nice to use an aspect to acquire locks in some standard way or, complex memoization, or hey right now I'm writing something to sandbox changes you make to model objects so that you can roll everything back in case something goes wrong late in the process.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1653835046.268739",
        "parent_user_id": "U03J1HP9C0G",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tE1js",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Interesting.  In my mind, a feature is most aspect appropriate when you can turn it on or off without conceptually affecting the semantics of the code being advised.  Otherwise you're implementing the concern rather than some tangentially related cross-cutting concern.  So validation, error recovery, logging, especially logging are my idea of typical aspects.  I mean sometimes the aspect is essential like it's nice to use an aspect to acquire locks in some standard way or, complex memoization, or hey right now I'm writing something to sandbox changes you make to model objects so that you can roll everything back in case something goes wrong late in the process."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1654693672.625439",
        "client_msg_id": "41c2bca9-4a91-4ea9-a566-7c14d5041543",
        "text": "Yeah you're right. I think we're saying the same thing. I consider all those to be changing the source code. Features. But imagine aspects that never change a line of code in the program.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1653835046.268739",
        "parent_user_id": "U03J1HP9C0G",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YMbZj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah you're right. I think we're saying the same thing. I consider all those to be changing the source code. Features. But imagine aspects that never change a line of code in the program."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1654711669.779349",
        "client_msg_id": "6d1b937f-2b87-425f-8d2f-13fe316a3036",
        "text": "Is this a known result in PL theory? \"The set of stable minimum models returned in response to a query in a goal-directed stable model constraint answer set programming language entail, taken together, a stable model constraint answer set program for answering only that query.\"",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1654711669.779349",
        "reply_count": 11,
        "reply_users_count": 5,
        "latest_reply": "1655143617.737309",
        "reply_users": [
            "U02U0AS3J49",
            "U03J1HP9C0G",
            "U03DNFDFYDA",
            "UA14TGLTC",
            "UDQBTJ211"
        ],
        "replies": [
            {
                "user": "U02U0AS3J49",
                "ts": "1654712123.224909"
            },
            {
                "user": "U03J1HP9C0G",
                "ts": "1654717390.843519"
            },
            {
                "user": "U02U0AS3J49",
                "ts": "1654718056.964149"
            },
            {
                "user": "U02U0AS3J49",
                "ts": "1654718223.709239"
            },
            {
                "user": "U03DNFDFYDA",
                "ts": "1654790807.626299"
            },
            {
                "user": "U03DNFDFYDA",
                "ts": "1654790846.396449"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1654831932.698139"
            },
            {
                "user": "U02U0AS3J49",
                "ts": "1654833095.129749"
            },
            {
                "user": "UDQBTJ211",
                "ts": "1654850145.675449"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1654854872.646929"
            },
            {
                "user": "U02U0AS3J49",
                "ts": "1655143617.737309"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pp5\/D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is this a known result in PL theory? \"The set of stable minimum models returned in response to a query in a goal-directed stable model constraint answer set programming language entail, taken together, a stable model constraint answer set program for answering only that query.\""
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1654712123.224909",
        "client_msg_id": "52be46ae-6fd7-46ba-9e4d-dc2ec2dc79b4",
        "text": "I may be phrasing it wrong. Not a theorist. But this just occurred to me, and it seems intuitive. If true, it means I could let my users compile their encodings into lightning-fast code without sacrificing any reasoning capabilities for expert system applications. Which would be huge.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GFs9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I may be phrasing it wrong. Not a theorist. But this just occurred to me, and it seems intuitive. If true, it means I could let my users compile their encodings into lightning-fast code without sacrificing any reasoning capabilities for expert system applications. Which would be huge."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U03J1HP9C0G",
        "type": "message",
        "ts": "1654717390.843519",
        "client_msg_id": "ea34fba4-7e2d-4f16-907c-0088400b9296",
        "text": "For not being a theorist the question seems to be built successfully convoluted enough. Can you pose the proposition more clearly?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "fd3b904fdc45",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-05-27\/3589814658547_fd3b904fdc456648ecb2_72.jpg",
            "first_name": "Václav",
            "real_name": "Václav Blažej",
            "display_name": "Václav Blažej",
            "team": "T5TCAFTA9",
            "name": "vaclavblazej",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cGCWY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For not being a theorist the question seems to be built successfully convoluted enough. Can you pose the proposition more clearly?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1654718056.964149",
        "client_msg_id": "2da75c64-3bba-4a62-a173-03d75579d643",
        "text": "Sure. If you ask your software \"what are all the fact patterns (inputs) that could support this output\", and it tells you, can you use that list of possible valid fact patterns to do pattern matching between other inputs and the valid fact patterns, getting the same result as if you had asked the original program whether the inputs were valid.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KVVY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sure. If you ask your software \"what are all the fact patterns (inputs) that could support this output\", and it tells you, can you use that list of possible valid fact patterns to do pattern matching between other inputs and the valid fact patterns, getting the same result as if you had asked the original program whether the inputs were valid."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1654718223.709239",
        "client_msg_id": "99aef540-19d1-416a-8cce-02271db461bf",
        "text": "Most systems cannot answer that first question, but the one I'm using can, and I'm wondering if that is effectively a means to compile a logic program and a query into more efficient code for answering only that specific query.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mjx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Most systems cannot answer that first question, but the one I'm using can, and I'm wondering if that is effectively a means to compile a logic program and a query into more efficient code for answering only that specific query."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U013ZLJARC7",
        "type": "message",
        "ts": "1654755891.210059",
        "edited": {
            "user": "U013ZLJARC7",
            "ts": "1654789010.000000"
        },
        "client_msg_id": "cd68ab50-9a37-453f-b1e1-6b211a33b65e",
        "text": "PLT circles are still mostly focused on the syntax + semantics approach that started in the 1960s, so anybody who wants to use non-syntactical notation is pretty much on their own. That said, the Racket people ship an IDE for the base language that's extensible enough to support projects like this:\n<https:\/\/dl.acm.org\/doi\/10.1145\/3428290>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8ea58fc41bd6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-10-13\/6057269405632_8ea58fc41bd6baa7dda6_72.png",
            "first_name": "",
            "real_name": "Jack Rusher",
            "display_name": "Jack Rusher",
            "team": "T5TCAFTA9",
            "name": "jack529",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1654606915.995129",
        "parent_user_id": "U03J1HP9C0G",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=07Ab",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "PLT circles are still mostly focused on the syntax + semantics approach that started in the 1960s, so anybody who wants to use non-syntactical notation is pretty much on their own. That said, the Racket people ship an IDE for the base language that's extensible enough to support projects like this:\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/dl.acm.org\/doi\/10.1145\/3428290"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UML4ZEKDK",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    }
]