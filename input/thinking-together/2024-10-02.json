[
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1727857436.296279",
        "client_msg_id": "0c24f806-5ec3-44a9-85e1-ec5e7bf667df",
        "text": "you're getting some \"already done under different names\", so I'll add mine! my PL is really just a graph rewriter.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lh334",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "you're getting some \"already done under different names\", so I'll add mine! my PL is really just a graph rewriter."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1727879746.740669",
        "client_msg_id": "bd49037a-90b9-4e61-9bfa-bc767a3bf983",
        "text": "<@UFPRPSA4S>'s <https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1727247298811129?thread_ts=1727247298.811129&amp;cid=C5U3SEW6A|recent idea> seems tantalizingly related, but breaks my brain to think about..",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "attachments": [
            {
                "from_url": "https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1727247298811129?thread_ts=1727247298.811129&amp;cid=C5U3SEW6A",
                "ts": "1727247298.811129",
                "author_id": "UFPRPSA4S",
                "channel_id": "C5U3SEW6A",
                "channel_team": "T5TCAFTA9",
                "is_msg_unfurl": true,
                "is_thread_root_unfurl": true,
                "message_blocks": [
                    {
                        "team": "T5TCAFTA9",
                        "channel": "C5U3SEW6A",
                        "ts": "1727247298.811129",
                        "message": {
                            "blocks": [
                                {
                                    "type": "rich_text",
                                    "block_id": "sO9yD",
                                    "elements": [
                                        {
                                            "type": "rich_text_section",
                                            "elements": [
                                                {
                                                    "type": "text",
                                                    "text": "Hey future of coding folks,\n\nI want to advertise the idea of non-abelian spreadsheets. The idea has slowly drifted into the center of my thinking this last year. I'm not sure if its a good idea or not. It kinda depends on how you build on it. So for now I just want to convey the general idea.\n\nPicture in your mind a normal spreadsheet. In some sense it is 'abelian' (commutative) because from any cell going down and then right is the same as going right and then going down. If we make it non-abelian, so the order we go right and down matters, we get something like the picture attached below.\n\nIf you tilt your head slightly you may recognize it as the infinite binary tree. So an infinite binary tree is just the non-abelian version of the usual grid-based spreadsheet. The nodes of the tree are the cells. We can also think of finite binary trees as the analogue of tables.\n\nA key feature of regular spreadsheets is the ability to write formulas with relative references. For instance in a regular spreadsheet you can use relative references so a formula always refers to the cell to the right of the given one, and in a tree you can write a formula that always refers to the cell you get by going down and to the right from the given cell.\n\nAnother key feature of spreadsheets is that you put stuff in cells! And we do that with trees all the time. For example if we write down the syntax tree for (a+b)*c what we are doing is putting each of the symbols into a cell of the tree.\n\nWe can push this analogy to account for all trees (in particular all syntax trees). This tree can't really be visualized because it branches infinitely at each node. It is much easier to describe algebraically. I'll use the term 'free monoid on a set X', which if you aren't in the know just means the set of strings made out of the elements of X regarded as distinct characters. The infinite binary tree, or more precisely the set of nodes of the infinite binary tree, can be described as the free monoid on a two element set {L, R}. e.g. RLL describes the node you get by going right, then left, and then left again. Now let X_n denote a set with n elements and X the disjoint union of the X_n for all n. It suffices to take the free monoid on X.\n\nA reasonable question at this point is what is the interface for an infinitely branching tree? You would think it is even worse than an infinite dimensional grid, which is the abelian version. But if we are restricting ourselves to trees coming from symbolic expressions then for the most part we already have the interface. It is just the symbolic expressions we would have written down in the first place.\n\nI'll leave it at that."
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ],
                "files": [
                    {
                        "id": "F07NH9CRN31",
                        "created": 1727247255,
                        "timestamp": 1727247255,
                        "user": "UFPRPSA4S",
                        "is_hidden_by_limit": 1
                    }
                ],
                "id": 1,
                "original_url": "https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1727247298811129?thread_ts=1727247298.811129&amp;cid=C5U3SEW6A",
                "fallback": "[September 24th, 2024 11:54 PM] robinps2: Hey future of coding folks,\n\nI want to advertise the idea of non-abelian spreadsheets. The idea has slowly drifted into the center of my thinking this last year. I'm not sure if its a good idea or not. It kinda depends on how you build on it. So for now I just want to convey the general idea.\n\nPicture in your mind a normal spreadsheet. In some sense it is 'abelian' (commutative) because from any cell going down and then right is the same as going right and then going down. If we make it non-abelian, so the order we go right and down matters, we get something like the picture attached below.\n\nIf you tilt your head slightly you may recognize it as the infinite binary tree. So an infinite binary tree is just the non-abelian version of the usual grid-based spreadsheet. The nodes of the tree are the cells. We can also think of finite binary trees as the analogue of tables.\n\nA key feature of regular spreadsheets is the ability to write formulas with relative references. For instance in a regular spreadsheet you can use relative references so a formula always refers to the cell to the right of the given one, and in a tree you can write a formula that always refers to the cell you get by going down and to the right from the given cell.\n\nAnother key feature of spreadsheets is that you put stuff in cells! And we do that with trees all the time. For example if we write down the syntax tree for (a+b)*c what we are doing is putting each of the symbols into a cell of the tree.\n\nWe can push this analogy to account for all trees (in particular all syntax trees). This tree can't really be visualized because it branches infinitely at each node. It is much easier to describe algebraically. I'll use the term 'free monoid on a set X', which if you aren't in the know just means the set of strings made out of the elements of X regarded as distinct characters. The infinite binary tree, or more precisely the set of nodes of the infinite binary tree, can be described as the free monoid on a two element set {L, R}. e.g. RLL describes the node you get by going right, then left, and then left again. Now let X_n denote a set with n elements and X the disjoint union of the X_n for all n. It suffices to take the free monoid on X.\n\nA reasonable question at this point is what is the interface for an infinitely branching tree? You would think it is even worse than an infinite dimensional grid, which is the abelian version. But if we are restricting ourselves to trees coming from symbolic expressions then for the most part we already have the interface. It is just the symbolic expressions we would have written down in the first place.\n\nI'll leave it at that.",
                "text": "Hey future of coding folks,\n\nI want to advertise the idea of non-abelian spreadsheets. The idea has slowly drifted into the center of my thinking this last year. I'm not sure if its a good idea or not. It kinda depends on how you build on it. So for now I just want to convey the general idea.\n\nPicture in your mind a normal spreadsheet. In some sense it is 'abelian' (commutative) because from any cell going down and then right is the same as going right and then going down. If we make it non-abelian, so the order we go right and down matters, we get something like the picture attached below.\n\nIf you tilt your head slightly you may recognize it as the infinite binary tree. So an infinite binary tree is just the non-abelian version of the usual grid-based spreadsheet. The nodes of the tree are the cells. We can also think of finite binary trees as the analogue of tables.\n\nA key feature of regular spreadsheets is the ability to write formulas with relative references. For instance in a regular spreadsheet you can use relative references so a formula always refers to the cell to the right of the given one, and in a tree you can write a formula that always refers to the cell you get by going down and to the right from the given cell.\n\nAnother key feature of spreadsheets is that you put stuff in cells! And we do that with trees all the time. For example if we write down the syntax tree for (a+b)*c what we are doing is putting each of the symbols into a cell of the tree.\n\nWe can push this analogy to account for all trees (in particular all syntax trees). This tree can't really be visualized because it branches infinitely at each node. It is much easier to describe algebraically. I'll use the term 'free monoid on a set X', which if you aren't in the know just means the set of strings made out of the elements of X regarded as distinct characters. The infinite binary tree, or more precisely the set of nodes of the infinite binary tree, can be described as the free monoid on a two element set {L, R}. e.g. RLL describes the node you get by going right, then left, and then left again. Now let X_n denote a set with n elements and X the disjoint union of the X_n for all n. It suffices to take the free monoid on X.\n\nA reasonable question at this point is what is the interface for an infinitely branching tree? You would think it is even worse than an infinite dimensional grid, which is the abelian version. But if we are restricting ourselves to trees coming from symbolic expressions then for the most part we already have the interface. It is just the symbolic expressions we would have written down in the first place.\n\nI'll leave it at that.",
                "author_name": "Robin Allison",
                "author_link": "https:\/\/futureofcoding.slack.com\/team\/UFPRPSA4S",
                "author_icon": "https:\/\/secure.gravatar.com\/avatar\/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-48.png",
                "author_subname": "Robin Allison",
                "mrkdwn_in": [
                    "text"
                ],
                "footer": "Thread in Slack Conversation"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jEyro",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFPRPSA4S"
                            },
                            {
                                "type": "text",
                                "text": "'s "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1727247298811129?thread_ts=1727247298.811129&cid=C5U3SEW6A",
                                "text": "recent idea"
                            },
                            {
                                "type": "text",
                                "text": " seems tantalizingly related, but breaks my brain to think about.."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDCLA1HU4",
        "type": "message",
        "ts": "1727906391.078199",
        "edited": {
            "user": "UDCLA1HU4",
            "ts": "1727906403.000000"
        },
        "client_msg_id": "de611ea5-6ead-4aa2-a4ba-3bd5ca330e41",
        "text": "Term rewriting is a nice reference I did not think of! I guess one difference between those and what I've been thinking about is that I imagined that you'd have a special \"current\" location in the tree (like instruction pointer...).\n\nYou can certainly do this with term rewriting systems too though, if you just have a special term like `[X]`  that marks the term\/tree node `X`  as being the current one.\n\nI guess term rewriting systems are basically how people define operational semantics of programming languages. It's strange people do not talk more about the connection between the two!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "bcf86f2e207e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-09-25\/7807695316512_bcf86f2e207ef54d3bda_72.jpg",
            "first_name": "",
            "real_name": "Tomas Petricek",
            "display_name": "tomasp",
            "team": "T5TCAFTA9",
            "name": "tomas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GHzMb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Term rewriting is a nice reference I did not think of! I guess one difference between those and what I've been thinking about is that I imagined that you'd have a special \"current\" location in the tree (like instruction pointer...).\n\nYou can certainly do this with term rewriting systems too though, if you just have a special term like "
                            },
                            {
                                "type": "text",
                                "text": "[X]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  that marks the term\/tree node "
                            },
                            {
                                "type": "text",
                                "text": "X",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  as being the current one.\n\nI guess term rewriting systems are basically how people define operational semantics of programming languages. It's strange people do not talk more about the connection between the two!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UDCLA1HU4",
        "type": "message",
        "ts": "1727906657.735399",
        "client_msg_id": "a2560fe1-2f73-4886-8c25-7d3e5cc17487",
        "text": "<@UFPRPSA4S>'s idea reminded me of something I wrote about in a post inspired by spaces in cities (see <https:\/\/tomasp.net\/blog\/2023\/vague-spaces\/>) There are some thoughts about how programs live in a different kind of space than cities (which have fixed space they have to fit into, whereas program spaces can expand - but spreadsheet space expands in only limited ways - you cannot create arbitrary amount of space in any particular location - which I guess this idea was getting at?).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "bcf86f2e207e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-09-25\/7807695316512_bcf86f2e207ef54d3bda_72.jpg",
            "first_name": "",
            "real_name": "Tomas Petricek",
            "display_name": "tomasp",
            "team": "T5TCAFTA9",
            "name": "tomas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8+cos",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFPRPSA4S"
                            },
                            {
                                "type": "text",
                                "text": "'s idea reminded me of something I wrote about in a post inspired by spaces in cities (see "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/tomasp.net\/blog\/2023\/vague-spaces\/"
                            },
                            {
                                "type": "text",
                                "text": ") There are some thoughts about how programs live in a different kind of space than cities (which have fixed space they have to fit into, whereas program spaces can expand - but spreadsheet space expands in only limited ways - you cannot create arbitrary amount of space in any particular location - which I guess this idea was getting at?)."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UDCLA1HU4",
        "type": "message",
        "ts": "1727907073.490539",
        "client_msg_id": "8fdedadf-de7b-4aa2-802e-719695e3c23b",
        "text": "... but using some kind of term rewriting system as the basis for document-like programming systems seems like a nice way of doing things - and it looks like there's lots of (some, at least) people here thinking in this direction!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "bcf86f2e207e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-09-25\/7807695316512_bcf86f2e207ef54d3bda_72.jpg",
            "first_name": "",
            "real_name": "Tomas Petricek",
            "display_name": "tomasp",
            "team": "T5TCAFTA9",
            "name": "tomas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ULavb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... but using some kind of term rewriting system as the basis for document-like programming systems seems like a nice way of doing things - and it looks like there's lots of (some, at least) people here thinking in this direction!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U017SHBAFE3",
        "type": "message",
        "ts": "1727916773.338669",
        "client_msg_id": "84643bba-671e-46ad-8a10-700bbd383f52",
        "text": "Would anyone be interested in a browser based smalltalk environment that tries to simplify the task of building software?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "c029e3e6e0b8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-03-01\/4874202208501_c029e3e6e0b8e1372a93_72.png",
            "first_name": "Rafi",
            "real_name": "Rafi Khan",
            "display_name": "Rafi Khan",
            "team": "T5TCAFTA9",
            "name": "rafi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727916773.338669",
        "reply_count": 7,
        "reply_users_count": 4,
        "latest_reply": "1728804637.484929",
        "reply_users": [
            "U017SHBAFE3",
            "UJBAJNFLK",
            "URKQXRCAC",
            "U0217A6C4KW"
        ],
        "replies": [
            {
                "user": "U017SHBAFE3",
                "ts": "1727916835.330819"
            },
            {
                "user": "U017SHBAFE3",
                "ts": "1727916913.521029"
            },
            {
                "user": "U017SHBAFE3",
                "ts": "1727917004.621209"
            },
            {
                "user": "U017SHBAFE3",
                "ts": "1727917064.723659"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1727936379.258539"
            },
            {
                "user": "URKQXRCAC",
                "ts": "1727961015.855419"
            },
            {
                "user": "U0217A6C4KW",
                "ts": "1728804637.484929"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VqOWK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Would anyone be interested in a browser based smalltalk environment that tries to simplify the task of building software?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U017SHBAFE3",
        "type": "message",
        "ts": "1727916835.330819",
        "client_msg_id": "8d7c00f0-da9e-4261-9e3f-fbf63b869d1e",
        "text": "The idea of the product is to have an all in one software development tool that let's you write code, run tests, deploy etc. \n\nIt will also be backed by a github like social coding repo system so you can easily import code that others have written",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "c029e3e6e0b8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-03-01\/4874202208501_c029e3e6e0b8e1372a93_72.png",
            "first_name": "Rafi",
            "real_name": "Rafi Khan",
            "display_name": "Rafi Khan",
            "team": "T5TCAFTA9",
            "name": "rafi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727916773.338669",
        "parent_user_id": "U017SHBAFE3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "go3ke",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The idea of the product is to have an all in one software development tool that let's you write code, run tests, deploy etc. \n\nIt will also be backed by a github like social coding repo system so you can easily import code that others have written"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U017SHBAFE3",
        "type": "message",
        "ts": "1727916913.521029",
        "client_msg_id": "b9af0440-fa77-45ac-a95f-57be4e29404b",
        "text": "The main reason I think this would be neat is to get more people into programming or solving problems with computers. \n\nThey can mostly fork\/remix existing code and only a portion of the users are likely to be professional developers who may be maintaining some of the libraries",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "c029e3e6e0b8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-03-01\/4874202208501_c029e3e6e0b8e1372a93_72.png",
            "first_name": "Rafi",
            "real_name": "Rafi Khan",
            "display_name": "Rafi Khan",
            "team": "T5TCAFTA9",
            "name": "rafi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727916773.338669",
        "parent_user_id": "U017SHBAFE3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ce97v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The main reason I think this would be neat is to get more people into programming or solving problems with computers. \n\nThey can mostly fork\/remix existing code and only a portion of the users are likely to be professional developers who may be maintaining some of the libraries"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U017SHBAFE3",
        "type": "message",
        "ts": "1727917004.621209",
        "client_msg_id": "9ead808c-06b5-42d5-bbe2-6a389bc3eb98",
        "text": "I'm not sure it solves any real problems. Yes it aims to make software easier and cheaper to write, but maybe businesses aren't too worried about optimising software development? \n\nIt would be a new language and completely foreign tool, and i think this has already held back lisp and smalltalk before",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "c029e3e6e0b8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-03-01\/4874202208501_c029e3e6e0b8e1372a93_72.png",
            "first_name": "Rafi",
            "real_name": "Rafi Khan",
            "display_name": "Rafi Khan",
            "team": "T5TCAFTA9",
            "name": "rafi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727916773.338669",
        "parent_user_id": "U017SHBAFE3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "c6Dkj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not sure it solves any real problems. Yes it aims to make software easier and cheaper to write, but maybe businesses aren't too worried about optimising software development? \n\nIt would be a new language and completely foreign tool, and i think this has already held back lisp and smalltalk before"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U017SHBAFE3",
        "type": "message",
        "ts": "1727917064.723659",
        "client_msg_id": "28a774f0-4f65-4858-94fc-d2f21c901b36",
        "text": "I was thinking if the entire system was essentially source available, and you can hook in a small llm agent that can generate and run code, we might get a slightly more general ai assistant",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "c029e3e6e0b8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-03-01\/4874202208501_c029e3e6e0b8e1372a93_72.png",
            "first_name": "Rafi",
            "real_name": "Rafi Khan",
            "display_name": "Rafi Khan",
            "team": "T5TCAFTA9",
            "name": "rafi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727916773.338669",
        "parent_user_id": "U017SHBAFE3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Tb8cs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was thinking if the entire system was essentially source available, and you can hook in a small llm agent that can generate and run code, we might get a slightly more general ai assistant"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1727936087.586529",
        "client_msg_id": "45159eb5-501b-42af-8321-330d64825b03",
        "text": "Maybe term rewriting systems _should_ have something like a \"current node\". Rule application order is something usually swept under the rug. It's there, but everybody hopes it doesn't matter, and it's usually implicit (part of the rewriting engine) rather than explicit (part of the rule set).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dDFbc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe term rewriting systems "
                            },
                            {
                                "type": "text",
                                "text": "should",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " have something like a \"current node\". Rule application order is something usually swept under the rug. It's there, but everybody hopes it doesn't matter, and it's usually implicit (part of the rewriting engine) rather than explicit (part of the rule set)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1727936379.258539",
        "client_msg_id": "5f041ea2-bd22-47d4-b298-ae67cbf933bd",
        "text": "You mean something like <https:\/\/amber-lang.net\/|Amber Smalltalk>, which is an actual Smalltalk environment running in the browser? Or something like <https:\/\/lively-kernel.org\/|Lively Kernel>, the same overall idea but in JavaScript?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727916773.338669",
        "parent_user_id": "U017SHBAFE3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eAlvd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You mean something like "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/amber-lang.net\/",
                                "text": "Amber Smalltalk"
                            },
                            {
                                "type": "text",
                                "text": ", which is an actual Smalltalk environment running in the browser? Or something like "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/lively-kernel.org\/",
                                "text": "Lively Kernel"
                            },
                            {
                                "type": "text",
                                "text": ", the same overall idea but in JavaScript?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFPRPSA4S",
        "type": "message",
        "ts": "1727936520.898839",
        "client_msg_id": "6eb9b506-6dbb-49f0-95d6-72874b039f98",
        "text": "<@UCUSW7WVD> I think there might be a connection here too. I don’t know if I can speak to document-based languages in general, but at least for subtext, there is the loose connection in that both are based on spreadsheets. Beyond that non-abelian spreadsheets serve as mathematical models, although they aren’t models of computation specifically. They actually take computation mostly for granted, although I think that can be an interesting perspective too. When I was first reading Tomas’ question it occurred to me that non-abelian spreadsheets could be thought of as a model of the ‘document’ part of ‘document-based programs’.\n\n<@UDCLA1HU4> Part of the point is absolutely that the space these things is is fixed, has particular characteristics, and is not created arbitrarily. I’m not sure if this makes them less like regular programs though. Generally the space of a non-abelian spreadsheet is far more expansive than the two dimensional space of a spreadsheet or paper or city. For one the “two dimensional” non-abelian spreadsheet has uncountably many cells, whereas a normal spreadsheet has countably many cells. And this only gets worse in the countably infinite dimensional case you need to account for syntax trees.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5f4ac5375e5",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png",
            "first_name": "",
            "real_name": "Robin Allison",
            "display_name": "Robin",
            "team": "T5TCAFTA9",
            "name": "robinps2",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kfKJk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I think there might be a connection here too. I don’t know if I can speak to document-based languages in general, but at least for subtext, there is the loose connection in that both are based on spreadsheets. Beyond that non-abelian spreadsheets serve as mathematical models, although they aren’t models of computation specifically. They actually take computation mostly for granted, although I think that can be an interesting perspective too. When I was first reading Tomas’ question it occurred to me that non-abelian spreadsheets could be thought of as a model of the ‘document’ part of ‘document-based programs’.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UDCLA1HU4"
                            },
                            {
                                "type": "text",
                                "text": " Part of the point is absolutely that the space these things is is fixed, has particular characteristics, and is not created arbitrarily. I’m not sure if this makes them less like regular programs though. Generally the space of a non-abelian spreadsheet is far more expansive than the two dimensional space of a spreadsheet or paper or city. For one the “two dimensional” non-abelian spreadsheet has uncountably many cells, whereas a normal spreadsheet has countably many cells. And this only gets worse in the countably infinite dimensional case you need to account for syntax trees."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]