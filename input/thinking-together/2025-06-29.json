[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1751201331.648289",
        "client_msg_id": "b43a5716-700e-49a7-8a43-de7ff7fdf5d2",
        "text": "&gt; ... that the magic lives in the gestalt ...\nI continue to hope that we could further dissect the magic. Yes, there is something more than feature-set here, and I under-spoke when I used the phrase \"tree-oriented\". At present, I am thinking that it might be goals: (a) do you want to build an MVI (Minimum Viable Implementation, regardless of \"efficiency\" (not the same as MVP))? (b) do you want to use power tools to just get something done? (c) do you want to optimize a system for production release? I don't see all of these goals being satisfied by just one language, nor one class of languages (e.g. dataflow IPC vs. function-based IPC). For example, the fact that we can build AST data structures in many languages does not have the same effect as lispers getting ASTs under their fingernails. After 50+ years, can we graft some of the lisp-y magic onto our current workflows?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JVeFt",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... that the magic lives in the gestalt ..."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI continue to hope that we could further dissect the magic. Yes, there is something more than feature-set here, and I under-spoke when I used the phrase \"tree-oriented\". At present, I am thinking that it might be goals: (a) do you want to build an MVI (Minimum Viable Implementation, regardless of \"efficiency\" (not the same as MVP))? (b) do you want to use power tools to just get something done? (c) do you want to optimize a system for production release? I don't see all of these goals being satisfied by just one language, nor one class of languages (e.g. dataflow IPC vs. function-based IPC). For example, the fact that we can build AST data structures in many languages does not have the same effect as lispers getting ASTs under their fingernails. After 50+ years, can we graft some of the lisp-y magic onto our current workflows?"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]