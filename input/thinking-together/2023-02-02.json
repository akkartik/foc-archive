[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1675339056.587149",
        "client_msg_id": "13f40712-5e94-443a-ae14-9c02a7d4e9e1",
        "text": "I agree and disagree.  A +tool+ should make anti-patterns painful - yes.  A +tool+ should not make hard things possible.  My ideal +environment+ is one which allows me to choose the most appropriate paradigm\/tool for the sub-problem that I want to think about.  That ideal environment should make it easy to compose solutions to uber-problems by plumbing sub-solutions together, regardless of the paradigm used.  To make hard things possible, I should be able to use Assembler (line-oriented or tree-oriented (Assembler, C, etc. vs ASTs, CSTs, Lisp)) and bolt these bits into the overall solution.  The last time I touched such an environment, was the UNIX command-line (#!\/bin\/bash, #!\/usr\/bin\/env node, #!\/usr\/bin\/env python, etc., etc.).  The problems with the UNIX Shell are (1) it over-specifies (!) the format of IPCs by insisting that the special byte 0x0a terminate every blob of IPC bytes, and, (2) the Shell’s insistence on using 1D notation (sequential characters, leading to the unrealistic restriction that commands have exactly one input and exactly two outputs (the UNIX kernel allows more of each, but the shell does not encourage this)).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675283935.164309",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SUHA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree and disagree.  A +tool+ should make anti-patterns painful - yes.  A +tool+ should not make hard things possible.  My ideal +environment+ is one which allows me to choose the most appropriate paradigm\/tool for the sub-problem that I want to think about.  That ideal environment should make it easy to compose solutions to uber-problems by plumbing sub-solutions together, regardless of the paradigm used.  To make hard things possible, I should be able to use Assembler (line-oriented or tree-oriented (Assembler, C, etc. vs ASTs, CSTs, Lisp)) and bolt these bits into the overall solution.  The last time I touched such an environment, was the UNIX command-line (#!\/bin\/bash, #!\/usr\/bin\/env node, #!\/usr\/bin\/env python, etc., etc.).  The problems with the UNIX Shell are (1) it over-specifies (!) the format of IPCs by insisting that the special byte 0x0a terminate every blob of IPC bytes, and, (2) the Shell’s insistence on using 1D notation (sequential characters, leading to the unrealistic restriction that commands have exactly one input and exactly two outputs (the UNIX kernel allows more of each, but the shell does not encourage this))."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1675360122.613349",
        "client_msg_id": "845449d9-f7b9-4330-9b34-c61aa615262b",
        "text": "Yes and yes! :slightly_smiling_face:\n\nYes, we need to have a variety of “paradigms”, which I would call _architectural styles_ at our disposal.\n\n<https:\/\/blog.metaobject.com\/2019\/02\/why-architecture-oriented-programming.html>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675283935.164309",
        "parent_user_id": "ULM3U6275",
        "attachments": [
            {
                "from_url": "https:\/\/blog.metaobject.com\/2019\/02\/why-architecture-oriented-programming.html",
                "service_icon": "https:\/\/blog.metaobject.com\/favicon.ico",
                "id": 1,
                "original_url": "https:\/\/blog.metaobject.com\/2019\/02\/why-architecture-oriented-programming.html",
                "fallback": "Why Architecture Oriented Programming Matters",
                "text": "On re-reading John Hughes influential Why Functional Programming Matters , two things stood out for me. The first was the claim that, \"......",
                "title": "Why Architecture Oriented Programming Matters",
                "title_link": "https:\/\/blog.metaobject.com\/2019\/02\/why-architecture-oriented-programming.html",
                "service_name": "blog.metaobject.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5CU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes and yes! "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": "\n\nYes, we need to have a variety of “paradigms”, which I would call "
                            },
                            {
                                "type": "text",
                                "text": "architectural styles",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " at our disposal.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/blog.metaobject.com\/2019\/02\/why-architecture-oriented-programming.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1675360530.487659",
        "client_msg_id": "bd293281-d6a8-4c18-bb2e-1ece2456dc25",
        "text": "And also yes, although Unix pipes\/filters is architecturally\/structurally great, and often a better fit than call\/return (procedures, functions, methods), it suffers from <https:\/\/dl.acm.org\/doi\/10.1109\/32.908958|packaging mismatch>.\n\nThat’s why for <http:\/\/objective.st|Objective-S>, I chose <https:\/\/dl.acm.org\/doi\/10.1145\/3359619.3359748?cid=81316491227|Polymorphic Write Streams>, which generalise pipes\/filters (and can be specialised to pipes\/filters in order to interoperate).\n\nAlthough I don’t mention it, that paper already mostly shows why filters are in a sense more fundamental than procedures.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675283935.164309",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0Fk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And also yes, although Unix pipes\/filters is architecturally\/structurally great, and often a better fit than call\/return (procedures, functions, methods), it suffers from "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/dl.acm.org\/doi\/10.1109\/32.908958",
                                "text": "packaging mismatch"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nThat’s why for "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/objective.st",
                                "text": "Objective-S"
                            },
                            {
                                "type": "text",
                                "text": ", I chose "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/dl.acm.org\/doi\/10.1145\/3359619.3359748?cid=81316491227",
                                "text": "Polymorphic Write Streams"
                            },
                            {
                                "type": "text",
                                "text": ", which generalise pipes\/filters (and can be specialised to pipes\/filters in order to interoperate).\n\nAlthough I don’t mention it, that paper already mostly shows why filters are in a sense more fundamental than procedures."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    }
]