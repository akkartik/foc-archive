<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-10-28/811814014976_259a1e56ad2e11fe3d56_72.jpg" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shubhadeep Roychowdhury</b>
<span style="margin:2em; color:#606060">2020-11-09 12:07</span><br/>
interesting article from HN today - <a href="http://neilmitchell.blogspot.com/2020/11/turing-incomplete-languages.html">http://neilmitchell.blogspot.com/2020/11/turing-incomplete-languages.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1604954805.209600"></a>
      <img src="https://secure.gravatar.com/avatar/5fae55cf900c6577e6c3841a344015bd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0012-72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1604954805.209600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>John Soo</b>
<span style="margin:2em; color:#606060">2020-11-09 12:46</span><br/>
I think cedille is on to something here. <br/><br/><a href="https://arxiv.org/pdf/1903.08233.pdf">https://arxiv.org/pdf/1903.08233.pdf</a><br/><br/>I may be wrong here, but because of the basis of equality on beta-equivalence, you get some nice properties of writing programs with general recursion
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1604955084.211100"></a>
      <img src="https://secure.gravatar.com/avatar/5fae55cf900c6577e6c3841a344015bd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0012-72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1604955084.211100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>John Soo</b>
<span style="margin:2em; color:#606060">2020-11-09 12:51</span><br/>
(Also by choosing erasure to untyped lambda calculus, choosing a lambda encoding that allows for nicer recursion in the surface language is possible)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605012497.213100"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605012497.213100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-11-10 04:48</span><br/>
The author seems to consider a rather specific sub-species of Turing-incomplete languages: those that try to be as close as possible to Turing-complete except for preventing non-termination. I haven't looked at any of those. What I am much more interested in is languages that reduce computational abilities in return for better reasoning about data and code. Something in between HTML and JavaScript, for example. Has anyone seen work on such languages?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605017947.213300"></a>
      <img src="https://avatars.slack-edge.com/2019-06-03/652459184852_2b4594ccf61c401763eb_72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605017947.213300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Prathyush</b>
<span style="margin:2em; color:#606060">2020-11-10 06:19</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> Dhall leverages non-TC for safety guarantees: <a href="http://www.haskellforall.com/2020/01/why-dhall-advertises-absence-of-turing.html">http://www.haskellforall.com/2020/01/why-dhall-advertises-absence-of-turing.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605023751.214600"></a>
      <img src="https://secure.gravatar.com/avatar/5fae55cf900c6577e6c3841a344015bd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0012-72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605023751.214600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>John Soo</b>
<span style="margin:2em; color:#606060">2020-11-10 07:55</span><br/>
Dhall is a cool use case for strong normalizing since most people feel uncomfortable with powerful languages for configuration
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605024190.214800"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605024190.214800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-11-10 08:03</span><br/>
<span style="background-color:#ccf">@prax08</span> Dhall looks interesting indeed, thanks for the pointer!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605025996.217100"></a>
      <img src="https://secure.gravatar.com/avatar/5fae55cf900c6577e6c3841a344015bd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0012-72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605025996.217100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>John Soo</b>
<span style="margin:2em; color:#606060">2020-11-10 08:33</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> I worked with elm for a while. While it has general recursion, the elm architecture really limits what you can do with it. The only functions you can write that ever get executed by the runtime have pure signatures. Now I really hate elm
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605026037.218000"></a>
      <img src="https://secure.gravatar.com/avatar/5fae55cf900c6577e6c3841a344015bd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0012-72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605026037.218000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>John Soo</b>
<span style="margin:2em; color:#606060">2020-11-10 08:33</span><br/>
Maybe something closer to a prolog would be interesting though
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605030260.219800"></a>
      <img src="https://avatars.slack-edge.com/2019-06-03/652459184852_2b4594ccf61c401763eb_72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605030260.219800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Prathyush</b>
<span style="margin:2em; color:#606060">2020-11-10 09:44</span><br/>
Oh yeah, that makes me think that Datalog also has terminating guarantees because of lack of negation(?). So does SQL if one takes out recursion. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605075904.220300"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605075904.220300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-11-10 22:25</span><br/>
Just wondering: why is everyone focusing so much on termination? In my personal debugging experience, endless loops are a rare issue and usually found and fixed quickly. As long as the OS allows interrupting a process... what's the problem?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605076079.220500"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605076079.220500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-11-10 22:27</span><br/>
What I hope to find in the space of Turing-incomplete languages is some form of robustness: ensure that small changes in the input (code + data) of a computation can only lead to small changes in the output. Robustness matters a lot in other forms of engineering - software should have access to it as well.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605096979.220800"></a>
      <img src="https://secure.gravatar.com/avatar/bc3e6041047849518d1b042f0a29d5af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605096979.220800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>S.M Mukarram Nainar</b>
<span style="margin:2em; color:#606060">2020-11-11 04:16</span><br/>
When you phrase it that way, robustness seems to be the opposite of expressiveness
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605113049.221000"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605113049.221000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2020-11-11 08:44</span><br/>
Yes and no. It's the opposite of expressiveness if you think about general-purpose programming. But I am thinking of DSLs. If your robustness criteria are those of the domain you design for, they don't imply a loss of expressiveness.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605157962.224000"></a>
      <img src="https://secure.gravatar.com/avatar/5fae55cf900c6577e6c3841a344015bd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0012-72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1605157962.224000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>John Soo</b>
<span style="margin:2em; color:#606060">2020-11-11 21:12</span><br/>
Yeah I don’t think termination is really so interesting. I think there’s a good metaphor out there but I can’t bring one to mind. I do like what you get with more expressive types though. Those usually require totality 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1610178372.463300"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../linking-together/1604952430.207700.html#1610178372.463300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2021-01-08 23:46</span><br/>
I came to the same conclusion, that requiring provable termination isn't useful, but perhaps it's a useful default - perhaps a language can be designed such that it can prove most programs will terminate, and for cases where it can't prove it, you'll get a warning that you can then turn off (either by 'conjecturing' that it terminates, or declaring that it doesn't always terminate and the programmer just accepts it).<br/><br/>However, if I was building a language, there are other type-system features I would prioritize over termination analysis (e.g. unit inference).
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
