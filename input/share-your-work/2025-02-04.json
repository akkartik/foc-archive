[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1738688010.403799",
        "client_msg_id": "e7770a35-e676-4395-8ce0-7540729df9d8",
        "text": "another attempt at explaining myself: <https:\/\/open.substack.com\/pub\/programmingsimplicity\/p\/function-chains-vs-pipelines?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1738331917.986289",
        "parent_user_id": "UGWUJUZHT",
        "attachments": [
            {
                "from_url": "https:\/\/open.substack.com\/pub\/programmingsimplicity\/p\/function-chains-vs-pipelines?r=1egdky&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true",
                "thumb_url": "https:\/\/substackcdn.com\/image\/fetch\/w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto\/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9d69eba9-d5d3-4387-a046-9b881b00bd45_131x131.png",
                "thumb_width": 131,
                "thumb_height": 131,
                "service_icon": "https:\/\/substackcdn.com\/image\/fetch\/f_auto,q_auto:good,fl_progressive:steep\/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9bf28261-3dbc-4931-99f3-57bb47beeb02%2Fapple-touch-icon-57x57.png",
                "id": 1,
                "original_url": "https:\/\/open.substack.com\/pub\/programmingsimplicity\/p\/function-chains-vs-pipelines?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true",
                "fallback": "Function Chains vs. Pipelines",
                "text": "2025-02-03",
                "title": "Function Chains vs. Pipelines",
                "title_link": "https:\/\/open.substack.com\/pub\/programmingsimplicity\/p\/function-chains-vs-pipelines?r=1egdky&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true",
                "service_name": "programmingsimplicity.substack.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rPiaF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "another attempt at explaining myself: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/open.substack.com\/pub\/programmingsimplicity\/p\/function-chains-vs-pipelines?r=1egdky&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0887QU9G2V",
        "type": "message",
        "ts": "1738701924.513329",
        "client_msg_id": "b0370425-7cb4-445d-91ba-1b107c4777d6",
        "text": "Thanks for the article!\n\n&gt; •  The key insight is that pipelines are about modelling data flow, while function chains are about control flow - they're different abstractions serving different purposes.\nI see function chains as about both data and control flow. In plain language: I do X and get Y; then I give Y to Z and Z does its thing.\n\n&gt; •  A pipeline only passes data, not control flow.\nIt's true that pipelines are more \"continuous\", in that the next utility might start working on its input before the previous one finishes generating the output. That's a remarkable difference. But for most practical purposes, I still see them as sequential.\n\n&gt; •  Pipeline nodes do NOT determine which code runs next [_pt: whereas functions do_]\nBut neither do the chained functions, right? This decision belongs to the caller, the one chaining the functions in the first place.\n\nOverall, I'm not trying to win an argument, just trying to see what I'm missing. Thanks again for sharing your insight!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6b9d24756ac1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-08\/8269664865108_6b9d24756ac1aa304bb9_72.jpg",
            "first_name": "Federico",
            "real_name": "Federico Pereiro",
            "display_name": "Federico Pereiro",
            "team": "T5TCAFTA9",
            "name": "fpereiro",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1738331917.986289",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ot\/p9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for the article!\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": " The key insight is that pipelines are about modelling data flow, while function chains are about control flow - they're different abstractions serving different purposes."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 1
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI see function chains as about both data and control flow. In plain language: I do X and get Y; then I give Y to Z and Z does its thing.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": " A pipeline only passes data, not control flow."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 1
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIt's true that pipelines are more \"continuous\", in that the next utility might start working on its input before the previous one finishes generating the output. That's a remarkable difference. But for most practical purposes, I still see them as sequential.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": " Pipeline nodes do NOT determine which code runs next ["
                                    },
                                    {
                                        "type": "text",
                                        "text": "pt: whereas functions do",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "]"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 1
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nBut neither do the chained functions, right? This decision belongs to the caller, the one chaining the functions in the first place.\n\nOverall, I'm not trying to win an argument, just trying to see what I'm missing. Thanks again for sharing your insight!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDCLA1HU4",
        "type": "message",
        "ts": "1738704357.662679",
        "edited": {
            "user": "UDCLA1HU4",
            "ts": "1738704410.000000"
        },
        "client_msg_id": "84545c06-80af-4db9-9c24-999e8a493616",
        "text": "I do not have a cool video to share - only dry text! :slightly_smiling_face: but I think there is a very interesting \"interaction pattern\" that comes up in a lot of simple programming systems (at least the ones that I sometimes work on) - so this is an attempt to capture that...\n\n*Choose-your-own-adventure calculus:* <https:\/\/tomasp.net\/blog\/2025\/adventure-calculus\/>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "bcf86f2e207e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-09-25\/7807695316512_bcf86f2e207ef54d3bda_72.jpg",
            "first_name": "",
            "real_name": "Tomas Petricek",
            "display_name": "tomasp",
            "team": "T5TCAFTA9",
            "name": "tomas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1738704357.662679",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1739223924.657479",
        "reply_users": [
            "U0887QU9G2V",
            "U01QUBNJSEQ",
            "UDCLA1HU4"
        ],
        "replies": [
            {
                "user": "U0887QU9G2V",
                "ts": "1738774507.841919"
            },
            {
                "user": "U01QUBNJSEQ",
                "ts": "1739184655.106139"
            },
            {
                "user": "UDCLA1HU4",
                "ts": "1739223924.657479"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JE8pJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I do not have a cool video to share - only dry text! "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " but I think there is a very interesting \"interaction pattern\" that comes up in a lot of simple programming systems (at least the ones that I sometimes work on) - so this is an attempt to capture that...\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Choose-your-own-adventure calculus: ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/tomasp.net\/blog\/2025\/adventure-calculus\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U05UK5T7LPP",
                    "UJBAJNFLK",
                    "U07KR4BMKNW",
                    "U01QUBNJSEQ"
                ],
                "count": 5
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1738705380.252299",
        "client_msg_id": "2b40cd7a-3ac9-49c7-bfe2-472eed6934fe",
        "text": "&gt; I do X and get Y\nWith a function, yes. With a node in a pipeline, it's async, hence, you `do X` and don't need to wait around. The callee just sends `Y` further down the pipe without bothering to return it to the caller. Once you break out of the habit of thinking only in terms of functions, other interesting combinations appear beyond just simple, sequential pipelines. [I can discuss further, but, am cutting myself off to KISS]\n\n&gt; But neither do the chained functions, right?\nNo. A _call_ passes `control flow` _immediately_ to the callee. A function specifies the callee directly, hence, determines which function will run next. A node in a pipeline cannot do this. This is subtle, but, important. In a pipeline node, the node does not `call` any other node, it simply leaves a result in a queue, to be be dispersed later by a higher power (the \"dispatcher\" in UNIX, \"Choreographer Parts\" in my stuff &lt;\/KISS&gt;).\n\nDependency injection _looks_ like it _sends_, but only adds a level of indirection to the naming process, while continuing to **choose** who gets to run next. Calling and sending deliver data differently. Imagine a queue - _call_ puts the data at the front of the queue, whereas _send_ puts data at the end of the queue.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1738331917.986289",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lQ0FC",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I do X and get Y"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "With a function, yes. With a node in a pipeline, it's async, hence, you "
                            },
                            {
                                "type": "text",
                                "text": "do X",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and don't need to wait around. The callee just sends "
                            },
                            {
                                "type": "text",
                                "text": "Y",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " further down the pipe without bothering to return it to the caller. Once you break out of the habit of thinking only in terms of functions, other interesting combinations appear beyond just simple, sequential pipelines. [I can discuss further, but, am cutting myself off to KISS]\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But neither do the chained functions, right?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "No. A "
                            },
                            {
                                "type": "text",
                                "text": "call",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " passes "
                            },
                            {
                                "type": "text",
                                "text": "control flow",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "immediately",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to the callee. A function specifies the callee directly, hence, determines which function will run next. A node in a pipeline cannot do this. This is subtle, but, important. In a pipeline node, the node does not "
                            },
                            {
                                "type": "text",
                                "text": "call",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " any other node, it simply leaves a result in a queue, to be be dispersed later by a higher power (the \"dispatcher\" in UNIX, \"Choreographer Parts\" in my stuff <\/KISS>).\n\nDependency injection "
                            },
                            {
                                "type": "text",
                                "text": "looks",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " like it "
                            },
                            {
                                "type": "text",
                                "text": "sends",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but only adds a level of indirection to the naming process, while continuing to *"
                            },
                            {
                                "type": "text",
                                "text": "choose",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "* who gets to run next. Calling and sending deliver data differently. Imagine a queue - "
                            },
                            {
                                "type": "text",
                                "text": "call",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " puts the data at the front of the queue, whereas "
                            },
                            {
                                "type": "text",
                                "text": "send",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " puts data at the end of the queue."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]