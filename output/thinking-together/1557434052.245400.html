<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 13:34</span><br/>
Crazy guy here to say that everyone is looking in the wrong direction.  Functional, Imperative, Excel spreadsheet-driven, who cares?  Computation is not the frontier anymore.  Most software is now built across networks and collections of computers (UIs/embedded being the large exceptions).  What do we have to gain by min-maxing programming a single machine? The glacial pace of innovation in this space since ~1990 should be a big wake up sign.  The future is wrangling distributed systems, which is something that single-machine Turing complete languages like to pretend is somebody else's problem.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557434195.245600"></a>
      <img src="https://avatars.slack-edge.com/2019-04-18/614285184934_3672059e546d2aa66322_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557434195.245600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pete Vilter</b>
<span style="margin:2em; color:#606060">2019-05-09 13:36</span><br/>
you might be interested in this talk about research on distributed programming languages <a href="https://www.youtube.com/watch?v=eAcDWcaezXY">https://www.youtube.com/watch?v=eAcDWcaezXY</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557434213.245900"></a>
      <img src="https://avatars.slack-edge.com/2019-04-18/614285184934_3672059e546d2aa66322_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557434213.245900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pete Vilter</b>
<span style="margin:2em; color:#606060">2019-05-09 13:36</span><br/>
some people are looking in this direction :stuck_out_tongue:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557434298.246100"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557434298.246100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 13:38</span><br/>
Not a critical mass for us to find each other I suppose!  Thanks for the talk; will watch later today.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557434579.246300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557434579.246300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-09 13:42</span><br/>
I spent time in the past building/maintaining distributed systems in industry before returning/retreating to single-core research in my spare time. Reasons I did so:<br/><br/>a) There’s value in building distributed systems out of robust parts that do what they say they’ll do.<br/>b) There’s value in being able to state distributed systems guarantees as tests that can run on a single machine (simulating multiple machines).<br/>c) There’s value in making it tractable to step through and debug distributed system scenarios simulated on a single box.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557434984.246500"></a>
      <img src="https://avatars.slack-edge.com/2019-04-10/604262911488_be27878783b4b23a5ed4_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557434984.246500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Niko Autio</b>
<span style="margin:2em; color:#606060">2019-05-09 13:49</span><br/>
I think it's all about what problem you are trying to solve. Different problems may be unrelated. Is biggest problem of our industry UI of computing or hardness of distributed system programming? Other is related how productive one current (significant?) subarea is and other is (mostly?) about how can we empower more people with it. Very different perspectives and I think you cannot say that looking either one you are looking a wrong direction :stuck_out_tongue:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557435944.246700"></a>
      <img src="https://avatars.slack-edge.com/2019-04-10/604262911488_be27878783b4b23a5ed4_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557435944.246700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Niko Autio</b>
<span style="margin:2em; color:#606060">2019-05-09 14:05</span><br/>
I am reading that you are kind of claiming that programming for single machine is solved problem (which is indeed subjective thing)?<br/><br/>Let me ask a question:<br/>If you would be part group of people who would using single super fast machine with own IO devices but otherwise shared machine. What benefits would be distribution bring?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557436098.246900"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557436098.246900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 14:08</span><br/>
Distribution brings availability (redundancy, system health, etc.), and as far as I know, that's really the only benefit over massive single machines.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557436206.247200"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557436206.247200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 14:10</span><br/>
I do believe we're past a point of diminishing returns on single machine language innovation.  I don't think whatever we do we'll see the same productivity leap as we did from assembly -&gt; LISP/C, or even C-&gt;Java.  Academics have proven that nothing is "solved" :stuck_out_tongue:, but we certainly pass points of diminishing returns.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557436334.247500"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557436334.247500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 14:12</span><br/>
I'm really bringing this up because I think there's thought within communities like this that "if we just get people to stop using the bad languages and get them to use the good ones we'll be way better off!" and I just don't think that's true.   I don't think the delta between Java and Haskell is as big as people would think.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557436432.247700"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557436432.247700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 14:13</span><br/>
I DO think that the delta between Java and a language that provides developers constructs and language to reason about distributed systems will be huge.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557437993.248300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557437993.248300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-09 14:39</span><br/>
I agree (and have ranted here before) that changing programming languages doesn’t accomplish much. I think improving single-threaded <em>runtimes</em> does help, and may make seemingly difficult problems in distributed computing more tractable.<br/><br/>Today you often have to communicate criteria like idempotence in comments, and guarantees can be violated from inexperience, etc. Making it easy to test for such guarantees would be helpful. A language that provided such “type checks” would be huge.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557438609.248700"></a>
      <img src="https://avatars.slack-edge.com/2019-04-16/610501525696_590662e8a2ae7b2c73e9_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557438609.248700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Priestley</b>
<span style="margin:2em; color:#606060">2019-05-09 14:50</span><br/>
I'm in complete agreement. Not only distributed programming, but other "side effects" are simply left to be solved "somehow" outside the programming environment. Persistence, versioning, authentication, building, I/O, UI all come to mind - old-school ALGOL is like a paradise compared to the tools we have to use to deal with these "extra" concerns, and as a result they take up a disproportionate part of development time
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557438991.249300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557438991.249300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-05-09 14:56</span><br/>
YES! The original comment resonated quite well with me. It's not that I don't prefer certain languages or think they make no difference. But the unquestioned assumption that the way to do large scale computation is to do 'small programs first' individually compiled and then tied together later needs a rethink.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557440658.249900"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557440658.249900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 15:24</span><br/>
You've all fallen for my trap--now its time to swoop in with the self-promotion!  <a href="https://strat.world/">https://strat.world/</a> is a language for systems, and has the audacity to not even be Turing complete!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557440723.250100"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557440723.250100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 15:25</span><br/>
Totally ignoring that previous comment and continuing the discussion, I have this concept of "Surface area programming".  Its the code that stiches components together.  My hypothesis is that as components get smaller and more numerous surface area increases exponentially, and we're at a critical point where surface area is dominating the task of building software--something has to give.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557440767.250300"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557440767.250300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 15:26</span><br/>
By its nature surface area programming is multi-machine, and our single machine "computation" languages can't express these concepts, so we have to build them up by hand.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557440829.250500"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557440829.250500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 15:27</span><br/>
End result: hundreds of lines of yaml, framework code, tooling, etc. to host 10 LOC of business logic in a distributed system
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557440888.250700"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557440888.250700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 15:28</span><br/>
<span style="background-color:#ccf">@Jason Priestley</span> Surface area code is exactly what you're talking about here
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557440951.251400"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557440951.251400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 15:29</span><br/>
<span style="background-color:#ccf">@Shalabh</span> How would you start?  With a top-down language and follow up with the nitty-gritty bits?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557440971.251900"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557440971.251900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 15:29</span><br/>
At some point you do have to write your single-machine algorithms
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557441101.252100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557441101.252100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-09 15:31</span><br/>
My hot take: we should be using the same programming language we use for the 10 LoC of business logic to maintain the specifications we currently use hundreds of lines of yaml, framework code, tooling, etc. And it should all be type-checked. And it should all have tests. (Because the 10 LoC have 40 LoC of tests, right? Right?) And you can prototype these in a single-machine language. It’s about choosing the right interfaces for the syscalls by which a computer interacts with its environment (including for bringing up and sending instructions to other computers).<br/><br/>Is that what strat.world does? Or are you assuming a bunch of conventions? In which case the examples I want to see are about how people would go about violating your opinionated conventions.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557441357.252400"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557441357.252400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 15:35</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> there's a lot to unpack there; I'll have to think about it and get back to you
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557445406.268100"></a>
      <img src="https://secure.gravatar.com/avatar/373561dd658617ebf8d413eb95361c0d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557445406.268100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Charlie</b>
<span style="margin:2em; color:#606060">2019-05-09 16:43</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> so what you're saying, if I'm interpreting correctly, is that we should still be programming single-machine, but with more emphasis/attention to the boundaries of that machine, and how it might interface with other machines, but without bringing in the concept of many machines?  The very strong benefits to staying single-machine are the wealth of theory and tooling (type systems, tests, math) we have for reasoning about computation--we lose much of this when we break the single-machine/no-network assumption.<br/><br/>Strat starts from the assumption of many machines and works downwards to what implementation makes sense (which may be locating all computation on a single machine or many).  There are "conventions" that it uses to fulfill that implementation (ex: uses JSON+HTTP to send messages between machines).   I'm of the opinion that Strat's compiler will trend towards picking better implementations than users could after enough time a la gcc writing better assembly.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557445904.268400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557445904.268400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-05-09 16:51</span><br/>
I disagree that gcc trying to match hand-crafted assembly has been a net positive for the world. But that’s a lengthy tangent :slightly_smiling_face:<br/><br/>Not sure I follow your rephrasing of my comment, so let me try new words: our distributed systems today are not robust because we can’t easily simulate network partitions, high network latency and other such environmental factors. It’s <em>possible</em> to do so but it’s expensive and tests take forever to run so there’s huge pressure against writing lots of such tests.<br/><br/>What I want to see is an OS that allows me to easily write tests simulating multiple computers with various settings for the environment between them. The reason it has to be in the OS is to keep the simulation cost low, and to provide verisimilitude in the simulation. The right way to deal with environmental problems actually depends a lot on how your underlying platform responds to various circumstances. You can’t just live at the app layer.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557506419.325200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557506419.325200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-05-10 09:40</span><br/>
&gt; <span style="background-color:#ccf">@Shalabh</span> How would you start?  With a top-down language and follow up with the nitty-gritty bits?<br/><span style="background-color:#ccf">@Charlie</span> yes something like that. I feel distribution is just and implementation detail and there's a larger algorithm/process that may be described without coupling to the distribution mechanism details. It could then be refined by layering on details, perhaps in a separate code artifact. This is a little bit like generic programming, but at the system level. E.g. I code to the List API but then make a separate choice about which specific implementation is used. At a system level I'd describe higher level processes that the entire cluster should implement, and separately define how it maps onto the machines.<br/><br/>BTW, I already was intrigued by strat.world when you posted your intro as I'm interested in this space (see also darklang, you might also like the book Vertically Integrated Architectures (Jos Jong)).<br/><br/>&gt; End result: hundreds of lines of yaml, framework code, tooling, etc. to host 10 LOC of business logic in a distributed system<br/><br/>Yes, and the logic is tightly couple to the distribution topology as well. This is actually also a problem with single process languages, but less pronounced. E.g. if I change the threading model or persistence strategy (nothing to do with business logic), I still have to fiddle with the business logic bits.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557590876.330300"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557590876.330300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2019-05-11 09:07</span><br/>
have yall looked into the unison programming language? <a href="https://youtu.be/rp_Eild1aq8">https://youtu.be/rp_Eild1aq8</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557767257.338500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557767257.338500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-05-13 10:07</span><br/>
Yes, Unison is interesting. Last I looked the focus was more on uniquely identifiable functions that can be run anywhere and not on specifying the higher level processes decoupled from the implementation topology. It's probably worth taking another look.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557907520.420700"></a>
      <img src="https://avatars.slack-edge.com/2019-05-06/616300651267_e35958b94f07da17cf17_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557907520.420700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Andreas S.</b>
<span style="margin:2em; color:#606060">2019-05-15 01:05</span><br/>
thank you charlie for this nice provocative post
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557908459.420900"></a>
      <img src="https://avatars.slack-edge.com/2019-05-06/616300651267_e35958b94f07da17cf17_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557908459.420900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Andreas S.</b>
<span style="margin:2em; color:#606060">2019-05-15 01:20</span><br/>
I agree that distribution is an important frontier. and this is why I  consider Bitcoin, Ethereum and all the Blockchain space such an important innovation. The frontier is right there. RChain is using the Rho calculus also tries to implement a public computation plattfrom . <span style="background-color:#ccf">@Pete Vilter</span> Its interesting to see heathers talk. But its also easy to see where she comes from ( scala and academic programming language research). Her main conclusion in the talk is? that its ok to embedd concepts in a general purpose language. I think I disagree with that because she misses an important perspective with that. And that is the perspective of complexity. instead it could be interesting to see what systems we could create out of specialised languages or sub systems liek the STEPS project tried: <a href="https://www.youtube.com/watch?v=gZmcmdsoAXU">https://www.youtube.com/watch?v=gZmcmdsoAXU</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1557909256.422900"></a>
      <img src="https://avatars.slack-edge.com/2019-05-06/616300651267_e35958b94f07da17cf17_72.png" style="float:left"/>
      <a href="../thinking-together/1557434052.245400.html#1557909256.422900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Andreas S.</b>
<span style="margin:2em; color:#606060">2019-05-15 01:34</span><br/>
Actually I do think that heathers talk show one of the major issues with research today. I think we need better systems than peer review jornals and talks at conference to judge the value of research.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
