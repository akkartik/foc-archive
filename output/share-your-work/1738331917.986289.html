<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-01-31 05:58</span><br/>
FWIW: <a href="https://programmingsimplicity.substack.com/p/of-interest?r=1egdky">this is a reply</a> I made elsewhere. Hoping it might be of interest here.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738616893.160679"></a>
      <img src="https://avatars.slack-edge.com/2025-01-08/8269664865108_6b9d24756ac1aa304bb9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738616893.160679" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Federico Pereiro</b>
<span style="margin:2em; color:#606060">2025-02-03 13:08</span><br/>
Thanks for sharing! <span style="background-color:#ccf">@Paul Tarvydas</span><br/><br/>&gt;  <a href="https://programmingsimplicity.substack.com/p/functions-and-pipes?r=1egdky">UNIX</a> pipelines were headed in the right direction, but, the shell pipeline concept has lagged behind advances in FP - and, pipelines were conflated with function calls, which ain't the same thing.<br/>Concerning those two points, I'm really curious to hear how that's the case. In my mental model, pipelines are homomorphic to chained functions. I'd love to know how you think that the concept of pipelines could be expanded, or where exactly it is lacking.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738620923.468509"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738620923.468509" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-02-03 14:15</span><br/>
Pipelines are <em>not</em> homomorphic to chained functions. I will endeavour to expand on this...
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738688010.403799"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738688010.403799" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-02-04 08:53</span><br/>
another attempt at explaining myself: <a href="https://open.substack.com/pub/programmingsimplicity/p/function-chains-vs-pipelines?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true">https://open.substack.com/pub/programmingsimplicity/p/functi&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738701924.513329"></a>
      <img src="https://avatars.slack-edge.com/2025-01-08/8269664865108_6b9d24756ac1aa304bb9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738701924.513329" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Federico Pereiro</b>
<span style="margin:2em; color:#606060">2025-02-04 12:45</span><br/>
Thanks for the article!<br/><br/>&gt; •  The key insight is that pipelines are about modelling data flow, while function chains are about control flow - they're different abstractions serving different purposes.<br/>I see function chains as about both data and control flow. In plain language: I do X and get Y; then I give Y to Z and Z does its thing.<br/><br/>&gt; •  A pipeline only passes data, not control flow.<br/>It's true that pipelines are more "continuous", in that the next utility might start working on its input before the previous one finishes generating the output. That's a remarkable difference. But for most practical purposes, I still see them as sequential.<br/><br/>&gt; •  Pipeline nodes do NOT determine which code runs next [<em>pt: whereas functions do</em>]<br/>But neither do the chained functions, right? This decision belongs to the caller, the one chaining the functions in the first place.<br/><br/>Overall, I'm not trying to win an argument, just trying to see what I'm missing. Thanks again for sharing your insight!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738705380.252299"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738705380.252299" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-02-04 13:43</span><br/>
&gt; I do X and get Y<br/>With a function, yes. With a node in a pipeline, it's async, hence, you <tt>do X</tt> and don't need to wait around. The callee just sends <tt>Y</tt> further down the pipe without bothering to return it to the caller. Once you break out of the habit of thinking only in terms of functions, other interesting combinations appear beyond just simple, sequential pipelines. [I can discuss further, but, am cutting myself off to KISS]<br/><br/>&gt; But neither do the chained functions, right?<br/>No. A <em>call</em> passes <tt>control flow</tt> <em>immediately</em> to the callee. A function specifies the callee directly, hence, determines which function will run next. A node in a pipeline cannot do this. This is subtle, but, important. In a pipeline node, the node does not <tt>call</tt> any other node, it simply leaves a result in a queue, to be be dispersed later by a higher power (the "dispatcher" in UNIX, "Choreographer Parts" in my stuff &lt;/KISS&gt;).<br/><br/>Dependency injection <em>looks</em> like it <em>sends</em>, but only adds a level of indirection to the naming process, while continuing to *<b>choose</b>* who gets to run next. Calling and sending deliver data differently. Imagine a queue - <em>call</em> puts the data at the front of the queue, whereas <em>send</em> puts data at the end of the queue.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738775004.152919"></a>
      <img src="https://avatars.slack-edge.com/2025-01-08/8269664865108_6b9d24756ac1aa304bb9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738775004.152919" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Federico Pereiro</b>
<span style="margin:2em; color:#606060">2025-02-05 09:03</span><br/>
Thank you for the clarification! I think I get it now.<br/><br/>However, if a function returns, isn't it the caller that determines who to call next? My homomorphism is roughly as follows:<br/><br/>• Utility in a pipeline: receives inputs (all at once or streamed), produces output (all at once or streamed), doesn't know where the input came from, doesn't know where it goes to<br/>• Function call: receives input all at once, returns data all at once, doesn't know where the data or control goes to (unless you passed a callback to it)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738775073.889689"></a>
      <img src="https://avatars.slack-edge.com/2025-01-08/8269664865108_6b9d24756ac1aa304bb9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738775073.889689" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Federico Pereiro</b>
<span style="margin:2em; color:#606060">2025-02-05 09:04</span><br/>
Despite the differences under the hood, I still conceptually see them as pretty much the same. It's a single chain of tubes.<br/><br/>Thank you for your points, I now understand better the distinctions you made earlier!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738793202.411439"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738793202.411439" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-02-05 14:06</span><br/>
Your questions and observations are wonderful! Thanks!<br/><br/>These things are definitely different, and, the difference results in bugs and hard-to-reason-about-ness in async programs.<br/><br/>&gt; Function call: receives input all at once, returns data all at once, doesn't know where the data or control goes to...<br/>The word <tt>return</tt> is loaded. It surreptitiously contains a scheduling decision AND it surreptitiously contains a routing decision (the <em>callee</em> must send data back to the <em>caller</em> - no choice. The decisions are hard-baked into the syntax.<br/><br/>... reaching for another way to say this (I seem to be batting 0 everywhere I try to expand on this) ...<br/>Syntax such as f(g(h(x))) does not allow for the possibility that j(k(h(x))) gets to run until f(g(h(x))) is finished, i.e. f(...) makes a data-flow decision (stack-based data transfer instead of queue-based data transfer) - AND - it makes a scheduling design - AND - f(...) blocks any other input from reaching h(x) until it decides to allow this.<br/><br/>Let's say you press a key on the keyboard, then click the left mouse button. That's different than a click on the left mouse button followed by a keypress. You can't differentiate these with f(g(h(x))) syntax followed by j(k(h(x))) syntax. F(g(h(x))) is fine if you have a single thread and no feedback. That's the way computers used to be in 1950. Today, computers are no longer like that (internet, robotics, IoT, etc), hence, strict sequential syntax cannot cope with reality any more. The best you can do is to write two async programlets that describe the innards of these things, but, it is hard to write a 3rd program that connects the two (without a lot of futzing and edge-cases and gotchas).<br/><br/>Pure functions are nice if all of your problems can be solved in a sequential manner, but, that ain't the case any more.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738903427.878439"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2508698086192_565c54a4fa91a0c8c75a_72.png" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738903427.878439" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Lieber</b>
<span style="margin:2em; color:#606060">2025-02-06 20:43</span><br/>
I think I get what you’re saying, Paul. In f(g(x)), g knows that f must be paused and that it will resume iff it relinquishes control. That makes sense.<br/><br/>But am I right that that only becomes relevant when you permit a system description that incorporates more than just the function call or pipeline? If you write g in a f|g pipeline with the assumption that f has rescinded control for the duration as if it were a function call, then you won’t observe anything to contradict that notion unless there are also <em>other</em> data- or control-flow mechanisms in play, like g sends information backward to f, or both f and g access some external system like a wall clock. Like Federico said, they’re conceptually the same… until you complicate them, and I think your point is that pipelines are amenable to “interesting combinations” that function calls are not.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1738936493.848799"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1738936493.848799" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-02-07 05:54</span><br/>
Thanks!<br/><br/>Yes, I think that your description is clearer than mine, but, there are several loaded phrases and words, like "g knows that f must be paused", "assumption", "more complicated"... <a href="https://open.substack.com/pub/programmingsimplicity/p/simplicity-vs-functional-programming?r=1egdky">https://open.substack.com/pub/programmingsimplicity/p/simpli&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1739736466.500619"></a>
      <img src="https://avatars.slack-edge.com/2025-01-08/8269664865108_6b9d24756ac1aa304bb9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1738331917.986289.html#1739736466.500619" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Federico Pereiro</b>
<span style="margin:2em; color:#606060">2025-02-16 12:07</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> two points. First, apologies it took me so long to respond, I missed your last message.<br/><br/>Second, your last example made it click for me. If you have a user clicking the mouse and then 100ms later entering a key, those actions are not necessarily sequential. Very much indeed!<br/><br/>The way I see it, each of those two user interactions start a new sequence. Those sequences are being executed at the same time (whether in parallel with many CPUs or concurrently by one, it doesn't matter). You might have to make them join into one, or keep them running separately. Indeed, the entire system cannot be modelled as one sequence. But I do believe it's possible to model it with parallel/concurrent sequences.<br/><br/>I also envision being able to have a command "fork" that runs things concurrently or in parallel, and then optionally waits for all of those sequences to finish so that they basically merge onto a single sequence afterwards.<br/><br/>The core assumption at the base of this view is that everything is decomposable into sequences that pass data. Control passing is not necessary. But what does matter is that whoever has to wait (for either the entire previous thing or a chunk of data) will wait. And I think that that's not only reasonable, but necessary.<br/><br/>Thanks for the example with the user interaction, it really made it click for me!
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
