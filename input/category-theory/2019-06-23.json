[
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1561288403.269800",
        "client_msg_id": "cc11b5f8-f2d1-4057-af01-8a1136dcd0bc",
        "text": "And, contrary to what I said, there can be only one per object <https:\/\/proofwiki.org\/wiki\/Identity_Morphism_is_Unique>.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1561053938.216700",
        "parent_user_id": "UKQT95T1V",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4wdI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And, contrary to what I said, there can be only one per object "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/proofwiki.org\/wiki\/Identity_Morphism_is_Unique"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UKF5Q8EUR",
        "type": "message",
        "ts": "1561316724.270000",
        "client_msg_id": "ab6ef712-7b30-497f-9959-568088b7732b",
        "text": "Yes, and the proof is very easy. Just assume you have two, and compose them.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g018f2132044",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/c018f213204496b4bbf481e7c8e6c15c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png",
            "first_name": "",
            "real_name": "Bartosz Milewski",
            "display_name": "Bartosz Milewski",
            "team": "T5TCAFTA9",
            "name": "bartosz",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1561053938.216700",
        "parent_user_id": "UKQT95T1V",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dy\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, and the proof is very easy. Just assume you have two, and compose them."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1561335322.270200",
        "client_msg_id": "1014dda9-a385-4c0a-8945-877e137722a5",
        "text": "Though it is possible to have a \"near\" identity call it `j` that works like the identity `i` with `j . x = x . j = x` for all compatible `x ≠ i` but in the remaining case `j . i = i . j = j`.  If you remove `i`, you remove the one exceptional case, and `j` serves as a bonafide identity in this not-quite subcategory.  Is this just a wild curiosity or an echo of something familiar?  What about languages with multiple \"falsey\" things.  JavaScript surely you can help us out?  `<http:\/\/Object.is|Object.is>(0, -0) == false;`  Promising.  `<http:\/\/Object.is|Object.is>(0, -0 + 0) == true;` Well then!  So in JavaScript if we consider the monoid of numbers under addition (that is the category with *one* object and an arrow for each number with `+` as composition) using `<http:\/\/Object.is|Object.is>` for our sense of equality (`==` and `===` work differently), then, and here's the kicker, `-0` is our true identity and `0` is our \"near\" identity!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1561053938.216700",
        "parent_user_id": "UKQT95T1V",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BZD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Though it is possible to have a \"near\" identity call it "
                            },
                            {
                                "type": "text",
                                "text": "j",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that works like the identity "
                            },
                            {
                                "type": "text",
                                "text": "i",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with "
                            },
                            {
                                "type": "text",
                                "text": "j . x = x . j = x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " for all compatible "
                            },
                            {
                                "type": "text",
                                "text": "x ≠ i",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " but in the remaining case "
                            },
                            {
                                "type": "text",
                                "text": "j . i = i . j = j",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  If you remove "
                            },
                            {
                                "type": "text",
                                "text": "i",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", you remove the one exceptional case, and "
                            },
                            {
                                "type": "text",
                                "text": "j",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " serves as a bonafide identity in this not-quite subcategory.  Is this just a wild curiosity or an echo of something familiar?  What about languages with multiple \"falsey\" things.  JavaScript surely you can help us out?  "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/Object.is",
                                "text": "Object.is",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "(0, -0) == false;",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  Promising.  "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/Object.is",
                                "text": "Object.is",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "(0, -0 + 0) == true;",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Well then!  So in JavaScript if we consider the monoid of numbers under addition (that is the category with "
                            },
                            {
                                "type": "text",
                                "text": "one",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " object and an arrow for each number with "
                            },
                            {
                                "type": "text",
                                "text": "+",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as composition) using "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/Object.is",
                                "text": "Object.is",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " for our sense of equality ("
                            },
                            {
                                "type": "text",
                                "text": "==",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "===",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " work differently), then, and here's the kicker, "
                            },
                            {
                                "type": "text",
                                "text": "-0",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is our true identity and "
                            },
                            {
                                "type": "text",
                                "text": "0",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is our \"near\" identity!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "exploding_head",
                "users": [
                    "UKQT95T1V"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJTHWNH2T",
        "type": "message",
        "ts": "1561345591.270500",
        "client_msg_id": "abb67f5c-bc53-4e3e-8541-47e21d0dc67e",
        "text": "Hi all, I'd like to recommend a resource. Algebra: Chapter 0 by Aluffi. It's an abstract algebra book which takes a CT-heavy approach. I think it occupies a unique place in being the easiest CT book that's all mathematics and no programming\/CS. I've read about people who try to learn CT in a rigorous way go straight to pure CT books which either contain no motivation or are full of examples from algebraic topology, algebraic geometry, etc. Aluffi is an excellent exception — it teaches abstract algebra and CT side-by-side (the definition of category is pg 19). In Aluffi's opinion CT and AA should be taught together from the beginning. Many programmers interested in CT (e.g. from Haskell) probably want to learn abstract algebra anyway. Also, the book has received praise for being approachable for self study, with doable exercises.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g540add01944",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/b540add019442ca4a6f3acf8a99024b1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0023-72.png",
            "first_name": "",
            "real_name": "Deklan Webster",
            "display_name": "Deklan Webster",
            "team": "T5TCAFTA9",
            "name": "deklanw",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IYS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi all, I'd like to recommend a resource. Algebra: Chapter 0 by Aluffi. It's an abstract algebra book which takes a CT-heavy approach. I think it occupies a unique place in being the easiest CT book that's all mathematics and no programming\/CS. I've read about people who try to learn CT in a rigorous way go straight to pure CT books which either contain no motivation or are full of examples from algebraic topology, algebraic geometry, etc. Aluffi is an excellent exception — it teaches abstract algebra and CT side-by-side (the definition of category is pg 19). In Aluffi's opinion CT and AA should be taught together from the beginning. Many programmers interested in CT (e.g. from Haskell) probably want to learn abstract algebra anyway. Also, the book has received praise for being approachable for self study, with doable exercises."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UKQT95T1V",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "UC2RTNAHZ",
                    "UHWC9PXBL",
                    "UL7M7H5GD"
                ],
                "count": 3
            }
        ]
    }
]