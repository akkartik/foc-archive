<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #introduce-yourself</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-05-30 16:25</span><br/>
Hi everyone! I'm Robert. I'm working on designing a hobbyist processor architecture that is designed to fit in a single person's head. The ultimate goal is to get a full software stack sitting on top of it that is useful from micro-controllers to serious desktop processing, simple enough to be fully understandable by a single human mind and yet powerful enough to do so-called "real" work. I basically want to figure out how simple we can make our entire software stack and perhaps unlock even more potential in the world by doing so.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590888971.262000"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1590888971.262000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2020-05-30 18:36</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> mission alignment alert
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590889245.262200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1590889245.262200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-30 18:40</span><br/>
This sounds a bit like the Forth programming language and the Forth CPU cores that have been designed for the language. Particularly Chuck Moore's work on ColorForth and the GreenArrays "minimal instruction set" CPU to execute it. What is your opinion of those efforts?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590889679.262500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1590889679.262500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-05-30 18:47</span><br/>
<span style="background-color:#ccf">@Garth Goldwater</span> Robert is actually building a Mu-like software stack for his computer :slightly_smiling_face:<br/><br/><a href="https://www.youtube.com/watch?v=lczvuLgElIw">https://www.youtube.com/watch?v=lczvuLgElIw</a><br/><br/><a href="https://github.com/grokthis/ucisc/blob/master/docs/01_Introduction.md">https://github.com/grokthis/ucisc/blob/master/docs/01_Introduction.md</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590897640.263000"></a>
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1590897640.263000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-05-30 21:00</span><br/>
<span style="background-color:#ccf">@Garth Goldwater</span> I was marching down the same philosophical path as <span style="background-color:#ccf">@Kartik Agaram</span>, just a few years behind. Mu propelled me forward and has been a huge influence on uCISC. Kartik even named it :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590897851.263200"></a>
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1590897851.263200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-05-30 21:04</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> Forth was a pretty big influence on my processor design and, in particular, the number of registers and some of the basic philosophy. I didn't know about ColorForth and GreenArrays until very recently, but the talk I watched sparked a critical insight on processor communication that led me to the final architecture: <a href="https://github.com/grokthis/ucisc/blob/master/docs/04_System.md">https://github.com/grokthis/ucisc/blob/master/docs/04_System.md</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590898116.263500"></a>
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1590898116.263500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-05-30 21:08</span><br/>
So... I have a highly favorable opinion of all of those things and have been heavily influenced by them. I'm actually a bit floored that you picked up on those influence just from my brief description. I've got my own twist on the ideas and I am curious to see how they play out. uCISC is minimal in the sense that it only has 2 instructions (copy and ALU) with an ALU opcode to indicate which mathematical op you are doing. It's a bit more expressive and CISC than ColorForth and GreenArrays though.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590939232.266100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1590939232.266100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-31 08:33</span><br/>
This seems more like a RISC architecture to me. Personal computers have gigabytes of RAM, which resides on different chips than the CPU. CISC CPUs create the illusion that RAM is directly addressable (eg, you can directly increment a word in RAM), but to make this work, they employ a complex cache hierarchy. By contrast, RISC uses a load/store architecture. Data from off-chip RAM must be explicitly loaded into local memory (registers) before it can be operated on by the ALU. uCISC takes the RISC philosophy one step further. AFAIK you can't execute instructions directly out of RAM, so there is no need for an instruction cache. Instead, even executable code must be explicitly loaded into local memory before it can be executed. So I would call this uRISC.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591027908.267500"></a>
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591027908.267500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-06-01 09:11</span><br/>
I suppose it depends on what you mean by RAM. All uCISC instructions read from and write to memory. That memory is up to 128 kb dedicated SRAM for the given processor. However, you are correct that the main multi-GB main memory bank is not directly accessible. I suppose you could look at it as RISC with up to 2^16 registers or CISC with isolated RAM banks. It's also RISC in that it is ultra reduced to instructions that are required to execute in constant cycle time and you only have 2 of them and a minimal set of mathematical operations. But it's complex in the sense that you can have attached higher order "complex" functions attached to the CPU as devices.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591028461.267700"></a>
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591028461.267700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-06-01 09:21</span><br/>
Wow... <span style="background-color:#ccf">@Doug Moen</span> you have really turned my perspective around here. So, imagine a minimal microcontroller instantiation of the architecture. Say, a single CPU with 4k of memory. Suddenly it is CISC because the 4k of main memory and single core is basically a CISC setup where each instruction loads and stores from memory. However, given a 12k LUT ECP5 FPGA which can fit roughly 6 cores with up to 5k dedicated block RAM each, (30k mem total). In a microcontroller config where there is no main mem, is this still CISC? Add 16mb of main memory to that same processor, now we are RISC basically because the logic of how you program the thing has changed simply by adding main RAM. Scale up to desktop or server and you now have a very, very RISC like setup because you will end up decomposing problems in such a way that you treat the attached memory like thousands of registers that you load from main RAM.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591028813.268000"></a>
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591028813.268000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-06-01 09:26</span><br/>
Perhaps I am not seeing clearly, but suddenly the difference between CISC and RISC has blurred for me.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591028921.268200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591028921.268200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-06-01 09:28</span><br/>
I'm not following all the details of this conversation, but I've never before seen RISC associated with software-managed memory. All computers have cache hierarchies for the last 30 years, regardless of what kind of processor they have.<br/><br/>Software-managed memory is more associated with VLIW architectures like Itanium.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591029556.268600"></a>
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591029556.268600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-06-01 09:39</span><br/>
Perhaps, in summary, the CISC view:<br/>• Local CPU memory is considered RAM. You can, but do not need to have a copy of local CPU memory in main memory. It's really just part of the RAM dedicated to a single CPU.<br/>• Instructions read from and write to RAM in one step since local memory is RAM.<br/>• Registers are primarily for addressing RAM<br/>RISC view:<br/>• Local CPU memory is not considered RAM, it is a Really Large Register Array (RLRA) that you load to/from main memory (i.e. software controlled cache)<br/>• Main memory is the real RAM area, local CPU memory will typically be a copy of some part of RAM (thus the caching part)<br/>• Registers are an indexing mechanism of the instruction for accessing the RLRA
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591029713.268800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591029713.268800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-06-01 09:41</span><br/>
I'm gonna need a citation for that..
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591030049.269000"></a>
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591030049.269000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-06-01 09:47</span><br/>
Great, now I'm going to have to go find and read a bunch of papers to definitively determine if my ISA is RISC or CISC  :sweat_smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591031657.269200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591031657.269200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-06-01 10:14</span><br/>
It's neither :smiling_imp: because the terms are meaningless. They're shades of gray that were given the illusion of crisp boundaries by some of the most savvy marketing seen in CS academia.<br/><br/>When I suggested the name uCISC, I intended it as an elaborate, subtle troll. Robert's instruction set has properties of both RISC and CISC. It has few registers like CISC, <em>and</em> few instructions like RISC (says so right in the name!) The hope is that this helps deconstruct a dichotomy that I've always found about as useful as drawing a continental boundary through Timbuktu.<br/><br/>If this gets people to ask more questions about instruction design, I'm happy to answer them. AMA. (In a previous life I did processor architecture research.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591036125.269900"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591036125.269900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-06-01 11:28</span><br/>
I agree with Kartik that they are marketing terms. My statement that uCISC "takes the RISC philosophy one step further" is also a marketing claim that I happen to think sounds cool. The term RISC was coined by Dave Patterson. The original idea was that by using a small simple instruction set and a simple micro-architecture, you need fewer transistors for a given amount of compute, or conversely, you get more compute out of a given transistor budget.<br/><br/>From the abstract of the original RISC paper by Patterson: "The limited number of instructions and addressing modes leads to a small control section and to a short machine cycle time. Such a machine also requires a much smaller layout effort and thus leads to a shorter design cycle." Doesn't this also apply to uCISC?<br/><br/><a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">https://www2.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591083718.271600"></a>
      <img src="https://avatars.slack-edge.com/2020-05-30/1167794177073_5446491963e3446625b7_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591083718.271600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Butler</b>
<span style="margin:2em; color:#606060">2020-06-02 00:41</span><br/>
Yeah, those were definitely some of my design goals.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591945185.286100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../introduce-yourself/1590881147.261300.html#1591945185.286100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-06-11 23:59</span><br/>
Just to circle back here, <span style="background-color:#ccf">@Robert Butler</span>: even though I suggested the name uCISC, I would recommend not identifying with one side of the CISC vs RISC debate. So take out the defense of CISC in places like <a href="https://github.com/grokthis/ucisc/blob/master/docs/02_Design_Goals.md">https://github.com/grokthis/ucisc/blob/master/docs/02_Design_Goals.md</a>. In the end the goal is a good design, not being ideologically consistent. These ideological categories are part of the map, not the territory. They're mostly in our heads and can keep us from seeing reality clearly.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
