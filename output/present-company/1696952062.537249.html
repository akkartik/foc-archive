<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #present-company</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-04-06/5085861186081_e3e6bba2ae4575d17358_72.jpg" style="float:left"/>
      <a href="../present-company/1696952062.537249.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Alan Hjelle</b>
<span style="margin:2em; color:#606060">2023-10-10 08:34</span><br/>
I was curious this morning: my naïve view of compiler history is that they used to be very small (due to performance constraints) and have gotten very complicated over the years in order to support multiple platforms and in order to employ more and more optimizations. Is that generally a fair take? What are the big changes to compiler architectures from the early days? Does something like LLVM produce enough better code to justify its complexity? Are there any blog post- or paper-length history of compilers articles out there? (I'm not quite so curious as to be ready to read a whole book, but if you've got a good recommendation…)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1696971900.506849"></a>
      <img src="https://secure.gravatar.com/avatar/bc993d98fe7bf26c048ac0818a598d4d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0001-72.png" style="float:left"/>
      <a href="../present-company/1696952062.537249.html#1696971900.506849" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mark Dewing</b>
<span style="margin:2em; color:#606060">2023-10-10 14:05</span><br/>
One change is that companies don't need to build their own complete compiler anymore.  Previously, each company might buy a front end (e.g. EDG) for parsing, but the rest of the compiler they had to build in-house (or go complete open and extend gcc).  In addition to hardware performance constraints, the compiler size (and complexity) was limited to what size compiler team a company was willing to fund.  With LLVM, companies can focus on the pieces specific to their needs.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1697015559.901719"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../present-company/1696952062.537249.html#1697015559.901719" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2023-10-11 02:12</span><br/>
 The question “is it worth it” is pretty hard to answer. There can be different assessments of the cost of LLVM being such a big project, and there are debates about how much the optimizations in LLVM matter, compared to a smaller compiler (see the discussion around Daniel Bernstein’s “the death of optimizing compilers”).<br/><br/>Throat clearing done, Bernstein is wrong, and the answer is “yes, it’s worth it.”
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
