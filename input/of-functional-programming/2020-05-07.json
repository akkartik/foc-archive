[
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1588840584.020400",
        "client_msg_id": "f0573478-13fd-491e-aaf2-539b5deb807f",
        "text": "For me FP hits its stride somewhere between non-strict evaluation and type classes.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1588813244.019700",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yMyp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For me FP hits its stride somewhere between non-strict evaluation and type classes."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1588856960.020700",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1588857670.000000"
        },
        "client_msg_id": "cb05f601-01f5-4918-b24a-f08db5c93a66",
        "text": "<@UC2A2ARPT> After Fortran exploded onto the scene in 1956, the record suggests that in the late 1950's, computer scientists on both sides of the Atlantic were working on programming languages inspired by lambda calculus.\n\nThe lambda calculus is a mathematical formalism: it is a model of the \"recursive functions\" aka the \"computable functions\". It is not a programming language. For one thing, there is no defined order of evaluation. Two popular choices are applicative order (most programming languages) and normal order (Algol 60 and Haskell). Normal order evaluation is more powerful, because it terminates and produces a result in cases where applicative order evaluation fails to terminate.\n\nOn the American side, McCarthy was a theoretician, and LISP was originally intended to be a mathematical model of the recursive functions, heavily inspired by lambda calculus, that was also executable on a computer. The ability to represent lambda expressions as data structures (\"S-expressions\" or symbolic expressions) was a key idea of Lisp. It led to Lisp FEXPRs and macros. But the identification of functions with LAMBDA expressions prevented early LISP from representing function values as closures or supporting lexical scoping. LISP has always used applicative order evaluation (except for FEXPRs and MACROs).\n\nAcross the Atlantic, Algol 60 was the successor to Algol 58 (aka IAL). In Algol 60, function parameters by default use \"call by name\" as the parameter passing mechanism (normal order evaluation). If you explicitly use the \"value\" keyword then you get \"call by value\", aka applicative order evaluation. It's just like using the ! operator in Haskell to force a function parameter to be strict. Allegedly, this strange choice of \"call by name\" as the default parameter passing mechanism was directly inspired by lambda calculus, where normal order evaluation is more powerful. I'd like to know who put normal order evaluation into the Algol 60 standard.\n\nHowever, Algol 60 is an imperative language, and the interaction between call-by-name and side effects made programs difficult to understand. The performance was also terrible, so call-by name gained a bad reputation and was dropped. It didn't reappear (AFAIK) until Haskell.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1588813244.019700",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+xT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " After Fortran exploded onto the scene in 1956, the record suggests that in the late 1950's, computer scientists on both sides of the Atlantic were working on programming languages inspired by lambda calculus.\n\nThe lambda calculus is a mathematical formalism: it is a model of the \"recursive functions\" aka the \"computable functions\". It is not a programming language. For one thing, there is no defined order of evaluation. Two popular choices are applicative order (most programming languages) and normal order (Algol 60 and Haskell). Normal order evaluation is more powerful, because it terminates and produces a result in cases where applicative order evaluation fails to terminate.\n\nOn the American side, McCarthy was a theoretician, and LISP was originally intended to be a mathematical model of the recursive functions, heavily inspired by lambda calculus, that was also executable on a computer. The ability to represent lambda expressions as data structures (\"S-expressions\" or symbolic expressions) was a key idea of Lisp. It led to Lisp FEXPRs and macros. But the identification of functions with LAMBDA expressions prevented early LISP from representing function values as closures or supporting lexical scoping. LISP has always used applicative order evaluation (except for FEXPRs and MACROs).\n\nAcross the Atlantic, Algol 60 was the successor to Algol 58 (aka IAL). In Algol 60, function parameters by default use \"call by name\" as the parameter passing mechanism (normal order evaluation). If you explicitly use the \"value\" keyword then you get \"call by value\", aka applicative order evaluation. It's just like using the ! operator in Haskell to force a function parameter to be strict. Allegedly, this strange choice of \"call by name\" as the default parameter passing mechanism was directly inspired by lambda calculus, where normal order evaluation is more powerful. I'd like to know who put normal order evaluation into the Algol 60 standard.\n\nHowever, Algol 60 is an imperative language, and the interaction between call-by-name and side effects made programs difficult to understand. The performance was also terrible, so call-by name gained a bad reputation and was dropped. It didn't reappear (AFAIK) until Haskell."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]