[
    {
        "user": "UUQ2EQW21",
        "type": "message",
        "ts": "1670255358.965499",
        "client_msg_id": "8ec8e56f-fb69-40b8-8467-7570933c6749",
        "text": "The guy at the top of this year's advent of code leader board (by some margin) is using a language he made himself (noulith), which is implemented in Rust (linked on the below page, which shows some of his solutions).  It even has a syntax highlighted CLI.  Next level for sure.  But interesting that he can 'optimize' his chances in so many varied puzzles by having his own language.  Of course, maybe he'd be just as fast in Python; but I wonder what there is to learn from his language design, if anything.\n<https:\/\/github.com\/betaveros\/advent-of-code-2022>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g2266cacc8f3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Chris",
            "real_name": "Chris Maughan",
            "display_name": "Chris Maughan",
            "team": "T5TCAFTA9",
            "name": "mornymorny",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1670255358.965499",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1670523891.551589",
        "reply_users": [
            "U04BP42ABFU"
        ],
        "replies": [
            {
                "user": "U04BP42ABFU",
                "ts": "1670523891.551589"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VPOZO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The guy at the top of this year's advent of code leader board (by some margin) is using a language he made himself (noulith), which is implemented in Rust (linked on the below page, which shows some of his solutions).  It even has a syntax highlighted CLI.  Next level for sure.  But interesting that he can 'optimize' his chances in so many varied puzzles by having his own language.  Of course, maybe he'd be just as fast in Python; but I wonder what there is to learn from his language design, if anything.\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/betaveros\/advent-of-code-2022"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U013ZLJARC7",
                    "U04BP42ABFU"
                ],
                "count": 2
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1670257585.817779",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1670274508.000000"
        },
        "client_msg_id": "8d5f7983-fef5-45e2-84e3-ba2160f619e6",
        "text": "Yes!\n\nAny problem can be viewed from multiple perspectives.\n\nSome views are more fruitful than others.\n\nHow do you know which views to use?\n\nYou don’t.  Experts, Senior Architects, Senior Engineers know which views to use.\n\nHow do Experts know this?\n\n1. Trial-and-error over the years.\n2. Apprenticing with Experts who preceded them.\nCan a machine figure out which views are the best?\n\nNo.\n\nA machine cannot figure out which views are the best.  Only an Expert can tell you which views to use.  A machine is but a tool.  An expert can specify which knobs to put on a machine and how much to turn each knob to achieve the most fruitful perspectives, but, the machine can’t figure out how to do this by itself.\n\nThe 2022++ computer medium is like a piece of paper and a pencil.  In the right hands it can convey a great deal of meaning.\n\nIn fact, 2022++ computers allow humans - for the first time?- to explore and visualize issues in 4 dimensions - x\/y\/z\/t.  Paper and pencil and clay tablets forced humans to collapse 4D concepts down to 2D for the sake of the written notation.\n\nHow does all of this manifest itself in Software and Programming?\n\nFor starters, we might use *multiple* languages for any problem.  Nano-languages - I call them SCNs (Solution Centric Notations).\n\nExamples:\n• one view of computers is “everything is a byte” - the notation is C\n• one view of computers is “everything is a string” - the notation is Perl, Icon, SNOBOL, Tcl\/Tk, etc.\n• one view of computers is “everything is a browsable web page” - the notation is HTML\n• one view of software is “everything is a hierarchical wrapper” - the notation is Smalltalk (OO)\n• one view of software is “everything is a function” - the notation is FP, Lambda Calculus, etc.\n• one view of software is “everything has state”  - the notation is StateCharts, Actors\n• one view is that “history matters, sequencing matters” - the notation is state machines - the *anti*-notation for this is functional notation, which outright discards history\n• one view of programming is “everything is a sequential set of functions” - the notation is FP and written mathematics\n• one view of programming is “everything is an asynchronous Component” - the notation is FBP, Actors, UNIX shell pipelines, ė[^eh], etc.\n[^eh]: I happen to be interested in exploring the rathole of asynchronous, pluggable Components.  I am exploring a notation\/functionality\/IDE\/... that I call ė.  I think that I have isolated some sub-atomic particles of concurrency and call the main one “0D”.\n\nConclusion:\n\nDon’t try to guess, let the Experts *tell* you which Views to use.\n\nHow?\n\nFind a way to allow Experts to create views - SCNs - quickly (in minutes instead of in years).\n\nRecursive Q: what is a fruitful view of the problem of how to let Experts create SCNs easily and quickly? A: Create multiple grammars to drape multiple syntaxes over various paradigms, let Experts reach into a toolbox to let them pull out and use bits and pieces of useful functionality.\n\nSuggestion:\n1. use Ohm-JS for creating syntaxes \n2. use Lisp as the toolbox[^js]\n3. use debuggers, honed by Experts over the years[^debuggers]\n4. build software as pluggable Components[^0d]\n[^js]: Aside: if you have an allergy to using Lisp, I have found that JavaScript and Python work acceptably, too, as toolbox languages (except for their pesky syntaxes)\n[^debuggers]: After all, the Experts in debugging have determined - by trial-and-error, and, by listening to customer demands, and, by learning from others - what works best when debugging and what doesn’t work when debugging.\n[^0d]: 0D, IMO, is the secret sauce of Componentizing software\n\nLispWorks is a better debugger than SBCL.  SBCL is a better debugger than VSCODE. Iterative design is better than waterfall design.  Debugging is a better way to design something than just inventing all of it in one fell swoop without a debugger and without iteration. Optimization should be applied only after-the-fact to a working design (i.e. eschew “premature optimization”).  Type checking mainly helps when optimizing (it attempts to guarantee that the optimized code faithfully represents the original design, but, it gets in the way of free-thinking during Design).\n\nOhm-JS is better than PEG. PEG is better than Language Theoretical compiler generators (e.g. YACC, LR(k), etc., etc.).\n\nLisp and Assembler share common traits:\n• expression language \n• easy to bolt pieces together to make bigger pieces\n• Assembler pieces are arranged as *lines of text*\n• Lisp pieces are arranged as recursive *trees of Atoms and trees* (*tree* is also known as *list*)\n• lack of pesky syntax (you don’t want your toolbox language to have an opinion about which syntax\/view you need to be using).\nMaybe there are other languages that have these traits?  I don’t know.  OTOH Lisp (and Assembler) has been around for looong time and Experts have tuned it to be a good toolbox. And, I am comfortable with Lisp.\n\nFP has been around a loooong time, too, in the form of written mathematics. In fact, Lisp was based on mathematical notation.  Computer hardware goes beyond what can *easily* be described using written mathematics, e.g. history (sequencing, DAWs, iMovie, robotics, blockchain protocols, IoT, etc.), mutation (RAM), asynchonosity (non-von-Neumann architectures), etc.\n\nIt should be noted that FP is simply *one notation* that can be fruitfully used to describe computer programming.  There are other notations that fruitfully describe non-FP aspects of computers better than FP can describe them.\n\nClaiming that one notation is *The Best* notation is a common human behaviour.  It is so common, that it has been given a name - “fad”.\n\nIMO, it is fruitless to continue inventing new languages and amazing features as one-shot deals.  We need to invent new ways to invent new languages quickly (i.e. in minutes).  We need to solve problems by inventing multiple SCNs (nano-languages) for the various views of problems.  We need to use multiple SCNs to solve little sub-problems, then bolt the solutions together into larger solutions.\n\nRecursively.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1669931082.605639",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LsIrz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes!\n\nAny problem can be viewed from multiple perspectives.\n\nSome views are more fruitful than others.\n\nHow do you know which views to use?\n\nYou don’t.  Experts, Senior Architects, Senior Engineers know which views to use.\n\nHow do Experts know this?\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Trial-and-error over the years."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Apprenticing with Experts who preceded them."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCan a machine figure out which views are the best?\n\nNo.\n\nA machine cannot figure out which views are the best.  Only an Expert can tell you which views to use.  A machine is but a tool.  An expert can specify which knobs to put on a machine and how much to turn each knob to achieve the most fruitful perspectives, but, the machine can’t figure out how to do this by itself.\n\nThe 2022++ computer medium is like a piece of paper and a pencil.  In the right hands it can convey a great deal of meaning.\n\nIn fact, 2022++ computers allow humans - for the first time?- to explore and visualize issues in 4 dimensions - x\/y\/z\/t.  Paper and pencil and clay tablets forced humans to collapse 4D concepts down to 2D for the sake of the written notation.\n\nHow does all of this manifest itself in Software and Programming?\n\nFor starters, we might use "
                            },
                            {
                                "type": "text",
                                "text": "multiple",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " languages for any problem.  Nano-languages - I call them SCNs (Solution Centric Notations).\n\nExamples:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "one view of computers is “everything is a byte” - the notation is C"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "one view of computers is “everything is a string” - the notation is Perl, Icon, SNOBOL, Tcl\/Tk, etc."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "one view of computers is “everything is a browsable web page” - the notation is HTML"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "one view of software is “everything is a hierarchical wrapper” - the notation is Smalltalk (OO)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "one view of software is “everything is a function” - the notation is FP, Lambda Calculus, etc."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "one view of software is “everything has state”  - the notation is StateCharts, Actors"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "one view is that “history matters, sequencing matters” - the notation is state machines - the "
                                    },
                                    {
                                        "type": "text",
                                        "text": "anti",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "-notation for this is functional notation, which outright discards history"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "one view of programming is “everything is a sequential set of functions” - the notation is FP and written mathematics"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "one view of programming is “everything is an asynchronous Component” - the notation is FBP, Actors, UNIX shell pipelines, ė[^eh], etc."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n[^eh]: I happen to be interested in exploring the rathole of asynchronous, pluggable Components.  I am exploring a notation\/functionality\/IDE\/... that I call ė.  I think that I have isolated some sub-atomic particles of concurrency and call the main one “0D”.\n\nConclusion:\n\nDon’t try to guess, let the Experts "
                            },
                            {
                                "type": "text",
                                "text": "tell",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " you which Views to use.\n\nHow?\n\nFind a way to allow Experts to create views - SCNs - quickly (in minutes instead of in years).\n\nRecursive Q: what is a fruitful view of the problem of how to let Experts create SCNs easily and quickly? A: Create multiple grammars to drape multiple syntaxes over various paradigms, let Experts reach into a toolbox to let them pull out and use bits and pieces of useful functionality.\n\nSuggestion:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "use Ohm-JS for creating syntaxes "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "use Lisp as the toolbox[^js]"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "use debuggers, honed by Experts over the years[^debuggers]"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "build software as pluggable Components[^0d]"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n[^js]: Aside: if you have an allergy to using Lisp, I have found that JavaScript and Python work acceptably, too, as toolbox languages (except for their pesky syntaxes)\n[^debuggers]: After all, the Experts in debugging have determined - by trial-and-error, and, by listening to customer demands, and, by learning from others - what works best when debugging and what doesn’t work when debugging.\n[^0d]: 0D, IMO, is the secret sauce of Componentizing software\n\nLispWorks is a better debugger than SBCL.  SBCL is a better debugger than VSCODE. Iterative design is better than waterfall design.  Debugging is a better way to design something than just inventing all of it in one fell swoop without a debugger and without iteration. Optimization should be applied only after-the-fact to a working design (i.e. eschew “premature optimization”).  Type checking mainly helps when optimizing (it attempts to guarantee that the optimized code faithfully represents the original design, but, it gets in the way of free-thinking during Design).\n\nOhm-JS is better than PEG. PEG is better than Language Theoretical compiler generators (e.g. YACC, LR(k), etc., etc.).\n\nLisp and Assembler share common traits:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "expression language "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "easy to bolt pieces together to make bigger pieces"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Assembler pieces are arranged as "
                                    },
                                    {
                                        "type": "text",
                                        "text": "lines of text",
                                        "style": {
                                            "bold": true
                                        }
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Lisp pieces are arranged as recursive "
                                    },
                                    {
                                        "type": "text",
                                        "text": "trees of Atoms and trees",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " ("
                                    },
                                    {
                                        "type": "text",
                                        "text": "tree",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " is also known as "
                                    },
                                    {
                                        "type": "text",
                                        "text": "list",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": ")"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "lack of pesky syntax (you don’t want your toolbox language to have an opinion about which syntax\/view you need to be using)."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe there are other languages that have these traits?  I don’t know.  OTOH Lisp (and Assembler) has been around for looong time and Experts have tuned it to be a good toolbox. And, I am comfortable with Lisp.\n\nFP has been around a loooong time, too, in the form of written mathematics. In fact, Lisp was based on mathematical notation.  Computer hardware goes beyond what can "
                            },
                            {
                                "type": "text",
                                "text": "easily",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " be described using written mathematics, e.g. history (sequencing, DAWs, iMovie, robotics, blockchain protocols, IoT, etc.), mutation (RAM), asynchonosity (non-von-Neumann architectures), etc.\n\nIt should be noted that FP is simply "
                            },
                            {
                                "type": "text",
                                "text": "one notation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that can be fruitfully used to describe computer programming.  There are other notations that fruitfully describe non-FP aspects of computers better than FP can describe them.\n\nClaiming that one notation is "
                            },
                            {
                                "type": "text",
                                "text": "The Best",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " notation is a common human behaviour.  It is so common, that it has been given a name - “fad”.\n\nIMO, it is fruitless to continue inventing new languages and amazing features as one-shot deals.  We need to invent new ways to invent new languages quickly (i.e. in minutes).  We need to solve problems by inventing multiple SCNs (nano-languages) for the various views of problems.  We need to use multiple SCNs to solve little sub-problems, then bolt the solutions together into larger solutions.\n\nRecursively."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1670261711.325459",
        "client_msg_id": "e00e0121-3f8a-4f94-9a72-a21fbfdfb2a5",
        "text": "Interesting long-tail tool-for-thought\n\n<https:\/\/leahneukirchen.org\/blog\/archive\/2022\/03\/note-taking-in-emacs-with-howm.html>\n\nThis bit is particularly tantalizing:\n&gt; There are two kinds of links supported by howm, namely *goto* and *come-from* (in a nod to INTERCAL). *goto* links are forward references and written like this:\n&gt; ```&gt;&gt;&gt; howm```\n&gt; Pressing return on this line when `howm-mode` is enabled will show a list of all occurences of the word `howm` in your notes directory.\n&gt; In contrast, a *come-from* link is written like this:\n&gt; ```&lt;&lt;&lt; howm```\n&gt; And this will cause the word `howm` in any howm-mode buffer to be underlined and trigger a search where the buffer with `&lt;&lt;&lt; howm` will appear first.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sl8U",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Interesting long-tail tool-for-thought\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/leahneukirchen.org\/blog\/archive\/2022\/03\/note-taking-in-emacs-with-howm.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThis bit is particularly tantalizing:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There are two kinds of links supported by howm, namely "
                            },
                            {
                                "type": "text",
                                "text": "goto",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "come-from",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (in a nod to INTERCAL). "
                            },
                            {
                                "type": "text",
                                "text": "goto",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " links are forward references and written like this:"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": ">>> howm"
                            }
                        ],
                        "border": 1
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Pressing return on this line when "
                            },
                            {
                                "type": "text",
                                "text": "howm-mode",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is enabled will show a list of all occurences of the word "
                            },
                            {
                                "type": "text",
                                "text": "howm",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in your notes directory.\nIn contrast, a "
                            },
                            {
                                "type": "text",
                                "text": "come-from",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " link is written like this:"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "<<< howm"
                            }
                        ],
                        "border": 1
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And this will cause the word "
                            },
                            {
                                "type": "text",
                                "text": "howm",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in any howm-mode buffer to be underlined and trigger a search where the buffer with "
                            },
                            {
                                "type": "text",
                                "text": "<<< howm",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " will appear first."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1670269571.503269",
        "client_msg_id": "209b63c0-eceb-4b31-b638-d5968c65336a",
        "text": "FYI: I am trying out Kinopio for notes.  Kinopio has GOTO and COMEFROM (but doesn’t use those names).  Before that I used Obsidian and before that I used emacs.  My original interest in Kinopio was to use it as a programming language, but I haven’t gone there yet and am stuck using <http:\/\/draw.io|draw.io> as a programming language.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1670269571.503269",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1670269766.260019",
        "reply_users": [
            "USH01JEDQ"
        ],
        "replies": [
            {
                "user": "USH01JEDQ",
                "ts": "1670269766.260019"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "po\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FYI: I am trying out Kinopio for notes.  Kinopio has GOTO and COMEFROM (but doesn’t use those names).  Before that I used Obsidian and before that I used emacs.  My original interest in Kinopio was to use it as a programming language, but I haven’t gone there yet and am stuck using "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/draw.io",
                                "text": "draw.io"
                            },
                            {
                                "type": "text",
                                "text": " as a programming language."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "USH01JEDQ",
        "type": "message",
        "ts": "1670269766.260019",
        "client_msg_id": "0730bded-20fb-4d92-a079-af4860952a2f",
        "text": "<https:\/\/kinopio.club\/|Kinopio> is fun and lovely – Pirijan is def one of us",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "854f96b690f5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-12-17\/6370745671793_854f96b690f51d1266ee_72.png",
            "first_name": "Christopher",
            "real_name": "Christopher Galtenberg",
            "display_name": "Chris G",
            "team": "T5TCAFTA9",
            "name": "galtenberg",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1670269571.503269",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SzRYB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/kinopio.club\/",
                                "text": "Kinopio"
                            },
                            {
                                "type": "text",
                                "text": " is fun and lovely – Pirijan is def one of us"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]