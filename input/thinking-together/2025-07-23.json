[
    {
        "user": "U096YUBC3KP",
        "type": "message",
        "ts": "1753274424.111109",
        "client_msg_id": "6a2f580d-34e6-4348-8551-a78c744c7e4e",
        "text": "Hrm, I think that \"distributed reactive programming\" describes what I am trying to invent at work. The ingredients that led me to this are:\n• A complicated domain entity at the heart of our app, with complex internals and a lot of business logic tightly connected\n• We want some interactions to be as-you-type in the browser, and in general we want all results to be calculated \"as you edit\" rather than by clicking a \"run simulation\" button \n• Some calculated results can take multiple seconds to complete due to intensive algorithms\n• Some calculations we don't want to distribute to the browser so we can keep our implementation private\nThis all has led me towards something like:\n• Read \"out of the Tarpit\" and decide to crack down on storing only essential state and calculating all the derived state, and relying on caching for performance\n• Read <https:\/\/lord.io\/spreadsheets\/|https:\/\/lord.io\/spreadsheets\/> and try to implement invalidation algorithms\n• Build in some kind of networking protocol so that nodes in the data flow graph can be transparently \"replaced\" with implementations on the other side of a network\n• Try to make the API \"look like\" Vue's implicit dependency tracking \nI'm not finished with this and have had several goes at it. I vacillate between thinking this is all over complicated and I should give up on the dream of a fancy in-house data flow engine, and thinking this is going to be incredible if I can just solve cache invalidation.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd73c13a9fb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-07-24\/9258602927281_cbd73c13a9fbc1999873_72.jpg",
            "first_name": "Daniel",
            "real_name": "Daniel Buckmaster",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "daniel961",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1751954442.859169",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6Unpf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hrm, I think that \"distributed reactive programming\" describes what I am trying to invent at work. The ingredients that led me to this are:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A complicated domain entity at the heart of our app, with complex internals and a lot of business logic tightly connected"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "We want some interactions to be as-you-type in the browser, and in general we want all results to be calculated \"as you edit\" rather than by clicking a \"run simulation\" button "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Some calculated results can take multiple seconds to complete due to intensive algorithms"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Some calculations we don't want to distribute to the browser so we can keep our implementation private"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "offset": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This all has led me towards something like:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Read \"out of the Tarpit\" and decide to crack down on storing only essential state and calculating all the derived state, and relying on caching for performance"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Read "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https:\/\/lord.io\/spreadsheets\/",
                                        "text": "https:\/\/lord.io\/spreadsheets\/"
                                    },
                                    {
                                        "type": "text",
                                        "text": " and try to implement invalidation algorithms"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Build in some kind of networking protocol so that nodes in the data flow graph can be transparently \"replaced\" with implementations on the other side of a network"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Try to make the API \"look like\" Vue's implicit dependency tracking "
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "offset": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not finished with this and have had several goes at it. I vacillate between thinking this is all over complicated and I should give up on the dream of a fancy in-house data flow engine, and thinking this is going to be incredible if I can just solve cache invalidation."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U018S42NMMM",
        "type": "message",
        "ts": "1753296752.660159",
        "client_msg_id": "b2644b30-8e74-4a53-9085-49395ee30570",
        "text": "<@U096YUBC3KP> Yeah, I'm in the same boat. :slightly_smiling_face:\n\nI came across an interesting paper that explored mixing of imperative code and reactive code which you might find interesting: <https:\/\/arxiv.org\/abs\/2306.12313>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "972d4c887a7c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-10\/4782052692709_972d4c887a7c689aae4a_72.jpg",
            "first_name": "",
            "real_name": "Nilesh Trivedi",
            "display_name": "Nilesh Trivedi",
            "team": "T5TCAFTA9",
            "name": "nilesh.tr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1751954442.859169",
        "parent_user_id": "U018S42NMMM",
        "attachments": [
            {
                "from_url": "https:\/\/arxiv.org\/abs\/2306.12313",
                "service_icon": "https:\/\/arxiv.org\/static\/browse\/0.3.4\/images\/icons\/apple-touch-icon.png",
                "thumb_url": "https:\/\/arxiv.org\/static\/browse\/0.3.4\/images\/arxiv-logo-fb.png",
                "thumb_width": 1200,
                "thumb_height": 700,
                "id": 1,
                "original_url": "https:\/\/arxiv.org\/abs\/2306.12313",
                "fallback": "arXiv.org: Tackling the Awkward Squad for Reactive Programming: The Actor-Reactor Model",
                "text": "Reactive programming is a programming paradigm whereby programs are internally represented by a dependency graph, which is used to automatically (re)compute parts of a program whenever its input changes. In practice reactive programming can only be used for some parts of an application: a reactive program is usually embedded in an application that is still written in ordinary imperative languages such as JavaScript or Scala. In this paper we investigate this embedding and we distill \"the awkward squad for reactive programming\" as 3 concerns that are essential for real-world software development, but that do not fit within reactive programming. They are related to long lasting computations, side-effects, and the coordination between imperative and reactive code. To solve these issues we design a new programming model called the Actor-Reactor Model in which programs are split up in a number of actors and reactors. Actors and reactors enforce a strict separation of imperative and reactive code, and they can be composed via a number of composition operators that make use of data streams. We demonstrate the model via our own implementation in a language called Stella.",
                "title": "Tackling the Awkward Squad for Reactive Programming: The Actor-Reactor Model",
                "title_link": "https:\/\/arxiv.org\/abs\/2306.12313",
                "service_name": "arXiv.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "d+LFv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U096YUBC3KP"
                            },
                            {
                                "type": "text",
                                "text": " Yeah, I'm in the same boat. "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI came across an interesting paper that explored mixing of imperative code and reactive code which you might find interesting: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/arxiv.org\/abs\/2306.12313"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "U096YUBC3KP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1753300415.904819",
        "client_msg_id": "45613b82-978c-4c9c-8722-89fad2967e8d",
        "text": "&gt;  and thinking this is going to be incredible if I can just solve cache invalidation.\n<https:\/\/github.com\/observablehq\/runtime\/blob\/622a1974087f03545b5e91c8625b46874e82e4df\/src\/runtime.js#L82>\nmarks variables as dirty, marks a subset as reachable (they are on the page). Then  does the transitive closure of the dirty set and updates in topological order. If a cell has not been marked dirty, it is not recomputed. Because it computes all its tracking stuff up front, I think it can support dynamic mutation of the dataflow graph. Glitches get deduped out coz its a batch algorithm.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1751954442.859169",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VKhVr",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " and thinking this is going to be incredible if I can just solve cache invalidation."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/observablehq\/runtime\/blob\/622a1974087f03545b5e91c8625b46874e82e4df\/src\/runtime.js#L82"
                            },
                            {
                                "type": "text",
                                "text": "\nmarks variables as dirty, marks a subset as reachable (they are on the page). Then  does the transitive closure of the dirty set and updates in topological order. If a cell has not been marked dirty, it is not recomputed. Because it computes all its tracking stuff up front, I think it can support dynamic mutation of the dataflow graph. Glitches get deduped out coz its a batch algorithm."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U05UK5T7LPP",
                    "U096YUBC3KP"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1753300564.720819",
        "client_msg_id": "55269bcd-d8f2-4659-ba5f-778ed131c249",
        "text": "Inspiration from today's demo meetup: <@U018S42NMMM> casually tossed out the idea that there are 2 kinds of edges between software units: edge (visible line) and containment (invisible(?), but, easy to calculate using bounding boxes). I think that containment is important, but, I've been avoiding it because I could only think of complicated ways to represent it. If it's \"just\" an edge, then the problem is solved :face_palm:. I've used Prolog (exhaustive search using backtracking) in the past to infer edge information from JSON (SWIPL even knows how to inhale and exhale JSON). Now that backtracking is no longer a verbotten technique (OhmJS, Prolog, miniKanren, Nils Holm's Scheme code &amp; transpilations of that code to other PLs, cl-holm, etc.) it should be straight-forward to create DPLs that use \"containment\" visual syntax. Hmmm...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1753300564.720819",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1753326848.158929",
        "reply_users": [
            "U018S42NMMM"
        ],
        "replies": [
            {
                "user": "U018S42NMMM",
                "ts": "1753326848.158929"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9R4Nx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Inspiration from today's demo meetup: "
                            },
                            {
                                "type": "user",
                                "user_id": "U018S42NMMM"
                            },
                            {
                                "type": "text",
                                "text": " casually tossed out the idea that there are 2 kinds of edges between software units: edge (visible line) and containment (invisible(?), but, easy to calculate using bounding boxes). I think that containment is important, but, I've been avoiding it because I could only think of complicated ways to represent it. If it's \"just\" an edge, then the problem is solved "
                            },
                            {
                                "type": "emoji",
                                "name": "face_palm",
                                "unicode": "1f926"
                            },
                            {
                                "type": "text",
                                "text": ". I've used Prolog (exhaustive search using backtracking) in the past to infer edge information from JSON (SWIPL even knows how to inhale and exhale JSON). Now that backtracking is no longer a verbotten technique (OhmJS, Prolog, miniKanren, Nils Holm's Scheme code & transpilations of that code to other PLs, cl-holm, etc.) it should be straight-forward to create DPLs that use \"containment\" visual syntax. Hmmm..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05UK5T7LPP",
        "type": "message",
        "ts": "1753300966.432959",
        "edited": {
            "user": "U05UK5T7LPP",
            "ts": "1753301023.000000"
        },
        "client_msg_id": "c825b272-608a-425d-a48c-3aac36d81fb8",
        "text": "c.f. 'glitch free observable reactivity semantics' which demonstrates deduping of updates, as defined above\n<https:\/\/observablehq.com\/@tomlarkworthy\/observable-notes>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "87f45e326f3a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-09-30\/5997119242352_87f45e326f3a692ca55c_72.png",
            "first_name": "Jasmine",
            "real_name": "Jasmine Otto",
            "display_name": "Jasmine Otto",
            "team": "T5TCAFTA9",
            "name": "ottojasmine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1751954442.859169",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "77Y\/B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "c.f. 'glitch free observable reactivity semantics' which demonstrates deduping of updates, as defined above\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/observablehq.com\/@tomlarkworthy\/observable-notes"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U096YUBC3KP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U018S42NMMM",
        "type": "message",
        "ts": "1753326848.158929",
        "client_msg_id": "413479e5-de46-45fb-b2aa-55fcc2b2beb3",
        "text": "Relevant for visual layout of such graphs: <https:\/\/arxiv.org\/abs\/2408.04045>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "972d4c887a7c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-10\/4782052692709_972d4c887a7c689aae4a_72.jpg",
            "first_name": "",
            "real_name": "Nilesh Trivedi",
            "display_name": "Nilesh Trivedi",
            "team": "T5TCAFTA9",
            "name": "nilesh.tr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1753300564.720819",
        "parent_user_id": "UGWUJUZHT",
        "attachments": [
            {
                "from_url": "https:\/\/arxiv.org\/abs\/2408.04045",
                "service_icon": "https:\/\/arxiv.org\/static\/browse\/0.3.4\/images\/icons\/apple-touch-icon.png",
                "thumb_url": "https:\/\/arxiv.org\/static\/browse\/0.3.4\/images\/arxiv-logo-fb.png",
                "thumb_width": 1200,
                "thumb_height": 700,
                "id": 1,
                "original_url": "https:\/\/arxiv.org\/abs\/2408.04045",
                "fallback": "arXiv.org: An Overview + Detail Layout for Visualizing Compound Graphs",
                "text": "Compound graphs are networks in which vertices can be grouped into larger subsets, with these subsets capable of further grouping, resulting in a nesting that can be many levels deep. In several applications, including biological workflows, chemical equations, and computational data flow analysis, these graphs often exhibit a tree-like nesting structure, where sibling clusters are disjoint. Common compound graph layouts prioritize the lowest level of the grouping, down to the individual ungrouped vertices, which can make the higher level grouped structures more difficult to discern, especially in deeply nested networks. Leveraging the additional structure of the tree-like nesting, we contribute an overview+detail layout for this class of compound graphs that preserves the saliency of the higher level network structure when groups are expanded to show internal nested structure. Our layout draws inner structures adjacent to their parents, using a modified tree layout to place substructures. We describe our algorithm and then present case studies demonstrating the layout's utility to a domain expert working on data flow analysis. Finally, we discuss network parameters and analysis situations in which our layout is well suited.",
                "title": "An Overview + Detail Layout for Visualizing Compound Graphs",
                "title_link": "https:\/\/arxiv.org\/abs\/2408.04045",
                "service_name": "arXiv.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kA7EI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Relevant for visual layout of such graphs: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/arxiv.org\/abs\/2408.04045"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U023V63MF6V"
                ],
                "count": 1
            }
        ]
    }
]