[
    {
        "user": "U0264CJ5W83",
        "type": "message",
        "ts": "1631117844.122100",
        "client_msg_id": "f681ffa3-641c-477b-8c7e-9926082d5238",
        "text": "<@UJBAJNFLK> curious why you think monads are messy",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e3142da7de3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-06-24\/2193499626679_e3142da7de3f64211bb6_72.jpg",
            "first_name": "",
            "real_name": "Tony O'Dell",
            "display_name": "Tony O'Dell",
            "team": "T5TCAFTA9",
            "name": "tony.odell",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jPm\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " curious why you think monads are messy"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1631118968.122300",
        "client_msg_id": "249d67db-eb9d-4d90-a881-6de2f5d9eda2",
        "text": "<@U0264CJ5W83> It's not monads as such that are messy, but their use as a substitute for exception mechanisms. In each function at each level of your software stack, you have to consider and possibly handle exceptional situations, at the very least by wrapping your types in `Maybe` or some more specific monad. That's a lot of code clutter.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H4omP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0264CJ5W83"
                            },
                            {
                                "type": "text",
                                "text": " It's not monads as such that are messy, but their use as a substitute for exception mechanisms. In each function at each level of your software stack, you have to consider and possibly handle exceptional situations, at the very least by wrapping your types in "
                            },
                            {
                                "type": "text",
                                "text": "Maybe",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or some more specific monad. That's a lot of code clutter."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0264CJ5W83",
        "type": "message",
        "ts": "1631119931.122500",
        "client_msg_id": "da10a955-f02d-41e7-83dc-6591837e7103",
        "text": "what's your take on golang's mess vs the monad pattern matching?  the former gives you a weird mess of if\/thens, the latter provides a little clearer picture (i'm not advocating haskell).\n\n```data, err := web.Get(\"<http:\/\/someservice.com\/health|someservice.com\/health>\")\nif err != nil {\n  if <http:\/\/errors.Is|errors.Is>(err, ErrNotFound) {\n    ...\n  } else if <http:\/\/errors.Is|errors.Is>(err, ErrTimeOut) {\n    ...\n  } else {\n    ...\n  }\n}\n\nvs\n\ncase WebGet(\"<http:\/\/someservice.com\/health|someservice.com\/health>\") of\n  NotFound =&gt; ...\n  TimeOut  =&gt; ...\n  _ =&gt; ...```\n",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e3142da7de3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-06-24\/2193499626679_e3142da7de3f64211bb6_72.jpg",
            "first_name": "",
            "real_name": "Tony O'Dell",
            "display_name": "Tony O'Dell",
            "team": "T5TCAFTA9",
            "name": "tony.odell",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H3CUM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "what's your take on golang's mess vs the monad pattern matching?  the former gives you a weird mess of if\/thens, the latter provides a little clearer picture (i'm not advocating haskell).\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "data, err := web.Get(\"someservice.com\/health\")\nif err != nil {\n  if errors.Is(err, ErrNotFound) {\n    ...\n  } else if errors.Is(err, ErrTimeOut) {\n    ...\n  } else {\n    ...\n  }\n}\n\nvs\n\ncase WebGet(\"someservice.com\/health\") of\n  NotFound => ...\n  TimeOut  => ...\n  _ => ..."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1631121162.122700",
        "client_msg_id": "e11389a1-4885-4f11-8888-ca290c340015",
        "text": "Pattern matching is certainly a bit nicer than conditionals (though it's not clear to me if the increased compiler complexity is a worthwhile trade-off) But I imagine both seem messy if you're anchored on data transfers that skip function calls on the stack.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OK1Y1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Pattern matching is certainly a bit nicer than conditionals (though it's not clear to me if the increased compiler complexity is a worthwhile trade-off) But I imagine both seem messy if you're anchored on data transfers that skip function calls on the stack."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0264CJ5W83",
        "type": "message",
        "ts": "1631122833.122900",
        "client_msg_id": "8c0a63e0-9c59-427d-b694-d1981c65c8a1",
        "text": "seems like complexity might be conflated with unfamiliarity.  i think there's a worse tradeoff made with the if\/else handling in that the compiler can't enumerate the types of errors or ask the user to consider them",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e3142da7de3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-06-24\/2193499626679_e3142da7de3f64211bb6_72.jpg",
            "first_name": "",
            "real_name": "Tony O'Dell",
            "display_name": "Tony O'Dell",
            "team": "T5TCAFTA9",
            "name": "tony.odell",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I8D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "seems like complexity might be conflated with unfamiliarity.  i think there's a worse tradeoff made with the if\/else handling in that the compiler can't enumerate the types of errors or ask the user to consider them"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "U027P92A0N5"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1631128572.123700",
        "client_msg_id": "d93a603f-f346-4cdb-9fdc-d0a1cdd29db1",
        "text": "<@U0264CJ5W83> Your Go example looks exactly like error handling in C. Which is messy as well of course. And, as you say, worse in terms of what the compiler can do usefully. But my argument is based purely on the _human_ aspect of code, and the human way of describing exceptional behaviour is via a separate description of exceptional cases, separate from the normal path.\n\nExample: you describe to a friend how to drive to your house. Turn right there, then left there, etc. Do you add, at every step of your description, \"if you have an accident, call the police?\" I bet you don't.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JFto",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0264CJ5W83"
                            },
                            {
                                "type": "text",
                                "text": " Your Go example looks exactly like error handling in C. Which is messy as well of course. And, as you say, worse in terms of what the compiler can do usefully. But my argument is based purely on the "
                            },
                            {
                                "type": "text",
                                "text": "human",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " aspect of code, and the human way of describing exceptional behaviour is via a separate description of exceptional cases, separate from the normal path.\n\nExample: you describe to a friend how to drive to your house. Turn right there, then left there, etc. Do you add, at every step of your description, \"if you have an accident, call the police?\" I bet you don't."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0264CJ5W83",
        "type": "message",
        "ts": "1631128652.123900",
        "edited": {
            "user": "U0264CJ5W83",
            "ts": "1631128659.000000"
        },
        "client_msg_id": "0c1b1f59-9807-4076-932e-a520bbc82f30",
        "text": "This is an excellent point, but of course if you looked at a map and it only had the road drawn on it that you needed and nothing else it'd be a rather difficult map to read",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e3142da7de3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-06-24\/2193499626679_e3142da7de3f64211bb6_72.jpg",
            "first_name": "",
            "real_name": "Tony O'Dell",
            "display_name": "Tony O'Dell",
            "team": "T5TCAFTA9",
            "name": "tony.odell",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ri1l",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is an excellent point, but of course if you looked at a map and it only had the road drawn on it that you needed and nothing else it'd be a rather difficult map to read"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1631142763.129900",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1631143061.000000"
        },
        "client_msg_id": "67ba14e1-5c88-4c3c-b6c1-1a0dc0a3be79",
        "text": "*Calling all software engineers who know basic category theory:* some applied category theorists in the US are organizing a hackathon to explore how <https:\/\/topos.site\/poly-course\/|the theory of polynomial functors> can be applied to software development (new programming libraries and\/or languages). The attendees would be a mix of software engineers (who know category theory) and category theorists. If you'd be interested in attending or brainstorming about such a hackathon let me know. I've offered to help organize it, but we need more input from software engineers. :slightly_smiling_face: This would be an in-person event in the US, taking place ~March next year.\n\nThere is <https:\/\/topos.site\/poly-course\/|a short course and book draft> on the category of polynomial functors, outlining its applicability to *interactive systems* and *databases*. I expect these applications will be the focus of the hackathon.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1631142763.129900",
        "reply_count": 6,
        "reply_users_count": 2,
        "latest_reply": "1631522890.004600",
        "reply_users": [
            "UN57U8V53",
            "UCGAK10LS"
        ],
        "replies": [
            {
                "user": "UN57U8V53",
                "ts": "1631365343.173900"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1631404772.174300"
            },
            {
                "user": "UN57U8V53",
                "ts": "1631443658.000200"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1631490675.001200"
            },
            {
                "user": "UN57U8V53",
                "ts": "1631520851.004400"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1631522890.004600"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ax1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Calling all software engineers who know basic category theory:",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " some applied category theorists in the US are organizing a hackathon to explore how "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/topos.site\/poly-course\/",
                                "text": "the theory of polynomial functors"
                            },
                            {
                                "type": "text",
                                "text": " can be applied to software development (new programming libraries and\/or languages). The attendees would be a mix of software engineers (who know category theory) and category theorists. If you'd be interested in attending or brainstorming about such a hackathon let me know. I've offered to help organize it, but we need more input from software engineers. "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " This would be an in-person event in the US, taking place ~March next year.\n\nThere is "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/topos.site\/poly-course\/",
                                "text": "a short course and book draft"
                            },
                            {
                                "type": "text",
                                "text": " on the category of polynomial functors, outlining its applicability to "
                            },
                            {
                                "type": "text",
                                "text": "interactive systems",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "databases",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I expect these applications will be the focus of the hackathon."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1631156760.159500",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1631163783.000000"
        },
        "client_msg_id": "7fe743b7-1704-438e-9238-a253931ad7f3",
        "text": "I'm thinking more about the _sensation of time_, as it pertains to the execution of code. (Yeah, back on my bullshit.) I see a spectrum here — a spectrum of different sensations of time for different ways we interact with computation.\n\nOn one end of the spectrum, we have raw math. There's not supposed to be any sensation of time in the evaluation of math. A variable _always_ has a specific value; relationships either exist or they don't. It might take you (or a computer) some time to crunch values and arrive at a result, but that's _absolutely_ _not_ supposed to be part of the aesthetic. Conal Elliot's Denotational Design is an application of this sort of thinking to software design. Lambda calculus, Curry-Howard, and some of the more hardcore FP languages all exist — infinitely, suspended frozen in midair — over here. Of course, no computer language is _actually_ timeless (that violated physics, and this is addressed in Church-Turing and related work, and we all agree never to try that again), but the desired _sensation_ — the aesthetic — is one in which time is not a constraint or concern.\n\nOn the other end of the spectrum, we have mechanical computers. There's no avoiding the sensation of time when operating these clockwork beasts. You're required to think about the passage of time as you plan an execution, or else the result will be nonsense, or malfunction. Nothing is instant, nothing exists until you build it. Here we find the CAP theorem, Turing machines, and Rich Hickey's The Language of the System, all of them toiling, sweating, grinding, churning.\n\n[Aside: note that Functional Programming is orthogonal to this spectrum — it is not bound to the _math_ side. On either extreme and anywhere in between, you can have programming that's about immutable values (or not), static vs dynamic binding, data &amp; behaviour co-located (or not), for-each vs map, place-oriented vs value-oriented, and so forth.]\n\nI've spent all my time over in the _mechanical labour camp_ — this is where Hest lives. So I don't have much insight at all into the _crystal tower of pure evaluation_. So beyond just suggesting \"Hey, talk about this spectrum\" (which, granted, I am suggesting), I'd also like to know what examples you can point to that obviously violate this common alignment of aesthetics. For example: what's the most _*I feel the passage of time in execution*_ you can get to when working with something like Coq, or Haskell, or APL? Is there some step debugger for SML that really lets you feel the iterative progress through execution? Or on the other side, what's out there that takes a process rooted in time — like CAP — and makes it shake that feeling of temporality? Look at something like Erlang\/OTP — they take Prolog (timeless) and reify the sensation of process (\"let it fail\"). Who else is doing that? Is anyone doing it in the other direction?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1631156760.159500",
        "reply_count": 26,
        "reply_users_count": 9,
        "latest_reply": "1631590915.011100",
        "reply_users": [
            "UFPPABQ7P",
            "UDQBTJ211",
            "UBN9AFS0N",
            "UJFN50C00",
            "UJZS8UUJV",
            "UEBG0NPDK",
            "UC2A2ARPT",
            "U8A5MS6R1",
            "UFEQUBNNT"
        ],
        "replies": [
            {
                "user": "UFPPABQ7P",
                "ts": "1631186340.163300"
            },
            {
                "user": "UFPPABQ7P",
                "ts": "1631186537.163600"
            },
            {
                "user": "UDQBTJ211",
                "ts": "1631193162.164400"
            },
            {
                "user": "UDQBTJ211",
                "ts": "1631193526.164600"
            },
            {
                "user": "UBN9AFS0N",
                "ts": "1631193660.164800"
            },
            {
                "user": "UJFN50C00",
                "ts": "1631211675.166600"
            },
            {
                "user": "UJZS8UUJV",
                "ts": "1631233109.167700"
            },
            {
                "user": "UJZS8UUJV",
                "ts": "1631237662.168000"
            },
            {
                "user": "UEBG0NPDK",
                "ts": "1631294050.170600"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1631295322.171500"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1631319396.172900"
            },
            {
                "user": "UDQBTJ211",
                "ts": "1631352756.173700"
            },
            {
                "user": "UJFN50C00",
                "ts": "1631524731.004900"
            },
            {
                "user": "UFEQUBNNT",
                "ts": "1631551187.006400"
            },
            {
                "user": "UFEQUBNNT",
                "ts": "1631551336.006600"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1631560756.007400"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1631561817.007600"
            },
            {
                "user": "UEBG0NPDK",
                "ts": "1631562687.008000"
            },
            {
                "user": "UFPPABQ7P",
                "ts": "1631562933.008200"
            },
            {
                "user": "UFPPABQ7P",
                "ts": "1631563010.008400"
            },
            {
                "user": "UFEQUBNNT",
                "ts": "1631565515.009000"
            },
            {
                "user": "UFEQUBNNT",
                "ts": "1631565650.009300"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1631578550.009800"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1631578830.010300"
            },
            {
                "user": "UFPPABQ7P",
                "ts": "1631579119.010500"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1631590915.011100"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4lmu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm thinking more about the "
                            },
                            {
                                "type": "text",
                                "text": "sensation of time",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", as it pertains to the execution of code. (Yeah, back on my bullshit.) I see a spectrum here — a spectrum of different sensations of time for different ways we interact with computation.\n\nOn one end of the spectrum, we have raw math. There's not supposed to be any sensation of time in the evaluation of math. A variable "
                            },
                            {
                                "type": "text",
                                "text": "always",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " has a specific value; relationships either exist or they don't. It might take you (or a computer) some time to crunch values and arrive at a result, but that's "
                            },
                            {
                                "type": "text",
                                "text": "absolutely",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " supposed to be part of the aesthetic. Conal Elliot's Denotational Design is an application of this sort of thinking to software design. Lambda calculus, Curry-Howard, and some of the more hardcore FP languages all exist — infinitely, suspended frozen in midair — over here. Of course, no computer language is "
                            },
                            {
                                "type": "text",
                                "text": "actually",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " timeless (that violated physics, and this is addressed in Church-Turing and related work, and we all agree never to try that again), but the desired "
                            },
                            {
                                "type": "text",
                                "text": "sensation ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "— the aesthetic — is one in which time is not a constraint or concern.\n\nOn the other end of the spectrum, we have mechanical computers. There's no avoiding the sensation of time when operating these clockwork beasts. You're required to think about the passage of time as you plan an execution, or else the result will be nonsense, or malfunction. Nothing is instant, nothing exists until you build it. Here we find the CAP theorem, Turing machines, and Rich Hickey's The Language of the System, all of them toiling, sweating, grinding, churning.\n\n[Aside: note that Functional Programming is orthogonal to this spectrum — it is not bound to the "
                            },
                            {
                                "type": "text",
                                "text": "math",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " side. On either extreme and anywhere in between, you can have programming that's about immutable values (or not), static vs dynamic binding, data & behaviour co-located (or not), for-each vs map, place-oriented vs value-oriented, and so forth.]\n\nI've spent all my time over in the "
                            },
                            {
                                "type": "text",
                                "text": "mechanical labour camp",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " — this is where Hest lives. So I don't have much insight at all into the "
                            },
                            {
                                "type": "text",
                                "text": "crystal tower of pure evaluation",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". So beyond just suggesting \"Hey, talk about this spectrum\" (which, granted, I am suggesting), I'd also like to know what examples you can point to that obviously violate this common alignment of aesthetics. For example: what's the most "
                            },
                            {
                                "type": "text",
                                "text": "I feel the passage of time in execution",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " you can get to when working with something like Coq, or Haskell, or APL? Is there some step debugger for SML that really lets you feel the iterative progress through execution? Or on the other side, what's out there that takes a process rooted in time — like CAP — and makes it shake that feeling of temporality? Look at something like Erlang\/OTP — they take Prolog (timeless) and reify the sensation of process (\"let it fail\"). Who else is doing that? Is anyone doing it in the other direction?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK",
                    "UDQBTJ211",
                    "UA14TGLTC"
                ],
                "count": 4
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1631159829.160000",
        "client_msg_id": "34952e0f-3094-4147-ade1-35e136906cb7",
        "text": "I don't follow what your analogy is trying to say, <@U0264CJ5W83>.\n\nI'm still thinking about <@UE6EFEPTQ> and <@UJBAJNFLK>'s exchange about domain-level vs system exceptions. It does seem a useful reasonable goal that lower levels of the stack not throw exceptions (same as \"require applications to specify error handling at all times\"?) It's also useful to provide a back-channel for data flow that better fits the way a single app's developer is likely to think. The trouble often is that, having provided an exception mechanism in system software, there's a temptation to use it for system software. In the spirit of self-hosting, dogfooding and so on. Perhaps that's the problem? It's good to give people the ability to demote some code paths, that they can use to taste. But it's also good not to require the use of those code paths in libraries. I wonder if this is the nub of the disagreement every time the subject of exceptions comes up (ever since <https:\/\/www.joelonsoftware.com\/2003\/10\/13\/13>)\n\nOn the subject of Common Lisp's interactive condition system, do people have any links to resources for learning more? Particularly tutorials with working code. A long-standing frustration of mine with Common Lisp: extremely low hit rate when I try to type in code fragments from blog posts. More than other languages, Common Lisp blog posts tend to assume a baseline level of knowledge -- about asdf, editor setup, what to load from a file, what to type in at the REPL -- that I've never been able to attain. (Most recent example of this: <https:\/\/pvk.ca\/Blog\/2014\/03\/15\/sbcl-the-ultimate-assembly-code-breadboard>. Though now I notice it's from 2014, so never mind.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "attachments": [
            {
                "service_name": "Joel on Software",
                "title": "13",
                "title_link": "https:\/\/www.joelonsoftware.com\/2003\/10\/13\/13",
                "text": "Exceptions People have asked why I don’t like programming with exceptions. In both Java and C++, my policy is: Never throw an exception of my own Always catch any possible exception that migh…",
                "fallback": "Joel on Software: 13",
                "thumb_url": "https:\/\/i0.wp.com\/www.joelonsoftware.com\/wp-content\/uploads\/2016\/12\/11969842.jpg?fit=400%2C400&ssl=1",
                "ts": 1066003525,
                "from_url": "https:\/\/www.joelonsoftware.com\/2003\/10\/13\/13",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https:\/\/i0.wp.com\/www.joelonsoftware.com\/wp-content\/uploads\/2016\/12\/11969842.jpg?fit=180%2C180&amp;ssl=1",
                "id": 1,
                "original_url": "https:\/\/www.joelonsoftware.com\/2003\/10\/13\/13"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RdDkx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't follow what your analogy is trying to say, "
                            },
                            {
                                "type": "user",
                                "user_id": "U0264CJ5W83"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nI'm still thinking about "
                            },
                            {
                                "type": "user",
                                "user_id": "UE6EFEPTQ"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": "'s exchange about domain-level vs system exceptions. It does seem a useful reasonable goal that lower levels of the stack not throw exceptions (same as \"require applications to specify error handling at all times\"?) It's also useful to provide a back-channel for data flow that better fits the way a single app's developer is likely to think. The trouble often is that, having provided an exception mechanism in system software, there's a temptation to use it for system software. In the spirit of self-hosting, dogfooding and so on. Perhaps that's the problem? It's good to give people the ability to demote some code paths, that they can use to taste. But it's also good not to require the use of those code paths in libraries. I wonder if this is the nub of the disagreement every time the subject of exceptions comes up (ever since "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.joelonsoftware.com\/2003\/10\/13\/13"
                            },
                            {
                                "type": "text",
                                "text": ")\n\nOn the subject of Common Lisp's interactive condition system, do people have any links to resources for learning more? Particularly tutorials with working code. A long-standing frustration of mine with Common Lisp: extremely low hit rate when I try to type in code fragments from blog posts. More than other languages, Common Lisp blog posts tend to assume a baseline level of knowledge -- about asdf, editor setup, what to load from a file, what to type in at the REPL -- that I've never been able to attain. (Most recent example of this: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/pvk.ca\/Blog\/2014\/03\/15\/sbcl-the-ultimate-assembly-code-breadboard"
                            },
                            {
                                "type": "text",
                                "text": ". Though now I notice it's from 2014, so never mind.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1631160443.160400",
        "client_msg_id": "2efc1452-f515-47b5-9ea0-3d0512f0805b",
        "text": "<@UCUSW7WVD> The most detailed description of the Common Lisp condition system is probably Michał Herda's recent book: <https:\/\/www.apress.com\/gp\/book\/9781484261330>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "attachments": [
            {
                "title": "The Common Lisp Condition System - Beyond Exception Handling with Control Flow Mechanisms | Michal Herda | Apress",
                "title_link": "https:\/\/www.apress.com\/gp\/book\/9781484261330",
                "text": "This book teaches the functioning and example uses of the Common Lisp condition system. It is intended to supplement already existing material for studying Common Lisp as a language by providing detailed information about the Lisp condition system and its control flow mechanisms....",
                "fallback": "The Common Lisp Condition System - Beyond Exception Handling with Control Flow Mechanisms | Michal Herda | Apress",
                "from_url": "https:\/\/www.apress.com\/gp\/book\/9781484261330",
                "service_icon": "https:\/\/www.apress.com\/favicon.ico",
                "service_name": "apress.com",
                "id": 1,
                "original_url": "https:\/\/www.apress.com\/gp\/book\/9781484261330"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vxZck",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " The most detailed description of the Common Lisp condition system is probably Michał Herda's recent book: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.apress.com\/gp\/book\/9781484261330"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC",
                    "UL2SJ88Q3"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1631161011.160800",
        "client_msg_id": "73f49b85-f6c8-4393-a2f0-82c53b8d56ce",
        "text": "As for the reasons for the long-standing disagreements about exception handling mechanisms, I suspect it comes down to looking at code as a formal notation for computation vs. code as a human-readable account of what the software does. From the former point of view, exceptions make reasoning about the code more difficult. From the latter point if view, they make the main code path clearer and more understandable.\nThat probably supports your view that exceptions are more useful at the domain level than at the systems level, which for most developers is a black box and therefore should ideally behave predictably.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1630621354.050800",
        "parent_user_id": "U01AD80KMLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QuRD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As for the reasons for the long-standing disagreements about exception handling mechanisms, I suspect it comes down to looking at code as a formal notation for computation vs. code as a human-readable account of what the software does. From the former point of view, exceptions make reasoning about the code more difficult. From the latter point if view, they make the main code path clearer and more understandable.\nThat probably supports your view that exceptions are more useful at the domain level than at the systems level, which for most developers is a black box and therefore should ideally behave predictably."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    }
]