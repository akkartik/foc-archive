[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1749390179.045749",
        "client_msg_id": "c51c5148-9b55-4856-b85b-630fd829ebab",
        "text": "<https:\/\/programmingsimplicity.substack.com\/p\/massive-parallelism?r=1egdky>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "reply_count": 43,
        "reply_users_count": 10,
        "latest_reply": "1751856705.178879",
        "reply_users": [
            "UC2A2ARPT",
            "UGWUJUZHT",
            "U011C25B38X",
            "U03U0SCU5LH",
            "U07BD7U4S4R",
            "UJBAJNFLK",
            "U049T6YAAGG",
            "U013ZLJARC7",
            "U06SS0DHZD1",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "UC2A2ARPT",
                "ts": "1749394956.786269"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1749398576.504229"
            },
            {
                "user": "U011C25B38X",
                "ts": "1749443076.123959"
            },
            {
                "user": "U03U0SCU5LH",
                "ts": "1749448201.625159"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1749479317.801589"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1749481938.967339"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1749521798.715299"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1749537135.482379"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1749537619.748759"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1749539813.519299"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1749540343.474209"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1749547648.442599"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1749548603.166069"
            },
            {
                "user": "U049T6YAAGG",
                "ts": "1749668882.804669"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1749672406.417569"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1750683897.654829"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1750701464.079179"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1750703297.261809"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1750704755.291639"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1750711895.804049"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1750732985.567609"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1750746307.919489"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1750758492.106669"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1750758929.585769"
            },
            {
                "user": "U06SS0DHZD1",
                "ts": "1750761576.662609"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1750805027.378679"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1750839361.171379"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1750839423.663119"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1750863384.269619"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1750863400.432009"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1750863515.402419"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1750877371.921099"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1750878127.990539"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1751201331.648289"
            },
            {
                "user": "U07BD7U4S4R",
                "ts": "1751356439.512999"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1751420197.436339"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1751435320.403559"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1751536931.702419"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1751606089.896809"
            },
            {
                "user": "U013ZLJARC7",
                "ts": "1751630127.694909"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1751634568.674989"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1751635107.869409"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1751856705.178879"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "attachments": [
            {
                "image_url": "https:\/\/substackcdn.com\/image\/fetch\/w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto\/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F8414f8d7-d1a8-4d69-9532-5b7e1d76e192_711x454.heic",
                "image_width": 711,
                "image_height": 454,
                "image_bytes": 78600,
                "from_url": "https:\/\/programmingsimplicity.substack.com\/p\/massive-parallelism?r=1egdky",
                "service_icon": "https:\/\/substackcdn.com\/image\/fetch\/f_auto,q_auto:good,fl_progressive:steep\/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9bf28261-3dbc-4931-99f3-57bb47beeb02%2Fapple-touch-icon-57x57.png",
                "id": 1,
                "original_url": "https:\/\/programmingsimplicity.substack.com\/p\/massive-parallelism?r=1egdky",
                "fallback": "Massive Parallelism",
                "text": "2025-06-07",
                "title": "Massive Parallelism",
                "title_link": "https:\/\/programmingsimplicity.substack.com\/p\/massive-parallelism?r=1egdky",
                "service_name": "programmingsimplicity.substack.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "q6oXI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/programmingsimplicity.substack.com\/p\/massive-parallelism?r=1egdky"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1749394956.786269",
        "client_msg_id": "8b982f1f-ba88-402e-a5ff-4e9499368561",
        "text": "I want to respond to this point, since I think it's a good stand-in for many of your other criticisms of the schematic:\n\n&gt; It is too complicated, it contains too much nuance and detail, the DI (Design Intent) is not obvious. Someone tried to improve the DI by colourizing the schematic, but, it still looks to be too complicated.\nI'm not an EE, but I did spend almost 20 years working for <https:\/\/www.lunchboxsessions.com|a schematic \"programming\" company>. To me, this schematic is about the typical complexity I'm used to seeing before you spill over to multiple pages. And the schematics I'm used to working with would come by the hundreds, bound in massive 3-ring binders, all describing a single piece of industrial equipment (like a single bulldozer or excavator).\n\nSo going by gut, this schematic feels about as \"complicated\" as few hundred LoC, in that it'd probably take me about as long to do a cursory scan or deep read of either — less than a minute to survey the broad structure, a few minutes to identify patterns, and maybe 20 minutes to deeply go over everything.\n\nIs that \"too complicated\"? Too complicated… for what?\n\nWithout presuming too much about your background (for instance, I wouldn't be the least bit surprised if you were an EE with lots of schematic-reading experience and still held this opinion), I think it's interesting to work through your \"too complicated\" reaction in a few ways.\n\n• How much of this detail and nuance is due to the *design of schematics* as a visual communication medium? Is there a different way of visualizing an electrical system that would be easier to read, while still being useful for the same purposes? Well, what's the purpose of a schematic? I believe they're primarily intended as documentation, useful if you need to repair an existing system to verify how it is supposed to work — they're a known-good reference you can compare your faulty system to, to identify short \/ open circuits, damaged components, etc. And, sort of like sheet music, these schematics elide plenty of information, such as the placement of components and routing of trace\/wires — they aren't like blueprints. So maybe we could find a different way to do the same job, or a different way to do a different job, by choosing to elide different information. Or maybe we need to overhaul the \"symbol language\", so that instead of capturing information about what the components are and how they're connected, we capture information about the dynamics of the system. (Bret shows something like this in Inventing on Principle, but none of the EEs I showed it to found it at all compelling :shrug:.) So — would your criticism be addressed if we changed the standard design of electrical schematics, and if so, how and why?\n• You rhetorically ask how many pieces of paper it'd take to hold the code for Pong in a modern language. I think that's a fascinating comparison. To make it fair, we'd probably have to find some way of normalizing the I\/O APIs so that they're the same as what's available to schematic. After all, if there was a \"runPong()\" API that'd be unfair. Would the Canvas2d API be fair or unfair? Etc etc. My gut is that if you did this normalization, you'd probably end up with code that felt to a typical coder about as \"complicated\" as this schematic would feel to a typical EE. After all, they'd both be doing roughly the same thing, and I don't think Pong is inherently complex enough to benefit from the sort of abstraction-building that makes code so powerful. (That's my gut sense, at least.) But maybe you disagree, and the code would be fundamentally different in some way that'd change how complicated it appears.\n• The schematic uses space and visual symbols in a way that's fundamentally different from textual code. When you computerize the schematic, you can animate it, and reveal all sorts of information about the runtime dynamics of the system. At that point, I think the schematic is significantly more expressive than the equivalent textual code. So maybe, in the absence of that augmentation, the visual \"juice\" isn't worth the complexity \"squeeze\", so to speak.\nAnyway, thanks for the post. Hit the spot!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Yx8\/V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I want to respond to this point, since I think it's a good stand-in for many of your other criticisms of the schematic:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It is too complicated, it contains too much nuance and detail, the DI (Design Intent) is not obvious. Someone tried to improve the DI by colourizing the schematic, but, it still looks to be too complicated."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI'm not an EE, but I did spend almost 20 years working for "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.lunchboxsessions.com",
                                "text": "a schematic \"programming\" company"
                            },
                            {
                                "type": "text",
                                "text": ". To me, this schematic is about the typical complexity I'm used to seeing before you spill over to multiple pages. And the schematics I'm used to working with would come by the hundreds, bound in massive 3-ring binders, all describing a single piece of industrial equipment (like a single bulldozer or excavator).\n\nSo going by gut, this schematic feels about as \"complicated\" as few hundred LoC, in that it'd probably take me about as long to do a cursory scan or deep read of either — less than a minute to survey the broad structure, a few minutes to identify patterns, and maybe 20 minutes to deeply go over everything.\n\nIs that \"too complicated\"? Too complicated… for what?\n\nWithout presuming too much about your background (for instance, I wouldn't be the least bit surprised if you were an EE with lots of schematic-reading experience and still held this opinion), I think it's interesting to work through your \"too complicated\" reaction in a few ways.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "How much of this detail and nuance is due to the "
                                    },
                                    {
                                        "type": "text",
                                        "text": "design of schematics ",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "as a visual communication medium? Is there a different way of visualizing an electrical system that would be easier to read, while still being useful for the same purposes? Well, what's the purpose of a schematic? I believe they're primarily intended as documentation, useful if you need to repair an existing system to verify how it is supposed to work — they're a known-good reference you can compare your faulty system to, to identify short \/ open circuits, damaged components, etc. And, sort of like sheet music, these schematics elide plenty of information, such as the placement of components and routing of trace\/wires — they aren't like blueprints. So maybe we could find a different way to do the same job, or a different way to do a different job, by choosing to elide different information. Or maybe we need to overhaul the \"symbol language\", so that instead of capturing information about what the components are and how they're connected, we capture information about the dynamics of the system. (Bret shows something like this in Inventing on Principle, but none of the EEs I showed it to found it at all compelling "
                                    },
                                    {
                                        "type": "emoji",
                                        "name": "shrug",
                                        "unicode": "1f937"
                                    },
                                    {
                                        "type": "text",
                                        "text": ".) So — would your criticism be addressed if we changed the standard design of electrical schematics, and if so, how and why?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "You rhetorically ask how many pieces of paper it'd take to hold the code for Pong in a modern language. I think that's a fascinating comparison. To make it fair, we'd probably have to find some way of normalizing the I\/O APIs so that they're the same as what's available to schematic. After all, if there was a \"runPong()\" API that'd be unfair. Would the Canvas2d API be fair or unfair? Etc etc. My gut is that if you did this normalization, you'd probably end up with code that felt to a typical coder about as \"complicated\" as this schematic would feel to a typical EE. After all, they'd both be doing roughly the same thing, and I don't think Pong is inherently complex enough to benefit from the sort of abstraction-building that makes code so powerful. (That's my gut sense, at least.) But maybe you disagree, and the code would be fundamentally different in some way that'd change how complicated it appears."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The schematic uses space and visual symbols in a way that's fundamentally different from textual code. When you computerize the schematic, you can animate it, and reveal all sorts of information about the runtime dynamics of the system. At that point, I think the schematic is significantly more expressive than the equivalent textual code. So maybe, in the absence of that augmentation, the visual \"juice\" isn't worth the complexity \"squeeze\", so to speak."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAnyway, thanks for the post. Hit the spot!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U07BD7U4S4R"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1749398576.504229",
        "client_msg_id": "98710e0b-3d1d-478b-b5f1-c7f9c04c1360",
        "text": "Yes, I learned to read schematics on my own, then I got an EE degree (which got me into compiler-writing! One 4th year course was \"pick your own topic for the next two terms\". Right at that moment, DDJ came out with its SmallC compiler article and my wire-wrapped Z80 was itching to be commanded (this was in an age of closed-source, so seeing other people's code was refreshing (the other thing I carried around in my briefcase was the source code to V7 UNIX)).\n\nI don't think that schematics are better than code, nor that code is better than schematics. I think that they both suffer from containing way too much detail splayed out in a meat-tenderizer method (bigger means wider, not taller (layered)). Both are difficult to understand unless you get a degree or misspend your youth learning their secrets.\n\nI do note:\n• when I built and debugged electronic circuits, I would be confident that they could be shipped with 0 bugs\n• when I build code, I always expect more hidden bugs to surface\n• I perceive our current software workflow as supporting the shipping of buggy designs (CI\/CD, convincing unwary customers that they should act as our Q\/A departments for free instead of suing us for selling them buggy products, quarterly Continuous Delivery updates, etc.)\n• I observe a major difference in the two techniques: code is sequential and synchronous, electronics is asynchronous and highly parallel even at low levels (cheapo ICs like the 7400 series)\n• I observe that both techniques are \"too complicated\" for getting a design overview\n• both techniques suffer from strongly-connected scoping - wires\/globals poke through sides of sections and directly tweak the innards of sections.\n• debugging async systems was easier with hardware tools, like 'scopes, meters, than is debugging code with single-stepping debuggers and the plethora of doo-dads that have been pastied onto the single-stepping techniques to make them multi-thread-stepping.\nSooo - what are \"the good parts\" of each? Can we pick and choose? I think that my 0D (PBP - Parts Based Programming) stuff is a step in that direction (surprise!). A system should be composed of multiple Parts, Parts must have well-defined Ports and must not allow their innards to be visible, tweaked, called by other Parts, i.e. data flow only (whereas FP transfers dataFlow+controlFlow). A system should be understandable in small (7+-5) chunks, digging deeper only by those interested in more detail (kinda like the colourized Pong schematic with all of the schematic details erased at the top level). It should be easily possible spray a design over multiple CPUs (functional thinking discourages that kind of thing due to its very low level over-synchronization \/ clockworkiness). Imagine each coloured box on the Pong diagram sitting on a separate Arduino with only thin wires connecting them through well-defined ports (my Wang word processor had a \"bus\" with 400 point-to-point wires on it to interconnect circuits plugged into the backplane - the S100 bus was much more general, hence, better and a breath of fresh air).\n\n[I have a \"The Good Parts\" article sitting on my disk, unpublished thus far. A lot of our programming techniques are based on 1960s biases, like concern for \"efficiency\". We should know better by now]",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "05jsv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, I learned to read schematics on my own, then I got an EE degree (which got me into compiler-writing! One 4th year course was \"pick your own topic for the next two terms\". Right at that moment, DDJ came out with its SmallC compiler article and my wire-wrapped Z80 was itching to be commanded (this was in an age of closed-source, so seeing other people's code was refreshing (the other thing I carried around in my briefcase was the source code to V7 UNIX)).\n\nI don't think that schematics are better than code, nor that code is better than schematics. I think that they both suffer from containing way too much detail splayed out in a meat-tenderizer method (bigger means wider, not taller (layered)). Both are difficult to understand unless you get a degree or misspend your youth learning their secrets.\n\nI do note:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "when I built and debugged electronic circuits, I would be confident that they could be shipped with 0 bugs"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "when I build code, I always expect more hidden bugs to surface"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I perceive our current software workflow as supporting the shipping of buggy designs (CI\/CD, convincing unwary customers that they should act as our Q\/A departments for free instead of suing us for selling them buggy products, quarterly Continuous Delivery updates, etc.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I observe a major difference in the two techniques: code is sequential and synchronous, electronics is asynchronous and highly parallel even at low levels (cheapo ICs like the 7400 series)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I observe that both techniques are \"too complicated\" for getting a design overview"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "both techniques suffer from strongly-connected scoping - wires\/globals poke through sides of sections and directly tweak the innards of sections."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "debugging async systems was easier with hardware tools, like 'scopes, meters, than is debugging code with single-stepping debuggers and the plethora of doo-dads that have been pastied onto the single-stepping techniques to make them multi-thread-stepping."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSooo - what are \"the good parts\" of each? Can we pick and choose? I think that my 0D (PBP - Parts Based Programming) stuff is a step in that direction (surprise!). A system should be composed of multiple Parts, Parts must have well-defined Ports and must not allow their innards to be visible, tweaked, called by other Parts, i.e. data flow only (whereas FP transfers dataFlow+controlFlow). A system should be understandable in small (7+-5) chunks, digging deeper only by those interested in more detail (kinda like the colourized Pong schematic with all of the schematic details erased at the top level). It should be easily possible spray a design over multiple CPUs (functional thinking discourages that kind of thing due to its very low level over-synchronization \/ clockworkiness). Imagine each coloured box on the Pong diagram sitting on a separate Arduino with only thin wires connecting them through well-defined ports (my Wang word processor had a \"bus\" with 400 point-to-point wires on it to interconnect circuits plugged into the backplane - the S100 bus was much more general, hence, better and a breath of fresh air).\n\n[I have a \"The Good Parts\" article sitting on my disk, unpublished thus far. A lot of our programming techniques are based on 1960s biases, like concern for \"efficiency\". We should know better by now]"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U011C25B38X",
        "type": "message",
        "ts": "1749443076.123959",
        "client_msg_id": "18C95BC8-CBF3-467F-9DB8-18B846E0B3F8",
        "text": "<@UC2A2ARPT> your comment makes me think of “alternative representations” (is there an official word for this?) of the same underlying thing. Like in Step Functions\/Airflow, you can toggle back and forth between a code-representation of a DAG and a visual representation of a DAG. And with React\/Vue developer tools, you can pull up a tree based view of your application alongside your application. I’m trying to think of more examples like this",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "afe258f63c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-05-12\/8869553941623_afe258f63c3f6ecf0e55_72.png",
            "first_name": "",
            "real_name": "Angus Mitchell",
            "display_name": "Angus Mitchell",
            "team": "T5TCAFTA9",
            "name": "anguspmitchell",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QMYYx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " your comment makes me think of "
                            },
                            {
                                "type": "text",
                                "text": "“"
                            },
                            {
                                "type": "text",
                                "text": "alternative representations"
                            },
                            {
                                "type": "text",
                                "text": "” (is there an official word for this?) of the same underlying thing. Like in "
                            },
                            {
                                "type": "text",
                                "text": "Step Functions\/Airflow"
                            },
                            {
                                "type": "text",
                                "text": ","
                            },
                            {
                                "type": "text",
                                "text": " you"
                            },
                            {
                                "type": "text",
                                "text": " can"
                            },
                            {
                                "type": "text",
                                "text": " toggle back and forth between a code-representation of a DAG and a visual representation"
                            },
                            {
                                "type": "text",
                                "text": " of a DAG"
                            },
                            {
                                "type": "text",
                                "text": ". And with React\/Vue developer tools, you can pull up a tree based view of your application alongside your application. "
                            },
                            {
                                "type": "text",
                                "text": "I’m trying to think of more examples like this"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U03U0SCU5LH",
        "type": "message",
        "ts": "1749448201.625159",
        "client_msg_id": "23821615-89a5-44c3-ad00-6bb24fb1a7d1",
        "text": "I'm fascinated by the asynchronous nature of the schematic. Is this not (yet?) a van Neuman computer? It also doesn't compare to modern GPU's where each thread usually runs the same program on different data.. this is different programs (on the same data?) Maybe more comparable to something like micro services.. or threads in an operating system. I always felt like our programming model is too ego-centric. We think of the computer as an entity that does stuff (just like ourself). That's why we like textual programs, it is a recipe, from top to bottom.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gdf6784b7d6d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/df6784b7d6d97fb67dec89320cc88a84.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0007-72.png",
            "first_name": "Dany",
            "real_name": "Dany",
            "display_name": "Dany",
            "team": "T5TCAFTA9",
            "name": "bitteldany",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1749390179.045749",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "w4mgP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm fascinated by the asynchronous nature of the schematic. Is this not (yet?) a van Neuman computer? It also doesn't compare to modern GPU's where each thread usually runs the same program on different data.. this is different programs (on the same data?) Maybe more comparable to something like micro services.. or threads in an operating system. I always felt like our programming model is too ego-centric. We think of the computer as an entity that does stuff (just like ourself). That's why we like textual programs, it is a recipe, from top to bottom."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]