[
    {
        "user": "UN57U8V53",
        "type": "message",
        "ts": "1721479891.416429",
        "client_msg_id": "1b1d83b3-afd4-4c7e-89d7-aef33be5978f",
        "text": "I had a similar question and reduced it down to \"what would an audio-only programming language sound like?\" My guess was a lot more <https:\/\/www.cs1subgoals.org\/what-are-subgoals\/#:~:text=To%20help%20instructors%20verbalize%20this,termination%20conditions%20for%20while%20loops.|subgoals>, markers for \"filling in later\", and fine scoped tests\/examples.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3447742b735b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-09\/753296041488_3447742b735b104a7ff2_72.png",
            "first_name": "",
            "real_name": "Don Abrams",
            "display_name": "Don Abrams",
            "team": "T5TCAFTA9",
            "name": "donabrams",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "attachments": [
            {
                "from_url": "https:\/\/www.cs1subgoals.org\/what-are-subgoals\/#:~:text=To%20help%20instructors%20verbalize%20this,termination%20conditions%20for%20while%20loops.",
                "id": 1,
                "original_url": "https:\/\/www.cs1subgoals.org\/what-are-subgoals\/#:~:text=To%20help%20instructors%20verbalize%20this,termination%20conditions%20for%20while%20loops.",
                "fallback": "SUBGOALS: What are subgoals?, SUBGOALS",
                "text": "What are subgoals? A common problem in introductory programming courses is the expert-novice gap between instructors and students.",
                "title": "What are subgoals?, SUBGOALS",
                "title_link": "https:\/\/www.cs1subgoals.org\/what-are-subgoals\/#:~:text=To%20help%20instructors%20verbalize%20this,termination%20conditions%20for%20while%20loops.",
                "service_name": "SUBGOALS"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zqq2E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I had a similar question and reduced it down to \"what would an audio-only programming language sound like?\" My guess was a lot more "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.cs1subgoals.org\/what-are-subgoals\/#:~:text=To%20help%20instructors%20verbalize%20this,termination%20conditions%20for%20while%20loops.",
                                "text": "subgoals"
                            },
                            {
                                "type": "text",
                                "text": ", markers for \"filling in later\", and fine scoped tests\/examples."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U079M43CQ31",
                    "U03JUAWDVSR"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U0791273STB",
        "type": "message",
        "ts": "1721483630.986659",
        "edited": {
            "user": "U0791273STB",
            "ts": "1721486674.000000"
        },
        "client_msg_id": "92f8d959-37f3-4d07-ada9-572d342a52be",
        "text": "Loving all of the orthogonal thinking prompts throughout this thread. My perspective is that text-based programming is more characterized by the interaction model of essentially being equivalent to typesetting a document. Also worth considering is that many people interact with textual programming strictly non-visually through the use of text-to-speech. In my mind, things move to being more \"visual\" or \"spatial\" programming as the document interaction model goes away and the mapping to audio-only interface becomes less clear.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "f986787e4339",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-06-18\/7287931680998_f986787e43399cbab7a5_72.jpg",
            "first_name": "Hayden",
            "real_name": "Hayden",
            "display_name": "Hayden",
            "team": "T5TCAFTA9",
            "name": "hayden",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O4sNU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Loving all of the orthogonal thinking prompts throughout this thread. My perspective is that text-based programming is more characterized by the interaction model of essentially being equivalent to typesetting a document. Also worth considering is that many people interact with textual programming strictly non-visually through the use of text-to-speech. In my mind, things move to being more \"visual\" or \"spatial\" programming as the document interaction model goes away and the mapping to audio-only interface becomes less clear."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U079M43CQ31"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1721491624.629439",
        "client_msg_id": "e492bce0-eaa4-4220-b098-996ffc2baeed",
        "text": "Thanks <@UGWUJUZHT> for this detailed explanation with a nice example!\n\nThere's one aspect I find missing from the discussion: CPUs. Early CPUs, the ones for which our languages, compilers, etc. were designed, have no accessible parallelism (and the very early ones no parallelism at all). There's a single instruction stream. In that universe, function-based programming did not any additional synchronicity constraint.\n\nToday, all CPUs and GPUs have some level of parallelism, but it's not under the control of the software. If I have a four-core processor, I can run up to four independent threads. That's a pretty severe constraint on asynchronicity in software as well.\n\nSo I wonder how we could possibly get to your dream situation of \"as many asynchronously working subsystems as our design requires\" with today's processors and no software layer for multithreading on top of them.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721246911.989019",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wQeOJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " for this detailed explanation with a nice example!\n\nThere's one aspect I find missing from the discussion: CPUs. Early CPUs, the ones for which our languages, compilers, etc. were designed, have no accessible parallelism (and the very early ones no parallelism at all). There's a single instruction stream. In that universe, function-based programming did not any additional synchronicity constraint.\n\nToday, all CPUs and GPUs have some level of parallelism, but it's not under the control of the software. If I have a four-core processor, I can run up to four independent threads. That's a pretty severe constraint on asynchronicity in software as well.\n\nSo I wonder how we could possibly get to your dream situation of \"as many asynchronously working subsystems as our design requires\" with today's processors and no software layer for multithreading on top of them."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U079M43CQ31",
        "type": "message",
        "ts": "1721497220.585449",
        "client_msg_id": "28e521eb-71af-4d93-b74f-2b053cb9fc13",
        "text": "Ok so sorry for posting a super long thing again but what <@U05UK5T7LPP> brought up about Geometric vs Algebraic representations got me thinking. So if you define an “Algebraic” representation to be a representation of some formal object that can be expressed as a sequence of symbols, and a “Geometric” representation to be one that has a set of symbols that can be oriented anywhere in 2d space in relation to one another, then I think you can actually draw a pretty clear distinction between the two. Maybe the distinction is better defined as 1 dimensional vs 2 dimensional, but I will stick with this Algebraic vs Geometric thing.\n\nsay the formal object we are representing is the fully connected graph of 3 nodes a, b, c. With a geometric representation, you can have three nodes laid out as an equilateral triangle, with 3 edges connecting them. Very simple. You have 4 different symbols, a, b, c, and &lt;line&gt;, which represents an edge. In the standard algebraic representation, where you have a pair (V,E) of vertices and edges, the representation is ({a,b,c},{(a,b),(b,c),(c,a)}). The symbols used are (, ), {, }, a, b, c, “,”, which is 8 different symbols. And the total number of symbols in the representation, counting repetitions is 29 (if I counted right).\n\nLet’s say we just want a representation that can distinctly express any graph with just 3 nodes to simplify things a bit. For the fully connected graph you can think of a sequential representation that has the same number of symbols and symbol instances as the geometric representation: “a-b-c-” the “-” at the end could be interpreted to mean that there is a connection back to the first node in the sequence. Or you could simply do “abca”, where two nodes have an edge between them if they are next to each other in the sequence. In this case, we have a repeated symbol “a”, but fewer symbol types than in the graphical representation.\n\nBut then you could similarly eliminate the &lt;line&gt; symbol from the geometric representation by saying that nodes are connected if the symbols representing them are touching. Maybe you replace each symbol a, b, c with that symbol inside a circle to imagine this better. Now I think you reach a point where there is a real difference. In the case of the geometric representation, you can differentiate between the fully connected graph between nodes abc, with only 3 symbol types, and 3 symbol occurrences. Whereas in the sequential graph, there is no way to differentiate between the two with only three symbol types and 3 symbol instances. With only “abc” you don’t know if the a is connected to the c or not.\n\nTextual programming is purely sequential in nature. No matter how you format your code visually, the one dimensional sequence of characters fully determines the program. So you will need either more symbol types, or more symbol occurrences to represent programs textually than we might if we use 2d space!!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8a7101a82239",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-06-27\/7327139528455_8a7101a8223949a332b4_72.jpg",
            "first_name": "Adam",
            "real_name": "Adam Davidson",
            "display_name": "Adam Davidson",
            "team": "T5TCAFTA9",
            "name": "adam26davidson",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oVyOK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ok so sorry for posting a super long thing again but what "
                            },
                            {
                                "type": "user",
                                "user_id": "U05UK5T7LPP"
                            },
                            {
                                "type": "text",
                                "text": " brought up about Geometric vs Algebraic representations got me thinking. So if you define an “Algebraic” representation to be a representation of some formal object that can be expressed as a sequence of symbols, and a “Geometric” representation to be one that has a set of symbols that can be oriented anywhere in 2d space in relation to one another, then I think you can actually draw a pretty clear distinction between the two. Maybe the distinction is better defined as 1 dimensional vs 2 dimensional, but I will stick with this Algebraic vs Geometric thing.\n\nsay the formal object we are representing is the fully connected graph of 3 nodes a, b, c. With a geometric representation, you can have three nodes laid out as an equilateral triangle, with 3 edges connecting them. Very simple. You have 4 different symbols, a, b, c, and <line>, which represents an edge. In the standard algebraic representation, where you have a pair (V,E) of vertices and edges, the representation is ({a,b,c},{(a,b),(b,c),(c,a)}). The symbols used are (, ), {, }, a, b, c, “,”, which is 8 different symbols. And the total number of symbols in the representation, counting repetitions is 29 (if I counted right).\n\nLet’s say we just want a representation that can distinctly express any graph with just 3 nodes to simplify things a bit. For the fully connected graph you can think of a sequential representation that has the same number of symbols and symbol instances as the geometric representation: “a-b-c-” the “-” at the end could be interpreted to mean that there is a connection back to the first node in the sequence. Or you could simply do “abca”, where two nodes have an edge between them if they are next to each other in the sequence. In this case, we have a repeated symbol “a”, but fewer symbol types than in the graphical representation.\n\nBut then you could similarly eliminate the <line> symbol from the geometric representation by saying that nodes are connected if the symbols representing them are touching. Maybe you replace each symbol a, b, c with that symbol inside a circle to imagine this better. Now I think you reach a point where there is a real difference. In the case of the geometric representation, you can differentiate between the fully connected graph between nodes abc, with only 3 symbol types, and 3 symbol occurrences. Whereas in the sequential graph, there is no way to differentiate between the two with only three symbol types and 3 symbol instances. With only “abc” you don’t know if the a is connected to the c or not.\n\nTextual programming is purely sequential in nature. No matter how you format your code visually, the one dimensional sequence of characters fully determines the program. So you will need either more symbol types, or more symbol occurrences to represent programs textually than we might if we use 2d space!!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT",
                    "U06BUK2M2RH"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1721508437.355739",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1721508472.000000"
        },
        "client_msg_id": "D5787C91-1BBB-40DC-998B-3AE6F64B8622",
        "text": "Shorter version of the previous:\n\nIn visual programming, spatial arrangement of objects doesn't have to be meaningful. But it can be. That part is open to design.\n\nNow I'll add:\n\nIn a good system, the programmer would get to choose whether spatial arrangement is meaningful or not.\n\nIn a good system, the movement of objects through time is just as significant as relative positions, connections, visual representations, etc.\n\nThere are physical dimensions we haven't explored. If you live in text, you won't feel the pull to explore them.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721406900.550659",
        "parent_user_id": "U079M43CQ31",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AgUZA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Shorter version of the previous:\n\nIn visual programming, spatial arrangement of objects doesn't have to be meaningful. But it can be"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " That part is open to design.\n\nNow I'll add:\n\nIn a good system, the programmer would get to choose whether spatial arrangement is meaningful or not.\n\nIn a good system, the movement of objects through time is just as significant as relative positions, connections, visual representations, etc.\n\nThere are physical dimensions we haven't explored. If you live in text, you won't feel the pull to explore them."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U079M43CQ31",
                    "U06BUK2M2RH",
                    "U05UK5T7LPP"
                ],
                "count": 3
            }
        ]
    }
]