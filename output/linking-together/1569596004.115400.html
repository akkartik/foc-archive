<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1569596004.115400.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-09-27 07:53</span><br/>
Every programming language consists of two parts: a basic set of given things,<br/>and mechanisms for defining new things in terms of existing things.<br/>These mechanisms are called "abstraction mechanisms".<br/><br/>Abstraction mechanisms allow you to replace repetitive, boilerplate code<br/>with a definition of a named entity, and multiple references to this entity.<br/>They allow you to disentangle two separate concerns that are initially<br/>tightly entangled with each other in the code.  This allows you to maintain<br/>the two design elements independently of one another.  Once disentangled, each<br/>of the resulting entities can be reused in multiple contexts.<br/><br/>The quest for better abstraction mechanisms is the engine that drives<br/>programming language evolution.<br/><br/>-- me, in 2012
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569655474.116100"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../linking-together/1569596004.115400.html#1569655474.116100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-09-28 00:24</span><br/>
How about an abstraction mechanism for changing the abstraction mechanisms? How about applying <em>that</em> mechanism to itself?<br/><br/>I actually just posted something that's somewhat about that: <a href="../thinking-together/1569653638.037600.html">../thinking-together/1569653638.037600.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569656154.116400"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../linking-together/1569596004.115400.html#1569656154.116400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-28 00:35</span><br/>
If you follow Dan's logic, you will end up with 2nd level LISP, which is devilishly hard to read. I am not aware of any program using 3rd level nesting, but perhaps some LISP fanatic can recall a case where it was needed. Most large LISP and FORTH programs were 2nd level. I am working in the opposite direction, trying to convert as much executable code into declarative, which is 0 level code; i.e. not executed but just "there".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569829071.119800"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../linking-together/1569596004.115400.html#1569829071.119800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-09-30 00:37</span><br/>
I agree that's not the best place to end up, and the idea is actually to find / implement a more ideal representation on top of it -- probably something static or declarative -- and then the layer beneath it transforms it into the "real thing".<br/><br/>That way the thing being specified / coded is 1st or 0 level -- and perhaps the best form reasonably possible for that thing -- and the 2nd level stuff acts more like a compiler or interpreter, which is 2nd level by definition.<br/><br/>The benefit is that you break free of restrictions imposed by any one language or format or editor, because you specify it exactly how you want.<br/><br/>This also blurs the lines between programming language, compiler/interpreter, user interaction, macros, and functions + data structures. Really these are all these same thing: specification, and the thing that builds / transforms it. The only difference is when &amp; where that happens. Really it's all just functions + data, so my idea is to just put it all in the same place and compose / separate / invoke the different pieces in the right order.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
