[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1753392357.748789",
        "client_msg_id": "08621175-7ece-46f6-b05b-d53abda7da8c",
        "text": "In true \"I wish I had thought of saying that\"-ism, I realize that I could have answered a question differently yesterday. The question was about handling Scheme-isms like Call\/CC. I focused solely on Nils Holm's code and didn't try to generalize. It just dawned on me that Holm's code does contain a Scheme-ism - named lets. Named lets in Scheme are meant to signal opportunities for tail recursion - to convert recursion into loops. I parse and deal with 2 named lets in Holm's code. As it stands, I cheaped out and simply emit recursive function calls,,, but, the fact that Javascript supports loops, means that I could have converted such code into proper tail recursion. I wasn't interested in getting fancy, but, the potential to do this right, is there. Scheme compiles down into assembler, as does Javascript, so, of course it's possible to do this right. Aside: a fundamental trick in this process, is that my code doesn't need to do type-checking nor semantic analysis. It transpiles working Scheme code. If the code works in Scheme, then there's no point in re-checking all of that stuff - big time saver.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1753148263.648519",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PX5nS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In true \"I wish I had thought of saying that\"-ism, I realize that I could have answered a question differently yesterday. The question was about handling Scheme-isms like Call\/CC. I focused solely on Nils Holm's code and didn't try to generalize. It just dawned on me that Holm's code does contain a Scheme-ism - named lets. Named lets in Scheme are meant to signal opportunities for tail recursion - to convert recursion into loops. I parse and deal with 2 named lets in Holm's code. As it stands, I cheaped out and simply emit recursive function calls,,, but, the fact that Javascript supports loops, means that I could have converted such code into proper tail recursion. I wasn't interested in getting fancy, but, the potential to do this right, is there. Scheme compiles down into assembler, as does Javascript, so, of course it's possible to do this right. Aside: a fundamental trick in this process, is that my code doesn't need to do type-checking nor semantic analysis. It transpiles working Scheme code. If the code works in Scheme, then there's no point in re-checking all of that stuff - big time saver."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]