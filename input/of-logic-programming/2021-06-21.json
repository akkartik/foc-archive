[
    {
        "user": "UN9SCH5RD",
        "type": "message",
        "ts": "1624344009.026100",
        "client_msg_id": "63951419-c4f4-4637-96be-ac845a371358",
        "text": "Been thinking a bit about \"custom unification\", or extensible unification. It seems it is a pretty common thing:\n\n• <https:\/\/www.lazutkin.com\/blog\/2014\/06\/10\/heya-unify-custom-unification\/|A library that implements unification \/ custom unification in JavaScript>\n• <https:\/\/github.com\/clojure\/core.logic\/wiki\/Extending-core.logic-%28Datomic-example%29|Extending unification in clojure's core.logic>\n• <https:\/\/github.com\/mrocklin\/unification|An unification library for Python>\n• <https:\/\/stackoverflow.com\/a\/27084453\/855105|Also TIL SWI prolog supports maps\/dictionaries>\nWondering how much it makes sense to use more complex data structures in prolog-like searches.\nDatalog seems to be an example that going \"the other way\", being more restrictive, may be more productive:\n&gt; Datalog disallows complex terms as arguments of predicates, e.g., p (1, 2) is admissible but not p (f (1), 2)\nPerhaps unification of complex\/custom data structures is more productive for pattern matching than for general logic programming ... but not sure (SWI prolog's dict maybe contradicts this idea).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaa31b79aded",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aa31b79adedc3f60547769f1a8971ba6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Emmanuel Oga",
            "display_name": "Emmanuel Oga",
            "team": "T5TCAFTA9",
            "name": "emmanueloga",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1624344009.026100",
        "reply_count": 4,
        "reply_users_count": 2,
        "latest_reply": "1624435483.029300",
        "reply_users": [
            "UN9SCH5RD",
            "UCGAK10LS"
        ],
        "replies": [
            {
                "user": "UN9SCH5RD",
                "ts": "1624345189.026700"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1624435131.028900"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1624435390.029100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1624435483.029300"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6i4I7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Been thinking a bit about \"custom unification\", or extensible unification. It seems it is a pretty common thing:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/www.lazutkin.com\/blog\/2014\/06\/10\/heya-unify-custom-unification\/",
                                        "text": "A library that implements unification \/ custom unification in JavaScript"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/github.com\/clojure\/core.logic\/wiki\/Extending-core.logic-%28Datomic-example%29",
                                        "text": "Extending unification in clojure's core.logic"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/github.com\/mrocklin\/unification",
                                        "text": "An unification library for Python"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/stackoverflow.com\/a\/27084453\/855105",
                                        "text": "Also TIL SWI prolog supports maps\/dictionaries"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nWondering how much it makes sense to use more complex data structures in prolog-like searches.\nDatalog seems to be an example that going \"the other way\", being more restrictive, may be more productive:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Datalog disallows complex terms as arguments of "
                            },
                            {
                                "type": "text",
                                "text": "predicates",
                                "style": {
                                    "unlink": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", e.g., p (1, 2) is admissible but not p (f (1), 2)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nPerhaps unification of complex\/custom data structures is more productive for pattern matching than for general logic programming ... but not sure (SWI prolog's dict maybe contradicts this idea)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UN9SCH5RD",
        "type": "message",
        "ts": "1624345189.026700",
        "edited": {
            "user": "UN9SCH5RD",
            "ts": "1624345338.000000"
        },
        "client_msg_id": "d58ca13d-3e0a-4a4c-ae60-b91d37b0b28e",
        "text": "Also trying to figure out why SWI's dicts include tags. My guess is that they needed the tag anyway so instead of giving it a fixed \"functor\", say `dict`, they allowed an arbitrary tag name to be used\n\nEdit: the manual say dicts are \"structs with named arguments\", so they need a tag like any other structure, I guess",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaa31b79aded",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aa31b79adedc3f60547769f1a8971ba6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png",
            "first_name": "",
            "real_name": "Emmanuel Oga",
            "display_name": "Emmanuel Oga",
            "team": "T5TCAFTA9",
            "name": "emmanueloga",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1624344009.026100",
        "parent_user_id": "UN9SCH5RD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=I+fv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also trying to figure out why SWI's dicts include tags. My guess is that they needed the tag anyway so instead of giving it a fixed \"functor\", say "
                            },
                            {
                                "type": "text",
                                "text": "dict",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", they allowed an arbitrary tag name to be used\n\nEdit: the manual say dicts are \"structs with named arguments\", so they need a tag like any other structure, I guess"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "man-shrugging",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    }
]