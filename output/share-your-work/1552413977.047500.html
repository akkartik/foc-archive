<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-12 11:06</span><br/>
I'd like feedback on my concept of Loyc trees and LES. I mean, what runs through your mind as you first read about it? I suspect reactions will vary depending on the background of each person here... <a href="http://loyc.net/loyc-trees/">http://loyc.net/loyc-trees/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552417319.051300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1552417319.051300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-03-12 12:01</span><br/>
I spent a while looking at it, though I tapered off without major conclusions as other stuff piled on top of my reading.<br/><br/>Looking back, I think my concerns are social rather than technical. You're solving a fundamentally social problem: creating a protocol for interop. The big question to answer with new protocols is a non-technical one: <b>Why you?</b> What do you bring to the table that will get others to want to interoperate with you? I remember noticing that Loyc trees weren't worked on since 2015, and that only one implementation exists. These are signs that you need to do something qualitatively different than what you've been doing so far, to get others to take it seriously.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552745426.100900"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1552745426.100900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2019-03-16 07:10</span><br/>
<span style="background-color:#ccf">@David Piepgrass</span> I don't understand how Loyc trees are useful as a representation of a program. Programs written in different languages not only have different syntax, but different type systems and semantics. If you can't represent types and semantics, I don't know what operations you can usefully do with these trees. But perhaps I'm missing some of the reasoning here.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552745619.101100"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1552745619.101100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2019-03-16 07:13</span><br/>
If you're looking for program interoperability, you probably want a high-level assembly language. WebAssembly could actually become this over time, as it gets managed memory (coming soon), and potentially parametric polymorphism and algebraic types in the future.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552746273.101400"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1552746273.101400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2019-03-16 07:24</span><br/>
(That would make it easier to link memory managed languages together, but wouldn't help them link with C, which will forever be awkward due to irreconcilable differences)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552748715.101800"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1552748715.101800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-16 08:05</span><br/>
<span style="background-color:#ccf">@Nick Smith</span> I agree that a better route to interoperability is via WebAssembly. However interoperability is explicitly a non-goal of Wasm and I can't figure out how to break into working in that area anyway. (e.g. they have online CG meetings I couldn't attend while I had a job; they have in-person meetings in the Bay Area and somewhere in Europe (France?).) Two weeks ago I emailed the two main people involved in the GC/managed area to ask if there's any way I could find work in WebAssembly, or something like that, and neither of them replied.<br/><br/>Loyc trees are obviously not a solution to interoperability by themselves. They are simply a better representation than what has been used for similar purposes in the past: XML, JSON and ad-hoc plain text formats.<br/><br/>Partly it's about communication, between humans as much as machines - no one wants to explain that the syntax tree of <tt>class Foo { int x; }</tt> is <tt>&lt;TypeDefinitionStatement name="Foo"&gt;&lt;VariableDefinitionStatement type="System.Int32" name="x"/&gt;&lt;/TypeDefinitionStatement&gt;</tt>, especially since the actual internal representation will be somewhat different anyway. I think ASTs are a lot easier to discuss via LES.<br/><br/>Yes, every language has different semantics and dealing with that automatically is very tricky, but if we agree on a convention that <tt>#class(Foo, #(), { #var(#int32, x); })</tt> means something like <tt>class Foo { int x; }</tt>, that's a meaningful step on the path toward language conversion. ÃŒ'm starting to write a TypeScript language printer, and it's no big deal to translate the standardized type name <tt>#int32</tt> to <tt>number</tt>, so that this tree prints as <tt>class Foo { x: number; }</tt>.<br/><br/>Once a number of printers exist and I write a few macros to provide some ad-hoc transformations, I think a small language will emerge that can be translated to a few other languages automatically. This is nowhere near the end-goal, but it's another step on the path.<br/><br/><span style="background-color:#ccf">@Kartik Agaram</span> asked "why you?".<br/>1. Why not me?<br/>2. I never wanted it to just be me, I've always wanted more people working on it and providing feedback.<br/><br/>I'm not sure where you got the idea I didn't work on Loyc trees since 2015 - if it's the html page for Loyc trees, I actually made some edits without remembering to change the last-modified date. But it's true that I didn't work on Loyc stuff a lot in the last 3 years, and the reason is that I had failed to attract interest in my work for the 3 years before that, aside from one person. I believed in my ideas, but since my goal is to make the world a better place, seeing that the world was entirely disinterested was disheartening.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552751597.102300"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1552751597.102300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-16 08:53</span><br/>
Oh, and of course, it's meant as an equivalent of s-expressions for non-Lisp languages. Just as s-expressions form the basis of several different programming languages with different semantics, LES is designed to be a basis for future languages, so that you can build a non-Lisp programming language without writing a parser or printer. Very good for DSLs and prototypes.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552778529.103100"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1552778529.103100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2019-03-16 16:22</span><br/>
Thanks for the explanation David. Personally, the reason why LES doesn't sound exciting to me is simply that I've never considered language interoperability an important enough problem to work on (compared to problems of language design, implementation, and especially use). If I were to tackle the problem, I feel like assembly languages would be the only practical pathway, because they're the only way to capture the execution semantics alongside the program structure. It's unfortunate that it's not easy to contribute to the WebAssembly project: I agree it's only an "open" community group in theory, and not in practice (especially when Google and Mozilla are the ones who have the final say on design decisions). Nevertheless, there are some good people working on it, and I think it has a bright future ahead, even if they're prioritising things a little differently to how we'd like.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552778641.103400"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1552778641.103400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2019-03-16 16:24</span><br/>
Also, for building parsers, there are purpose-designed projects like <a href="https://github.com/harc/ohm">https://github.com/harc/ohm</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552783110.103600"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1552783110.103600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-16 17:38</span><br/>
Yeah, I made a parser generator too, called LLLPG; it is used to parse LES and EC#. But this one sounds like it has a good design philosophy.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553269129.115600"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553269129.115600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-22 08:38</span><br/>
Oh, another thing is, if you have a bunch of parsers and printers for Loyc trees for different languages, you can run language-agnostic algorithms on the syntax trees. Here are three examples:<br/><br/>1. LeMP: the lexical macro processor is language-agnostic and since it works at the level of syntax, not semantics, it can be used to transform code of any language.<br/>2. Tree-structured find / find and replace: I wrote basic pattern-matching and find-and-replace algorithms for Loyc trees, so again, given the necessary parsers, the same algorithms can be used with any language.<br/>3. Gathering comments. Typical lexers throw comments away since the parser can't easily handle comments in arbitrary locations. But if you gather the comments and newlines into a list, I've written a language-independent algorithm to recombine the comments with the Loyc tree produced by the parser. (It requires a small amount of custom code per-language, and in order for the algorithm to work reliably, there are some reasonable constraints on the relationship between the Loyc tree and the original text. But it's a lot less hassle than reimplementing the algorithm from scratch for every language.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553271649.116600"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553271649.116600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-03-22 09:20</span><br/>
Responding a couple of comments back, <span style="background-color:#ccf">@Nick Smith</span> I don't think a closed decision-making process can <em>ever</em> yield a hackable result. And if ever there was a project that needs the result to be hackable, it's WebAssembly. "Good people" is irrelevant.<br/><br/>Alternative phrasing: if you don't have a (potential) say in how it's implemented you aren't who it's designed for. Not really. Programming is fundamentally a political act. So yes, WebAssembly may well have a bright future. But it's a bright future for Mozilla and Google, not for the rest of us.<br/><br/>I've been citing Conway's Law a lot lately (<a href="https://en.wikipedia.org/wiki/Conway's_law">https://en.wikipedia.org/wiki/Conway's_law</a>). If your process for creating it is closed, the result will be closed also.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553271805.117000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553271805.117000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-03-22 09:23</span><br/>
<span style="background-color:#ccf">@David Piepgrass</span> Does supporting Loyc trees require parsing comments? Most (all?) languages filter out comments during lexing. Actually including comments in the parse tree massively complicates the grammar, because every non-terminal may turn into 2, or 3.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553274575.119400"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553274575.119400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-22 10:09</span><br/>
No, what I'm saying is that the parser never sees the comments, the lexer throws them "out" - into a list of comment tokens - before they reach the parser. Then you use <tt>StandardTriviaInjector</tt> to recombine the comments with the syntax tree.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553275197.119900"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553275197.119900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-22 10:19</span><br/>
So with Loyc trees you get this feature almost for free, and you can use it to build other tools (e.g. documentation generator, documentation detector in IDEs) more easily. You could also build refactoring tools, although other designs like Roslyn are better for refactoring since they preserve the parse tree, whereas all my code so far has only been designed to preserve the AST (this approach saves memory and since my goal was conversion between languages, the complete parse tree was not relevant for my purposes.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553275635.120300"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553275635.120300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-22 10:27</span><br/>
Note that WebAssembly's decision process is semi-open via the Community Group, though some key decisions were made more privately. I think it's fair to say that Mozilla and Google will end up with most of the power since they are the only ones funding people to work on Wasm full-time. If you live in the Bay Area you could probably attend in-person meetings and theoretically have as much say in Wasm as Mozilla and Google, but let's face it, if no one is paying you to do that, how can you work on it in the Bay Area where rent is crazy, or fly to Paris for some meetings?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553275814.120500"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553275814.120500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-22 10:30</span><br/>
But my main concern is their goals - the goal isn't to achieve the "best" solution that will support "all" programming languages, nor is interop a goal - I think the goal is to support <em>most</em> programming languages <em>more-or-less</em> with <em>reasonably short time to market</em> and probably without spending too much money on it... which to me is aiming low. I'm worried that WebAssembly will become wildly popular and then features that could have been possible in new programming languages will be dropped because "Wasm can't do that" or "We can do that but there would be a performance hit on Wasm so... let's not bother".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553276521.121700"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553276521.121700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-03-22 10:42</span><br/>
How does <tt>StandardTriviaInjector</tt> know where to add each comment? Do you include source code location information when funneling them out? (At that point the lexer only has row/column co-ordinates; does the grammar have to carry that information along to permit recombination downstream?)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553276765.121900"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553276765.121900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-22 10:46</span><br/>
Loyc trees include a source range per-node and the tokens, of course, should also have that. (Source ranges use half the memory compared to pairs of row/column and are often easier for algorithms to work with.) IIRC, the syntax tree from the parser needs to <em>mostly</em> follow the constraint that for each node X, the range of all children of X is a subrange of X's range, and ranges of siblings must not overlap. The children are not required to be in order but it's slower if they are out-of-order.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553276912.122200"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553276912.122200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-22 10:48</span><br/>
See documentation: <a href="http://ecsharp.net/doc/code/classLoyc_1_1Syntax_1_1AbstractTriviaInjector.html">http://ecsharp.net/doc/code/classLoyc_1_1Syntax_1_1AbstractTriviaInjector.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553276984.122400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553276984.122400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-03-22 10:49</span><br/>
Do existing languages need to change to plumb source ranges through?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553277228.122600"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553277228.122600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-22 10:53</span><br/>
Most parsers already do this in order to be able to report warnings/errors long after parsing is done. (The hard part is converting an existing parser's output to a Loyc tree. And I haven't quite worked out how I'll port my existing code to the language in which most parsers are written - C++. I plan to work on surface syntax conversion first.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553278715.123700"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553278715.123700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-03-22 11:18</span><br/>
They're tracking <em>something</em> but is it source ranges? Do the units interoperate?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1553280343.124500"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../share-your-work/1552413977.047500.html#1553280343.124500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2019-03-22 11:45</span><br/>
I predict it'll usually be ranges but the lowest-common-denominator is row/col pairs, as all parsers need to be able to produce those for error messages. As a hack the algorithm ought to still generally work if you combine row/cols into an integer (like, top 16 bits for row, 15 bits for col). A bit less hacky, one could use <tt>IndexPositionMapper</tt> to go from row/cols back to indexes. The main thing some parsers might be missing is an end index (in compilers that can only report start indexes in errors, not ranges) in which case, yeah, you'd have to retrofit the parser. And some parsers (including my own) might occasionally have a bug in their range assignments, which tends to cause comments to be assigned to the wrong place in the AST.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
