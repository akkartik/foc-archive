<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1651254426.150879.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-04-29 10:47</span><br/>
Parsers generators allow you to write code that creates trees (usually), from a string of characters. So a way of creating a sort of abstractly 2D thing from a 1D representation. Is there an equivalent tool for generating representations from symbols arranged in 2D? A node-and-arrow parser generator, for example? Something in the graph database world?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651256716.907359"></a>
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1651254426.150879.html#1651256716.907359" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-04-29 11:25</span><br/>
I think a good small example would be a tool that allowed you to define linear graphemes, which is ironically both above ("we don't process 2D images") and below ("we already have characters") the scope of parser generators. Imagine describing "two parallel straight lines of the same length connected at an obtuse angle by a constant radius curved line" for the uppercase U. Are there tools for that?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651259463.493579"></a>
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1651254426.150879.html#1651259463.493579" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-04-29 12:11</span><br/>
A large example would be something that detects and parses UML diagrams on a whiteboard. Which seems very promising.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651264590.697439"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1651254426.150879.html#1651264590.697439" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2022-04-29 13:36</span><br/>
Not sure it's what you are looking for but the cypher query language is kind of "ascii art graph pattern matching"<br/><br/><br/><pre style="white-space:pre-wrap">MATCH (nicole:Actor {name: 'Nicole Kidman'})-[:ACTED_IN]-&gt;(movie:Movie)<br/>WHERE movie.year &lt; $yearParameter<br/>RETURN movie</pre><br/>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651269541.591509"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1651254426.150879.html#1651269541.591509" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-04-29 14:59</span><br/>
- FYI - there are 2 kinds of parser generators<br/>1. parser generators based on language definitions (YACC, LR(k), etc.)<br/>2. parser generators based on DSLs for specifying parsers (PEG, Ohm-JS, etc.)<br/>- DaS (Diagrams as Syntax) If you are interested in experiments, I would be glad to share<br/>- I argue that graphics is not the problem, but ascribing meaning (semantics) to the diagrams is the problem, start small and build up, e.g.<br/>	- what does a “box” compile to?<br/>	- what do boxes-with-ports-and-arrows compile to?<br/>	-  what do concentric boxes compile to?<br/>- “we already have characters”<br/>	- we use characters for IDEs (aka programming languages) only because mid-1900s hardware made it easier to grok grids of non-overlapping, small bitmaps
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651270332.069189"></a>
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1651254426.150879.html#1651270332.069189" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-04-29 15:12</span><br/>
I'm not clear what the difference is between a "language definition" and an expression in a "DSL for specifying parsers". But what I'd love to see is an example of 1 or 2 where the elements being parsed are graphical... lines, points, colours, shapes. Graphics is not a problem, agreed. And you can always roll-your-own in terms of parsing from some unusual user input. It's just a data tarnsformation. I'm just curious if the idea of parsing from graphical input has ever been abstracted in the way that is has for text.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651272082.880249"></a>
      <img src="https://avatars.slack-edge.com/2022-04-29/3447576657367_f58a6508f11105e0d0be_72.png" style="float:left"/>
      <a href="../thinking-together/1651254426.150879.html#1651272082.880249" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alex Cruise</b>
<span style="margin:2em; color:#606060">2022-04-29 15:41</span><br/>
like OCR but for symbols that aren’t necessarily characters :wink:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651272178.838069"></a>
      <img src="https://avatars.slack-edge.com/2022-04-29/3447576657367_f58a6508f11105e0d0be_72.png" style="float:left"/>
      <a href="../thinking-together/1651254426.150879.html#1651272178.838069" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alex Cruise</b>
<span style="margin:2em; color:#606060">2022-04-29 15:42</span><br/>
I’ve drawn thousands of whiteboards over the years… transcribing them into diagram drawing software is usually an opportunity to revisit, clarify and edit. :sweat_smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1651272612.981879"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1651254426.150879.html#1651272612.981879" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-04-29 15:50</span><br/>
collecting dust on my shelf<br/>- <a href="https://link.springer.com/book/10.1007/978-1-4612-1676-6">https://link.springer.com/book/10.1007/978-1-4612-1676-6</a><br/>- (tc;dr)<br/>- all you really need is SVG + contains () + intersects () + connectedTo ()<br/>- see sections “Expressive Power” and “Ambiguity Detection” in <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">https://en.wikipedia.org/wiki/Parsing_expression_grammar</a><br/>	- PEG defines a <b>parser</b> in a top-down manner (TDPL), e.g. “if this matches, try to match this next”<br/>	- LR(k) and LL(k) define <b>languages</b> in a bottom-up manner, e.g. “if this looks like a number, then bubble it upwards as a number” (regardless of the context) ; this is what is taught as “language  theory”, and is commonly understood to form the basis of parser generators<br/>	- TDPL is order-dependent, Lx(k) is not order-dependent (but more restricted)
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
