[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1685283278.761809",
        "client_msg_id": "5a3a46d6-5e01-4b0b-b611-2a1dcfc79be4",
        "text": "Software Engineers do not write code.\n\nImplementors (coders) write code.\n\nEngineers think (deeply) about what code needs to be written, and, what trade-offs need to be made to simply make the system work.\n\nProduction Engineers think about making trade-offs so that the system is “efficient” along one or more dimensions (speed, space, cost, etc.), but, only after the initial system is working and shown to satisfy end-users’ needs.\n\nCurrent popular programming languages, like Rust, Haskell, Python, etc., conflate all of these issues together, thus,  making the code more difficult to design.  Conflating issues together like this has a name: “cottage industry”.\n\nThen, there’s Software Architecture, Maintenance, Testing, Q\/A, Security, etc., etc.\n\nThe above pattern is visible in other, older professions, such as building construction.  Software might re-use these ideas and re-purpose them for creating electronic machines.\n\nNote, too, that more-established professions use diagrams to augment the use of written words when communicating designs (blueprints, schematics, molecular diagrams, etc.).\n\nNote, too, that more-established professions use elements that are completely isolated and decoupled from one another.  This assumption (of inherent non-coupling) is violated by most popular programming languages.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1685283278.761809",
        "reply_count": 5,
        "reply_users_count": 4,
        "latest_reply": "1685793063.009289",
        "reply_users": [
            "UMQ6LR9NZ",
            "UGWUJUZHT",
            "U03A53YJB1A",
            "U04E5QAD6DD"
        ],
        "replies": [
            {
                "user": "UMQ6LR9NZ",
                "ts": "1685287034.275639"
            },
            {
                "user": "UMQ6LR9NZ",
                "ts": "1685287322.146709"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1685292380.838139"
            },
            {
                "user": "U03A53YJB1A",
                "ts": "1685645283.348519"
            },
            {
                "user": "U04E5QAD6DD",
                "ts": "1685793063.009289"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ndg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Software Engineers do not write code.\n\nImplementors (coders) write code.\n\nEngineers think (deeply) about what code needs to be written, and, what trade-offs need to be made to simply make the system work.\n\nProduction Engineers think about making trade-offs so that the system is “efficient” along one or more dimensions (speed, space, cost, etc.), but, only after the initial system is working and shown to satisfy end-users’ needs.\n\nCurrent popular programming languages, like Rust, Haskell, Python, etc., conflate all of these issues together, thus,  making the code more difficult to design.  Conflating issues together like this has a name: “cottage industry”.\n\nThen, there’s Software Architecture, Maintenance, Testing, Q\/A, Security, etc., etc.\n\nThe above pattern is visible in other, older professions, such as building construction.  Software might re-use these ideas and re-purpose them for creating electronic machines.\n\nNote, too, that more-established professions use diagrams to augment the use of written words when communicating designs (blueprints, schematics, molecular diagrams, etc.).\n\nNote, too, that more-established professions use elements that are completely isolated and decoupled from one another.  This assumption (of inherent non-coupling) is violated by most popular programming languages."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "U85HCL7JP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UMQ6LR9NZ",
        "type": "message",
        "ts": "1685287034.275639",
        "client_msg_id": "c8716725-c310-4189-a993-959a0117fc6e",
        "text": "&gt; The above pattern is visible in other, older professions, such as building construction.  Software might re-use these ideas and re-purpose them for creating electronic machines.\n&gt; \n&gt; Note, too, that more-established professions use diagrams to augment the use of written words when communicating designs (blueprints, schematics, molecular diagrams, etc.).\ndo you think that software development has any actual similarities to construction in the arc of it's actual praxis when removed from business contexts?\n\nBy this question I mean: it seems that a lot of folks readily reach for architectural\/engineering analogs when talking about software dev., but, when I think it through I struggle to see the actual similarities outside of how projects are run...and how projects are run, to my mind, has little to nothing to do with producing good outcomes and everything to do with leaning on known business processes.\n\nWhat if a software team was run more like a kitchen, or software dev was thought of as being more akin to weaving at a loom?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf70d12f2630",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f70d12f2630b6c2a0854e3bef118e73c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "Eli",
            "real_name": "Eli Mellen",
            "display_name": "Eli",
            "team": "T5TCAFTA9",
            "name": "eli.mellen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1685283278.761809",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qe8IY",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The above pattern is visible in other, older professions, such as building construction.  Software might re-use these ideas and re-purpose them for creating electronic machines.\n\nNote, too, that more-established professions use diagrams to augment the use of written words when communicating designs (blueprints, schematics, molecular diagrams, etc.)."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\ndo you think that software development has any actual similarities to construction in the arc of it's actual praxis when removed from business contexts?\n\nBy this question I mean: it seems that a lot of folks readily reach for architectural\/engineering analogs when talking about software dev., but, when I think it through I struggle to see the actual similarities outside of how projects are run...and how projects are run, to my mind, has little to nothing to do with producing good outcomes and everything to do with leaning on known business processes.\n\nWhat if a software team was run more like a kitchen, or software dev was thought of as being more akin to weaving at a loom?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "U01LCRM5RT7"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "U01LCRM5RT7"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UMQ6LR9NZ",
        "type": "message",
        "ts": "1685287322.146709",
        "client_msg_id": "96769e9f-b409-4478-a8b1-f765eca7d6c7",
        "text": "&gt; Note, too, that more-established professions use elements that are completely isolated and decoupled from one another.  This assumption (of inherent non-coupling) is violated by most popular programming languages.\nI think this bit is true, but missing some nuance in that a lot of software that is developed isn't developed exclusively by programmers using programming languages -- there are designers using design tools, there may be researchers using various research methods, etc.\n\nThose different roles tend to rely on elements that are wholly (or at least mostly) isolated and decoupled from one another.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf70d12f2630",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f70d12f2630b6c2a0854e3bef118e73c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "Eli",
            "real_name": "Eli Mellen",
            "display_name": "Eli",
            "team": "T5TCAFTA9",
            "name": "eli.mellen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1685283278.761809",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "enT",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Note, too, that more-established professions use elements that are completely isolated and decoupled from one another.  This assumption (of inherent non-coupling) is violated by most popular programming languages."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI think this bit is true, but missing some nuance in that a lot of software that is developed isn't developed exclusively by programmers using programming languages -- there are designers using design tools, there may be researchers using various research methods, etc.\n\nThose different roles tend to rely on elements that are wholly (or at least mostly) isolated and decoupled from one another."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1685292380.838139",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1685292972.000000"
        },
        "client_msg_id": "56f4b992-06bd-47e3-be9d-0806d028a678",
        "text": "Yes, I believe that software development should be like The Film Industry (or Construction, or ...)\n\nBut, I believe that software development - in its current form - cannot be easily stratified into layers.  The wrong questions are being asked, emphasis is not being placed on layered processes and technologies.\n\nEngineering processes were not created by business.  Engineering processes were created by Engineering.  Business capitalized on this structure, later.\n\n” ... Those different roles tend to rely on elements that are wholly (or at least mostly) isolated and decoupled from one another. ...”\n\nSoftware libraries, though, are not wholly isolated.  This limits growth and prevents a Moore’s Law for Software from existing and prevents Christopher Alexander-like Patterns from being applied (easily).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1685283278.761809",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TWUIG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, I believe that software development should be like The Film Industry (or Construction, or ...)\n\nBut, I believe that software development - in its current form - cannot be easily stratified into layers.  The wrong questions are being asked, emphasis is not being placed on layered processes and technologies.\n\nEngineering processes were not created by business.  Engineering processes were created by Engineering.  Business capitalized on this structure, later.\n\n” ... Those different roles tend to rely on elements that are wholly (or at least mostly) isolated and decoupled from one another. ...”\n\nSoftware libraries, though, are not wholly isolated.  This limits growth and prevents a Moore’s Law for Software from existing and prevents Christopher Alexander-like Patterns from being applied (easily)."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UMQ6LR9NZ"
                ],
                "count": 1
            }
        ]
    }
]