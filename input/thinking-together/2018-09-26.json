[
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537948820.000100",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1537955701.000000"
        },
        "client_msg_id": "f2e6caef-0ad5-4bb2-aa9a-c35e08eed3eb",
        "text": "I’m curious: does anyone agree with the proposition that Elm (<http:\/\/elm-lang.org\/>) has a pretty decent programming model and user experience which if matched with a “good” development environment can lead somewhere “future programmey”? I think it’s targeting the right platform (Web and soon WASM), is developed with the right mindset (extreme learnability) and using the right paradigms (purely functional programming and something close to the actor model). It is designed for producing GUI-based apps out of the box (abstractions over HTML\/CSS) rather than printf-based terminal apps. What I feel it’s missing is integration with the “right” development environment (something like Light Table as a starting point).\n\nI’ve been thinking about what a “right” environment entails. After having contemplated “future programming” for around 3 years now, I don’t think that developing visual languages or augmenting text with visual widgets (i.e. working on how to _present_ code) will get us very far. This has been tried for decades in many different forms and the ideas rarely hold up, so my hunch is that addressing challenges through visual representations is a dead end. The right kind of question to ask is perhaps: what does an effective development _workflow_ look like? This hints that a focus on tools may be needed: for example instant feedback tools (how do I see what the thing I’m building actually does), code organisation tools (where do I put code and documentation, how do I keep track of history, and how do I find the right thing when I need it), sharing tools (how do I share _libraries_ and how do I share _applications_), and collaboration tools (how do I work as part of a team). Importantly, the building blocks of a language are themselves tools for constructing programs. They’re the “obvious” thing that has been a central focus for decades but they remain an important consideration.\n\nSo far I’ve been referring to things that many “Future of Programming” people have identified as desirable, but my own understanding of the Future of Programming involves technologies outside what we consider “programming tech” today: stuff like glasses-based AR for the interface (we’re headed beyond WIMP and the desktop metaphor; give it 5 years) and autonomous distributed systems as a computational material (“blockchains” but not as useless as existing ones: something close to the potential of <https:\/\/dfinity.org\/>). All this stuff is out of our hands, but we should factor it all into our understanding of what tech is on the horizon and how it will affect how we might build programming editors and programs. Some of it could be game-changing.\n\nThat’s my brain dump anyway. I’d be interested to hear where people agree and where your thoughts differ.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "reply_count": 27,
        "reply_users_count": 5,
        "latest_reply": "1538153115.000100",
        "reply_users": [
            "UCKRZS3DZ",
            "UCGAK10LS",
            "U85HCL7JP",
            "U8A5MS6R1",
            "U5STGTB3J"
        ],
        "replies": [
            {
                "user": "UCKRZS3DZ",
                "ts": "1537955125.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1537955981.000100"
            },
            {
                "user": "UCKRZS3DZ",
                "ts": "1537956511.000100"
            },
            {
                "user": "UCKRZS3DZ",
                "ts": "1537956613.000100"
            },
            {
                "user": "UCKRZS3DZ",
                "ts": "1537957119.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1537958341.000100"
            },
            {
                "user": "UCKRZS3DZ",
                "ts": "1537958395.000100"
            },
            {
                "user": "U85HCL7JP",
                "ts": "1537977376.000100"
            },
            {
                "user": "U85HCL7JP",
                "ts": "1537977666.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1537980220.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1537999031.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1537999587.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1538003079.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1538032552.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1538033853.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1538069872.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1538069873.000100"
            },
            {
                "user": "UCKRZS3DZ",
                "ts": "1538082273.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1538090450.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1538099754.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1538100913.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1538102432.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1538106952.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1538112212.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1538112349.000100"
            },
            {
                "user": "U5STGTB3J",
                "ts": "1538145722.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1538153115.000100"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yur",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I’m curious: does anyone agree with the proposition that Elm ("
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/elm-lang.org\/"
                            },
                            {
                                "type": "text",
                                "text": ") has a pretty decent programming model and user experience which if matched with a “good” development environment can lead somewhere “future programmey”? I think it’s targeting the right platform (Web and soon WASM), is developed with the right mindset (extreme learnability) and using the right paradigms (purely functional programming and something close to the actor model). It is designed for producing GUI-based apps out of the box (abstractions over HTML\/CSS) rather than printf-based terminal apps. What I feel it’s missing is integration with the “right” development environment (something like Light Table as a starting point).\n\nI’ve been thinking about what a “right” environment entails. After having contemplated “future programming” for around 3 years now, I don’t think that developing visual languages or augmenting text with visual widgets (i.e. working on how to "
                            },
                            {
                                "type": "text",
                                "text": "present",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " code) will get us very far. This has been tried for decades in many different forms and the ideas rarely hold up, so my hunch is that addressing challenges through visual representations is a dead end. The right kind of question to ask is perhaps: what does an effective development "
                            },
                            {
                                "type": "text",
                                "text": "workflow",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " look like? This hints that a focus on tools may be needed: for example instant feedback tools (how do I see what the thing I’m building actually does), code organisation tools (where do I put code and documentation, how do I keep track of history, and how do I find the right thing when I need it), sharing tools (how do I share "
                            },
                            {
                                "type": "text",
                                "text": "libraries",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and how do I share "
                            },
                            {
                                "type": "text",
                                "text": "applications",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "), and collaboration tools (how do I work as part of a team). Importantly, the building blocks of a language are themselves tools for constructing programs. They’re the “obvious” thing that has been a central focus for decades but they remain an important consideration.\n\nSo far I’ve been referring to things that many “Future of Programming” people have identified as desirable, but my own understanding of the Future of Programming involves technologies outside what we consider “programming tech” today: stuff like glasses-based AR for the interface (we’re headed beyond WIMP and the desktop metaphor; give it 5 years) and autonomous distributed systems as a computational material (“blockchains” but not as useless as existing ones: something close to the potential of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/dfinity.org\/"
                            },
                            {
                                "type": "text",
                                "text": "). All this stuff is out of our hands, but we should factor it all into our understanding of what tech is on the horizon and how it will affect how we might build programming editors and programs. Some of it could be game-changing.\n\nThat’s my brain dump anyway. I’d be interested to hear where people agree and where your thoughts differ."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537948954.000100",
        "client_msg_id": "0b823194-56a7-4a80-a589-5dcf7886da12",
        "text": "Also, is anyone based in Australia? Nobody working on this stuff ever seems to be from Australia :stuck_out_tongue:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948954.000100",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1543991587.062400",
        "reply_users": [
            "UCSJ44X1S",
            "UCGAK10LS"
        ],
        "replies": [
            {
                "user": "UCSJ44X1S",
                "ts": "1543764771.045700"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1543991587.062400"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eno9A",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, is anyone based in Australia? Nobody working on this stuff ever seems to be from Australia "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue",
                                "unicode": "1f61b"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1537953961.000100",
        "client_msg_id": "A36C8F9D-96EB-4FD5-9BE5-BB603BCD8C24",
        "text": "<@UCGAK10LS> The AR\/VR\/MR space has a certain UI possibility excitement that I haven't felt since being a kid in the 80s.  (Online in the 90s and mobile were smaller blips.)  I take the variety of dubious, beautifully awful VR experiences as a great sign.  I'm sure we'll figure out how to \"ruin\" it, but the potential here?  It's exciting and surprising.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537953961.000100",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1537975881.000100",
        "reply_users": [
            "UCGAK10LS",
            "U5STGTB3J",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "UCGAK10LS",
                "ts": "1537954214.000100"
            },
            {
                "user": "U5STGTB3J",
                "ts": "1537972580.000100"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1537975881.000100"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rgmZK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " The AR\/VR\/MR space has a certain UI possibility excitement that I haven't felt since being a kid in the 80s.  (Online in the 90s and mobile were smaller blips.)  I take the variety of dubious, beautifully awful VR experiences as a great sign.  I'm sure we'll figure out how to \"ruin\" it, but the potential here?  It's exciting and surprising."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537954214.000100",
        "client_msg_id": "48ee43ff-2ab8-4e47-8bad-9e6d0671c0a8",
        "text": "It’s definitely exciting. My own theory is that AR glasses will end up being the dominant thing (rather than VR) because they let you still do your work in a physical workspace and let you easily transition between (and cross-contaminate) the physical and the digital. VR seems like it will end up being better for “immersive” experiences rather than day-to-day work.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537953961.000100",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Fua",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It’s definitely exciting. My own theory is that AR glasses will end up being the dominant thing (rather than VR) because they let you still do your work in a physical workspace and let you easily transition between (and cross-contaminate) the physical and the digital. VR seems like it will end up being better for “immersive” experiences rather than day-to-day work."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "thread_broadcast",
        "user": "UCKRZS3DZ",
        "thread_ts": "1537948820.000100",
        "root": {
            "user": "UCGAK10LS",
            "type": "message",
            "ts": "1537948820.000100",
            "edited": {
                "user": "UCGAK10LS",
                "ts": "1537955701.000000"
            },
            "client_msg_id": "f2e6caef-0ad5-4bb2-aa9a-c35e08eed3eb",
            "text": "I’m curious: does anyone agree with the proposition that Elm (<http:\/\/elm-lang.org\/>) has a pretty decent programming model and user experience which if matched with a “good” development environment can lead somewhere “future programmey”? I think it’s targeting the right platform (Web and soon WASM), is developed with the right mindset (extreme learnability) and using the right paradigms (purely functional programming and something close to the actor model). It is designed for producing GUI-based apps out of the box (abstractions over HTML\/CSS) rather than printf-based terminal apps. What I feel it’s missing is integration with the “right” development environment (something like Light Table as a starting point).\n\nI’ve been thinking about what a “right” environment entails. After having contemplated “future programming” for around 3 years now, I don’t think that developing visual languages or augmenting text with visual widgets (i.e. working on how to _present_ code) will get us very far. This has been tried for decades in many different forms and the ideas rarely hold up, so my hunch is that addressing challenges through visual representations is a dead end. The right kind of question to ask is perhaps: what does an effective development _workflow_ look like? This hints that a focus on tools may be needed: for example instant feedback tools (how do I see what the thing I’m building actually does), code organisation tools (where do I put code and documentation, how do I keep track of history, and how do I find the right thing when I need it), sharing tools (how do I share _libraries_ and how do I share _applications_), and collaboration tools (how do I work as part of a team). Importantly, the building blocks of a language are themselves tools for constructing programs. They’re the “obvious” thing that has been a central focus for decades but they remain an important consideration.\n\nSo far I’ve been referring to things that many “Future of Programming” people have identified as desirable, but my own understanding of the Future of Programming involves technologies outside what we consider “programming tech” today: stuff like glasses-based AR for the interface (we’re headed beyond WIMP and the desktop metaphor; give it 5 years) and autonomous distributed systems as a computational material (“blockchains” but not as useless as existing ones: something close to the potential of <https:\/\/dfinity.org\/>). All this stuff is out of our hands, but we should factor it all into our understanding of what tech is on the horizon and how it will affect how we might build programming editors and programs. Some of it could be game-changing.\n\nThat’s my brain dump anyway. I’d be interested to hear where people agree and where your thoughts differ.",
            "team": "T5TCAFTA9",
            "thread_ts": "1537948820.000100",
            "reply_count": 27,
            "reply_users_count": 5,
            "latest_reply": "1538153115.000100",
            "reply_users": [
                "UCKRZS3DZ",
                "UCGAK10LS",
                "U85HCL7JP",
                "U8A5MS6R1",
                "U5STGTB3J"
            ],
            "replies": [
                {
                    "user": "UCKRZS3DZ",
                    "ts": "1537955125.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1537955981.000100"
                },
                {
                    "user": "UCKRZS3DZ",
                    "ts": "1537956511.000100"
                },
                {
                    "user": "UCKRZS3DZ",
                    "ts": "1537956613.000100"
                },
                {
                    "user": "UCKRZS3DZ",
                    "ts": "1537957119.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1537958341.000100"
                },
                {
                    "user": "UCKRZS3DZ",
                    "ts": "1537958395.000100"
                },
                {
                    "user": "U85HCL7JP",
                    "ts": "1537977376.000100"
                },
                {
                    "user": "U85HCL7JP",
                    "ts": "1537977666.000100"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1537980220.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1537999031.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1537999587.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1538003079.000100"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1538032552.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1538033853.000100"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1538069872.000100"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1538069873.000100"
                },
                {
                    "user": "UCKRZS3DZ",
                    "ts": "1538082273.000100"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1538090450.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1538099754.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1538100913.000100"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1538102432.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1538106952.000100"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1538112212.000100"
                },
                {
                    "user": "UCGAK10LS",
                    "ts": "1538112349.000100"
                },
                {
                    "user": "U5STGTB3J",
                    "ts": "1538145722.000100"
                },
                {
                    "user": "U8A5MS6R1",
                    "ts": "1538153115.000100"
                }
            ],
            "is_locked": false,
            "subscribed": false,
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "PZH",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "I’m curious: does anyone agree with the proposition that Elm ("
                                },
                                {
                                    "type": "link",
                                    "url": "http:\/\/elm-lang.org\/"
                                },
                                {
                                    "type": "text",
                                    "text": ") has a pretty decent programming model and user experience which if matched with a “good” development environment can lead somewhere “future programmey”? I think it’s targeting the right platform (Web and soon WASM), is developed with the right mindset (extreme learnability) and using the right paradigms (purely functional programming and something close to the actor model). It is designed for producing GUI-based apps out of the box (abstractions over HTML\/CSS) rather than printf-based terminal apps. What I feel it’s missing is integration with the “right” development environment (something like Light Table as a starting point).\n\nI’ve been thinking about what a “right” environment entails. After having contemplated “future programming” for around 3 years now, I don’t think that developing visual languages or augmenting text with visual widgets (i.e. working on how to "
                                },
                                {
                                    "type": "text",
                                    "text": "present",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " code) will get us very far. This has been tried for decades in many different forms and the ideas rarely hold up, so my hunch is that addressing challenges through visual representations is a dead end. The right kind of question to ask is perhaps: what does an effective development "
                                },
                                {
                                    "type": "text",
                                    "text": "workflow",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " look like? This hints that a focus on tools may be needed: for example instant feedback tools (how do I see what the thing I’m building actually does), code organisation tools (where do I put code and documentation, how do I keep track of history, and how do I find the right thing when I need it), sharing tools (how do I share "
                                },
                                {
                                    "type": "text",
                                    "text": "libraries",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " and how do I share "
                                },
                                {
                                    "type": "text",
                                    "text": "applications",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": "), and collaboration tools (how do I work as part of a team). Importantly, the building blocks of a language are themselves tools for constructing programs. They’re the “obvious” thing that has been a central focus for decades but they remain an important consideration.\n\nSo far I’ve been referring to things that many “Future of Programming” people have identified as desirable, but my own understanding of the Future of Programming involves technologies outside what we consider “programming tech” today: stuff like glasses-based AR for the interface (we’re headed beyond WIMP and the desktop metaphor; give it 5 years) and autonomous distributed systems as a computational material (“blockchains” but not as useless as existing ones: something close to the potential of "
                                },
                                {
                                    "type": "link",
                                    "url": "https:\/\/dfinity.org\/"
                                },
                                {
                                    "type": "text",
                                    "text": "). All this stuff is out of our hands, but we should factor it all into our understanding of what tech is on the horizon and how it will affect how we might build programming editors and programs. Some of it could be game-changing.\n\nThat’s my brain dump anyway. I’d be interested to hear where people agree and where your thoughts differ."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        "type": "message",
        "ts": "1537955125.000100",
        "edited": {
            "user": "UCKRZS3DZ",
            "ts": "1537955493.000000"
        },
        "client_msg_id": "8b6faa03-c29c-494c-8380-7a5434dfbed2",
        "text": "Hey <@UCGAK10LS>!\n\nI don't have any experience with Elm but I got an image that it's too restricted with its' type system.\n\nFuture Programming for me always associated with hot code reload and live programming. How can programming platform both have static type check and code reload with state transition between old and new versions of code? As far as I understand, it will require to write migration code for each code reload.\n\nI like this statement of Alan Kay:\n\n&gt; I'm not against types, but I don't know of any type systems that aren't a complete pain, so I still like dynamic typing",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WqMz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hey "
                            },
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": "!\n\nI don't have any experience with Elm but I got an image that it's too restricted with its' type system.\n\nFuture Programming for me always associated with hot code reload and live programming. How can programming platform both have static type check and code reload with state transition between old and new versions of code? As far as I understand, it will require to write migration code for each code reload.\n\nI like this statement of Alan Kay:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not against types, but I don't know of any type systems that aren't a complete pain, so I still like dynamic typing"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537955981.000100",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1537956334.000000"
        },
        "client_msg_id": "09ED6FAA-AB3C-4825-BCA7-B44309AA0B28",
        "text": "<@UCKRZS3DZ> My understanding is that static vs dynamic typing has very little impact on hot reloading or live programming. If you change code so that it causes a data type incompatibility, it will crash regardless of whether those types are statically checked or dynamically checked. Dynamic typing is just about delaying those checks until the moment the code runs, after all. Do you disagree with any of this?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l4W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCKRZS3DZ"
                            },
                            {
                                "type": "text",
                                "text": " My understanding is that static vs dynamic typing has very little impact on hot reloading or live programming. If you change code so that it causes a data type incompatibility, it will crash regardless of whether those types are statically checked or dynamically checked. Dynamic typing is just about delaying those checks until the moment the code runs, after all. Do you disagree with any of this?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537956259.000100",
        "text": "",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "fallback": "[September 26th, 2018 7:59 PM] nmsmith65: <@UCKRZS3DZ> My understanding is that static vs dynamic typing has very little impact on hot reloading or live programming. If you change code so that it causes a data type incompatibility, it will crash whether or not those types are statically checked or dynamically checked. Dynamic typing is just about delaying those checks until the moment the code runs, after all. Do you disagree with any of this?",
                "ts": "1537955981.000100",
                "author_id": "UCGAK10LS",
                "author_subname": "Nick Smith",
                "channel_id": "C5T9GPWFL",
                "is_msg_unfurl": true,
                "is_reply_unfurl": true,
                "text": "<@UCKRZS3DZ> My understanding is that static vs dynamic typing has very little impact on hot reloading or live programming. If you change code so that it causes a data type incompatibility, it will crash whether or not those types are statically checked or dynamically checked. Dynamic typing is just about delaying those checks until the moment the code runs, after all. Do you disagree with any of this?",
                "author_name": "Nick Smith",
                "author_link": "https:\/\/futureprogramming.slack.com\/team\/UCGAK10LS",
                "author_icon": "https:\/\/secure.gravatar.com\/avatar\/2ff9f833591969741be3573d880baa0d.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2F66f9%2Fimg%2Favatars%2Fava_0011-48.png",
                "mrkdwn_in": [
                    "text"
                ],
                "color": "D0D0D0",
                "from_url": "https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1537955981000100?thread_ts=1537948820000100&cid=C5T9GPWFL",
                "is_share": true,
                "footer": "Thread in Slack Conversation"
            }
        ]
    },
    {
        "user": "UCKRZS3DZ",
        "type": "message",
        "ts": "1537956511.000100",
        "edited": {
            "user": "UCKRZS3DZ",
            "ts": "1537956526.000000"
        },
        "client_msg_id": "966078de-c5bb-4332-8430-a61a9aa71d8f",
        "text": "Consider this:\n\nImage we have some event callbacks that accept and return state. Image that this state is a tuple with six elements.\n\nWe change code, write some more event callbacks and realize that we need more data. We add new field, change state type from six to seven elements tuple.\n\nWe have working program that has data in state that we don't want to lose (say socket connection). We load new code. This additional field in tuple breaks typechecks, breaks matching.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "222a2870915d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-15\/861537614034_222a2870915d24ec10cc_72.jpg",
            "first_name": "Vladimir",
            "real_name": "Vladimir Gordeev",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gordeev.vladimir.v",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BjQ2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Consider this:\n\nImage we have some event callbacks that accept and return state. Image that this state is a tuple with six elements.\n\nWe change code, write some more event callbacks and realize that we need more data. We add new field, change state type from six to seven elements tuple.\n\nWe have working program that has data in state that we don't want to lose (say socket connection). We load new code. This additional field in tuple breaks typechecks, breaks matching."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCKRZS3DZ",
        "type": "message",
        "ts": "1537956613.000100",
        "edited": {
            "user": "UCKRZS3DZ",
            "ts": "1537956680.000000"
        },
        "client_msg_id": "b574c28d-eb6b-4e82-97c4-4e7916598243",
        "text": "You need some kind of migration, if you keep name of the type, but change what it describes, right?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "222a2870915d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-15\/861537614034_222a2870915d24ec10cc_72.jpg",
            "first_name": "Vladimir",
            "real_name": "Vladimir Gordeev",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gordeev.vladimir.v",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VSf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You need some kind of migration, if you keep name of the type, but change what it describes, right?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCKRZS3DZ",
        "type": "message",
        "ts": "1537957119.000100",
        "edited": {
            "user": "UCKRZS3DZ",
            "ts": "1537957188.000000"
        },
        "client_msg_id": "1a362806-2f24-4010-a62a-e760f42bb853",
        "text": "I'm not totally sure that it's not possible with static typing. Maybe it's possible.\n\nJust feels like this area is yet to explore.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "222a2870915d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-15\/861537614034_222a2870915d24ec10cc_72.jpg",
            "first_name": "Vladimir",
            "real_name": "Vladimir Gordeev",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gordeev.vladimir.v",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aJAA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not totally sure that it's not possible with static typing. Maybe it's possible.\n\nJust feels like this area is yet to explore."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537958341.000100",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1537965085.000000"
        },
        "client_msg_id": "C43564BA-DD1E-4D7E-9B62-2362D7ECD486",
        "text": "I can talk in more detail later, but it turns out we can actually do this with static typing. The theoretical concept is known as “row types”, and in Elm they’re called “records”. Basically, a tuple\/record of six named fields is treated as a supertype of a tuple\/record with an additional seventh field. Therefore adding additional fields won’t break the static typing.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JdE=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I can talk in more detail later, but it turns out we can actually do this with static typing. The theoretical concept is known as “row types”, and in Elm they’re called “records”. Basically, a tuple\/record of six named fields is treated as a supertype of a tuple\/record with an additional seventh field. Therefore adding additional fields won’t break the static typing."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCKRZS3DZ",
        "type": "message",
        "ts": "1537958395.000100",
        "client_msg_id": "25f2a113-7b56-4ba1-b369-3a22d4c7600d",
        "text": "Okay, I see.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "222a2870915d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-15\/861537614034_222a2870915d24ec10cc_72.jpg",
            "first_name": "Vladimir",
            "real_name": "Vladimir Gordeev",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gordeev.vladimir.v",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7d+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Okay, I see."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1537963715.000100",
        "client_msg_id": "736d818e-4499-492d-b504-524d14b6d838",
        "text": "<@UCGAK10LS> <@UCKRZS3DZ> Though the freedom afforded by a Smalltalk image is beautiful thing (Lisp too), it can go pretty strange for a long lived object as the codepath that lead to its current state can easily be edited away.  My lesson is not that we should have more static and separated systems (though there is some virtue in them) rather Smalltalk's growth was stunted before sound dynamic semantics were realized.  Of course, it's been a long while so perhaps some more recent developments have improved stability.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0EN4a",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UCKRZS3DZ"
                            },
                            {
                                "type": "text",
                                "text": " Though the freedom afforded by a Smalltalk image is beautiful thing (Lisp too), it can go pretty strange for a long lived object as the codepath that lead to its current state can easily be edited away.  My lesson is not that we should have more static and separated systems (though there is some virtue in them) rather Smalltalk's growth was stunted before sound dynamic semantics were realized.  Of course, it's been a long while so perhaps some more recent developments have improved stability."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537966312.000100",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1537966339.000000"
        },
        "client_msg_id": "499DDA6B-0096-4B6A-9FEC-86BDCBE34BEE",
        "text": "<@UA14TGLTC> I agree altering the code of a live system presents challenges. It also happens all the time in real-world systems (anything with a database) so I’m sure there’s some theories out there about how to do it gracefully :thinking_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "E9+L0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " I agree altering the code of a live system presents challenges. It also happens all the time in real-world systems (anything with a database) so I’m sure there’s some theories out there about how to do it gracefully "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "sunglasses",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U6KQ2S410",
        "type": "message",
        "ts": "1537968075.000100",
        "client_msg_id": "051c46d0-3c3c-4e32-9a63-2e4cf85cbd8a",
        "text": "<@UA14TGLTC> <@UCGAK10LS> Schema Change is a giant blind spot. I believe it requires both static types and structural editing, so it violates most people's ideologies. Conventional solution is to assume it's someone else's problem.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e8f4c2151d2b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-09\/225308926294_e8f4c2151d2b70ebfae3_72.jpg",
            "first_name": "Jonathan",
            "real_name": "Jonathan Edwards",
            "display_name": "jonathoda",
            "team": "T5TCAFTA9",
            "name": "jonathoda",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QP7R",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " Schema Change is a giant blind spot. I believe it requires both static types and structural editing, so it violates most people's ideologies. Conventional solution is to assume it's someone else's problem."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "sob",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1537968544.000100",
        "client_msg_id": "88077681-201c-4245-8cf8-b79f518543e8",
        "text": "Indeed, Schema Change has held my interest for quite a while now.  It's a miracle that anything works.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537968544.000100",
        "reply_count": 8,
        "reply_users_count": 3,
        "latest_reply": "1538102111.000100",
        "reply_users": [
            "U8A5MS6R1",
            "UCGAK10LS",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "U8A5MS6R1",
                "ts": "1537978604.000100"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1537997584.000100"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1538014199.000100"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1538015555.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1538033127.000100"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1538034293.000100"
            },
            {
                "user": "U8A5MS6R1",
                "ts": "1538085672.000100"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1538102111.000100"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ItB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Indeed, Schema Change has held my interest for quite a while now.  It's a miracle that anything works."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1537971359.000100",
        "client_msg_id": "A56D20C0-B9D2-460D-9685-8023E5FAEAC6",
        "text": "I know the word “performance” is used a lot in that article, but I don’t think it’s really performance he’s talking about. He talks about waste. We keep building systems without caring much about how much of what we add is essential and how much is waste. Sure, that distinction isn’t always easy, but I feel we’re also not trying very hard.\n\nSure, performance in the evil, premature optimization kind is not what we need to fix that, but a general sense of where we can reduce waste would be useful.\n\nWhat makes me feel especially sad about this, is that it seems like we’re accelerating how much waste we create by just piling more stuff on top of huge technology stacks of mediocre technology, while at the same time making these technologies more complex.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537671606.000100",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/qB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I know the word “performance” is used a lot in that article, but I don’t think it’s really performance he’s talking about. He talks about waste. We keep building systems without caring much about how much of what we add is essential and how much is waste. Sure, that distinction isn’t always easy, but I feel we’re also not trying very hard.\n\nSure, performance in the evil, premature optimization kind is not what we need to fix that, but a general sense of where we can reduce waste would be useful.\n\nWhat makes me feel especially sad about this, is that it seems like we’re accelerating how much waste we create by just piling more stuff on top of huge technology stacks of mediocre technology, while at the same time making these technologies more complex."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1537972580.000100",
        "client_msg_id": "E81F34D4-8B6E-47F3-990B-3AEF2D693EB9",
        "text": "Yes, I don’t think we’ll distinguish between AR and VR much at a not so distant time in the future, and your AR glasses will allow you to basically move continuously between minimal augmentation and maximal immersion depending on what you want.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537953961.000100",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4BRf0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, I don’t think we’ll distinguish between AR and VR much at a not so distant time in the future, and your AR glasses will allow you to basically move continuously between minimal augmentation and maximal immersion depending on what you want."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1537975881.000100",
        "client_msg_id": "2a68d85e-354c-4e27-8d29-3c4e8d553341",
        "text": "A better question is what will we be getting done with these glasses.  I'm reminded of the James Cameron quote from last year was it?  Got a good day of retweeting, \"VR is a yawn ... what most people are calling VR right now is not VR ... several generations of technology away,\" somehow missing a few moments later, \"I work in a VR environment all day everyday ... if I wasn't making the Avatar films I would be experimenting around in VR.\"  It's a really weird space right now.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537953961.000100",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hs3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A better question is what will we be getting done with these glasses.  I'm reminded of the James Cameron quote from last year was it?  Got a good day of retweeting, \"VR is a yawn ... what most people are calling VR right now is not VR ... several generations of technology away,\" somehow missing a few moments later, \"I work in a VR environment all day everyday ... if I wasn't making the Avatar films I would be experimenting around in VR.\"  It's a really weird space right now."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1537976482.000100",
        "client_msg_id": "bdeeeed7-31b2-43ec-b130-d14e5df59a77",
        "text": "Totally. To directly answer <@UA14TGLTC>'s question, \"what should we optimize for?\":\n\n* Optimize for the new developer experience.\n* Optimize for big-picture coherence. A newcomer shouldn't have to care about the path a project took to arrive at the present state.\n* Optimize for number of layers in the stack. There's lots of opportunity for ripping out layers.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537671606.000100",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2I0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Totally. To directly answer "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": "'s question, \"what should we optimize for?\":\n\n* Optimize for the new developer experience.\n* Optimize for big-picture coherence. A newcomer shouldn't have to care about the path a project took to arrive at the present state.\n* Optimize for number of layers in the stack. There's lots of opportunity for ripping out layers."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U85HCL7JP",
        "type": "message",
        "ts": "1537977376.000100",
        "client_msg_id": "8ba9f7c4-07f9-4bee-b293-0398306d9bfd",
        "text": "Hi <@UCGAK10LS>\n&gt; I don’t think that developing visual languages or augmenting text with visual widgets (i.e. working on how to _present_ code) will get us very far.\nWould love to hear more about why you think this.\nTo me something like projectional editing, that enhance text with other forms of presenting the code, could be a big improvement in understanding",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c5d8f6a2266",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-25\/1286770110448_0c5d8f6a2266551a36f2_72.jpg",
            "first_name": "",
            "real_name": "Daniel Garcia",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "daniel.garcia.carmona",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "h+cb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi "
                            },
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don’t think that developing visual languages or augmenting text with visual widgets (i.e. working on how to "
                            },
                            {
                                "type": "text",
                                "text": "present",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " code) will get us very far."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Would love to hear more about why you think this.\nTo me something like projectional editing, that enhance text with other forms of presenting the code, could be a big improvement in understanding"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U85HCL7JP",
        "type": "message",
        "ts": "1537977666.000100",
        "client_msg_id": "9072f408-15f7-4a32-8258-7ee6fede7e06",
        "text": "My biggest concern with Elm is that is a really small team of people working on it and not willing to build Elm as a community project where everyone can contribute to it",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c5d8f6a2266",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-25\/1286770110448_0c5d8f6a2266551a36f2_72.jpg",
            "first_name": "",
            "real_name": "Daniel Garcia",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "daniel.garcia.carmona",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dMx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My biggest concern with Elm is that is a really small team of people working on it and not willing to build Elm as a community project where everyone can contribute to it"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1537978604.000100",
        "client_msg_id": "043391aa-e1e1-4887-889b-401cdaaff451",
        "text": "Mine too. Schema evolution must be part of  the core design of the system. I've been thinking along these lines: if 'code', 'schema' and 'data' are held in the *same* versioned (immutable, append only) model, maybe we can have some sanity? New schema is introduced as new version of older schema, but older data and code artifacts continue to point to the older schema. So something like the Git\/MVCC model where the versioned artifacts are not byte blobs but higher level entities such as functions, types, values etc. that can all refer to each other.\n\nThe main idea is that all of these are in a *single* versioning system. So a version number in such a system identifies a very precise snapshot of the 'system state' which includes not just the data but also the code and schema entities that exist 'at that time'.\n\nDoes anything like this exist?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537968544.000100",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=q2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Mine too. Schema evolution must be part of  the core design of the system. I've been thinking along these lines: if 'code', 'schema' and 'data' are held in the "
                            },
                            {
                                "type": "text",
                                "text": "same",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " versioned (immutable, append only) model, maybe we can have some sanity? New schema is introduced as new version of older schema, but older data and code artifacts continue to point to the older schema. So something like the Git\/MVCC model where the versioned artifacts are not byte blobs but higher level entities such as functions, types, values etc. that can all refer to each other.\n\nThe main idea is that all of these are in a "
                            },
                            {
                                "type": "text",
                                "text": "single",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " versioning system. So a version number in such a system identifies a very precise snapshot of the 'system state' which includes not just the data but also the code and schema entities that exist 'at that time'.\n\nDoes anything like this exist?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1537980220.000100",
        "client_msg_id": "5f928df4-4f6d-4aa0-8f5b-33a4e2f17982",
        "text": "Great thread - a deeper question here is how many existing concepts do we want to throw out before we build the future. I agree that looking at the 'whole workflow' and use cases is a great way to start. Perhaps also reconsider the prevalent 'languages are distinct from tooling' mindset?\n\nI was just writing something called 'Systems, not Programs' - arguing for a system-first perspective: we are 'crafting systems with behavior', not 'writing programs' -  the latter is only way to do the former but takes up most of the mindshare, etc. In the end any 'future programming' model needs to solve not just programming in the 'small' - i.e. what happens *inside* a single program - but more importantly it needs to solve 'in the large' - i.e. how programs compose with each other within a system. In fact, are these even two separate problems? (Only if you presume the 'program' concept).\n\nThis is where today's static typing approach breaks down - you can only build 'small' things because all the verification and binding happens in one shot. Composing programs is 'out of scope'. You cant build\/deploy whole systems this way ('the internet is dynamically typed'). OTOH verification is nice so we need some way to reconcile with the fact that the system is continuously evolving with parts being upgraded and replaced. We may need some kind of incremental binding and verification model (~'bind time verification' instead of compile time or run time).\n\nRe the text vs visual debate, I agree 'augmenting text with widgets' is a poor solution, but what about replacing text itself with a richer substrate? See <http:\/\/subtext-lang.org|subtext-lang.org> for instance.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DoMMP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great thread - a deeper question here is how many existing concepts do we want to throw out before we build the future. I agree that looking at the 'whole workflow' and use cases is a great way to start. Perhaps also reconsider the prevalent 'languages are distinct from tooling' mindset?\n\nI was just writing something called 'Systems, not Programs' - arguing for a system-first perspective: we are 'crafting systems with behavior', not 'writing programs' -  the latter is only way to do the former but takes up most of the mindshare, etc. In the end any 'future programming' model needs to solve not just programming in the 'small' - i.e. what happens "
                            },
                            {
                                "type": "text",
                                "text": "inside",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a single program - but more importantly it needs to solve 'in the large' - i.e. how programs compose with each other within a system. In fact, are these even two separate problems? (Only if you presume the 'program' concept).\n\nThis is where today's static typing approach breaks down - you can only build 'small' things because all the verification and binding happens in one shot. Composing programs is 'out of scope'. You cant build\/deploy whole systems this way ('the internet is dynamically typed'). OTOH verification is nice so we need some way to reconcile with the fact that the system is continuously evolving with parts being upgraded and replaced. We may need some kind of incremental binding and verification model (~'bind time verification' instead of compile time or run time).\n\nRe the text vs visual debate, I agree 'augmenting text with widgets' is a poor solution, but what about replacing text itself with a richer substrate? See "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/subtext-lang.org",
                                "text": "subtext-lang.org"
                            },
                            {
                                "type": "text",
                                "text": " for instance."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U85HCL7JP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCDBW1H26",
        "type": "message",
        "ts": "1537990484.000100",
        "client_msg_id": "d83b216c-8a25-4552-8c92-3d1b6386a399",
        "text": "is anyone in this community at Strange Loop this year? If so let me know, would love to meet up!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4262cddd28e",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/94262cddd28e127e29dacba5f09c8125.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "",
            "real_name": "Geoffrey Litt",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gklitt",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0eb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "is anyone in this community at Strange Loop this year? If so let me know, would love to meet up!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537997584.000100",
        "client_msg_id": "4a00acf4-f4da-4f0e-8310-3e4bd4ffea5e",
        "text": "How is holding onto older schemas useful? You want a way to transition old data to new schema, so that you can safely assume all data has a specific shape.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537968544.000100",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vs3i",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How is holding onto older schemas useful? You want a way to transition old data to new schema, so that you can safely assume all data has a specific shape."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537999031.000100",
        "client_msg_id": "060e6c08-d6ce-4d00-99ef-e6540f7c3559",
        "text": "<@U85HCL7JP> I think projectional editing could turn out to be really useful for domain-specific languages (e.g. constructing math formulae), or for direct manipulation of data. I'd like to see it happen, but I think there are far bigger fish to fry. After all, it doesn't look like it will solve the major causes of programmer headaches (iteration times, spaghetti code &amp; code comprehension, preventing &amp; debugging errors, code management, data management, distributed systems...). And my belief is that we need to make \"professional programming\" orders of magnitude easier before we can really make leaps in end-user programming.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IxSo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U85HCL7JP"
                            },
                            {
                                "type": "text",
                                "text": " I think projectional editing could turn out to be really useful for domain-specific languages (e.g. constructing math formulae), or for direct manipulation of data. I'd like to see it happen, but I think there are far bigger fish to fry. After all, it doesn't look like it will solve the major causes of programmer headaches (iteration times, spaghetti code & code comprehension, preventing & debugging errors, code management, data management, distributed systems...). And my belief is that we need to make \"professional programming\" orders of magnitude easier before we can really make leaps in end-user programming."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "the_horns",
                "users": [
                    "U85HCL7JP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1537999587.000100",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1537999616.000000"
        },
        "client_msg_id": "1d0e3784-f587-43f7-ae32-1ee70187df6e",
        "text": "<@U85HCL7JP> The development of Elm is restricted to a small group of people for very good reason: _everyone_ has ideas, but most of them wouldn't suit the project. That includes my own ideas. In particular, Elm draws a lot of attention from Haskell developers. These developers come to Elm with lots of ideas about how to \"improve\" Elm: often they want it to be more like Haskell. Haskell has never been considered a \"learnable\" or \"simple\" programming language, so Haskell features often conflict with Elm's goals.\n\nThat's not to say you can't discuss ideas for how Elm can grow. The community is very receptive to discussion (blog posts, forum posts...). The only challenge you'll face is that the core contributors won't integrate ideas (or accept your help to develop them) unless they fit Elm's goals.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2k2mF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U85HCL7JP"
                            },
                            {
                                "type": "text",
                                "text": " The development of Elm is restricted to a small group of people for very good reason: "
                            },
                            {
                                "type": "text",
                                "text": "everyone",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " has ideas, but most of them wouldn't suit the project. That includes my own ideas. In particular, Elm draws a lot of attention from Haskell developers. These developers come to Elm with lots of ideas about how to \"improve\" Elm: often they want it to be more like Haskell. Haskell has never been considered a \"learnable\" or \"simple\" programming language, so Haskell features often conflict with Elm's goals.\n\nThat's not to say you can't discuss ideas for how Elm can grow. The community is very receptive to discussion (blog posts, forum posts...). The only challenge you'll face is that the core contributors won't integrate ideas (or accept your help to develop them) unless they fit Elm's goals."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1538003079.000100",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1538003160.000000"
        },
        "client_msg_id": "24aee80e-0d22-4e41-ad0e-00fbf729b1ed",
        "text": "<@U8A5MS6R1> I feel like static typing naturally progresses to \"bind-time typing\" in a system that is developed in pieces and then bolted together. This is already done in C\/C++ with header files and object files. Of course this doesn't support interface evolution, but that's a problem which is again independent of static and dynamic typing: if an interface breaks, it's going to cause errors whenever the types happen to be checked.\n(I'll again mention row types as a kind of data type that can adapt to non-breaking changes without causing static type checking to fail).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537948820.000100",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tIx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " I feel like static typing naturally progresses to \"bind-time typing\" in a system that is developed in pieces and then bolted together. This is already done in C\/C++ with header files and object files. Of course this doesn't support interface evolution, but that's a problem which is again independent of static and dynamic typing: if an interface breaks, it's going to cause errors whenever the types happen to be checked.\n(I'll again mention row types as a kind of data type that can adapt to non-breaking changes without causing static type checking to fail)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1538014199.000100",
        "client_msg_id": "366b30f1-cf34-4577-ab03-f0d12adb578e",
        "text": "It depends.  For different applications (or parts in a single application), a change in core or schema means different things.  On the one hand, we have you long-term data, file formats that you need to support and migrate carefully in perpetuity.  On the other, we have ephemeral calculations, views, and exploratory development where you're happy to throw everything away.  Different needs mean there's no one, good answer.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537968544.000100",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+QwG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It depends.  For different applications (or parts in a single application), a change in core or schema means different things.  On the one hand, we have you long-term data, file formats that you need to support and migrate carefully in perpetuity.  On the other, we have ephemeral calculations, views, and exploratory development where you're happy to throw everything away.  Different needs mean there's no one, good answer."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1538015555.000100",
        "edited": {
            "user": "UA14TGLTC",
            "ts": "1538016452.000000"
        },
        "client_msg_id": "0beb2d0c-998a-4d99-a343-2f9748b43e92",
        "text": "My particular interest boils down to this.  You have a software system in which events cause state changes.  You update the system and now you're curious how similar events effect corresponding state changes.  This is tricky enough when refactoring, when you want the outputs to line up with inputs up to a sometimes difficult to pin down isomorphism.  What I'm really interested in, my work scenario, is where I keep making the \"same\" software with superficially \"slight\" modifications at not trivial scale (~50,000 LOC in the project).  If we're running this year's version vs last year's what is the diff not in the code (that ends up also being about ~50,000 LOC as it turns out) but in the experience: of the 30 odd screens in the application how much does each one differ?  It ends up being pervasive (most screens) but smallish (one or two things).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1537968544.000100",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eZlmg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My particular interest boils down to this.  You have a software system in which events cause state changes.  You update the system and now you're curious how similar events effect corresponding state changes.  This is tricky enough when refactoring, when you want the outputs to line up with inputs up to a sometimes difficult to pin down isomorphism.  What I'm really interested in, my work scenario, is where I keep making the \"same\" software with superficially \"slight\" modifications at not trivial scale (~50,000 LOC in the project).  If we're running this year's version vs last year's what is the diff not in the code (that ends up also being about ~50,000 LOC as it turns out) but in the experience: of the 30 odd screens in the application how much does each one differ?  It ends up being pervasive (most screens) but smallish (one or two things)."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]