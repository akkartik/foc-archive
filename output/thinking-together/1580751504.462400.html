<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-03 09:38</span><br/>
Let's talk about the positive benefits of accidental / incidental complexity in this thread.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580751521.462800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580751521.462800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-03 09:38</span><br/>
Paging <span style="background-color:#ccf">@Kartik Agaram</span> and <span style="background-color:#ccf">@Chris Granger</span> 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580751571.463100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580751571.463100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 09:39</span><br/>
For starters, some examples would be good.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580752431.463400"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580752431.463400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-03 09:53</span><br/>
As a caveat, I've read Silver Bullet, Tar Pit, etc. only a handful of times, so I might not have internalized all the nuance of incidental vs essential. So these examples are based on my naive view.<br/><br/>Type systems, syntax highlighting, keyboard shortcuts, choice of language, literate programming, and all other programmer affordances are at their core incidental to the problem that the software you write needs to solve. They're also incidental to the act of programming. You feel this when you fiddle with your linter instead of creating a better abstraction or implementing a feature.<br/><br/>For that matter, abstractions are incidental complexity. Again, they're an affordance for thought that isn't strictly necessary.<br/><br/>Using a mouse to move the insertion point. The ability to delete characters. Agile.<br/><br/>If you stood in the middle of your programming memory palace, spun around in a circle, and pointed at a random object.. chances are good it represents something incidental. Something meant to make your job easier, or even humanly possible.<br/><br/>Now, this viewpoint is taking Brooks (etc) past the point of usefulness, far into absurdity. But the reason I like to do that is to establish that the essence vs. incident of complexity is not binary. It's not even a linear spectrum. Many kinds of incidental complexity are deliberate and ergonomic. Some kinds of incidental complexity are simply emergent. In both cases, you might prefer to have them.<br/><br/>As I like to say, incidental complexity is a resource to be spent, not an evil to be purged.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580752623.463900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580752623.463900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-02-03 09:57</span><br/>
This is not a fully formed thought but...<br/>When making something is hard, you think about what's really valuable. E.g. older movies without CGI would have to rely more on the storyline. Many newer ones are more about special effects.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580752710.464300"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580752710.464300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2020-02-03 09:58</span><br/>
I’d argue that abstraction and duplication are both incidental complexity.<br/><br/>The debate over them is about in which circumstances choosing one or another minimizes incidental complexity.<br/><br/>Which would lead to the argument that you’re still trying to purge incidental complexity, it’s just that all of our approaches leave some incidental complexity in place.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580752822.464500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580752822.464500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 10:00</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> <span style="background-color:#ccf">@Justin Blank</span> This is a kind of mind-blowing idea. I'm not a scholar of those papers either, but it never occurred to me to interpret 'accidental complexity' so broadly. Regardless, it feels like a very fertile line of thought.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580752894.464700"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580752894.464700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2020-02-03 10:01</span><br/>
To be fair, I’ve read Brooks twice and while I’ve read the intro to Out of the Tar Pit many times, I think I’ve only read the whole thing once. It’s possible that I’m not using the authors’ own interpretations of what the terms meant.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580752958.464900"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580752958.464900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2020-02-03 10:02</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> “Many kinds of incidental complexity are deliberate and ergonomic. Some kinds of incidental complexity are simply emergent. In both cases, you might prefer to have them.”<br/><br/>This is a really great few sentences .
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580753661.465300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-10/691633887223_2b2204b9c98e11f0ad1f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580753661.465300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Martin Kavalar</b>
<span style="margin:2em; color:#606060">2020-02-03 10:14</span><br/>
This is a bit of a tangent but regarding abstraction I’m with Zach Tellman who argues that we can only talk about the usefulness of it in a given context. Highly recommend his book <a href="http://elementsofclojure.com">http://elementsofclojure.com</a> (which we might have called elements of software as well) or his recent appearance on the CoRecursive podcast: <a href="https://corecursive.com/042-zach-tellman-software-in-context/">https://corecursive.com/042-zach-tellman-software-in-context/</a> Thinking the same might be true for incidental complexity – you have to talk about the context.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580754281.465700"></a>
      <img src="https://avatars.slack-edge.com/2020-01-04/893378739792_34e7a55348e8c86c1901_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580754281.465700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jared Windover</b>
<span style="margin:2em; color:#606060">2020-02-03 10:24</span><br/>
Is it really incidental though? If I have a text editor that allows me to move forward and back, and I’d like to move to the beginning of the document, I have a procedure for getting there. I press back many times until I get there. But there is a cost to doing this (time, keypresses, cycles in evaluating 1000 <tt>move-back</tt> commands). So we introduce a home button. It fully and minimally captures the action I was trying to take. We have made the keyboard more complex, and every layer of software in between that needs to care about this keycode, but is that complexity really incidental? It is perfectly and minimally in service of a real:tm: problem.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580754517.465900"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580754517.465900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2020-02-03 10:28</span><br/>
My take: it’s essential complexity for a document editor, but the idea of editing files is incidental complexity for programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580754982.466300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580754982.466300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-02-03 10:36</span><br/>
This topic reminded me of this essay on complexity: <a href="1578176757.362700.html#1578176757.362700">1.578176.html&hellip;</a><br/><br/>&gt; we can then start to analyze things like that fact that I want to "simplify my life". On its own, the statement is meaningless because we do not know in regards to which aspect in my life I would like to make easier. If I buy more appliances, to reduce my working time -- say a food processor, for example -- I save time in chopping. But it comes at the expense of having to buy the machine, washing it afterward, and occasionally performing some type of maintenance to keep it in working order. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580755572.466600"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580755572.466600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2020-02-03 10:46</span><br/>
I'll echo what <span style="background-color:#ccf">@Ivan Reese</span> said with a simple example from Eve, and add another perspective as well.<br/><br/>From Eve: It's not essential in a relational language to have removal, instead the simplest mechanism is to assert a retraction. As a person though, that's pretty mind bendy. It's much easier to think of removing something as an action, rather than an addition of a fact to the world. Having removal or set (remove the current add this new one) is purely incidental, but as Ivan pointed out, extremely useful.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580755794.466900"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580755794.466900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2020-02-03 10:49</span><br/>
The other perspective that underlies Ivan's points I think: programming is a process performed by people and as a result we have to deal with things like inferential distance (as the example above shows). What we forget though is it's not just about making things simple/intuitive/easy to work with, it's  just as much about crafting the entire process to manage emotional context. If something is objectively better, but feels bad, then it's just going to largely get binned as bad. When we remove all incidental complexity from the process, there's a second order effect to the pacing: you've now moved all of the essential (and likely hard) parts of the problem all right next to each other.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580755847.467300"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580755847.467300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2020-02-03 10:50</span><br/>
The effect is that you've made it feel <b>much</b> harder than it used to be, because the complex bits were spread out among more mundane considerations. Monotony was breaking the difficulty.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580756052.467500"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580756052.467500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2020-02-03 10:54</span><br/>
Pacing and emotion management are very important aspects of the problem to consider and are well understood in other domains. E.g. you can't watch a movie that runs at 110% the whole 2 hours, it's emotionally exhausting and you start to tune out at some point. In the programming context, you get one of two effects: either you cause long thinking pauses in between the actual "points of progress," which makes it feel stuttery and  like it never flows. Or you end up just getting distracted, because it's much easier to do something else than consider all the difficult things about your problem.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580756297.467700"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580756297.467700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-03 10:58</span><br/>
Beautifully illustrated, Chris.<br/><br/>To zoom back in from my <em>reductio ad absurdum</em> to <em>what Silver Bullet / Tar Pit were meaning</em> — when looking at the frustrating cruft that builds up in, say, a tower of abstractions, each piece of cruft was originally created as an affordance for, say, legacy or convenience or familiarity or flexibility. Taking my absurd examples in one hand, and these practical examples in the other, you can see that it's simply a case of: one person's needless complexity is another person's accessibility.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580756403.468000"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580756403.468000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2020-02-03 11:00</span><br/>
Another interesting effect: if you make things simple enough, people then think they're trivial and ignore them :slightly_smiling_face: We've struggled a lot with that in various contexts over the years.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580756659.468200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580756659.468200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-02-03 11:04</span><br/>
&gt; objectively better, but feels bad<br/>Sometimes I prefer to drive on town streets that are always moving instead of the freeway which has a single strech of very slow congestion. The freeway might actually be faster overall, but its more painful.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580757488.478900"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580757488.478900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2020-02-03 11:18</span><br/>
Reading through this thread I get the impression that essential/accidental complexity is conflated with good/bad user experience or usability and accessibility. I’m still pondering how I feel about that, but felt like just pointing this out could be useful by itself…?<br/><br/>My initial feeling is that these things are neither orthogonal nor directly related but somewhere in between (yay, what a safe position to take… ;-). It should be possible to remove accidental complexity in extreme ways and then still provide a good experience. Although some might interpret that as adding accidental complexity back in for the sake of experience. :thinking_face:<br/><br/>The other observation I want to make is that we (including myself) prefer talking about removing accidental complexity. It’s always easier to identify things we don’t want. It’s much harder to identify what we want. I wonder if we’d be better off thinking about what essential really means other than that convenient “necessary for the problem at hand” definition.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580760287.480200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580760287.480200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 12:04</span><br/>
Yeah, these great examples reinforce my sense that essential/accidental is a useful dichotomy -- and we humans are terrible at distinguishing the two. Our math sides push us too far towards declarativity IMO, and anything imperative is treated as accidental complexity. But anything that exists in users' mental models <em>a priori</em> is, I think, by definition essential.<br/><br/>As an example, I manage a deployment system in my day job, and it operates as a convergence engine: you give it the desired state (package versions, number of hosts, etc.) and it takes the steps to get from here to there. Once we released it, however, we uncovered several cases where people care <em>how</em> we get from here to there:<br/><br/>a) Sometimes there are hosts that we think can be reused but customers don't want to allow, for reasons our tooling can't see (and there'll always be some of those reasons: outdated secrets, corrupted data, etc.)<br/><br/>b) Sometimes our customers want for a specific cluster to not be modified, while another subset is. Rather than have to painfully specify the desired state to be identical to the existing state in those cases, they'd rather just get a checkbox that says "hands off this cluster!"<br/><br/>Both these changes have been difficult because of the deep architectural division between ends and means in our tool.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580760562.480400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580760562.480400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 12:09</span><br/>
Anecdote regarding putting things too close together: we've been trying to onboard teams in my company to a new tool. Our good intentions originally were to do all the legwork and present them with a single go/no-go decision. And we kept finding that people would put off the decision.<br/><br/>One of the things we discovered (this is an ongoing issue) was that our decision to show all the services owned by a team in a single document was counter-productive. Talking about each service separately helped people feel less overwhelmed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580760834.480900"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580760834.480900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2020-02-03 12:13</span><br/>
I think things that give the user a good experience can be essential complexity, but it’s more debatable. We <em>know</em> that not crashing or corrupting data is essential, but you can always argue (and sometimes you’ll be right) that a particular thing that makes an application feel nice to use isn’t really essential.<br/><br/>(Also, what’s essential now isn’t the same as what was essential in the past. At lunch, I watched half of Modern Compiler Construction, where Anders Hejlsberg compares a 32kb compiler to a modern compiler--what users want has changed).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580761003.481100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580761003.481100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 12:16</span><br/>
Yeah, user mental model feels like a superior scalpel here than user experience for teasing apart the two categories. Experience may be at a local optimum. But what's in the user's head you can never get away from.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580761361.481400"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580761361.481400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2020-02-03 12:22</span><br/>
I guess I’m assuming that if something doesn’t match your mental model, you’ll probably have a bad experience.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580761459.481600"></a>
      <img src="https://avatars.slack-edge.com/2020-01-04/893378739792_34e7a55348e8c86c1901_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580761459.481600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jared Windover</b>
<span style="margin:2em; color:#606060">2020-02-03 12:24</span><br/>
I think we’re describing a property of a system. Since users are different, we can’t design something that will seem essential to all users, but I think we can design systems that empower users to strip away the pieces that they feel are inessential. Programming itself, I believe, has this property. I can choose to use a high-level library, or I can look at its dependencies and use those, or I can re-implement the small piece I need from scratch. Emacs, to the extent that its functionality is implemented as modes on top of a fairly bare-bones editor also has this property.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580761660.481800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580761660.481800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-03 12:27</span><br/>
With respect to mental models..<br/><br/>I have a blog post draft I've been sitting on for over a year. It's about the positive value of flawed mental models, and by extension that harm that can come from us toolmakers being too concerned with instilling correct mental models in the users of our tools.<br/><br/>A motivating example:<br/>&gt; Hammers can hit nails. That's their very purpose. But they can also hit screws, which is a great way to make a screw stay put while you reach for the screwdriver. They can also dent and deform sheet metal, which is useful for crafting a steel drum. They can knock loose a stuck fitting or lid, especially when hitting the free end of a long wrench on a stuck nut. They can punch a hole in drywall, making it easier to tear down. They can also smash your hand.<br/>&gt; Hammers are tools for working with nails. This is a conceptual constraint placed on hammers by their designers. Hammers are designed with this specific intent in mind. But sometimes, hammers are just tools for amplifying the force of your arm. Sometimes, hammers are but tools for surviving a forceful impact.<br/>The [unfinished] draft, if you're interested: <a href="https://ivanish.ca/mental-models/">https://ivanish.ca/mental-models/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580761779.482300"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580761779.482300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-03 12:29</span><br/>
So to that end, I don't think mental models are a superior scalpel — if these mental models are what drive the distinction between essential and accidental, that's going to force us to be even more careful about mental model correctness, and then lose the benefit of seeing our tool users as unreliable narrators, a font of happy accidents, or intentional creative misusers.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580762000.482600"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580762000.482600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2020-02-03 12:33</span><br/>
I think that’s right. I think it matters when the mental model has too much slippage. Or when the mental model and the underlying model differ in ways that result in the user being surprised/stuck.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580762123.482800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580762123.482800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-03 12:35</span><br/>
Surprise can lead to excitement (further to what Chris Granger was talking about above), and being stuck can lead to creative alternatives (like my hammer examples). I see both outcomes <em>constantly</em> from the artists on my team.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580762541.484000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580762541.484000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 12:42</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> I totally agree with that! By "mental model" I mean what people come to the computer <em>with</em> (which is usually about a problem), and not what the computer tries to 'instill' in them (which I think of more as the information architecture of a <em>solution</em>)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580762589.484200"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580762589.484200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2020-02-03 12:43</span><br/>
I don’t know how seriously we’re disagreeing. If you’re just saying that can sometimes be true, I imagine so. But if you think it’s the norm, I’m going to disagree and say it’s “man bites dog”.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580764158.484700"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580764158.484700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-03 13:09</span><br/>
I'm not sure to agree with "For that matter, abstractions are incidental complexity. Again, they're an affordance for thought that isn't strictly necessary."<br/><br/>I always understood accidental/incidental complexity as relative to a problem that a human is trying to solve. So the problem and the fact that a human is trying to solve it are important in order to consider whether an abstraction is essential or not.<br/><br/>You will always express your computation using some kind of abstraction. If your solution is expressed in the language of the domain, I would consider that there is little accidental complexity. But as soon as those abstractions get in your way and you see yourself doing more and more housekeeping then you have accidental complexity and a different abstraction is probably necessary to get rid of it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580764636.484900"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580764636.484900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-03 13:17</span><br/>
And that's no different from scientific theories. To take the famous example of Ptolemaic epicycles. If you want to predict the position of a planet in our solar system, an heliocentric model is not "strictly necessary". It is just much easier because you have a lot less accidental complexity.<br/><br/>What is also interesting in this example is that the abstractions of the geocentric model are easier than the heliocentric ones. They just don't scale as well to solve actual problems. Illustrating that what seems harder at first can make things simpler later.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580766205.485400"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580766205.485400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-03 13:43</span><br/>
&gt; abstractions of the geocentric model are easier than the heliocentric ones<br/>I don't follow. Would you mind explaining that point a bit more? Do you mean that we developed the geocentric model first, and thus it was "easier" to discover than the later, more elusive heliocentric one?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580767174.487100"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580767174.487100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-03 13:59</span><br/>
Easier because circles are easier to describe than ellipses.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580767256.488100"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580767256.488100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-03 14:00</span><br/>
They’re neat and simple compared to an ellipse.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580778870.489900"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580778870.489900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-02-03 17:14</span><br/>
I don't agree with Ivan's definition of complexity.<br/><br/>The first sentence of Out Of The Tar Pit is "Complexity is the single major difficulty in the successful development of large-scale software systems."<br/><br/>The goal of this paper is to explore ways of reducing complexity, so as to make software engineering less difficult.<br/><br/>Ivan said "Ivan: abstractions are incidental complexity. Again, they're an affordance for thought that isn't strictly necessary."<br/><br/>That can't be right. Programming without abstractions is virtually impossible. The only "programming languages" that lack abstraction mechanisms are mathematical formalisms like Turing machines and the SKI combinator calculus, and a few esoteric languages like Brainfuck.<br/><br/>If you eliminate Ivan's kind of complexity from programming, then you are reduced to programming in Brainfuck. Brainfuck programs are not less complex than, say, well written Lisp programs, in any way that I can see. They are actually far <b>more</b> complicated, using any reasonable metric for measuring the complexity of a program.<br/><br/>Abstractions are our principle tool in eliminating complexity from software. Tar Pit advocates the use of functional programming and the relational model to reduce complexity, and these are methodologies for constructing software abstractions.<br/><br/>Whatever complexity Ivan is talking about, it's not the kind of complexity that Tar Pit is teaching us to eliminate from software.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580789094.491400"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580789094.491400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-03 20:04</span><br/>
Here's how I think about complexity.<br/><br/>How many different ideas do you need to know in order to understand what a program does?<br/><br/>The second-least complex way to write a piece of software would be to push a button and have the exact program you need be spit out. You hardly need to know any ideas in that case — push button, get program that magically does what you want. All the baggage and pain and coordination and effort of software development is gone, like magic.<br/><br/>Every time you introduce a new idea that needs to be understood — whether it's functions, function composition, currying, partial application, the existence of one particular function in your codebase, the history of that function and previous issues it had that are now avoided by doing things in a slightly surprising way, the syntax for the documentation explaining that change, the fact that the change was made to bring the resulting program closer in line with the end user expectations for what this program does — you add an additional complexity that you, the programmer, need to deal with to work on this program, which you wouldn't need to deal with in the magical example above. <em>All</em> of this is incidental complexity.<br/><br/>My whole point is that Out of the Tar Pit is wrong. They say that reducing incidental complexity is crucially important. I say that it's not — instead, you want to be empowered to choose exactly what incidental complexity you need to deal with.<br/><br/>When you draw a line and say "These ideas are incidental complexity because they meet criteria X, and these ideas are not because they don't," you're making a value judgment. When you read Tar Pit with that lens, is painfully clear what values the authors hold ("Mutable state is evil"), and they of course base their <em>what is incidental</em> selection criteria on those values. Hogwash. Incidental complexity, by their own definition, is broad enough to include mutable state, immutability, any even the purely theoretical notion that state, and change, are concepts that exist.<br/><br/>(The absolutely least complex way to write a piece of software is to not have to do anything. Hat tip to Steve Jobs, paraphrased <em>the line of code that has the least bugs, runs the fastest, requires the least documentation, etc etc is the line you never wrote.</em>)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580790725.492100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580790725.492100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 20:32</span><br/>
I'm rereading Tar Pit for the umpteenth time. Never liked it, and jeez it has more italics than a Robert Ludlum novel.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580796314.493500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580796314.493500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 22:05</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> My <em>a priori</em> biases are very similar to yours. However when I read your last comment my first reaction was, "that's not what they mean by incidental complexity." So I went back to reread the paper.<br/><br/>You're right, they do say "accidental complexity is all the rest" except the essence of the problem as seen by users. Which is identical to what I was saying above, and opens them up to your interpretation. And that seems like the most acute criticism I've seen so far of this paper: the terms are so broad that they're very open to interpretation, and the authors' interpretation serves only to reveal their biases.<br/><br/>The authors' "ideal world" is one where computation has no cost, but social structures remain unchanged, with "users" having "requirements". <em>But</em> the users are all mathematical enough to want formal requirements. They don't seem to notice that the arrow in "Informal requirements -&gt; Formal requirements" may indicate that formal requirements are <em>themselves</em> accidental complexity.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580797713.493800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580797713.493800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 22:28</span><br/>
To push back one tiny part of your comment, though:<br/><br/>&gt; Every time you introduce a new idea that needs to be understood — whether it's functions, function composition, currying, partial application, ...<br/>These seem like accidental complexity for a music-creation app, but essential complexity for a programming language.<br/><br/>&gt; ...the existence of one particular function in your codebase, the history of that function and previous issues it had that are now avoided by doing things in a slightly surprising way, the syntax for the documentation explaining that change, the fact that the change was made to bring the resulting program closer in line with the end user expectations for what this program does — you add an additional  complexity that you, the programmer, need to deal with to work on this program...<br/>These seem like accidental complexity for the users of a program, but potentially essential complexity for someone working with it given our current context (the world already exists, the codebase already exists in the world, etc.)<br/><br/>So the context seems crucial here. What is the system under consideration, who is the target audience, all this affects where the line is.<br/><br/>The further to one extreme you draw the line, the less useful the distinction becomes.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580798329.494100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580798329.494100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-03 22:38</span><br/>
Perhaps my fundamental criticism of this whole dichotomy is that it treats "users" as immutable rather than capable of learning. As <span style="background-color:#ccf">@Doug Moen</span> points out, if you treat the user's goals as gospel (say that they want to make this one specific app), then maybe teaching them programming shouldn't include functions. The insanity of that proposition puts this whole framing in sharp relief for me. To some extent someone wanting to do something in a new area needs to learn from its traditions.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580841634.499100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580841634.499100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-02-04 10:40</span><br/>
Trying to wrap my head around the different perspectives. Consider 'writing' and 'science'. Is writing essential for science? Is it accidental complexity? Lets break it apart a bit more.. it's not just the written form, but what the form represents - some abstract ideas (formulae, functions) - are these abstractions essential?<br/><br/>If <b>I am the science itself</b> then I wouldn't need to understand it, I'd just be it. But I'm not science. There is something out there and science gives me a model to grasp that external something (presumably) and fit it internally - something I can understand. This gap is covered by a series of 'mediums' and 'messages' for lack of better words. 'Symbols' are one primitive medium (the idea that 'signifiers represent the signified'), we learn this medium very early in childhood. A message in this medium is 'tree' (doesn't look like a tree, but makes you think of one). The 'written medium' is quite useful too - signs themselves now have physical forms. Sentences are perhaps the next level of medium (a composition of symbols that represents a composite idea). Further, from maths we have variables, propositions, formulae, functions - these are all higher level mediums. We express science in these mediums (e.g. <tt>f=ma</tt> is a message that requires us to <b>become the medium</b> first and then absorb its meaning).<br/><br/>What is the end goal in this endeavor? We're trying to predict something perhaps, or design something for a purpose - these are our goals, our vision of the purpose.<br/><br/>Now a twist: how do we represent our purpose? <em>The purpose is just another medium</em>. When I put pen to paper, I'm using the physical medium to affect the written medium. Is pen and paper incidental? Yes, ideally I'd just think the words and they'd appear on paper. But follow that chain - why am I creating the written words anyway - maybe I'm distributing an idea across. So writing is just incidental - the greater purpose is distributing the idea. Indeed I could make a video instead. (So why spread an idea.. the chain keeps growing) So what's incidental depends entirely on where we 'cut off' our context.<br/><br/>I think what Ivan is saying is that there are multiple alternative paths of medium/message stacks to get to our goals. All of these are 'incidental complexity'. The simplest solution is having the button with 'my goal' on it, that I push. (Well technically that still has incidental complexity because you'd have to grasp the <em>medium of buttons</em> - push, cause, effect etc.) But anything else on this path from the vision of purpose to purpose fulfillment is incidental.<br/><br/>I've taken the position that 'programs' are a red herring. I think it's based on the fundamental position that all these abstractions, ideas, mediums and messages of thought are incidental and we can choose different ones.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580845199.499500"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580845199.499500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-04 11:39</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> "How many different ideas do you need to know in order to understand what a program does?" If that was a good description of complexity then we would all be programming with turing machines. You have very few ideas in a turing machine and they're very easy to understand. They theoretically let you compute anything. We don't do it because it doesn't scale to build entire programs.<br/><br/>I understand where you're coming from. There are a lot of bad and over-engineered abstractions out there that are often unnecessary to solve the problem. There is also an advantage of having no learning curve when approaching a new program.<br/><br/>It's really a fundamental question of design.<br/><br/>1) Do I put together existing (familiar) building blocks and end-up with a codebase that is easy to understand locally but bigger than the other option and not necessarily easier to understand in its totality.<br/><br/>2) Or do I create more appropriate building-blocks (not necessary familiar) to solve my problem and end up with a smaller codebase which might have a steeper learning curve but which will pay-off later.<br/><br/>You can easily err on either sides. But overall as a discipline, I think we're erring towards the first approach.<br/><br/>I'm also in disagreement with the second part when you say that an idea is either incidental or essential complexity. It doesn't make sense to me because whether something is incidental or accidental depends on the problem. An idea X can be incidental to solve problem A and essential to solve problem B.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580847517.499800"></a>
      <img src="https://avatars.slack-edge.com/2020-01-04/893378739792_34e7a55348e8c86c1901_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580847517.499800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jared Windover</b>
<span style="margin:2em; color:#606060">2020-02-04 12:18</span><br/>
&gt; “How many different ideas do you need to know in order to understand what a program does?” If that was a good description of complexity then we would all be programming with turing machines.<br/>I don’t think that’s true. I don’t think a human could be presented with a complex program expressed as a turing machine and understand what it does without developing, either internally or externally, abstractions over those operations. I think it may still be a useful description of complexity if we take into account that limited humans are the ones doing the understanding.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580847963.000000"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580847963.000000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-04 12:26</span><br/>
I think we agree. The goal should not be to reduce the number of ideas but coming up with the ideas that make the problem understandable/solvable.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580849895.000200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580849895.000200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-02-04 12:58</span><br/>
&gt;  "How many different ideas do you need to know in order to understand what a program does?" If that was a good description of complexity then we would all be programming with turing machines.<br/>But programming with Turing machines is complicated and programming with programming languages is easier? So maybe there is a cost/benefit aspect to each new idea? Each abstraction/concept has a cost and a benefit. The deeper question is this: is there any concept that is <b>fundamentally essential</b> to the problem being solved? E.g. are pure functions fundamentally essential and stateful objects fundamentally unessential to programming the game of Pong? My interpretation of Ivan's position is that <em>it's all incidental complexity</em> - and computing is a game of choose your poison.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580851645.000600"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580851645.000600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-04 13:27</span><br/>
I think you mean "fundamentally essential" in the sense that you could not solve your problem without it. If so, this is the realm of the theory of computation/universality... But the terms essential/accidental are in the realm of software engineering (made by humans). A lot of our languages (abstractions) are universal and this is totally fine. This is not accidental complexity. You have many languages to understand and solve different kinds of problems. The same way you have many sciences to understand different parts of the world. Should physicists tell biologists to stop creating their own abstractions because physics is "enough" to explain biology?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580852475.000800"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580852475.000800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-04 13:41</span><br/>
I wanted to comment also on the idea of pushing a button to solve a problem. I understand it is an extreme example but it illustrates exactly the same point regarding scaling. Yes of course if you want to solve only one problem the push button is the simplest approach. The reality is that people don't have only one problem to solve. And if they had to learn the location of a button for each problem they have it becomes extremely complex. And if they don't have the button they will need to ask a programmer to make it for them. If instead you provide this user with building blocks they can rearrange to solve a wide range of problems then you design a robust and simple solutions. The problems for end users are exactly the same as for the programmers. And the state of UX (regarding building blocks) is even worse :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580854036.001600"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580854036.001600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-04 14:07</span><br/>
<span style="background-color:#ccf">@Benoît Fleury</span> I think you took my argument the wrong way — but we are both agreeing on the conclusion.<br/><br/>&gt; "How many different ideas do you need to know in order to understand what a program does?" If that was a good description of complexity then we would all be programming with turing machines. You have very few ideas in a turing machine and they're very easy to understand.<br/>I'm not advocating that we should be <em>minimizing</em> the number of different ideas. I'm just trying to establish that the <em>number of ideas</em> is how you measure complexity. Take that together with my overall assertion that <em>complexity isn't evil</em>, and you'll see that I don't think we should be programming with Turing machines. I think we should have richer, more complex programming machinery than we have today.<br/><br/>---<br/><br/>You win — surpassing Out of the Tar Pit — when you recognize that inessential complexity is not binary. It's not even scalar. There are different <em>flavors</em> of incidental complexity. What kind of incidental complexity you want, or don't want, depends on a lot of factors. It depends on the essential complexity of the problem you're solving. It depends on what ideas you and the people around you know and can work with.<br/><br/><span style="background-color:#ccf">@Shalabh</span>’s comment that starts "Trying to wrap my head around the different perspectives" absolutely nails it. This is not just about software engineering. This is about epistemology.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580854343.002100"></a>
      <img src="https://avatars.slack-edge.com/2020-01-04/893378739792_34e7a55348e8c86c1901_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580854343.002100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jared Windover</b>
<span style="margin:2em; color:#606060">2020-02-04 14:12</span><br/>
I think one point that has come up repeatedly though, is that what is inessential is a matter of context. I suspect that what is being thought of as useful or good inessential complexity is just essential complexity from a different context.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580854506.002400"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580854506.002400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-04 14:15</span><br/>
Yes, though I think it's better if you say it the other way around: What is being thought of as essential complexity is just useful or good inessential complexity from a different context.<br/><br/>All complexity is only as essential as your context requires — and from a gods-eye view, you have total control your context.<br/><br/>Also — I really want to avoid conflating <em>essential</em> and <em>good</em>. I think the good stuff should be called <em>preferential complexity</em>, because then it feels selected to suit on your context, and not imposed by the universe.<br/><br/>For instance, there's great harm in making your starting position, "I am a programmer," because that includes a whole boatload of unchecked assumptions about what your context is. (This is the sin that Out of the Tar Pit commits.) If you disavow yourself of that perspective, you'll do a better job of seeing certain bad inessential complexity that might otherwise be seen as essential, and you'll be better equipped to figure out what preferential complexity you should be working with.<br/><br/>Again, <span style="background-color:#ccf">@Shalabh</span> nailed it:<br/><br/>&gt; Now a twist: how do we represent our purpose? The purpose is just another medium. When I put pen to paper, I'm using the physical medium to affect the written medium. Is pen and paper incidental? Yes, ideally I'd just think the words and they'd appear on paper. But follow that chain - why am I creating the written words anyway - maybe I'm distributing an idea across. So writing is just incidental - the greater purpose is distributing the idea. Indeed I could make a video instead. (So why spread an idea.. the chain keeps growing) So what's incidental depends entirely on where we 'cut off' our context.<br/>and<br/><br/>&gt; computing is a game of choose your poison.<br/>So, I have 2 beefs with the Tar Pit.<br/><br/>1) "Incidental / accidental complexity is bad and should be reduced to the absolute minimum" — this breaks down as soon as you ask questions like, "Is my type system essential or incidental?"<br/><br/>2) "Essential complexity is that which remains when you strip a problem to its most minimal essence" — this breaks down when the above breaks down, because as you approach the most minimal essence of a problem, stripping away complexity after complexity, it's going to look wildly different depending on who does the stripping — and you won't reach truly the most minimal essence until you've reduced the problem to total black nonexistent nothingness.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580856793.004300"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580856793.004300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-04 14:53</span><br/>
If your type system gets in the way and prevent you to do certain things. You will have to go around it, this is accidental complexity. You didn't need to solve those extra problems caused by the type system to solve the original problem. But if your type system works and help you then it is not a complexity at all. We do not have to put everything in either bucket.<br/><br/>I think the point of accidental/incidental complexity is to figure out whether the problems you're having are related to the actual problem or caused by your tools. I don't see why you would want to try to have problems caused by your tools. So saying "there are certain kinds of inessential complexity that are good" seems to me to be a contradiction in terms.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580857410.007500"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580857410.007500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-04 15:03</span><br/>
Exactly. And that's why Out of the Tar Pit is wrong — their definition of accidental complexity sucks, as <span style="background-color:#ccf">@Kartik Agaram</span> pointed out here: <a href="1580751504.462400.html#1580796314.493500">1.580796.html&hellip;</a><br/><br/>Where this becomes a problem is that the Tar Pit definition of accidental / incidental complexity has come to be seen by programmers writ large as a bad thing.<br/><br/>Everyone has a loosey-goosey feeling about what is meant by "inessential complexity", but I think there are a lot of good kinds of complexity being caught in that net.<br/><br/>I'm not saying we should <em>actually</em> "strip everything to zero" or "embrace magic" or "don't use type systems" or anything like that. Those are all just examples to push your perspective to the places where it's easiest to see the flaw in the Tar Pit argument.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580858713.007800"></a>
      <img src="https://secure.gravatar.com/avatar/0a164d5ab3ffe877513fe9c400908eaa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580858713.007800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Benoît Fleury</b>
<span style="margin:2em; color:#606060">2020-02-04 15:25</span><br/>
I see. Thanks! I didn't understand tar pit that way. I will reread it to clarify. It doesn't make sense to me to talk about complexity for things that help you solve your problem. So I don't see a type system or or a user interface that matches more closely your mental model as incidental complexity.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580865680.011800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580865680.011800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-04 17:21</span><br/>
And I don't see mutable, stateful objects as incidental complexity — I see them as tools, good for some jobs and bad for others. Tar Pit's authors present their personal values as empirical truths, as <span style="background-color:#ccf">@Kartik Agaram</span> said.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580866348.012000"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580866348.012000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-02-04 17:32</span><br/>
&gt;  It doesn't make sense to me to talk about complexity for things that help you solve your problem<br/>I think it's that any solution also brings its own complexity.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580866437.012200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580866437.012200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-02-04 17:33</span><br/>
I'm just now reading Tar Pit, I've only ever skimmed parts of it earlier. Already have a few things to say! For instance, isn't there a lack of imagination here:<br/>&gt; There are two widely-used approaches to understanding systems (or components of systems):<br/>&gt; <br/>&gt; <b>Testing</b>: This is attempting to understand a system from the outside — as a “black box”. ...<br/>&gt; <b>Informal Reasoning</b>: This is attempting to understand the system by examining it from the inside....<br/>&gt; <br/>&gt; Of the two informal reasoning is the most important by far.<br/>So reading the code and testing is it? For a while I've thought 'reading code' isn't really going to scale. How about "querying the system"? Can I say "given these <em>kinds of conditions</em> show me how <em>these kinds of outcomes arise</em>"? Of course we can't ask this of a program, but if you consider a whole programming system, it may have an abstract evaluator that can try and figure this from the model (whether it's code or something else). It would then give you 'abstract execution traces' showing the internals of the system. But doing this means you have to first design the system and model with this use case in mind and not presume a workflow of programming exists.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580884447.019100"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580884447.019100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-02-04 22:34</span><br/>
Is it not the case that property-based testing gives you that same information?<br/><br/>If not, I don't follow what you mean and would love more explanation.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580898747.043200"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580898747.043200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2020-02-05 02:32</span><br/>
It’s been too long since I read Tar Pit and reading some comments here I’m not sure if I want to invest the time to read it again.<br/><br/>I do find a distinction between accidental and essential complexity useful. Of course, for it to be useful we need to (a) consider some context and (b) agree on what these mean in such context. If we don’t, we talk past each other. And “we” includes Tar Pit authors.<br/><br/>For instance, if I put my mathematician hat on, then of course stuff like available registers and memory and the time it takes for each instruction to execute are incidental complexities that I don’t need to describe efficiently what the essence of computation is and a Turing Machine is a beautifully simple model to cover all cases of what can be computed.<br/><br/>Now, if I take that hat off I’m just an engineer and I’m furiously angry at that mathematician who clearly has never built anything useful in their life because then they would’ve noticed that a Turing Machine is a piece of crap that makes even the most basic calculation way too complicated to express. And how can you possibly do anything useful without considering the engineering challenges of building a real computation machine? Execution speed and memory and instruction sets and architecture and freaking laws of physics are clearly essential components of such a system.<br/><br/>And let’s not even get into what happens when I put on my UX designer hat… or my business founder hat… let’s say they don’t get along that well either. It’s almost like a little FoC Slack just inside my head…<br/><br/>TL;DR: Wear more :tophat:!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580924471.043800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580924471.043800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-02-05 09:41</span><br/>
&gt; Is it not the case that property-based testing gives you that same information?<br/>There's an overlap but not quite. I mean specifically abstract interpretation (property testing does actual execution with a large number of inputs).<br/><br/>For example, if you have a chunk of untyped Python code you can informally reason about the types of values flowing around by reading and simulating in your head. An abstract interpreter (pytype) will actually evaluate the code in terms of types (not values) and can show you the predicted types of various parameters and locals. It can get much further than mental simulation, because it can evaluate much larger chunks of the code. Technically this might belong in formal reasoning, which the paper mentions in the following paragraph:<br/>&gt; The bottom line is that allways of attempting to understand a system have their limitations (and this includes both informal reasoning— which is limited in scope, imprecise and hence prone to error — as well as formal reasoning— which is dependent upon the accuracy of a specification)<br/>I think the abstract interpretation approach could be extended so you "feed in scenarios", e.g. the user says "what if the local <tt>a</tt> here is an integer between 0 and 1000 and <tt>b</tt> is an empty list" and the system does abstract interpretation (specifically one execution and <b>not</b> 1000 different executions) to find other properties of an execution under that scenario - dead code, exceptions, and notes  "<tt>c</tt> will be <tt>a+20</tt> " etc.<br/><br/>A more apt name for this kind of approach might be <b>computer aided reasoning</b> - we're not reading static code on paper and we're not writing complex types and have the system prove something, but we're simply asking targeted questions. I'd love to ask the system "show me why this dependency is invoked when this kind of request arrives" and then follow up by zooming into a part of the abstract execution trace. A related idea is "program slicing" - point to a value and have the computer tell you the subpart (slice) of the program that affects that variable. I think these are all good ideas to make state trackable, a different angle than going state-free and aiding informal reasoning.<br/><br/>Even with the most 'readable' code, I'll note that reading doesn't scale very far - how much can you read in a day anyway? We might climb out of a small tar pit only to fall into a larger one. But targeted questions in a query language might be able to handle very large programs and even large systems with multiple programs! They'd have to be built using a model that is designed for something like this and scales up.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580924992.044000"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580751504.462400.html#1580924992.044000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-02-05 09:49</span><br/>
Here's a related tweet thread: <a href="https://twitter.com/chatur_shalabh/status/1126201095636652032">https://twitter.com/chatur_shalabh/status/1126201095636652032</a>. Take the simplest of programs and compose them in a small distributed system, and you'll see informal reasoning ability disappear. How about e_xpect complexity and design to handle it_ rather than <em>avoid complexity</em>.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
