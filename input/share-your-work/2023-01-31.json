[
    {
        "user": "U04MAEU6VHN",
        "type": "message",
        "ts": "1675199807.657629",
        "client_msg_id": "141eda50-4e32-42a8-9bd8-e5f22e316a64",
        "text": "<@UJBAJNFLK> :exploding_head: domain-specific type systems? Do you have any more thoughts on what that would look like? As far as whether the layer is optional, it very much isn't as knowledge of types informs code generation :shrug: .\n<@U0296ACR13M> Thanks! So, in this system, we no longer have a notion of \"precedence\" in function overload resolution. If there is any ambiguity (multiple functions w\/ the same signature), the answer is to always ask the user. `You could still end visibly exactly the same function calls binding to different overloads.` So that's already the case with `a + b` and `c + d`, if a &amp; b are ints, but c &amp; d are strings, right? Now I actually solve this by coloring all identifiers according to the hash of the definition, so the two function calls would very likely have different colors, allowing you to immediately recognize them as distinct.\n<@U013ZLJARC7> thanks for the link! fascinating read.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43e7ef32ef6c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-01-25\/4713451001249_43e7ef32ef6c84455dbd_72.jpg",
            "first_name": "Jared",
            "real_name": "Jared Forsyth",
            "display_name": "Jared Forsyth",
            "team": "T5TCAFTA9",
            "name": "jabapyth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675140821.935599",
        "parent_user_id": "U04MAEU6VHN",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ky6Xb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "emoji",
                                "name": "exploding_head",
                                "unicode": "1f92f"
                            },
                            {
                                "type": "text",
                                "text": " domain-specific type systems? Do you have any more thoughts on what that would look like? As far as whether the layer is optional, it very much isn't as knowledge of types informs code generation "
                            },
                            {
                                "type": "emoji",
                                "name": "shrug",
                                "unicode": "1f937"
                            },
                            {
                                "type": "text",
                                "text": " .\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U0296ACR13M"
                            },
                            {
                                "type": "text",
                                "text": " Thanks! So, in this system, we no longer have a notion of \"precedence\" in function overload resolution. If there is any ambiguity (multiple functions w\/ the same signature), the answer is to always ask the user. "
                            },
                            {
                                "type": "text",
                                "text": "You could still end visibly exactly the same function calls binding to different overloads.",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " So that's already the case with "
                            },
                            {
                                "type": "text",
                                "text": "a + b",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "c + d",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", if a & b are ints, but c & d are strings, right? Now I actually solve this by coloring all identifiers according to the hash of the definition, so the two function calls would very likely have different colors, allowing you to immediately recognize them as distinct.\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U013ZLJARC7"
                            },
                            {
                                "type": "text",
                                "text": " thanks for the link! fascinating read."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1675203197.509849",
        "client_msg_id": "65a55129-d386-4213-a901-e5575a16580b",
        "text": "A more horrifying implication of theories being amorphous: bad decisions can become part of the theory once accepted. As more people use the bad idea it becomes increasingly adaptive to understand it.\n\nPut that in your pipe and smoke it before you undertake your next code review. No pressure.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1673042540.979739",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5=MQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A more horrifying implication of theories being amorphous: bad decisions can become part of the theory once accepted. As more people use the bad idea it becomes increasingly adaptive to understand it.\n\nPut that in your pipe and smoke it before you undertake your next code review. No pressure."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cry",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            },
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1675203931.695309",
        "client_msg_id": "1e54abe6-c0c5-4ddb-9f0b-f3c57df2c2af",
        "text": "After listening to the first 30 minutes I realize I dislike most philosophical work because _it doesn't know when to stop._ Jimmy's Ryle has a central nugget of enormous value, but it's lost in the angels-on-pinheads discussion of whether thoughts exist. (Though it did present the fun daydream of a Ryle cagematch with Julian Jaynes, he of the obsession with the inner experience of consciousness.)\n\nAnyways, I'm glad Naur did the work to bring it down to my level.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1673042540.979739",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D4R",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "After listening to the first 30 minutes I realize I dislike most philosophical work because "
                            },
                            {
                                "type": "text",
                                "text": "it doesn't know when to stop.",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Jimmy's Ryle has a central nugget of enormous value, but it's lost in the angels-on-pinheads discussion of whether thoughts exist. (Though it did present the fun daydream of a Ryle cagematch with Julian Jaynes, he of the obsession with the inner experience of consciousness.)\n\nAnyways, I'm glad Naur did the work to bring it down to my level."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "U017TE5R09M"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U0296ACR13M",
        "type": "message",
        "ts": "1675232368.604429",
        "client_msg_id": "24ba1147-97a9-4cee-980d-1fea48c22aed",
        "text": "Okay, so say there exists a 'myfunc (double x, double y) -&gt; double' and an implicit conversion from int to double. the user writes the call 'myfunc(1, 2)' which binds to the function. now user adds 'myfunc (int x, int y) -&gt; int' and writes another call 'myfunc(1, 2)'. Do you ask the user which overload to use or bind to the int version? Do you ask the user to re-evaluate which overload to bind the first call to? Either way the user could end up in a situation that exactly the same calls (down to argument types) bind to different overloads, possibly without the user ever choosing that the first call should bind to the less-specific double overload. Of course if the only difference in the signature is numeric types, it's likely that the functions do the same thing, but you could end up with a more problematic case with user defined types.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "59de929720a2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-09-08\/4075674207584_59de929720a2fe0a13d8_72.jpg",
            "first_name": "",
            "real_name": "Jarno Montonen",
            "display_name": "Jarno Montonen",
            "team": "T5TCAFTA9",
            "name": "jarno.montonen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675140821.935599",
        "parent_user_id": "U04MAEU6VHN",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S0ehc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Okay, so say there exists a 'myfunc (double x, double y) -> double' and an implicit conversion from int to double. the user writes the call 'myfunc(1, 2)' which binds to the function. now user adds 'myfunc (int x, int y) -> int' and writes another call 'myfunc(1, 2)'. Do you ask the user which overload to use or bind to the int version? Do you ask the user to re-evaluate which overload to bind the first call to? Either way the user could end up in a situation that exactly the same calls (down to argument types) bind to different overloads, possibly without the user ever choosing that the first call should bind to the less-specific double overload. Of course if the only difference in the signature is numeric types, it's likely that the functions do the same thing, but you could end up with a more problematic case with user defined types."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]