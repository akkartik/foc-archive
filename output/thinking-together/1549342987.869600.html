<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2020-07-25/1286770110448_0c5d8f6a2266551a36f2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1549342987.869600.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Garcia</b>
<span style="margin:2em; color:#606060">2019-02-04 21:03</span><br/>
Last talk by Rich Hickey. Do you agree with what he considers downsides of Maybe and Either? <a href="https://youtu.be/YR5WdGrpoug">https://youtu.be/YR5WdGrpoug</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549388511.875700"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1549342987.869600.html#1549388511.875700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-02-05 09:41</span><br/>
I agree in the sense I feel 'having or not having' is a very different thing than 'int or string' and fusing them into the same type system seems off. I'm also more comfortable with the set oriented thinking that Hickey discusses.<br/><br/>Relatedly, I'm also not a fan of the usual ADT types anymore. I think they impose too much of an implementation detail onto what should be a conceptually pure relationship model. They define not just the relationship but also the bit representation and normalization/denormalization strategy. I feel the entities and relationships should be defined separately from how they materialize - what parts are in contiguous bits of memory, whether they are row oriented or column oriented, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549388677.875900"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1549342987.869600.html#1549388677.875900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-02-05 09:44</span><br/>
&gt; Do you agree with what he considers downsides of Maybe and Either?<br/><br/>Yes.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549389065.876600"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1549342987.869600.html#1549389065.876600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-02-05 09:51</span><br/>
&gt; I feel the entities and relationships should be defined separately from how they materialize<br/><br/>Clojure is actually pretty good for this. The abundant data manipulation functions are all coded to interfaces that just care about things like "Is this sorted? Is this a seq? It it associative?". You can add your own concrete datatype with, say, a different storage strategy, and conform to whichever interfaces make sense. Very a la carte.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1549432893.880600"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1549342987.869600.html#1549432893.880600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-02-05 22:01</span><br/>
It is a kind of law of the evolution of computer languages, that when a language has a design flaw, particularly an omission, it will then evolve to fix that original omission. In this case you can see how Clojure which does not have the concept of a record, something that goes back to Assembler/FORTAN/COBOL/PL1/PASCAL/C/MODULA-2/ etc. has invented spec/keys to fix this. Records are the most commonly used data structure in business programming. You might have a customer in a database, and you have fields name, age, etc. The record definition makes it clear what data is to be stored. if you define a_person to hold name, age, etc., then in the code if you copy a record, in one operation you have copied a whole set of fields, thus achieve some leverage. The lack of structure and strong typing which were a hallmark of Clojure's flexibility is now being perceived as a problem, and so they are augmenting the language. Clojure and esp. Clojurescript are among the most powerful languages extant today, however, i wouldn't call them that easy to read. In some aspects, the dogshit (pardon my french) simplicity of COBOL represents a simpler programming universe. Isn't the most important thing in programming helping to eliminate programmer error? Don't the errors in programming dominate our total time spent, and thus anything we can do in the language to help catch errors early before the program is run, a positive thing, and shouldn't we therefore start to measure how well a language prevents error compared to another? Isn't that the real future of coding? I think the graphical interface prevent a lot of invalid operations from occurring, then you have solved a lot of errors. No missing commas, or unbalanced parentheses, so many errors go away in graphical space, which is why i believe they are so attractive to everyone. But isn't it also true, that the most difficult errors in programming are never syntactical or simple in nature, and that incorrect order of evaluation, and subtle dependency errors are the real spenders of elapsed time? And now that we are doing networking, and multithreading, aren't the timing and sync issues now the big issues? Those are not really visible in a graphical representation, which emphasizes connections over all other things.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
