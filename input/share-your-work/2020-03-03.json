[
    {
        "user": "UKP3B2J5D",
        "type": "message",
        "ts": "1583243639.072700",
        "edited": {
            "user": "UKP3B2J5D",
            "ts": "1583243656.000000"
        },
        "client_msg_id": "c3f6537a-a394-44e9-883e-3c8ef27b2c7a",
        "text": "<@UFPPABQ7P> sorry I havent been here a lot.\n\nYes, one could specify a subset of Json schema and just go with that but that’s not a real fix imho.\n\nThere is things it does like dependent keywords (properties, additionalproperties and patternProperties depend on each other) and types that change (e.g a type takes a list or a string) that I think are problematic and too complex to understand(if you read the latest specification I think you would agree - stuff like recursiveRef, annotations etc).\n\nOne of the reasons for doing these things is better developer ux. So the canonical example they have of using writing a schema - {“type”: [“number”, “string”], “maxLength”: 4} . this validates a string of length 4 or a number (maxLength applies to just strings).\n\nAll of these kind of problems disappear with a DSL. You might ask why a new language? but i think even though json schema is written with json, you need to understand it is semantics for it to make sense just like any other language and having one designed from the ground up to support validation is better + you can always compile to native languages just like protobufs for example.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4980e1f3e51a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-03\/1220847671058_4980e1f3e51a273b630a_72.png",
            "first_name": "Ope",
            "real_name": "Ope",
            "display_name": "opeispo",
            "team": "T5TCAFTA9",
            "name": "ogunks900",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1581764938.103400",
        "parent_user_id": "UKP3B2J5D",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "usopd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFPPABQ7P"
                            },
                            {
                                "type": "text",
                                "text": " sorry I havent been here a lot.\n\nYes, one could specify a subset of Json schema and just go with that but that’s not a real fix imho.\n\nThere is things it does like dependent keywords (properties, additionalproperties and patternProperties depend on each other) and types that change (e.g a type takes a list or a string) that I think are problematic and too complex to understand(if you read the latest specification I think you would agree - stuff like recursiveRef, annotations etc).\n\nOne of the reasons for doing these things is better developer ux. So the canonical example they have of using writing a schema - {“type”: [“number”, “string”], “maxLength”: 4} . this validates a string of length 4 or a number (maxLength applies to just strings).\n\nAll of these kind of problems disappear with a DSL. You might ask why a new language? but i think even though json schema is written with json, you need to understand it is semantics for it to make sense just like any other language and having one designed from the ground up to support validation is better + you can always compile to native languages just like protobufs for example."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]