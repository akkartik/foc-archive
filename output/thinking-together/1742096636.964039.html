<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-03-15 20:43</span><br/>
Rhetorical question?: how would your programming workflow change if you deeply believed that creating SCNs was cheap and easy? Perl leaned heavily on REGEX. REGEX was once thought to be hoary and problematic. Perl made it accessible. New kinds of things were invented when Perl started being widely used. T2t is “better” than REGEX, because t2t makes it easy to deal with patterns containing recursive nesting. CFGs, like YACC, make it possible to parse recursively nested text, but, CFGs need painful, full specification of too much detail. If you had a way to specify pattern-matching using tiny DSLs that didn’t cost a lot of time to build, how would your workflow change? ['t2t' leans heavily on PEG and esp. OhmJS] [SCN === Solution Centric Notation, essentially a nano-DSL, I think of Richard Feynman breaking away from mathematical/Gutenberg notation and inventing and using Feynman diagrams. Language affects thought, notation affects thought].
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742113397.187839"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742113397.187839" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-03-16 01:23</span><br/>
I do actually believe that creating SCNs is cheap and easy, but so far I express this belief mostly by creating s-expression-based SCNs in Lisp. I am aware of the limitations of that technique, but so far it has been a good compromise for me. The step to PEG gives more power but also comes with a higher cost, in particular if you consider editor support for your DSL, which with s-expressions basically comes for free.<br/><br/>What I'd love to see explored is other wide-spectrum syntax frameworks than s-expressions. See <a href="https://parentheticallyspeaking.org/articles/bicameral-not-homoiconic/">this blog post by Shriram Krishnamurthi</a> for a detailed discussion of s-expression as a framework for building DSLs (the label "framework" is mine though). In particular for non-textual syntax, which remains largely unchartered territory.<br/><br/>Assuming we get to the point of people widely believing in SCNs being possible and desirable, the next interesting question is software system architecture design with SCN, i.e. putting them to good use with minimal undesirable side effects.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742116641.157319"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742116641.157319" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-03-16 02:17</span><br/>
The goal should be to produce notations so concise that whole programs fit in one eye-full, so that traditional concerns, like editor support, don't apply any more. Writing "bigger" programs should mean writing less code in islands and layers. I first wrote t2t using diagrams (using the non-programming editor <a href="http://draw.io">draw.io</a>) based on the idea of pipelines and circuits that used OhmJS multiple times. I've since reduced it to a single js program to ease carrying it around. In my mind, the technique is powerful enough to build compilers with and to do non-traditional things like parsing diagrams and building notations that fit in less space on the screen. I've written a lot of Lisp macros, now PEG/OhmJS/t2t give me the power to do this with non-lispy languages. I was taught to build compilers as pipelines connected by little, custom SCNs for each pass - I found this to be mentally liberating allowing me to concentrate deeply on one task at a time. Parsing is easy, the other stuff is hard, I toss custom parsers around liberally.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742135996.165019"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742135996.165019" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2025-03-16 07:39</span><br/>
See: Racket’s “Language Oriented Programming” 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742139442.732509"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742139442.732509" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-03-16 08:37</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> For the use cases I have in mind, there will always be incompressible long code because of the amount of embedded data. That's why I want editor support.<br/><br/><span style="background-color:#ccf">@Jack Rusher</span> That's very nice indeed, as long as you stay inside the Racket ecosystem. What I like about <span style="background-color:#ccf">@Paul Tarvydas</span> t2t approach is that it can target many compilers and runtimes, so you can use what you know and/or fits your needs. Plus you can easily inspect the t2t output, whereas inspecting fully macro-expanded Racket can be quite challenging (trying to put it nicely).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742162362.400849"></a>
      <img src="https://avatars.slack-edge.com/2023-08-29/5820723719363_3ecb3076c7b047d665ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742162362.400849" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Guyren Howe</b>
<span style="margin:2em; color:#606060">2025-03-16 14:59</span><br/>
Ruby lends itself to DSLs and this pardigm is widely used in Ruby code.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742212230.110659"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742212230.110659" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2025-03-17 04:50</span><br/>
<span style="background-color:#ccf">@Guyren Howe</span> Note that <span style="background-color:#ccf">@Paul Tarvydas</span> was also asking for real parsers rather than DSLs that look like the language in which they’re embedded. That’s the thing with Racket’s approach: you can have the syntax of Pascal (or whatever) and the Racket tooling gives you some automatic goodies for things like syntax highlighting in your new syntax, &amp;c. I haven’t seen that done as well by any other project.<br/><br/>That said, I find DSLs with radically different syntax are usually not worth creating for quick things, and on balance prefer embedding the DSL in a language with a flexible syntax (that is, I’d rather just write some Lisp macros in most cases).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742212444.815339"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742212444.815339" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2025-03-17 04:54</span><br/>
Also, special mention should probably be given to Kay’s approach at VPRI. They didn’t make it easy to spin up throwaway languages, but they did experiment heavily with layered custom languages starting with Maru at the bottom.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742222712.875809"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742222712.875809" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-03-17 07:45</span><br/>
&gt; eval really treats "data as code", not "code as data".<br/>&gt; "syntax is a view"<br/>[Points that jumped out at me from the blog article that <span style="background-color:#ccf">@Konrad Hinsen</span> mentioned]
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742261105.085899"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742261105.085899" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-03-17 18:25</span><br/>
> ... I find DSLs with radically different syntax are usually not worth creating for quick things, and on balance prefer embedding the DSL in a language with a flexible syntax (that is, I'd rather just write some Lisp macros in most cases)<br/>I think that PEG gives us the power to create Lisp-like, quickie macros for non-Lisp languages. Challenge to self: give examples that demonstrate this. Aside: REGEX is a DSL, albeit with a horrible syntax. PEG is the new REGEX.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742261228.607929"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742261228.607929" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-03-17 18:27</span><br/>
It's "steam engine time" for PEG: Lately Janet, earlier Rebol, Racket, ...
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742261347.509669"></a>
      <img src="https://avatars.slack-edge.com/2023-08-29/5820723719363_3ecb3076c7b047d665ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742261347.509669" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Guyren Howe</b>
<span style="margin:2em; color:#606060">2025-03-17 18:29</span><br/>
When you’ve lots of declarative machinery available, it’s nice to be able to write those declarations in a concise way.<br/><br/>A Ruby on Rails controller might have code within it like:<br/><br/><pre style="white-space:pre-wrap">has_one :user<br/>has_many :logins<br/>has_and_belongs_to_Many :account_groups<br/><br/>validates :user, presence: true</pre><br/>It’s nice when without much fuss, your language naturally supports expressing declarative truths in your program with close to optimal concision.<br/>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742281588.151989"></a>
      <a href="../thinking-together/1742096636.964039.html#1742281588.151989" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2025-03-18 00:06</span><br/>
Is Ruby syntax able to come close to optimal for expressing these? 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742286358.341989"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742286358.341989" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-03-18 01:25</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> Relevant for editor support: <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Parsing-Expression-Grammars.html">Emacs</a> (haven't tried this yet).<br/><br/>It would definitely be nice to have PEG support as ubiquitous as regex support.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742300380.368299"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742300380.368299" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-03-18 05:19</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> Wonderful! Haha, it never dawned on me to look to see if emacs supported PEG (I shoulda known better :-). I will poke at it some more. Thanks!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742300694.531479"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742300694.531479" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-03-18 05:24</span><br/>
<span style="background-color:#ccf">@Jack Rusher</span> I am interested in looking more at LoP and Mora (or its descendants), but, I'm lazy and have become wary of wading through walls of reference information. Does anything jump out as the best places to start discovering more about these things?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742301781.772859"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742301781.772859" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2025-03-18 05:43</span><br/>
Here’s an example of embedding a different syntax in a program:<br/><a href="https://docs.racket-lang.org/algol60/">https://docs.racket-lang.org/algol60/</a><br/>… and the source code for the parser for Algol 60 used in this implementation:<br/><a href="https://github.com/racket/algol60/blob/master/parse.rkt">https://github.com/racket/algol60/blob/master/parse.rkt</a><br/>And a friendly article on the approach:<br/><a href="https://cacm.acm.org/research/a-programmable-programming-language/">https://cacm.acm.org/research/a-programmable-programming-language/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1742302234.342029"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1742302234.342029" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-03-18 05:50</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> PEG support is a new feature in Emacs 30, though the library has been around as an add-on for a while (<a href="https://www.emacswiki.org/emacs/peg.el">https://www.emacswiki.org/emacs/peg.el</a>).<br/><br/>As for language-oriented programming in Racket, that's definitely worth a look. The last link in <span style="background-color:#ccf">@Jack Rusher</span>'s comment is a good entry point. Racket has become a modular compiler in which a new language is just another library.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1745002221.698389"></a>
      <img src="https://avatars.slack-edge.com/2024-07-04/7377091009748_d0343f70ca57c18eeb41_72.png" style="float:left"/>
      <a href="../thinking-together/1742096636.964039.html#1745002221.698389" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>misha</b>
<span style="margin:2em; color:#606060">2025-04-18 11:50</span><br/>
&gt; The goal should be to produce notations so concise that whole programs fit in one eye-full,<br/>yes. Maybe not entire programs, because of non-reducible amount of states in non-trivial programs, but yes.<br/>&gt; "syntax is a view"<br/>yes<br/>&gt; I express this belief mostly by creating s-expression-based SCNs in Lisp.<br/>yes. Not that many 'usual' text-based things are hard to cram into s-expressions.<br/>Trivial things are expressible with no extra work, but few extra parens.<br/>Larger but manageable things can be just string arg (that racket-algol example, or infamous SQL strings).<br/>But there is always just "flat s-expr with hundred args" approach, especially when you can express DSL's literal tokens in your fav LISP's literals: chars, strings, symbols, numbers, bools, keywords, vecs, lists, maps, sets.<br/>For example, clojure's <tt>(let [a 1] a)</tt> is a DSL too, since in the rest of the language same level tokens have independent scope: in <tt>(+ x y)</tt> - <tt>y</tt> does not have <tt>x</tt> in scope.<br/>But replace <tt>+</tt> with <tt>let</tt> and <tt>x</tt> with bindings vector, and suddenly <tt>y</tt> has in scope whatever is on the left:<br/><tt>(+ x y)</tt>  -&gt; <tt>(let bindings y)</tt> -&gt; <tt>(let [y 1] y)</tt><br/>(ofc every macro is a DSL).<br/>I guess my point is you can ride s-expr macros pretty far even without reaching for multiple compilers, especially if DSLs are tiny.<br/><br/>re: IDE support - this seems relevant: <a href="https://www.jetbrains.com/help/idea/using-language-injections.html#language_annotation">https://www.jetbrains.com/help/idea/using-language-injection&hellip;</a>
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
