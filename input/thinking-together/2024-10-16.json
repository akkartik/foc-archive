[
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1729070151.662469",
        "edited": {
            "user": "UJBAJNFLK",
            "ts": "1729070273.000000"
        },
        "client_msg_id": "0c528562-76d5-43ca-81b1-ae5f632fbf70",
        "text": "One reason I suspect for the success of regex is the (horrible but) compact notation that makes them suitable for command-line tools such as grep. I would love to have a grep-like tool based on a real (recursive descent) parser with a notation that I can actually remember. Not sure if my requirements are compatible, but... you don't get what you don't ask for!\n\nNote that \"command line\" isn't really a requirement, but I don't see how such a tool could ever become widespread (and thus widely available, optimized, tested, ...) if it expects some richer environment.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1729002727.805319",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lxFzW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One reason I suspect for the success of regex is the (horrible but) compact notation that makes them suitable for command-line tools such as grep. I would love to have a grep-like tool based on a real (recursive descent) parser with a notation that I can actually remember. Not sure if my requirements are compatible, but... you don't get what you don't ask for!\n\nNote that \"command line\" isn't really a requirement, but I don't see how such a tool could ever become widespread (and thus widely available, optimized, tested, ...) if it expects some richer environment."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1729073276.085289",
        "client_msg_id": "cb5cc958-86db-412a-bf09-c14315aabe49",
        "text": "I agree and am inspired to wonder\/seek-to-express why I think that this is worth the trouble...\n\nIt might be something along the lines:\n• Generating code is incredibly useful and will lead to even higher-level languages and notations.\n• A \"command line\" is 1D-think based on 1950's hardware. 2024 hardware is capable of presenting multiple windows. Maybe the concept of \"command line\" needs to be overhauled to mean a 2D canvas of \"windows\". For what I describe, you only need 4 windows (source code, grammar, rewrite, read-only output).\n• Deep down, I think that the concept of a single program must be liberated from consisting of only a single syntax. To me, a program is a composition of snippets written in many syntaxes (using an IDE that glues them all together to make a whole). A 2D \"command line\" supports this notion (i.e. a \"better\" IDE).\n• The concept of \"compilers\" allowed us to crawl out of the trenches of programming in assembler. To me, the concept of \"t2t\" may let us crawl out of the tranches of using single-syntax general purpose programming languages like Haskell, Python, Javascript, etc.\n• There is a huge gaping chasm between the two extremes (1) REGEX, and, (2) CFG-based parsers. Can something fill this gap?\n",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1729002727.805319",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f\/p+j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree and am inspired to wonder\/seek-to-express why I think that this is worth the trouble...\n\nIt might be something along the lines:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Generating code is incredibly useful and will lead to even higher-level languages and notations."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A \"command line\" is 1D-think based on 1950's hardware. 2024 hardware is capable of presenting multiple windows. Maybe the concept of \"command line\" needs to be overhauled to mean a 2D canvas of \"windows\". For what I describe, you only need 4 windows (source code, grammar, rewrite, read-only output)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Deep down, I think that the concept of a single program must be liberated from consisting of only a single syntax. To me, a program is a composition of snippets written in many syntaxes (using an IDE that glues them all together to make a whole). A 2D \"command line\" supports this notion (i.e. a \"better\" IDE)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The concept of \"compilers\" allowed us to crawl out of the trenches of programming in assembler. To me, the concept of \"t2t\" may let us crawl out of the tranches of using single-syntax general purpose programming languages like Haskell, Python, Javascript, etc."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "There is a huge gaping chasm between the two extremes (1) REGEX, and, (2) CFG-based parsers. Can something fill this gap?"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1729146449.410189",
        "client_msg_id": "8584cb9d-55b0-447e-b4bd-fcb6c5433217",
        "text": "Your second point is something that most people would agree to. To the point that we have dozens (maybe even hundreds) of GUI frameworks that could do the job. But none of them has the market share that would make it suitable for software infrastructure. The other CLI feature that no GUI framework offers is embeddability. You can run a CLI tool from every existing programming environment.\n\nThe best answer I know to your point three is Racket. Its main weakness is that implementing a new language is still too much effort, because Racket is targeted at complex rather than simple languages. Also, t2t allows inspection of the output, whereas Racket's compilation chain produces very opaque code representations.\n\nThe best intermediate I have found for my own needs is Glamorous Toolkit, which comes with a parser engine (SmaCC) that is fully integrated into the environment (Pharo) and the developer tools. Not t2t, but t2s (text-to-smalltalk) with a decent user interface.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1729002727.805319",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XDspj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Your second point is something that most people would agree to. To the point that we have dozens (maybe even hundreds) of GUI frameworks that could do the job. But none of them has the market share that would make it suitable for software infrastructure. The other CLI feature that no GUI framework offers is embeddability. You can run a CLI tool from every existing programming environment.\n\nThe best answer I know to your point three is Racket. Its main weakness is that implementing a new language is still too much effort, because Racket is targeted at complex rather than simple languages. Also, t2t allows inspection of the output, whereas Racket's compilation chain produces very opaque code representations.\n\nThe best intermediate I have found for my own needs is Glamorous Toolkit, which comes with a parser engine (SmaCC) that is fully integrated into the environment (Pharo) and the developer tools. Not t2t, but t2s (text-to-smalltalk) with a decent user interface."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]