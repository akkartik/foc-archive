[
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1715945615.115089",
        "client_msg_id": "a2b96e3e-001c-4542-8226-28115375317d",
        "text": "An interesting video: <https:\/\/www.youtube.com\/watch?v=gWNXGfXOrro|The 100 Games That Taught Me Game Design>\n\nI would like to see \"The 100 Applications That Taught Me Application Design\".\n\nWhich ones are yours?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1715945615.115089",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1715951406.500149",
        "reply_users": [
            "UMQ6LR9NZ"
        ],
        "replies": [
            {
                "user": "UMQ6LR9NZ",
                "ts": "1715951406.500149"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iVUhF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An interesting video: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=gWNXGfXOrro",
                                "text": "The 100 Games That Taught Me Game Design"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI would like to see \"The 100 Applications That Taught Me Application Design\".\n\nWhich ones are yours?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UMQ6LR9NZ",
        "type": "message",
        "ts": "1715951406.500149",
        "client_msg_id": "8c1b0e03-7e53-4e1b-ac5b-38ca2d57762b",
        "text": "I could list a whole bunch, but two that come quickly to mind are\n\n1. <https:\/\/www.youtube.com\/watch?v=19RJE4TDwI8|Burning Monkey Solitaire> (which yes, I realize is a game, but the way that it incorporated all kinds of noninvasive feedback mechanisms influenced my early thinking about UX design)\n2. the <http:\/\/tinytree.info|Bonsai static site generator> opened my eyes to a non-standard but still predictable way of designing command line UX, and showed me that maybe we can make programs that are more like an Emily Dickinson poem, and less like a dictionary. ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf70d12f2630",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f70d12f2630b6c2a0854e3bef118e73c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "Eli",
            "real_name": "Eli Mellen",
            "display_name": "Eli",
            "team": "T5TCAFTA9",
            "name": "eli.mellen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1715945615.115089",
        "parent_user_id": "UBN9AFS0N",
        "attachments": [
            {
                "from_url": "https:\/\/www.youtube.com\/watch?v=19RJE4TDwI8",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/19RJE4TDwI8\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"300\" src=\"https:\/\/www.youtube.com\/embed\/19RJE4TDwI8?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen title=\"Apple Macintosh Longplay - Burning Monkey Solitaire - Freecell\"><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 300,
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=19RJE4TDwI8",
                "fallback": "YouTube Video: Apple Macintosh Longplay - Burning Monkey Solitaire - Freecell",
                "title": "Apple Macintosh Longplay - Burning Monkey Solitaire - Freecell",
                "title_link": "https:\/\/www.youtube.com\/watch?v=19RJE4TDwI8",
                "author_name": "hirudov2d",
                "author_link": "https:\/\/www.youtube.com\/@hirudov2d",
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GIGi2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I could list a whole bunch, but two that come quickly to mind are\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/www.youtube.com\/watch?v=19RJE4TDwI8",
                                        "text": "Burning Monkey Solitaire"
                                    },
                                    {
                                        "type": "text",
                                        "text": " (which yes, I realize is a game, but the way that it incorporated all kinds of noninvasive feedback mechanisms influenced my early thinking about UX design)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "the "
                                    },
                                    {
                                        "type": "link",
                                        "url": "http:\/\/tinytree.info",
                                        "text": "Bonsai static site generator"
                                    },
                                    {
                                        "type": "text",
                                        "text": " opened my eyes to a non-standard but still predictable way of designing command line UX, and showed me that maybe we can make programs that are more like an Emily Dickinson poem, and less like a dictionary. "
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1715954336.099829",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1715954511.000000"
        },
        "client_msg_id": "8d67b2e8-6ffe-4eb6-8740-399d4f0949f7",
        "text": "Frederick P. Brooks in _<https:\/\/worrydream.com\/refs\/Brooks_1986_-_No_Silver_Bullet.pdf|No Silver Bullet>_ seems to have a perspective on that:\n> _The reality of software is not inherently embedded in space. Hence *it has no ready geometric representation in the way that land has maps, silicon chips have diagrams, computers have connectivity schematics*. As soon as we attempt to diagram software structure, we find it to constitute *not one, but several, general directed graphs, superimposed one upon another*. The several graphs may represent the flow of control, the flow of data, patterns of dependency, time sequence, name-space relationships. These are usually not even planar, much less hierarchical. Indeed, one of the ways of establishing conceptual control over such structure is to enforce link cutting until one or more of the graphs becomes hierarchical._\n<http:\/\/nature-of-order.stefan-lesser.com\/geometry-in-software|I’ve been struggling with this before>, and still haven’t found the time to put what I said <https:\/\/youtu.be\/qGDrrxuR584|here> into a more concise and readable format, but the gist is: Maps are powerful because they help us navigate… ha… I guess I should just end the sentence here… but I wanted to say… navigate multiple dimensions at once. Wardley defines maps as visualizations where position and direction have meaning, so these encode additional information in a spatial way that we are very well adapted to intuitively understand. So not everything visual qualifies as maps in his (and my) view, especially the now ubiquitous infinite canvasses rarely encode meaning in position deliberately.\n\nThat power of such representations, however, can cause us to overlook that they all are just models of a reality that has more dimensions than included in the representations we are looking at. That’s why it’s easy for Brooks to just casually list a few different visualizations we can easily create for software which all highlight and leave out different aspects of the same thing. In conclusion, as long as we are not trying to look for the one ultimate representation but accept various different ones for what they do and don’t do, it’s a magnificent tool in our toolbox.\n\nBrooks continues saying:\n> _In spite of progress in restricting and simplifying the structures of software, they remain inherently unvisualizable, thus depriving the mind of some of its most powerful conceptual tools. This lack not only impedes the process of design within one mind, it severely hinders communication among minds._",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1715846961.582069",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hNZNg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Frederick P. Brooks in "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/worrydream.com\/refs\/Brooks_1986_-_No_Silver_Bullet.pdf",
                                "text": "No Silver Bullet",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " seems to have a perspective on that:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The reality of software is not inherently embedded in space. Hence ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "it has no ready geometric representation in the way that land has maps, silicon chips have diagrams, computers have connectivity schematics",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". As soon as we attempt to diagram software structure, we find it to constitute ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "not one, but several, general directed graphs, superimposed one upon another",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". The several graphs may represent the flow of control, the flow of data, patterns of dependency, time sequence, name-space relationships. These are usually not even planar, much less hierarchical. Indeed, one of the ways of establishing conceptual control over such structure is to enforce link cutting until one or more of the graphs becomes hierarchical.",
                                "style": {
                                    "italic": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/nature-of-order.stefan-lesser.com\/geometry-in-software",
                                "text": "I’ve been struggling with this before"
                            },
                            {
                                "type": "text",
                                "text": ", and still haven’t found the time to put what I said "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/youtu.be\/qGDrrxuR584",
                                "text": "here"
                            },
                            {
                                "type": "text",
                                "text": " into a more concise and readable format, but the gist is: Maps are powerful because they help us navigate… ha… I guess I should just end the sentence here… but I wanted to say… navigate multiple dimensions at once. Wardley defines maps as visualizations where position and direction have meaning, so these encode additional information in a spatial way that we are very well adapted to intuitively understand. So not everything visual qualifies as maps in his (and my) view, especially the now ubiquitous infinite canvasses rarely encode meaning in position deliberately.\n\nThat power of such representations, however, can cause us to overlook that they all are just models of a reality that has more dimensions than included in the representations we are looking at. That’s why it’s easy for Brooks to just casually list a few different visualizations we can easily create for software which all highlight and leave out different aspects of the same thing. In conclusion, as long as we are not trying to look for the one ultimate representation but accept various different ones for what they do and don’t do, it’s a magnificent tool in our toolbox.\n\nBrooks continues saying:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In spite of progress in restricting and simplifying the structures of software, they remain inherently unvisualizable, thus depriving the mind of some of its most powerful conceptual tools. This lack not only impedes the process of design within one mind, it severely hinders communication among minds.",
                                "style": {
                                    "italic": true
                                }
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U03HC3XHZGW",
        "type": "message",
        "ts": "1715978541.417449",
        "edited": {
            "user": "U03HC3XHZGW",
            "ts": "1715978586.000000"
        },
        "client_msg_id": "a35dc9ae-7bf7-41da-82e0-5c9ca68a78e7",
        "text": "Loose set of thoughts:\n1. could you make a type system that somehow captures all information possible about every value in a codebase? Like where the following is true: if typeof(a) === number, then typeof(a + 1 + 2) === number+3 !== typeof(a) …\n2. I might want to “pin” and “unpin” my types - e.g. before refactoring a function, to “pin” its return type. If I had a more powerful type system like described in part one, I wouldn’t want to have to write out the whole type, I would want to just say “pin this such that whatever changes I make could not possibly effect the outcome of the function for any input, or else give me errors describing exactly what part of the input space no longer maps logically the same to the output space”\n3. Another way to think of this might be to say, rather than writing tests, to be able to say “assume infinite test coverage of this codebase (and all tests are passing), now let me refactor things”.\n4. I have no idea how this would work, but it makes me think of getting fractions into “simplest form”. Maybe you could get two functions into “simplest form” to test their similarity?\nI wonder if anything like that exists, or if this is gesturing at some existing area of research?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "675dd03f5d4b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-08-02\/3889194159300_675dd03f5d4baa904b88_72.jpg",
            "first_name": "Daniel",
            "real_name": "Daniel Sosebee",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dnsosebee",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1715978541.417449",
        "reply_count": 8,
        "reply_users_count": 6,
        "latest_reply": "1720112403.966849",
        "reply_users": [
            "UBKNXPBAB",
            "U018S42NMMM",
            "UJBAJNFLK",
            "UA14TGLTC",
            "U03HC3XHZGW",
            "UFPPABQ7P"
        ],
        "replies": [
            {
                "user": "UBKNXPBAB",
                "ts": "1715988854.390149"
            },
            {
                "user": "U018S42NMMM",
                "ts": "1715996424.395829"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1716009341.326619"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1716276615.293559"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1716276770.243879"
            },
            {
                "user": "U03HC3XHZGW",
                "ts": "1716655695.209849"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1716795014.869709"
            },
            {
                "user": "UFPPABQ7P",
                "ts": "1720112403.966849"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XmmcS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Loose set of thoughts:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "could you make a type system that somehow captures all information possible about every value in a codebase? Like where the following is true: if typeof(a) === number, then typeof(a + 1 + 2) === number+3 !== typeof(a) …"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I might want to “pin” and “unpin” my types - e.g. before refactoring a function, to “pin” its return type. If I had a more powerful type system like described in part one, I wouldn’t want to have to write out the whole type, I would want to just say “pin this such that whatever changes I make could not possibly effect the outcome of the function for any input, or else give me errors describing exactly what part of the input space no longer maps logically the same to the output space”"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Another way to think of this might be to say, rather than writing tests, to be able to say “assume infinite test coverage of this codebase (and all tests are passing), now let me refactor things”."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I have no idea how this would work, but it makes me think of getting fractions into “simplest form”. Maybe you could get two functions into “simplest form” to test their similarity?"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wonder if anything like that exists, or if this is gesturing at some existing area of research?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBKNXPBAB",
        "type": "message",
        "ts": "1715988854.390149",
        "edited": {
            "user": "UBKNXPBAB",
            "ts": "1715988903.000000"
        },
        "client_msg_id": "c6cd4aef-a8ca-4c57-b2d4-e73fc376aa7b",
        "text": "Some pointers which may (or may not) relate to your interests here…\n\nre #1: Dependently typed languages let you put a ton of information about a value into its type. For instance, in Idris you can have a type `Vect n a` meaning “a vector of n elements of type a”, and then you can write an “append” function with type `Vect n a -> Vect m a -> Vect (n + m) a`. Using functions like this, you propagate information about the lengths of vectors as you perform computations on them.\n\nre #2: Neat idea. This may be less ambitious than you’re thinking, but I can imagine an IDE feature saying “turn the inferred type of this value into an explicit type annotation”. That way, you can make types explicit before a refactor to make sure you’re not changing types as you refactor.\n\nre all: Your interests here seem related to software verification and other “formal methods”. In case you haven’t seen that stuff, I’d suggest <https:\/\/github.com\/dafny-lang\/dafny|Dafny> as an accessible starting point. It lets you write functions accompanied by logical specifications the functions are supposed to satisfy, and then to guide the system to proving that the functions satisfy these specifications. (Most systems like this cannot be automated in the same way that type inference is automated, because once you want to prove general properties of programs like “functions f and g do the same thing”, you get into things that are <https:\/\/en.wikipedia.org\/wiki\/List_of_undecidable_problems|not computable> in principle.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7b3bc9e878d6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-03-28\/6866700980471_7b3bc9e878d663396caf_72.jpg",
            "first_name": "",
            "real_name": "Joshua Horowitz",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "joshuah",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1715978541.417449",
        "parent_user_id": "U03HC3XHZGW",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Z4SJT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some pointers which may (or may not) relate to your interests here…\n\nre #1: Dependently typed languages let you put a ton of information about a value into its type. For instance, in Idris you can have a type "
                            },
                            {
                                "type": "text",
                                "text": "Vect n a",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " meaning “a vector of n elements of type a”, and then you can write an “append” function with type "
                            },
                            {
                                "type": "text",
                                "text": "Vect n a -> Vect m a -> Vect (n + m) a",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Using functions like this, you propagate information about the lengths of vectors as you perform computations on them.\n\nre #2: Neat idea. This may be less ambitious than you’re thinking, but I can imagine an IDE feature saying “turn the inferred type of this value into an explicit type annotation”. That way, you can make types explicit before a refactor to make sure you’re not changing types as you refactor.\n\nre all: Your interests here seem related to software verification and other “formal methods”. In case you haven’t seen that stuff, I’d suggest "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/dafny-lang\/dafny",
                                "text": "Dafny"
                            },
                            {
                                "type": "text",
                                "text": " as an accessible starting point. It lets you write functions accompanied by logical specifications the functions are supposed to satisfy, and then to guide the system to proving that the functions satisfy these specifications. (Most systems like this cannot be automated in the same way that type inference is automated, because once you want to prove general properties of programs like “functions f and g do the same thing”, you get into things that are "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/List_of_undecidable_problems",
                                "text": "not computable"
                            },
                            {
                                "type": "text",
                                "text": " in principle.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U018S42NMMM",
        "type": "message",
        "ts": "1715996424.395829",
        "client_msg_id": "72fd86cb-feb2-449d-b049-918cdf9ed58a",
        "text": "Adjacent to this: There's even an extension of dependent typing, called quantitative typing that let's you track how many times (0,1 or more) a value has been consumed. Idris2 uses this: <https:\/\/idris2.readthedocs.io\/en\/latest\/tutorial\/multiplicities.html>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "972d4c887a7c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-10\/4782052692709_972d4c887a7c689aae4a_72.jpg",
            "first_name": "",
            "real_name": "Nilesh Trivedi",
            "display_name": "Nilesh Trivedi",
            "team": "T5TCAFTA9",
            "name": "nilesh.tr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1715978541.417449",
        "parent_user_id": "U03HC3XHZGW",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bl71A",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Adjacent to this: There's even an extension of dependent typing, called quantitative typing that let's you track how many times (0,1 or more) a value has been consumed. Idris2 uses this: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/idris2.readthedocs.io\/en\/latest\/tutorial\/multiplicities.html"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1716008870.722079",
        "client_msg_id": "011d51eb-ba72-4fab-acfc-a73bacc98848",
        "text": "From the Moldable Development perspective, the question is not \"can we create maps for software systems\" but \"can we create mappable software systems, by making the maps as part of the design and implementation process\".\n\nA meaningful use of the directions is indeed a major challenge, and I hope that Wardley will come up with something in the course of his work with Glamorous Toolkit.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1715846961.582069",
        "parent_user_id": "UJBAJNFLK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ne+4n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "From the Moldable Development perspective, the question is not \"can we create maps for software systems\" but \"can we create mappable software systems, by making the maps as part of the design and implementation process\".\n\nA meaningful use of the directions is indeed a major challenge, and I hope that Wardley will come up with something in the course of his work with Glamorous Toolkit."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U5STGTB3J",
                    "U014WA16VNJ"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1716009341.326619",
        "client_msg_id": "b5e687b6-84b6-40fc-be46-a39787379aad",
        "text": "&gt; a type system that somehow captures all information possible about every value in a codebase\nFirst thought: \"all possible information\" about a value includes the value itself. And then you quickly get to dependent types, as <@UBKNXPBAB> suggested.\n\nA more difficult problem is exploiting all that information in a useful way, i.e. come up with useful inference rules. I doubt that a single set of rules, i.e. a single type system, can capture all useful inferences while remaining usable. Unfortunately, the dogma of \"thou shalt not have any type system other than the one of your one and only programming language\" is rarely challenged.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1715978541.417449",
        "parent_user_id": "U03HC3XHZGW",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NlAuq",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "a type system that somehow captures all information possible about every value in a codebase"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFirst thought: \"all possible information\" about a value includes the value itself. And then you quickly get to dependent types, as "
                            },
                            {
                                "type": "user",
                                "user_id": "UBKNXPBAB"
                            },
                            {
                                "type": "text",
                                "text": " suggested.\n\nA more difficult problem is exploiting all that information in a useful way, i.e. come up with useful inference rules. I doubt that a single set of rules, i.e. a single type system, can capture all useful inferences while remaining usable. Unfortunately, the dogma of \"thou shalt not have any type system other than the one of your one and only programming language\" is rarely challenged."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "point_up_2",
                "users": [
                    "UJFN50C00"
                ],
                "count": 1
            }
        ]
    }
]