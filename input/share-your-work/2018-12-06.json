[
    {
        "user": "UEH6T3RJB",
        "type": "message",
        "ts": "1544108136.033400",
        "client_msg_id": "99a081f9-b6f8-4f7c-99af-975b3f40480d",
        "text": "<@UEKEQGB9C> - I think we agree in practice. We both think that a language-level feature would be the ideal end - but I argue that we have insufficient knowledge about how such a language-level feature should be structured in order to justify the implementation and community costs of building it that way up front. This will be a multi-decade project and I think we can't support the costs for the community with whom the feature is being co-designed being split off from mainstream improvements\/changes in VMs, tooling and general idiom for all of those decades. I don't see this as a relatively well-characterised and self-contained facility like garbage collection for which the engineering tradeoffs can be quite well described and variant implementations slotted in without disturbing the semantics of the host language too much. However, you may be interested in Stephen Kell's conception of an \"Integration Domain\" which perhaps promises a cross-language notion of assemblages along the lines you are considering - <https:\/\/www.cs.kent.ac.uk\/people\/staff\/srk21\/research\/papers\/kell09mythical.pdf> - he describes his \"linking language\" named Cake which I believe would be a good substrate for this.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5184556fcf3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png",
            "first_name": "",
            "real_name": "Antranig Basman",
            "display_name": "Bosmon",
            "team": "T5TCAFTA9",
            "name": "amb26slack",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543873883.010000",
        "parent_user_id": "UEKEQGB9C",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vsr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEKEQGB9C"
                            },
                            {
                                "type": "text",
                                "text": " - I think we agree in practice. We both think that a language-level feature would be the ideal end - but I argue that we have insufficient knowledge about how such a language-level feature should be structured in order to justify the implementation and community costs of building it that way up front. This will be a multi-decade project and I think we can't support the costs for the community with whom the feature is being co-designed being split off from mainstream improvements\/changes in VMs, tooling and general idiom for all of those decades. I don't see this as a relatively well-characterised and self-contained facility like garbage collection for which the engineering tradeoffs can be quite well described and variant implementations slotted in without disturbing the semantics of the host language too much. However, you may be interested in Stephen Kell's conception of an \"Integration Domain\" which perhaps promises a cross-language notion of assemblages along the lines you are considering - "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.cs.kent.ac.uk\/people\/staff\/srk21\/research\/papers\/kell09mythical.pdf"
                            },
                            {
                                "type": "text",
                                "text": " - he describes his \"linking language\" named Cake which I believe would be a good substrate for this."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEKEQGB9C",
        "type": "message",
        "ts": "1544112367.033600",
        "client_msg_id": "c5c7cfec-c487-4542-ba11-166114b53527",
        "text": "<@UEH6T3RJB> We're basically in violent agreement on 90% of it. And I guess if I think it's cheap and easy enough to do, the onus is on me, not to argue, but to get on and build it :slightly_smiling_face:\n\nThanks for the link ... looks good, I'll go read it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g48a3c4ba8f2",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Phil Jones",
            "display_name": "interstar",
            "team": "T5TCAFTA9",
            "name": "interstar",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543873883.010000",
        "parent_user_id": "UEKEQGB9C",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tWVB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEH6T3RJB"
                            },
                            {
                                "type": "text",
                                "text": " We're basically in violent agreement on 90% of it. And I guess if I think it's cheap and easy enough to do, the onus is on me, not to argue, but to get on and build it "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThanks for the link ... looks good, I'll go read it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEH6T3RJB",
        "type": "message",
        "ts": "1544134503.033800",
        "edited": {
            "user": "UEH6T3RJB",
            "ts": "1544139686.000000"
        },
        "client_msg_id": "589d494c-f87f-40f7-bee8-5193ff4e0bae",
        "text": "<@UEKEQGB9C> - it's possible I'm casting your \"feature\" as something more grandiose than you were intending - but assuming we had an \"assemblage language\" that could i) be superimposed on top of the semantics of existing languages, ii) function mostly as a first-class language in its own right, wouldn't we then expect that it could, as Kell is imagining, act as a runtime broker between the object models of any collection of runtimes expressed in heterogeneous languages? As you said in an earlier post, we have seen these kinds of mostly static assemblage frameworks in the previous decade in the guise of DI systems like Spring, and their \"fire and forget\" model, that takes no interest in the dynamic, so-called \"runtime\" structure of the system is largely uninteresting.\nActually Kell is more grandiose about this than I can see as realistic but his implementation capability is vastly greater than mine. When I say to him, \"How to you plan to 'abstract' over the fact that one of your cooperating runtimes has just thrown a bus error as a result of being asked to dereference something that the memory model of one of the others insisted was deterministically deallocated?\", he just waves the question away as though it were a fly.. \"that will be no problem!\". For my part, I can't see that we can get to this point until we actually do away with all the languages and their runtimes entirely. The point at which Infusion, or something like it, finally casts off its host language entirely, will be the point at which such languages become largely irrelevant for general purpose developers\/users and we instead \"code\" primarily against integration domains. There we go, two modest, easily achievable views of the future of programming :slightly_smiling_face:\nInterested to see anything you end up building, cheap and easy or not - cheers!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5184556fcf3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/75184556fcf3aa660f5e56b8e5bdd46d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png",
            "first_name": "",
            "real_name": "Antranig Basman",
            "display_name": "Bosmon",
            "team": "T5TCAFTA9",
            "name": "amb26slack",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543873883.010000",
        "parent_user_id": "UEKEQGB9C",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sCwbw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEKEQGB9C"
                            },
                            {
                                "type": "text",
                                "text": " - it's possible I'm casting your \"feature\" as something more grandiose than you were intending - but assuming we had an \"assemblage language\" that could i) be superimposed on top of the semantics of existing languages, ii) function mostly as a first-class language in its own right, wouldn't we then expect that it could, as Kell is imagining, act as a runtime broker between the object models of any collection of runtimes expressed in heterogeneous languages? As you said in an earlier post, we have seen these kinds of mostly static assemblage frameworks in the previous decade in the guise of DI systems like Spring, and their \"fire and forget\" model, that takes no interest in the dynamic, so-called \"runtime\" structure of the system is largely uninteresting.\nActually Kell is more grandiose about this than I can see as realistic but his implementation capability is vastly greater than mine. When I say to him, \"How to you plan to 'abstract' over the fact that one of your cooperating runtimes has just thrown a bus error as a result of being asked to dereference something that the memory model of one of the others insisted was deterministically deallocated?\", he just waves the question away as though it were a fly.. \"that will be no problem!\". For my part, I can't see that we can get to this point until we actually do away with all the languages and their runtimes entirely. The point at which Infusion, or something like it, finally casts off its host language entirely, will be the point at which such languages become largely irrelevant for general purpose developers\/users and we instead \"code\" primarily against integration domains. There we go, two modest, easily achievable views of the future of programming "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": "\nInterested to see anything you end up building, cheap and easy or not - cheers!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEKEQGB9C",
        "type": "message",
        "ts": "1544144879.034100",
        "client_msg_id": "85b0a97c-3986-44a5-85f8-7a4d46f1d3d5",
        "text": "OK ... with the proviso that I haven't read Kell yet, just skimmed the first page or so, it seems to me we've always had a secondary level of management of programs, from <https:\/\/en.wikipedia.org\/wiki\/Job_Control_Language> through to all the ways we orchestrate microservices within container platforms like Kubernetes etc.\n\nI certainly don't want to claim that we can or should collapse this layer down into our ordinary programming language. Or that my \"assemblage language\" could scale to that grandiose level.\n\nI accept that there's a valid role for separate language or tool for orchestration of microservices in containers and you only want to talk about those things as black-boxes with some kind of wire-protocol and message-queue architecture between them.\n\nNow I have some opinions about how those languages for higher-level orchestration or even defining continuous integration pipelines and provisioning etc. should be. I think they should be more like Prolog, based on rules rather than imperative scripts copying files around and launching \/ closing down nodes.\n\nAnd being rule based they should certainly be \"dynamic\" eg. able to adapt and compensate when the configuration \/ architecture changes.\n\nBut they aren't the same as the object oriented languages I imagine being extended with assemblage programming.\n\nAssemblages are still much closer to the kind of OO code we know and love \/ hate today. They're just one or two scales \"up\".  Instead of having a system with 1000 separate class files leading to 100000 objects of 1000 types, you now have a system of 100 separate assemblage files, leaving to 100000 objects of 1000 types.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g48a3c4ba8f2",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/248a3c4ba8f2972427222d46954f9c1c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Phil Jones",
            "display_name": "interstar",
            "team": "T5TCAFTA9",
            "name": "interstar",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543873883.010000",
        "parent_user_id": "UEKEQGB9C",
        "attachments": [
            {
                "title": "Job Control Language",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/Job_Control_Language",
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/Job_Control_Language",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/",
                "text": "Job Control Language (JCL) is a name for scripting languages used on IBM mainframe operating systems to instruct the system on how to run a batch job or start a subsystem.More specifically, the purpose of JCL is to say which programs to run, using which files or devices  for input or output, and at times to also indicate under what conditions to skip a step.\nThere are two distinct IBM Job Control languages: \n\none for the operating system lineage that begins with DOS\/360 and whose latest member is z\/VSE; and\nthe other for the lineage from OS\/360 to z\/OS, the latter now including JES extensions, Job Entry Control Language (JECL).They share some basic syntax rules and a few basic concepts, but are otherwise very different.",
                "fallback": "wikipedia: Job Control Language",
                "service_icon": "https:\/\/a.slack-edge.com\/bfaba\/img\/unfurl_icons\/wikipedia.png",
                "id": 1,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/Job_Control_Language"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U3q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "OK ... with the proviso that I haven't read Kell yet, just skimmed the first page or so, it seems to me we've always had a secondary level of management of programs, from "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Job_Control_Language"
                            },
                            {
                                "type": "text",
                                "text": " through to all the ways we orchestrate microservices within container platforms like Kubernetes etc.\n\nI certainly don't want to claim that we can or should collapse this layer down into our ordinary programming language. Or that my \"assemblage language\" could scale to that grandiose level.\n\nI accept that there's a valid role for separate language or tool for orchestration of microservices in containers and you only want to talk about those things as black-boxes with some kind of wire-protocol and message-queue architecture between them.\n\nNow I have some opinions about how those languages for higher-level orchestration or even defining continuous integration pipelines and provisioning etc. should be. I think they should be more like Prolog, based on rules rather than imperative scripts copying files around and launching \/ closing down nodes.\n\nAnd being rule based they should certainly be \"dynamic\" eg. able to adapt and compensate when the configuration \/ architecture changes.\n\nBut they aren't the same as the object oriented languages I imagine being extended with assemblage programming.\n\nAssemblages are still much closer to the kind of OO code we know and love \/ hate today. They're just one or two scales \"up\".  Instead of having a system with 1000 separate class files leading to 100000 objects of 1000 types, you now have a system of 100 separate assemblage files, leaving to 100000 objects of 1000 types."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]