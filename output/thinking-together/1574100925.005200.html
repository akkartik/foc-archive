<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-11-18 10:15</span><br/>
This has probably been posted before but reposting because this always impresses me. I believe this note is from Alan Kay:<br/><br/>&gt; This system --including everything -- "OS", SDK, Media, GUI, Tools, and the content -- is about 10,000 lines of Smalltalk-78 code sitting on top of about 6K bytes of machine code (the latter was emulated to get the whole system going).<br/><br/>The software mentioned has a windowing system, multiple desktops, IDE/code editing and running, paint, animation, document editing/viewing, gesture recognition). 16K lines on top of hardware.. how is this possible? (What am I missing?)<br/><br/>Source: <a href="https://news.ycombinator.com/item?id=19722205">https://news.ycombinator.com/item?id=19722205</a><br/><br/>Link to demo: <a href="https://www.youtube.com/watch?v=AnrlSqtpOkw&amp;t=135s">https://www.youtube.com/watch?v=AnrlSqtpOkw&amp;t=135s</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574100973.005400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574100973.005400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-11-18 10:16</span><br/>
Here's live editing of an animation in motion by runtime coupling of the paint view and the animation view: <a href="https://youtu.be/AnrlSqtpOkw?t=609">https://youtu.be/AnrlSqtpOkw?t=609</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574109726.006000"></a>
      <img src="https://avatars.slack-edge.com/2020-04-19/1070853245589_9c42167d8bfa4cbf26ad_72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574109726.006000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nuno Leiria</b>
<span style="margin:2em; color:#606060">2019-11-18 12:42</span><br/>
It's possible because the level of <em>accidental</em> complexity was low. When you build all the systems across all levels of the stack you can ensure each of them do their jobs well and there are no inefficiencies. If there are, you can change it. I'm not a fan of Apple but this is one of reasons they do so well technically (design, latency, etc) - their technology is vertically integrated. Here are some talks about the complexity crisis in software today and why it <em>seems</em> baffling that you could develop complex systems in a few thousand lines of code:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574109731.006200"></a>
      <img src="https://avatars.slack-edge.com/2020-04-19/1070853245589_9c42167d8bfa4cbf26ad_72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574109731.006200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nuno Leiria</b>
<span style="margin:2em; color:#606060">2019-11-18 12:42</span><br/>
<a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk">https://www.youtube.com/watch?v=pW-SOdj4Kkk</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574109736.006500"></a>
      <img src="https://avatars.slack-edge.com/2020-04-19/1070853245589_9c42167d8bfa4cbf26ad_72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574109736.006500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nuno Leiria</b>
<span style="margin:2em; color:#606060">2019-11-18 12:42</span><br/>
<a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">https://www.youtube.com/watch?v=kZRE7HIO3vk</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574114930.006900"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574114930.006900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2019-11-18 14:08</span><br/>
C Code on MC6809 was 40% the size of the same C code on MC68000.<br/><br/>MC6809 was an 8-bit cpu, MC6800 was 16-bit.<br/><br/>Code size for 16-bit cpus is larger than for 8-bit cpus (MC6809, Smalltalk-78 8-bit VM).<br/><br/>Probably another big step from 8-bit to 64-bit.<br/><br/>Some early Burroughs machine used Huffman encoding for instructions.  Smallest instruction was 2-bits (?).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574148073.022200"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574148073.022200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-18 23:21</span><br/>
I’m not sure I want to buy into the sentiment that “things are just more complex today than they had been in the past”. I mean, yes, sure, but they are because we made them so. That applies to hardware as much as to software.<br/><br/>We’re just generally bad at cleaning up and getting rid of things. And so we keep old stuff around forever, because, hey, it still works and software is difficult to get right so let’s better not touch it and build new stuff on top of it instead.<br/><br/>It takes courage to change the infrastructure and throw away the old that still works, but overall just introduces complexity we no longer need. It’s a dumb and risky thing to do. You’ll break a lot of things and really piss off a lot of people who’ve gotten used to the old ways of doing things.<br/><br/>You’d have to be crazy to think that the long-term benefits of reducing that complexity will outweigh the short-term hassle of new bugs, missing features, and annoyed customers.<br/><br/>I’m glad there are still a few people crazy enough to keep doing it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574155613.022700"></a>
      <img src="https://secure.gravatar.com/avatar/cf29e340a09ac08ae262632ef9101046.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574155613.022700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ian Rumac</b>
<span style="margin:2em; color:#606060">2019-11-19 01:26</span><br/>
Exactly - We added a ton of complexity and legacy through time, which wasn’t always written by great developers and was often times written to be as generic as possible and it’s all below the surface of your application.<br/><br/>For example, look at Android - so much code that was written long time ago and focused at the time of it’s development (32mb RAM smartphones, while they have 8GB now), but it’s still alive and the team is just deciding to rewrite the whole UI layer because the early decisions screwed it up so hard that they’ve been trying to fix those mistakes by throwing more libraries on it and just adding more and more complexity.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574165939.029800"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574165939.029800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-11-19 04:18</span><br/>
I don’t disagree with all that has been said, but I’d like to point out the complexity of the real world vs. a demo as another aspect. An address book good enough for all of planet Earth is probably as complex as à windowing system, because of the complexity of street addresses. Dates are another can of worms. Add domain-specific complexities that few people are even aware of.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574179437.030000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574179437.030000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-19 08:03</span><br/>
Some things missing from Smalltalk '78: Unicode support (character set, fonts, text rendering). Hi res 24bit RGB display, compositing window manager, ability to display and edit photos, play videos. 3D graphics. Internet (TCP/IP, HTTP, etc). A web browser (HTML, JS, CSS). This is maybe 10M loc today? libFFMPEG alone is 1.4M loc just dealing with all the video formats.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574183702.036700"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574183702.036700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-19 09:15</span><br/>
STEPS (<a href="http://www.vpri.org/pdf/tr2012001_steps.pdf">http://www.vpri.org/pdf/tr2012001_steps.pdf</a>) would be a better benchmark than Smalltalk-78, as that research was designed with the goal of how much of a “multimedia system” could you design in 20k LOCs and it included a 2D compositing engine, networking, web browser and sort of like an office suite (although it still lacked many other things).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574186175.037300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574186175.037300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-11-19 09:56</span><br/>
Great responses. Some themes I see are:<br/><br/>Vertical integration:<br/><br/>&gt;  When you build all the systems across all levels of the stack you can ensure each of them do their jobs well and there are no inefficiencies.<br/><br/><br/>&gt;  a ton of complexity and legacy... it’s all below the surface of your application<br/><br/>More essential complexity<br/><br/>&gt;  the complexity of the real world vs. a demo<br/><br/><br/>&gt;  Unicode support (character set, fonts, text rendering). Hi res 24bit RGB display, compositing window manager, ability to display and edit photos, play videos<br/><br/>'inertia'<br/><br/>&gt; bad at cleaning up and getting rid of things. And so we keep old stuff around forever, because, hey, it still works and software is difficult to get right so let’s better not touch it and build new stuff on top of it instead.<br/><br/><br/>&gt; they’ve been trying to fix those mistakes by throwing more libraries on it and just adding more and more complexity.<br/><br/>'compatibility'<br/><br/>&gt;  ...HTTP, etc). A web browser (HTML, JS, CSS).<br/><br/>Perhaps it's also the interaction between all of these dimensions that produces a combinatorial explosion in complexity and 'software material' all around. Specifically wrt 'compatibility', I think we want to look at the end goals rather than the specific implementations. E.g. what services does the web browser/HTTP system provide? Some kind of a UI kit for distributed information/computation systems. Is a browser an efficient model for this goal? What other system could provide the same service?<br/><br/>The 'vertical integration' aspect is particularly appealing to me.  It seems so much effort is spent just building bridges between layers that have different models.<br/><br/>There definitely is much more essential complexity than exists in the ST system. I believe STEPS implemented the compositing engine, basic TCP/IP networking and font rendering. TCP/IP specifically was ~200 LOC (<a href="http://www.moserware.com/2008/04/towards-moores-law-software-part-3-of-3.html">http://www.moserware.com/2008/04/towards-moores-law-software-part-3-of-3.html</a>).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574192789.074400"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574192789.074400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-19 11:46</span><br/>
Just reading through all three parts of the article you just linked. This is a great quote from number 2 of 3 <a href="http://www.moserware.com/2008/04/towards-moores-law-software-part-2-of-3.html">http://www.moserware.com/2008/04/towards-moores-law-software-part-2-of-3.html</a>:<br/>&gt;modern software is typically designed by accretion, much like a pyramid. That is, we design by adding around the edges rather than being willing to do a radical top to bottom design like the Empire State Building which was built in about a year with great engineering precision. We keep adding to systems rather than look back at their core assumptions to see if they’re still meeting our needs.<br/><br/>I don’t think the “dimensions” you extracted are creating “a combinatorial explosion of complexity”, and rather see them as an incentive structure pushing us to “add around the edges” instead of redesign radically:<br/><br/>1. Most projects or organizations are not vertically integrated and don’t control the whole stack, and if you’re dependent on things you don’t control you can’t touch them.<br/>2. The world hasn’t changed much, but we decided we want to model it more closely and with higher fidelity. That’s a design decision (and a good one) that certainly causes more complexity, but not all of that complexity is essential and choosing to leave existing solutions behind also works higher up the ladder of abstraction — do we really need all those different image compression algorithms or should we just keep one of them? Which leads nicely into…<br/>3. Compatibility — of course we want to still access all the JPEGs and GIFs scattered all over the web, even though we have so much better compression algorithms now. Huge incentive towards keeping the old stuff around. We could attempt to convert everything but that’s obviously more difficult than to just keep a few extra LOCs around to still be able to read JPEGs.<br/><br/>All that provides pretty strong incentives to not break what already works, avoid the heat of people complaining that legacy will be removed, and so we just keep adding. It's the totally reasonable thing to do. And it’s a viscious cycle as we keep adding more and more things people and other things start to rely on and don’t want to go away.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574194333.074800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574194333.074800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-19 12:12</span><br/>
Choice of programming language is also a consideration. Co-dfns is a 20 pass optimizing APL compiler in 750 lines of code. <a href="https://github.com/Co-dfns/Co-dfns">https://github.com/Co-dfns/Co-dfns</a> The Steps project included Gezira, 2D vector graphics in &lt;400loc, written in Nile, equivalent to 10,000 loc in C (Cairo), even though the Nile code is far less compact than the APL/Co-dfns code. <a href="https://raw.githubusercontent.com/wiki/damelang/nile/socal.pdf">https://raw.githubusercontent.com/wiki/damelang/nile/socal.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574195177.075000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574195177.075000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-19 12:26</span><br/>
Gezira would probably be &lt;40 loc in terse-style APL. And harder to read. APLers justify the terse coding style as making large, complex programs easier to understand and maintain if you can see all the code on the screen at once, without scrolling. Could a sophisticated IDE make this kind of code easier to understand?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574204193.080000"></a>
      <img src="https://secure.gravatar.com/avatar/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574204193.080000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Garth Goldwater</b>
<span style="margin:2em; color:#606060">2019-11-19 14:56</span><br/>
i really think that apl could benefit from a game-style visualization: when it was invented this kind of thing was a pipe dream—but the functions and operators were designed to be super evocative (“suggestive”) among other things and expose a lot at the heart of math that lead to an actual textbook for math being developed that used the same notation
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574214563.084000"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574214563.084000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-11-19 17:49</span><br/>
You get a lot done by avoiding fiddly bits.  If a subsystem isn't carrying its weight, throw it out and everything it does.  An example.  Back long while now, we had some specific XML we needed to parse in an environment with no proper XML parser.  So we wrote a parser for the 5% of XML that we did need.  It wan't especially domain specific: it amounted to 95% of the XML that people generally use.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574278538.085600"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574278538.085600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-11-20 11:35</span><br/>
On the topic of vertical integration and complexity, I wrote an article about this a while ago which was a lot of fun to write (so I hope it's the same for reading!). "A Dream of Simplicity: Scientific Computing on Turing Machines" <a href="https://hal.archives-ouvertes.fr/hal-02117720">https://hal.archives-ouvertes.fr/hal-02117720</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574278750.085900"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574278750.085900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-11-20 11:39</span><br/>
The Web browser is an interesting case. Web standards are organically grown and committee-approved complexity. If you want to redesign computing from scratch, with less accidental complexity, you might well decide to redesign the Web as well and get rid of all the cruft. But then, so much information is available exclusively via this mess of standards that it can also be considered a part of the "real world" mess, and thus essential complexity.<br/>"First we shape our tools and then our tools shape us."
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574284112.086300"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574284112.086300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 13:08</span><br/>
And even standards evolve and — although backwards compatibility is often considered for newer iterations of such standards — every now and then incompatible changes are introduced and the expectation is that indeed everything will be upgraded eventually. Of course, neither does that ever happen for 100% of all content, nor does anybody seriously argue to just stop inventing new and better things in hope of replacing old and worse ones. That's the continuum we operate in and our own tough design decision of what to break and when to break it.<br/><br/>And this is a fundamental issue all over our industry: floppy disk/optical drives/networking/streaming, serial and parallel ports/USB-A/USB-C, VGA/HDMI/USB-C, x68 architecture (still supports 8086 instructions). win32/MFC/.net/UWP, Carbon/Cocoa, Obj-C/Swift, HTML/XHTML/HTML5, etc.<br/><br/>What's interesting is that in surprisingly many cases these transitions are absolutely unfathomable before the new technology appears, then totally never happening when a new technology is presented as a potential successor, then grudgingly adopted through forcing mechanisms or because of market dynamics, and then absolutely obvious and logical looking back.<br/><br/>I cannot think of another industry with such a schizophrenic obsession for both preserving the status quo and radically changing it at the same time.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574285825.086600"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574285825.086600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-11-20 13:37</span><br/>
I wonder if at some fundamental level the kinds of things new standards do is similar to old standards. (e.g. all cpus are 'equivalent' to a Turing machine). And if we are able to define the standards by mapping them to the same thing then moving to newer ones is 'automatic' to a large degree.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574287534.086900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574287534.086900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-11-20 14:05</span><br/>
Nice writeup <span style="background-color:#ccf">@Konrad Hinsen</span>! Still reading through it. Particularly agree with:<br/><br/>&gt;  composition  really  is at  the  heart of most  of  our  frustrations  with computer<br/>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574450296.111900"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1574100925.005200.html#1574450296.111900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-11-22 11:18</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span> What makes computing special is that it’s a technology that is at the same time immature and essential for modern life. Hence the need to improve and the wish for stability.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
