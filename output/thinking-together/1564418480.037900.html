<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Will Crichton</b>
<span style="margin:2em; color:#606060">2019-07-29 09:41</span><br/>
If you wanted to justify the claim “functional programming and PL theory are useful tools to learn”, how would you do it? What concepts and skills would you point to, and what real-world examples/applications would you use to demonstrate the usefulness of FP?<br/><br/>For example, “Can Programming Be Liberated from the von Neumann Style” and “Why Functional Programming Matters” both use higher-order functions/composition on lists/trees to prove the point.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564418550.038000"></a>
      <img src="https://secure.gravatar.com/avatar/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564418550.038000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Will Crichton</b>
<span style="margin:2em; color:#606060">2019-07-29 09:42</span><br/>
Distinctly not looking for arguments like “Scala/Rust/etc. have a functional flavor, and companies use them, therefore you should learn FP”
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564435232.041800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564435232.041800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-07-29 14:20</span><br/>
I'd argue that FP isn't useful (because <em>that's, like, my opinion, man</em>) and then look for weaknesses in my argument.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564435338.042000"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564435338.042000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-07-29 14:22</span><br/>
The most successful arguments in favor of FP that I've encountered came from Rich Hickey and Joe Armstrong talks, describing how they arrived at the philosophies that support the design of Clojure and Erlang.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564435384.042200"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564435384.042200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-07-29 14:23</span><br/>
Simple Made Easy, for instance, seems to be the gateway drug that gets a lot of people hooked on FP. So an answer to your question might be found in there.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564435683.042400"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564435683.042400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-07-29 14:28</span><br/>
When it comes to concepts, skills, real world examples.. that's actually the point where I fall off the FP train. I've found it's easier to justify the benefits of writing all your code in C, getting a lot more intimate with registers and memory allocation and nurturing the skill of mechanical sympathy, doing any advanced data manipulation yourself — rather than leaving all that to the compiler and benefitting from a language that lets you explicitly label your algebraic data types (etc).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564435815.042700"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564435815.042700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-07-29 14:30</span><br/>
Being aware of category theory and abstract algebra... being able to know when you need to use an abelian group (eg: for perf reasons) — that's valuable. But once you have that theoretical knowledge, you can leverage it in whatever language you want.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564435866.042900"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564435866.042900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-07-29 14:31</span><br/>
People typically seem to learn that theory at the same time they learn Haskell, so I think the benefits of the former are conferred upon the latter (not undeservedly, since Haskell does allow you to be a lot more explicit about your algebra than most languages). But there's nothing stopping you from taking "FP, The Good Parts" and doing it in whatever language/paradigm you want.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564436342.043200"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564436342.043200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-07-29 14:39</span><br/>
So to answer your question, I'd say the concepts to know are things like.. associativity, commutativity, set theory, a tiny bit of group theory... and things like the joy (and pain) of a pure function, the pain (and joy) of a side effect, etc. The motivating examples are things like.. the difficulty of unit testing stateful code vs pure code, the ease (and joy) of finding analogies between things like sets, and vectors, and maps, and functions (in the math sense), and functions (in the colloquial C/Java sense) when you know about concepts like fixed points, functors, the hyperoperation sequence, etc.<br/><br/>There's nothing really in there that is conceptually under the umbrella of FP — it's just math, and FP just makes good use of math — but a good education in FP should probably teach you all of that math stuff.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564472631.053500"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564472631.053500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-07-30 00:43</span><br/>
I am one of the lucky few people alive who got to see John Backus' (IBM inventor of FORTRAN) presentation of his Function language in 1973. The professors left the room shaking their heads saying he was crazy because not being able to update the state of a variable creates a mad hatter's tea party situation where memory is gobbled up while pretending you aren't updating a mutable state. In his case, you are using up a new memory slot and keeping all prior values which is a fairly expensive tradeoff. Crockford has some serious criticisms of FP. It isn't the panacea of the future, and for liberating from the Von Neumann style, one should study Chapel and Parasail languages, both of which handle automatic parallelization. In the case of Parasail it does it on one machine node only, while in the case of Chapel it can handle machine clusters which represents a doubly hard problem; you have a whole rack of multicore machines, how do you harness them? Chapel is like a super Fortran. It is from Cray who have a legacy of handling the toughest problems on the planet.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564473195.053800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564473195.053800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-07-30 00:53</span><br/>
Category theory and FP is full of obscure jargon which confers great solemnity on people, but from a readability point of view languages like Elm fall very short. They are very hard to understand, and Haskell is also terrible. In the commercial world if you can't transfer the code easily from one team member to another, it will have very poor acceptance. Look at the problems Boeing is having, trying to get their MCAS software accepted by the FAA and airlines. They are losing over a million dollars a day because other people can't verify a fairly simple program is accurate. The airplane has a constantly changing state, and the finite state machine they have programmed has to respond sensibly. Having software be robust is very important, and although the concept of pure functions is a fun one, and allows for easy composition, frankly very little of my code one has to write is composable. I don't take the output of a function and feed it to a long chain of functions very often. So the mathematical wonders of composition are just not that usable a great deal of the time. Most of the code in a graphical interactive product is devoted to handling input, and drawing things, none of which are heavily nested. Lots of graphical constraints, and heuristics for sizing and placement.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564483972.058900"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564483972.058900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-07-30 03:52</span><br/>
<span style="background-color:#ccf">@Will Crichton</span> Another person I learned to turn to as a good resource for this kind of question is Kevlin Henney, who I heard first about in this forum. I recommend one of the variations of his talk “Functional Programming You Already Know”, perhaps this one: <a href="https://www.infoq.com/presentations/functional-declarative-style/">https://www.infoq.com/presentations/functional-declarative-style/</a><br/><br/>Slide 60 in this presentation seems like a good, powerful, and practical argument why we at least can't ignore functional programming, because it definitely solves a few problems we've been maneuvering ourselves into with imperative and OOP approaches:<br/><a href="https://www.slideshare.net/Codemotion/functional-programming-you-already-know-46496208">https://www.slideshare.net/Codemotion/functional-programming&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564515330.081200"></a>
      <img src="https://secure.gravatar.com/avatar/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564515330.081200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Will Crichton</b>
<span style="margin:2em; color:#606060">2019-07-30 12:35</span><br/>
Thanks for the responses everyone! I’ll link my course notes here once they’re done if anyone is interested.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564544351.098300"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564544351.098300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-07-30 20:39</span><br/>
Deductive programming is far more profitable an avenue to study than FP. It is one of the great tragedies of the past when the LISP crowd at MIT beat out the French team that was using PROLOG. PROLOG is not a very useful language, but the concepts inside are fantastic. Deduction allows the computer to do work that is very error-prone for programmers. The entire history of the evolution of programming languages consists of identifying common error patterns, and engineering a system that prevents them from happening entirely. We started with register clobberation, the most dangerous error of all, because it introduces a random result into a deterministic program, then moved on to memory management, function call parameter matching, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1564569519.112000"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1564418480.037900.html#1564569519.112000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-07-31 03:38</span><br/>
Just came across this article, which is another very pragmatic example of functional concepts applied to (post-?)modern programming and making an interesting connection between imperative and reactive programming: <a href="https://jasdev.me/duals">https://jasdev.me/duals</a><br/><br/>It also closes the loop to category theory and provides concrete examples (and intuitive understanding for those familiar with the platform) for topics we just discussed in #category-theory.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
