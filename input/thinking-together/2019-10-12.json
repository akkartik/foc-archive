[
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1570872743.237500",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1570906346.000000"
        },
        "client_msg_id": "b702f1d4-3fc9-447f-94f3-c5b828b74175",
        "text": "20 million is a lot of money. If i recall correctly Eve raised 2.3 million from Andreesen Horowitz, and the Luna team just raised 2 million for their second round, and the Red team via an ICO raised an unknown amount, probably in the tens of millions.  So 2 million gets you about a team of 6 people for 2-3 years, depends on the country of course. Red is pursuing a multi-platform initial release, so they have higher costs and a larger team. the best way to do this type of funding is to put at least 3 parallel competing teams on the same general project area, and whichever one looks the most promising after N months gets increased funding and the other teams are disbanded. This was the general methodology used so successfully under Thomas J. Watson Jr. who presided over the most successful and excellent tech company the world has ever seen. I know that most of you folks don't know how great IBM was, but they were amazing, and for a near monopoly, while Watson was in charge, the company was of the highest integrity and innovative like no other. After he retired it was ruined as a company, they became gutless and lazy. They are only a shadow of their former selves. But anyway back to this idea, by having competing teams you get peoples' juices going. A race is far more exciting than a country club atmosphere with no deadlines and a steady paycheck you won't get much. Look at how little gets accomplished in France. They are so smart, but so far behind in programming. I think it is just too comfortable. I had a friend David who tried working in Paris and couldn't stand the lack of motivation and quit his cushy job. If you are not going to have a VC breathing down your neck, at least put some danger into the process by having some competition. Some of the greatest creations in history were done very quickly. Like building the Pentagon (under 1 year), or the most impressive musical composition feat in a short time period in history, Donizetti's Don Pasquale which was done in just in a handful of weeks, which if you ever go to a big public library and see the score, you would be hard pressed to copy by hand that score in the time he took to write it. Nobody has ever done an opera of that quality in what amounted to just a few days.  <@U5TCAFTD3> , i suggest you study the biography of Thomas J. Watson, as he directed some of the most productive R&amp;D, and was quite a forceful personality without being a chair thrower, etc. Hewlett &amp; Packard were also superb tech managers and developers; actually very few great leaders in computer history. If you just throw money into a project without a strong plan, you get poor results. Take a gander at the doomed california high speed rail project for an example of how not to run a project. They spent billions, and accomplished nothing useful. Or the hot fusion projects of the last 30 years, which have promised fusion in 10 years for the last 30 years straight. Many R&amp;D projects fail, so I thing Watson had the most practical approach to solving an important problem.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kxap",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "20 million is a lot of money. If i recall correctly Eve raised 2.3 million from Andreesen Horowitz, and the Luna team just raised 2 million for their second round, and the Red team via an ICO raised an unknown amount, probably in the tens of millions.  So 2 million gets you about a team of 6 people for 2-3 years, depends on the country of course. Red is pursuing a multi-platform initial release, so they have higher costs and a larger team. the best way to do this type of funding is to put at least 3 parallel competing teams on the same general project area, and whichever one looks the most promising after N months gets increased funding and the other teams are disbanded. This was the general methodology used so successfully under Thomas J. Watson Jr. who presided over the most successful and excellent tech company the world has ever seen. I know that most of you folks don't know how great IBM was, but they were amazing, and for a near monopoly, while Watson was in charge, the company was of the highest integrity and innovative like no other. After he retired it was ruined as a company, they became gutless and lazy. They are only a shadow of their former selves. But anyway back to this idea, by having competing teams you get peoples' juices going. A race is far more exciting than a country club atmosphere with no deadlines and a steady paycheck you won't get much. Look at how little gets accomplished in France. They are so smart, but so far behind in programming. I think it is just too comfortable. I had a friend David who tried working in Paris and couldn't stand the lack of motivation and quit his cushy job. If you are not going to have a VC breathing down your neck, at least put some danger into the process by having some competition. Some of the greatest creations in history were done very quickly. Like building the Pentagon (under 1 year), or the most impressive musical composition feat in a short time period in history, Donizetti's Don Pasquale which was done in just in a handful of weeks, which if you ever go to a big public library and see the score, you would be hard pressed to copy by hand that score in the time he took to write it. Nobody has ever done an opera of that quality in what amounted to just a few days.  "
                            },
                            {
                                "type": "user",
                                "user_id": "U5TCAFTD3"
                            },
                            {
                                "type": "text",
                                "text": " , i suggest you study the biography of Thomas J. Watson, as he directed some of the most productive R&D, and was quite a forceful personality without being a chair thrower, etc. Hewlett & Packard were also superb tech managers and developers; actually very few great leaders in computer history. If you just throw money into a project without a strong plan, you get poor results. Take a gander at the doomed california high speed rail project for an example of how not to run a project. They spent billions, and accomplished nothing useful. Or the hot fusion projects of the last 30 years, which have promised fusion in 10 years for the last 30 years straight. Many R&D projects fail, so I thing Watson had the most practical approach to solving an important problem."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJUQESQ1Z",
        "type": "message",
        "ts": "1570875520.237800",
        "client_msg_id": "3d475433-acc2-47db-9bae-d10ef274e0ec",
        "text": "I don’t think I’d want to maintain a Self project (nor a Smalltalk one), but the level of introspectability of these tools is pretty amazing, and something I’d like in other languages. I think we can learn from the good stuff, and praise them without needing to have these rants about how terrible inheritance and OOP is all the time. That’s an unrelated issue.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g52a48f76fc9",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e52a48f76fc911d40711f788d74773a0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png",
            "first_name": "",
            "real_name": "Brendan Zabarauskas",
            "display_name": "Brendan Zabarauskas",
            "team": "T5TCAFTA9",
            "name": "bjzaba",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570649221.097300",
        "parent_user_id": "UHWC9PXBL",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O=djf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don’t think I’d want to maintain a Self project (nor a Smalltalk one), but the level of introspectability of these tools is pretty amazing, and something I’d like in other languages. I think we can learn from the good stuff, and praise them without needing to have these rants about how terrible inheritance and OOP is all the time. That’s an unrelated issue."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UN06QADNV",
        "type": "message",
        "ts": "1570881041.238200",
        "client_msg_id": "21166437-6daf-4ba5-9445-2ed6289d6d1d",
        "text": "Perhaps <https:\/\/scalameta.org\/docs\/semanticdb\/specification.html> is an angle on a similar idea?\nIts a \"data model for semantic information such as symbols and types about programs.\"",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g96c2c97e5ed",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/96c2c97e5edea550b6935e656f64204c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0023-72.png",
            "first_name": "",
            "real_name": "Brent",
            "display_name": "Brent",
            "team": "T5TCAFTA9",
            "name": "brentgracey",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL",
        "attachments": [
            {
                "title": "SemanticDB Specification · Scalameta",
                "title_link": "https:\/\/scalameta.org\/docs\/semanticdb\/specification.html",
                "text": "SemanticDB is a data model for semantic information such as symbols and types about",
                "fallback": "SemanticDB Specification · Scalameta",
                "from_url": "https:\/\/scalameta.org\/docs\/semanticdb\/specification.html",
                "service_name": "scalameta.org",
                "id": 1,
                "original_url": "https:\/\/scalameta.org\/docs\/semanticdb\/specification.html"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ous1T",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Perhaps "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/scalameta.org\/docs\/semanticdb\/specification.html"
                            },
                            {
                                "type": "text",
                                "text": " is an angle on a similar idea?\nIts a \"data model for semantic information such as symbols and types about programs.\""
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UP6RJV9KP",
        "type": "message",
        "ts": "1570881843.238500",
        "client_msg_id": "d2e7df17-f280-4d08-8176-0444342f7673",
        "text": "<@UEBG0NPDK> Could you please expand on “stubbed out demo”? How do you decide which parts to stub out? What is most minimal demo do you start with?\n\n&gt; When we build something we try creating an end to end stubbed out demo and then fill it in over time.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6951c56a4328",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-12\/793287341024_6951c56a43287684a5ae_72.jpg",
            "first_name": "",
            "real_name": "Alexey Shamrin",
            "display_name": "Alexey Shamrin",
            "team": "T5TCAFTA9",
            "name": "shamrin",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mepj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEBG0NPDK"
                            },
                            {
                                "type": "text",
                                "text": " Could you please expand on “stubbed out demo”? How do you decide which parts to stub out? What is most minimal demo do you start with?\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When we build something we try creating an end to end stubbed out demo and then fill it in over time."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1570886861.238900",
        "client_msg_id": "ddaac693-06bb-4182-8b92-cfee4124650e",
        "text": "An idea from a discussion I had yesterday with different people on a different topic: One way to usefully spend money on researchy topics with little overhead is organizing meetings\/workshops\/... and pay for all the participants' travel costs. It's a small-perturbation thing for everyone (nobody moves to a different job, for example), and therefore creates no long-term seconday effect (\"what will I do when my grant runs out?\"). But it's a big boon for those of us who somehow manage to work on our FoC projects but couldn't afford spending much money on it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5PWA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An idea from a discussion I had yesterday with different people on a different topic: One way to usefully spend money on researchy topics with little overhead is organizing meetings\/workshops\/... and pay for all the participants' travel costs. It's a small-perturbation thing for everyone (nobody moves to a different job, for example), and therefore creates no long-term seconday effect (\"what will I do when my grant runs out?\"). But it's a big boon for those of us who somehow manage to work on our FoC projects but couldn't afford spending much money on it."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UNLS33M61",
        "type": "message",
        "ts": "1570892929.240300",
        "client_msg_id": "85b41e50-4d86-435f-bdde-c5988f6345ee",
        "text": "PG announced his second Lisp variant: Bel. <http:\/\/paulgraham.com\/bel.html> He’s taking an axiomatic approach to Lisp, as described here: <https:\/\/sep.yimg.com\/ty\/cdn\/paulgraham\/bellanguage.txt?t=1570888282&amp;>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g915aac3dfde",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/915aac3dfde2fb502ce415d77643a72d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0004-72.png",
            "first_name": "",
            "real_name": "Wil Chung",
            "display_name": "Wil Chung",
            "team": "T5TCAFTA9",
            "name": "iamwil",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "reply_count": 37,
        "reply_users_count": 10,
        "latest_reply": "1571335071.468300",
        "reply_users": [
            "UAVCC2X70",
            "UCKRZS3DZ",
            "UEQ6M68H0",
            "UJN1TAYEQ",
            "ULM3U6275",
            "UMVFWPZ36",
            "UCUSW7WVD",
            "UJBAJNFLK",
            "U71PMQ1V0",
            "UKJGU23KP"
        ],
        "replies": [
            {
                "user": "UAVCC2X70",
                "ts": "1570894342.240700"
            },
            {
                "user": "UCKRZS3DZ",
                "ts": "1570903753.242800"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1570906198.243200"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1570906768.243800"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1570910690.245000"
            },
            {
                "user": "ULM3U6275",
                "ts": "1570913339.249600"
            },
            {
                "user": "UMVFWPZ36",
                "ts": "1570913423.249900"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570913863.250500"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570913994.250800"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1570914101.251000"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570914107.251200"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570914235.251500"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1570915304.252000"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570916231.252400"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1570916932.252600"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570917721.252800"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570917864.253000"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1570918261.253200"
            },
            {
                "user": "ULM3U6275",
                "ts": "1570920327.253500"
            },
            {
                "user": "ULM3U6275",
                "ts": "1570920799.253700"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1570921230.254200"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570922910.255200"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1570925495.256100"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1570926777.256800"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1570983127.264700"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571066056.280800"
            },
            {
                "user": "U71PMQ1V0",
                "ts": "1571067844.281000"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571080124.283300"
            },
            {
                "user": "UKJGU23KP",
                "ts": "1571081059.283500"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571084651.284200"
            },
            {
                "user": "UKJGU23KP",
                "ts": "1571084967.284500"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571085451.284800"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571086489.285000"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1571121111.285900"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1571122053.286200"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571155697.334300"
            },
            {
                "user": "UKJGU23KP",
                "ts": "1571335071.468300"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WjZT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "PG announced his second Lisp variant: Bel. "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/paulgraham.com\/bel.html"
                            },
                            {
                                "type": "text",
                                "text": " He’s taking an axiomatic approach to Lisp, as described here: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/sep.yimg.com\/ty\/cdn\/paulgraham\/bellanguage.txt?t=1570888282&amp;",
                                "text": "https:\/\/sep.yimg.com\/ty\/cdn\/paulgraham\/bellanguage.txt?t=1570888282&"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UAVCC2X70",
                    "ULM3U6275",
                    "UA14TGLTC"
                ],
                "count": 3
            },
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "ULM3U6275"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UNLS33M61",
        "type": "message",
        "ts": "1570893762.240400",
        "client_msg_id": "cdf9591c-af16-4245-9a15-f28b39c6bbef",
        "text": "Hence, I’m guessing this made queries in Eve data independent and had more flexibility in the paths it can find to arrive at an answer?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g915aac3dfde",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/915aac3dfde2fb502ce415d77643a72d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0004-72.png",
            "first_name": "",
            "real_name": "Wil Chung",
            "display_name": "Wil Chung",
            "team": "T5TCAFTA9",
            "name": "iamwil",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1569782281.071300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pz\/Pu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hence, I’m guessing this made queries in Eve data independent and had more flexibility in the paths it can find to arrive at an answer?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1570894342.240700",
        "client_msg_id": "c862a78c-d96b-418a-850a-de3e7698224c",
        "text": "Very nice!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aN0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Very nice!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1570896466.240900",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1570897088.000000"
        },
        "client_msg_id": "87968002-5ad6-4ab1-ad1f-471b144c97c3",
        "text": "I have many ideas\/goals for [Interact](<https:\/\/github.com\/d-cook\/Interact>), but one is that instead of representing \"source code\" as static text, it is instead an entire interactive model\/representation. And everything that makes that model work (how it is visualized and interacted with, how it builds, etc.) is built in to the self-same model.\n\nThe relevance here is that everything about language (e.g. compilers, interpreters, syntax, semantics), data representation, visualization, editors\/tools, ... everything about programs and programming, really ... It's really no different from (e.g. can be accomplished via) ordinary programming techniques using functions + data-structures + abstraction, etc. And since code can be represented as data-structures, the whole world of programming can fit into things like lists and key-value stores. You really don't need anything more than that for anything!\n\nAs for the DB, you can code up whatever model works best instead, or you have something that translates your \"ideal model\" into code that creates and populates a DB and the code interface to it. (I can explain more if needed)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YpO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have many ideas\/goals for [Interact]("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/d-cook\/Interact"
                            },
                            {
                                "type": "text",
                                "text": "), but one is that instead of representing \"source code\" as static text, it is instead an entire interactive model\/representation. And everything that makes that model work (how it is visualized and interacted with, how it builds, etc.) is built in to the self-same model.\n\nThe relevance here is that everything about language (e.g. compilers, interpreters, syntax, semantics), data representation, visualization, editors\/tools, ... everything about programs and programming, really ... It's really no different from (e.g. can be accomplished via) ordinary programming techniques using functions + data-structures + abstraction, etc. And since code can be represented as data-structures, the whole world of programming can fit into things like lists and key-value stores. You really don't need anything more than that for anything!\n\nAs for the DB, you can code up whatever model works best instead, or you have something that translates your \"ideal model\" into code that creates and populates a DB and the code interface to it. (I can explain more if needed)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570897577.241800",
        "client_msg_id": "45ad7137-5554-4abc-809a-3f1e8f5c5f0d",
        "text": "<@UAVCC2X70> can you talk about how your different projects are connected?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "c+qdB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UAVCC2X70"
                            },
                            {
                                "type": "text",
                                "text": " can you talk about how your different projects are connected?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1570901439.242200",
        "client_msg_id": "c002ea42-3a7d-482c-a7bc-9183e3ae21d8",
        "text": "I'll start with \"Objects\":\n<https:\/\/github.com\/d-cook\/Objects>\n\nMy first attempt\/iteration at making a system entirely out of \"objects\" (e.g. JSON\/LISP-like data-structures). Expressions are LISP-like (list of operation + arguments), but the interpreter\/evaluator simply looks up ALL operations in a \"context\" object (which represents lexical scope and may reference a \"parent\" context -- think Scheme).\n\nFunctions can be native, or consist of objects that contain the code to evaluate, the arguments it takes, and the context (scope) in which to do so (typically same as lexical scope of the function).\n\nThe entire system (evaluator, a compiler, base operations like get, set, +, -, etc.) are all defined in a \"root\" context, which is not different from any other manipulatable entity. The evaluator was originally written natively (JavaScript for now), but then rewritten in \"objects\".\n\nThe goal was to rewrite everything that way, and have code that regenerates the native code for the whole system which, when run, recreates everything as it was at the time. This mostly just means spitting out the static data-structure for the whole thing, inserting a native evaluator (by feeding it into the compiler) which is then invoked immediately on some code to bootstrap the UI.\n\nFrom that point, you can reshape the whole thing just by interacting with the running program -- and that will allow me to evolve it further without ever looking at the \"source code\" again!\n\nThe only remaining \"native\" code (other than the base operations) was the logic in the compile function to convert code to JavaScript. But hey, I could (using the tool itself) make a compiler for something else (e.g. assembly, .NET, JVM) and supply the level base operations for it, and then boot up the entire system (in the same state) on something else!\n\nI took it too far with how minimal I wanted the native set to be (e.g. defining \"lookup\" in terms of objects, when that's a key function that the compiler injects everywhere), and forcing a CPS model under the hood sooner than I should have. It just became very difficult to manage, and stuff started to blow up when I got 90% of the way through rewriting it in itself ... I might go back some day and replay some of my development with different decisions.\n\nI'd been developing and interact with this entirely though the browser debugger, leaving the UI as an afterthought for after the base system was working properly. I knew I'd need some primitive graphical operations that could translate to any system -- just whatever is minimally sufficient to bootstrap a minimal foot-in-the-door UI, because then I could just use the UI to improve the UI code. ... But as stated, I never got to the UI.\n\nMy \"Interact\" project starts from the UI first and will work backwards to eventually bootstrap itself into that UI. It's essentially becoming a do-over of \"Objects\", though I might come back to that model eventually and reconcile them. ... I'll describe \"Interact\" next",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Wk4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'll start with \"Objects\":\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/d-cook\/Objects"
                            },
                            {
                                "type": "text",
                                "text": "\n\nMy first attempt\/iteration at making a system entirely out of \"objects\" (e.g. JSON\/LISP-like data-structures). Expressions are LISP-like (list of operation + arguments), but the interpreter\/evaluator simply looks up ALL operations in a \"context\" object (which represents lexical scope and may reference a \"parent\" context -- think Scheme).\n\nFunctions can be native, or consist of objects that contain the code to evaluate, the arguments it takes, and the context (scope) in which to do so (typically same as lexical scope of the function).\n\nThe entire system (evaluator, a compiler, base operations like get, set, +, -, etc.) are all defined in a \"root\" context, which is not different from any other manipulatable entity. The evaluator was originally written natively (JavaScript for now), but then rewritten in \"objects\".\n\nThe goal was to rewrite everything that way, and have code that regenerates the native code for the whole system which, when run, recreates everything as it was at the time. This mostly just means spitting out the static data-structure for the whole thing, inserting a native evaluator (by feeding it into the compiler) which is then invoked immediately on some code to bootstrap the UI.\n\nFrom that point, you can reshape the whole thing just by interacting with the running program -- and that will allow me to evolve it further without ever looking at the \"source code\" again!\n\nThe only remaining \"native\" code (other than the base operations) was the logic in the compile function to convert code to JavaScript. But hey, I could (using the tool itself) make a compiler for something else (e.g. assembly, .NET, JVM) and supply the level base operations for it, and then boot up the entire system (in the same state) on something else!\n\nI took it too far with how minimal I wanted the native set to be (e.g. defining \"lookup\" in terms of objects, when that's a key function that the compiler injects everywhere), and forcing a CPS model under the hood sooner than I should have. It just became very difficult to manage, and stuff started to blow up when I got 90% of the way through rewriting it in itself ... I might go back some day and replay some of my development with different decisions.\n\nI'd been developing and interact with this entirely though the browser debugger, leaving the UI as an afterthought for after the base system was working properly. I knew I'd need some primitive graphical operations that could translate to any system -- just whatever is minimally sufficient to bootstrap a minimal foot-in-the-door UI, because then I could just use the UI to improve the UI code. ... But as stated, I never got to the UI.\n\nMy \"Interact\" project starts from the UI first and will work backwards to eventually bootstrap itself into that UI. It's essentially becoming a do-over of \"Objects\", though I might come back to that model eventually and reconcile them. ... I'll describe \"Interact\" next"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1570901752.242400",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1570928072.000000"
        },
        "client_msg_id": "a258948a-1c00-48ba-b93a-2fe5eb71c2b1",
        "text": "\"Interact\":\n<https:\/\/github.com\/d-cook\/Interact>\n\n(continuing from previous) ... So the minimal UI would just expose the raw structure of everything, and provide a way to execute \/ evaluate code. (That's not the end goal, but I'll get back to that later)\n\nEntities (strings, numbers, lists, functions, etc.) sit freely on a canvas, where they can be moved around, inspected, expanded\/collapsed, etc.\n\nDragging values onto a function causes the function to be evaluated with those \"arguments\", and the result appears as a new entity on the canvas. Since there is a function for every basic operation, this is sufficient for making every kind of manipulation *possible* (but not necessarily ideal - I'll get back to that!)\n\n(Certain basic things like getting or setting a value could be as simple as drag-and-drop; but I'll get a working tool first, and then use the tool itself to see what works best for what -- let's call that \"phase 2\")\n\nEither way (e.g. whether the UI \"helps\" or not), any sequence of operations that can be done -- whether through user interaction or by evaluating \"code\" -- directly corresponds to sequence of (nested or otherwise) function calls. Therefore, by recording and replaying actions taken, all code can be created and viewed as direct interactions, rather than as the textual or structural representation one normally thinks of as \"code\". *(From here I might use \"code\" and \"actions\" interchangeably)\n\nSo essentially you can do a bunch of manipulations, and then say \"See what I did? Call that a function, and THIS value here is the result\". And then edit the *actions and\/or the object that represents the new function to replace certain values with arguments, etc.\n\nNow whereas \"normal\" code references values by identifiers (e.g. looking up variables by name), the user is able to just \"grab\" values that are just sitting there. So under the hood, code is stored as a list of actions, which contain either simple values or the index of some other action (referring to the result of that action) ... In other words, it's a DAG.\n\nWhen viewing \/ editing a function, actual values are substituted from the arguments, and you are shown the \"aftermath\" of the actions (i.e. values on a canvas), as if you had performed all the actions yourself. Changing any actions or values causes the whole thing to recompute (think FRP)\n\nThis means that any operation you do becomes part of the current \"function\" you are editing. I'll provide a way to \"cut\" dependencies though, so you can use the canvas as an interactive REPL, and then either throw out the results, or \"forget\" how it was computed and just use the generated value directly. I could also have a \"cleanup\" that will throw out all intermediate operations that did not contribute to the ultimate result of the function.\n\nAll editing is done in a function, so even the \"top level\" (global scope) is a \"function\" with its own record of actions taken. This also means that all the work of \"programming\" you do is recorded as some step somewhere, giving you multiple layers of undo\/redo.  Anything you do can be abstracted into a function and edited for generic reuse. E.g. \"Here's how I do x to the code\"\n\n... Anyway, I'm getting lost in low-level specifics. I'll tie this up in another reply",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JNZRt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"Interact\":\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/d-cook\/Interact"
                            },
                            {
                                "type": "text",
                                "text": "\n\n(continuing from previous) ... So the minimal UI would just expose the raw structure of everything, and provide a way to execute \/ evaluate code. (That's not the end goal, but I'll get back to that later)\n\nEntities (strings, numbers, lists, functions, etc.) sit freely on a canvas, where they can be moved around, inspected, expanded\/collapsed, etc.\n\nDragging values onto a function causes the function to be evaluated with those \"arguments\", and the result appears as a new entity on the canvas. Since there is a function for every basic operation, this is sufficient for making every kind of manipulation "
                            },
                            {
                                "type": "text",
                                "text": "possible",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (but not necessarily ideal - I'll get back to that!)\n\n(Certain basic things like getting or setting a value could be as simple as drag-and-drop; but I'll get a working tool first, and then use the tool itself to see what works best for what -- let's call that \"phase 2\")\n\nEither way (e.g. whether the UI \"helps\" or not), any sequence of operations that can be done -- whether through user interaction or by evaluating \"code\" -- directly corresponds to sequence of (nested or otherwise) function calls. Therefore, by recording and replaying actions taken, all code can be created and viewed as direct interactions, rather than as the textual or structural representation one normally thinks of as \"code\". *(From here I might use \"code\" and \"actions\" interchangeably)\n\nSo essentially you can do a bunch of manipulations, and then say \"See what I did? Call that a function, and THIS value here is the result\". And then edit the *actions and\/or the object that represents the new function to replace certain values with arguments, etc.\n\nNow whereas \"normal\" code references values by identifiers (e.g. looking up variables by name), the user is able to just \"grab\" values that are just sitting there. So under the hood, code is stored as a list of actions, which contain either simple values or the index of some other action (referring to the result of that action) ... In other words, it's a DAG.\n\nWhen viewing \/ editing a function, actual values are substituted from the arguments, and you are shown the \"aftermath\" of the actions (i.e. values on a canvas), as if you had performed all the actions yourself. Changing any actions or values causes the whole thing to recompute (think FRP)\n\nThis means that any operation you do becomes part of the current \"function\" you are editing. I'll provide a way to \"cut\" dependencies though, so you can use the canvas as an interactive REPL, and then either throw out the results, or \"forget\" how it was computed and just use the generated value directly. I could also have a \"cleanup\" that will throw out all intermediate operations that did not contribute to the ultimate result of the function.\n\nAll editing is done in a function, so even the \"top level\" (global scope) is a \"function\" with its own record of actions taken. This also means that all the work of \"programming\" you do is recorded as some step somewhere, giving you multiple layers of undo\/redo.  Anything you do can be abstracted into a function and edited for generic reuse. E.g. \"Here's how I do x to the code\"\n\n... Anyway, I'm getting lost in low-level specifics. I'll tie this up in another reply"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UCKRZS3DZ",
        "type": "message",
        "ts": "1570903753.242800",
        "client_msg_id": "4b0e211e-0a68-478e-aa7a-825d2f33652f",
        "text": "I skimmed through it, still didn't understand is there any novelty",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "222a2870915d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-15\/861537614034_222a2870915d24ec10cc_72.jpg",
            "first_name": "Vladimir",
            "real_name": "Vladimir Gordeev",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gordeev.vladimir.v",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0ii\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I skimmed through it, still didn't understand is there any novelty"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1570906198.243200",
        "client_msg_id": "62f2a745-f832-43f1-995a-1de75ea312dd",
        "text": "From my reading it is a back to basics Lisp.  A very clever language from a great mathematician, but its over-reliance on recursion as the main power tool makes Lisp unsuitable for the future.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R76q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "From my reading it is a back to basics Lisp.  A very clever language from a great mathematician, but its over-reliance on recursion as the main power tool makes Lisp unsuitable for the future."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1570906768.243800",
        "client_msg_id": "44f8ac5a-6794-4e9f-a701-ea3c3e57354c",
        "text": "The power of Lisp has everything to do with the kind of underlying model it can be (and on that sense, it's inescapable).\n\nBut it's not necessarily a good top-level model (aka \"language\" or \"interface\") for most things. But that's also true of programming language + code in general",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0oTel",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The power of Lisp has everything to do with the kind of underlying model it can be (and on that sense, it's inescapable).\n\nBut it's not necessarily a good top-level model (aka \"language\" or \"interface\") for most things. But that's also true of programming language + code in general"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1570910690.245000",
        "client_msg_id": "99e4c4db-a475-4365-9a25-8e62d53d11be",
        "text": "I really like the idea of building up a full featured programming language from a small core. It's elegant. In theory, it means that creating a new from-scratch implementation of the language can be done quickly, with a small amount of code, since you only need to reimplement the core. I mostly associate this idea with Lisp and Forth: having a small, simple syntax makes it easier to have a small core.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6AI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I really like the idea of building up a full featured programming language from a small core. It's elegant. In theory, it means that creating a new from-scratch implementation of the language can be done quickly, with a small amount of code, since you only need to reimplement the core. I mostly associate this idea with Lisp and Forth: having a small, simple syntax makes it easier to have a small core."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UMVFWPZ36",
        "type": "message",
        "ts": "1570913248.248300",
        "client_msg_id": "6a298996-9c35-4151-812a-1dfcf43ff5e7",
        "text": "<@UEQ6M68H0> I like the IBM \"build 3 and pick the best\" approach. I think perhaps you could have \"problem teams\", and \"solution teams\". The problem teams would go out and define what the problems are, and build datasets that all the solution teams could use (like <@U5TCAFTD3>’s recent dataset on next gen IDEs). That work is a lot more straightforward (but less sexy and underfunded). Then you have the competition on the solution teams. Perhaps, i dunno.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "j6u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " I like the IBM \"build 3 and pick the best\" approach. I think perhaps you could have \"problem teams\", and \"solution teams\". The problem teams would go out and define what the problems are, and build datasets that all the solution teams could use (like "
                            },
                            {
                                "type": "user",
                                "user_id": "U5TCAFTD3"
                            },
                            {
                                "type": "text",
                                "text": "’s recent dataset on next gen IDEs). That work is a lot more straightforward (but less sexy and underfunded). Then you have the competition on the solution teams. Perhaps, i dunno."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1570913324.249400",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1570928135.000000"
        },
        "client_msg_id": "655d9088-4b68-4188-a436-62814ab5959a",
        "text": "(Continuing about \"Interact\" from before)\n\nAnyway, the point is not to have that specific tool per se, but to have *something* sufficient to edit code in a more freeform way, and to let whatever that looks like be very easy to evolve and change to whatever is more ideal for whatever context.\n\nThe plan is to eventually bootstrap all the code for the tool into itself, so it can be changed and explored over time (per use, and to evolve this tool generally). The benefit is that whatever \"nice way\" is found to represent or edit something, can be immediately applied to itself to make it easier to make things easier, etc.\n\nOne thing I'll provide to that end, is the idea of a custom \"view\". What I've described for viewing and editing functions is just one such \"view\", which is different than viewing a \"function\" as raw JSON. But perhaps something is better viewed as a table, or a graph, or some other interactive visualization.\n\nA custom view will contain whatever code is necessary to render something, and respond to interaction. This will probably \"just be code\", but (for example) there's no reason there couldn't be a custom view for specifying views using some custom DSL.\n\nAnd that brings me to another major goal of this tool:\n\nThings like DSLs, macros, syntax, even \"programming language\" (compiling, interpreting, translating), ... these can all be fluid things defined by ordinary code. The only difference is when and where it happens. But in a system like this, everything is the result of some \"actions\" taken to create it. So there's always some \"code\" that specifies how your code got created. And there's no reason to treat *that* code any differently!\n\nExpanding this further, with all the possible ways to view and edit \"code\" (or anything else), there's no reason to distinguish between \"code\" and a UI widget with its own custom behavior. No fundamental difference between a macro or a compiler, and anything else that let's you specify or view code\/data one way, and then generate it another way.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KFMYG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(Continuing about \"Interact\" from before)\n\nAnyway, the point is not to have that specific tool per se, but to have "
                            },
                            {
                                "type": "text",
                                "text": "something",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " sufficient to edit code in a more freeform way, and to let whatever that looks like be very easy to evolve and change to whatever is more ideal for whatever context.\n\nThe plan is to eventually bootstrap all the code for the tool into itself, so it can be changed and explored over time (per use, and to evolve this tool generally). The benefit is that whatever \"nice way\" is found to represent or edit something, can be immediately applied to itself to make it easier to make things easier, etc.\n\nOne thing I'll provide to that end, is the idea of a custom \"view\". What I've described for viewing and editing functions is just one such \"view\", which is different than viewing a \"function\" as raw JSON. But perhaps something is better viewed as a table, or a graph, or some other interactive visualization.\n\nA custom view will contain whatever code is necessary to render something, and respond to interaction. This will probably \"just be code\", but (for example) there's no reason there couldn't be a custom view for specifying views using some custom DSL.\n\nAnd that brings me to another major goal of this tool:\n\nThings like DSLs, macros, syntax, even \"programming language\" (compiling, interpreting, translating), ... these can all be fluid things defined by ordinary code. The only difference is when and where it happens. But in a system like this, everything is the result of some \"actions\" taken to create it. So there's always some \"code\" that specifies how your code got created. And there's no reason to treat "
                            },
                            {
                                "type": "text",
                                "text": "that",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " code any differently!\n\nExpanding this further, with all the possible ways to view and edit \"code\" (or anything else), there's no reason to distinguish between \"code\" and a UI widget with its own custom behavior. No fundamental difference between a macro or a compiler, and anything else that let's you specify or view code\/data one way, and then generate it another way."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1570913339.249600",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1570913359.000000"
        },
        "client_msg_id": "15FD4994-9372-4F7E-93D3-DE640CE089B2",
        "text": "I love seeing ambitious projects like this where the author is making the tool they’d like to use.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SZi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I love seeing ambitious projects like this where the author is making the tool they’d like to use."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UMVFWPZ36",
        "type": "message",
        "ts": "1570913423.249900",
        "client_msg_id": "b0e2dbed-cfbd-4636-8eb1-d332bd930302",
        "text": "Very cool! Also cool to see the shoutout to  <@UCUSW7WVD> !  Any thoughts you could share about Bel? \"The code I wrote to generate and test the Bel source is written in Arc,\" So he was not writing Bel directly?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GqzK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Very cool! Also cool to see the shoutout to  "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " !  Any thoughts you could share about Bel? \"The code I wrote to generate and test the Bel source is written in Arc,\" So he was not writing Bel directly?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570913863.250500",
        "client_msg_id": "69e64d6c-9a2b-4542-b589-77dbc259ac2b",
        "text": "I actually asked the same question but didn't get an answer. I haven't seen Bel running either, just given feedback on early drafts of what you see.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PsX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I actually asked the same question but didn't get an answer. I haven't seen Bel running either, just given feedback on early drafts of what you see."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570913994.250800",
        "client_msg_id": "312b308b-2ce9-48fc-b97d-a5f3eed19685",
        "text": "I'd like to implement something like Bel in my machine code. With its emphasis on using little of the underlying platform it feels like a good fit for Mu. But I'm not sure when I'll get to that. I'm currently designing the C-ish level of the Mu stack.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lK1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd like to implement something like Bel in my machine code. With its emphasis on using little of the underlying platform it feels like a good fit for Mu. But I'm not sure when I'll get to that. I'm currently designing the C-ish level of the Mu stack."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "UC2A2ARPT"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1570914101.251000",
        "client_msg_id": "e05e358c-35c3-4723-885b-316a53de2e5d",
        "text": "The minimalistic approach I use is like a Lisp\/Scheme evaluator, but all operations are stored as functions (native if necessary), and the evaluator simply looks them up from a dictionary and invokes them. No operations are \"built in\" to the language",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AaZyb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The minimalistic approach I use is like a Lisp\/Scheme evaluator, but all operations are stored as functions (native if necessary), and the evaluator simply looks them up from a dictionary and invokes them. No operations are \"built in\" to the language"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570914107.251200",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1570914135.000000"
        },
        "client_msg_id": "ae110f04-3844-4121-956d-8eff41fc9265",
        "text": "While the Bel interpreter shown here is built in itself, it only needs a subset of Bel. One suggestion I had was to show two interpreters, one for Bel0 and one for the full Bel. Implement both in Bel0. That would improve the exposition, I think.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x0p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "While the Bel interpreter shown here is built in itself, it only needs a subset of Bel. One suggestion I had was to show two interpreters, one for Bel0 and one for the full Bel. Implement both in Bel0. That would improve the exposition, I think."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570914235.251500",
        "client_msg_id": "70f2dbc6-92e3-4bea-b5e0-5ccd00809172",
        "text": "<@UAVCC2X70> Does your language have primitives that are not functions? Other languages have keywords. Lisp has special forms. Smalltalk has blocks. I suspect you can't avoid something like that.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EiG5p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UAVCC2X70"
                            },
                            {
                                "type": "text",
                                "text": " Does your language have primitives that are not functions? Other languages have keywords. Lisp has special forms. Smalltalk has blocks. I suspect you can't avoid something like that."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1570914783.251700",
        "client_msg_id": "fb9d13d7-df0d-4550-9fd7-0206996ebe50",
        "text": "At the end of the day you are looking for some combination of 1) ease of learning and use during development, 2) ability to transfer projects from original author to maintainer gracefully, 3) aesthetic quality of the products produced, 4) target platform range, and 5) suitability for large data inputs. I don't think the future of computing is going to target niche markets like ML or exascale computing; those are best left to specialized toolchains custom made for that sort of thing. You could start by giving a product to clone, saying make me facebook in 3000 man hours, or pick some popular game, etc. Jonathan Blow's very clever Jai programming language is custom built around making his next game. The language does exactly what he needs for that game. And since it is a complex game, the language is pretty complex, and fairly low level as he is shooting for low power consoles like the Nintendo switch.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rV7t=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At the end of the day you are looking for some combination of 1) ease of learning and use during development, 2) ability to transfer projects from original author to maintainer gracefully, 3) aesthetic quality of the products produced, 4) target platform range, and 5) suitability for large data inputs. I don't think the future of computing is going to target niche markets like ML or exascale computing; those are best left to specialized toolchains custom made for that sort of thing. You could start by giving a product to clone, saying make me facebook in 3000 man hours, or pick some popular game, etc. Jonathan Blow's very clever Jai programming language is custom built around making his next game. The language does exactly what he needs for that game. And since it is a complex game, the language is pretty complex, and fairly low level as he is shooting for low power consoles like the Nintendo switch."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1570915304.252000",
        "client_msg_id": "172c67e5-5366-44cd-a4d3-c7cf847aff8b",
        "text": "Smalltalk is a bit different: the entire Smalltalk system is written in Smalltalk, all the way down. It's similar in this sense to C and Unix, where the C compiler and the operating system are written in C. I gather that the Smalltalk bootstrapping process involves a small, statically typed subset of Smalltalk with semantics similar to C, but I'm not familiar with the details. C was originally bootstrapped using a C compiler written in assembly language, but I bet nobody has bootstrapped C in that way since the 1970's.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qp=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Smalltalk is a bit different: the entire Smalltalk system is written in Smalltalk, all the way down. It's similar in this sense to C and Unix, where the C compiler and the operating system are written in C. I gather that the Smalltalk bootstrapping process involves a small, statically typed subset of Smalltalk with semantics similar to C, but I'm not familiar with the details. C was originally bootstrapped using a C compiler written in assembly language, but I bet nobody has bootstrapped C in that way since the 1970's."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570916231.252400",
        "client_msg_id": "7303435c-fb86-4f4b-a737-e0cf28ae2e0a",
        "text": "It's not clear to me that Smalltalk is different. Since the substrate (machine code) isn't Smalltalk or C, it is by definition impossible that the entire system is written in Smalltalk all the way down. Even if nobody works on the bootstrap any more it's still worth spreading the knowledge about how the bootstrap works, precisely what subset of the language it uses, and how the semantics differ from the full language. Until we understand this we can't actually say how parsimonious Smalltalk's bootstrap is compared to other languages.\n\n(This may seem pedantic, but I think it's hugely important for the health of society: <https:\/\/app.slack.com\/client\/T5TCAFTA9\/C5T9GPWFL>)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Do+QV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's not clear to me that Smalltalk is different. Since the substrate (machine code) isn't Smalltalk or C, it is by definition impossible that the entire system is written in Smalltalk all the way down. Even if nobody works on the bootstrap any more it's still worth spreading the knowledge about how the bootstrap works, precisely what subset of the language it uses, and how the semantics differ from the full language. Until we understand this we can't actually say how parsimonious Smalltalk's bootstrap is compared to other languages.\n\n(This may seem pedantic, but I think it's hugely important for the health of society: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/app.slack.com\/client\/T5TCAFTA9\/C5T9GPWFL"
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1570916932.252600",
        "client_msg_id": "1d84401f-bcf8-46c8-aaa6-3d5a182c0fca",
        "text": "In a system like Bel, I gather that most Bel functions are written in Bel, but some Bel functions are 'primitive': they do not have source code written in Bel. In Smalltalk, nothing is primitive. The entire interpreter and virtual machine are written in Smalltalk. You can inspect the source code, you can debug it, you can change the way it works, using live coding within a running Smalltalk image. That's what's different, and that's what I meant by \"written in Smalltalk all the way down\".",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ATb6G",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In a system like Bel, I gather that most Bel functions are written in Bel, but some Bel functions are 'primitive': they do not have source code written in Bel. In Smalltalk, nothing is primitive. The entire interpreter and virtual machine are written in Smalltalk. You can inspect the source code, you can debug it, you can change the way it works, using live coding within a running Smalltalk image. That's what's different, and that's what I meant by \"written in Smalltalk all the way down\"."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570917721.252800",
        "client_msg_id": "0f3f6f59-f1ee-4d4f-b26f-99739fe33e39",
        "text": "<@UJN1TAYEQ> I see, you're right. It may be worth distinguishing between \"built in Smalltalk\" and \"could be modified using Smalltalk\". The latter property is indeed universal, and that's pretty rare. Maybe Self and Io share it, besides Smalltalk? My Wart had it as well. What I learned from it was that while it's cool to be able to modify plumbing all the way down, there are extremely subtle implications for correctness and performance that the environment as a whole isn't equipped to support debugging. And arguably _couldn't possibly_ support. So it doesn't seem worth chasing or bragging about. Just stick to 5% or 1% that isn't introspectable. To do otherwise is status signalling at best.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jY8Y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " I see, you're right. It may be worth distinguishing between \"built in Smalltalk\" and \"could be modified using Smalltalk\". The latter property is indeed universal, and that's pretty rare. Maybe Self and Io share it, besides Smalltalk? My Wart had it as well. What I learned from it was that while it's cool to be able to modify plumbing all the way down, there are extremely subtle implications for correctness and performance that the environment as a whole isn't equipped to support debugging. And arguably "
                            },
                            {
                                "type": "text",
                                "text": "couldn't possibly",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " support. So it doesn't seem worth chasing or bragging about. Just stick to 5% or 1% that isn't introspectable. To do otherwise is status signalling at best."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570917864.253000",
        "client_msg_id": "74b81755-3159-4fec-a7ea-79a9c3b3606d",
        "text": "Common Lisp supports replacing `if` with your own version. You have to crack open a package lock and whatnot, but you _can_ do it. But trust me, you don't want to. The package lock is there for a reason.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pkvg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Common Lisp supports replacing "
                            },
                            {
                                "type": "text",
                                "text": "if",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with your own version. You have to crack open a package lock and whatnot, but you "
                            },
                            {
                                "type": "text",
                                "text": "can",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " do it. But trust me, you don't want to. The package lock is there for a reason."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1570918261.253200",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1570921754.000000"
        },
        "client_msg_id": "cf629e21-12b3-47c1-a141-4ade03e9ec5e",
        "text": "<@UCUSW7WVD> There are primitive values, lists, key-value objects, and native functions. The base operations are native, and other \"functions\" are just objects with \"code\", \"args\", and \"context\" properties.\n\nWhen an object-function is invoked, a new context (i.e. a lexical scope object) is created with the function's context as its parent, the arguments are set into that context, and then that context and the function's \"code\" are fed into the evaluator.\n\nHowever, when a function-object does not contain any \"context\" property, then the context of the caller is used as the parent context (aka dynamic scope). The practice is to embed such functions in calls to things like \"if\" -- which is very much like how SmallTalk blocks work.\n\n[\"if\", condition, {code:[...]}]\n\nSo instead of macros, functions are used for code that might or might not be invoked.\n\nIt's interesting to note that arrow-functions in JavaScript work similarly (i.e. they don't override \"this\" or \"arguments\", like other functions do)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YPV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " There are primitive values, lists, key-value objects, and native functions. The base operations are native, and other \"functions\" are just objects with \"code\", \"args\", and \"context\" properties.\n\nWhen an object-function is invoked, a new context (i.e. a lexical scope object) is created with the function's context as its parent, the arguments are set into that context, and then that context and the function's \"code\" are fed into the evaluator.\n\nHowever, when a function-object does not contain any \"context\" property, then the context of the caller is used as the parent context (aka dynamic scope). The practice is to embed such functions in calls to things like \"if\" -- which is very much like how SmallTalk blocks work.\n\n[\"if\", condition, {code:[...]}]\n\nSo instead of macros, functions are used for code that might or might not be invoked.\n\nIt's interesting to note that arrow-functions in JavaScript work similarly (i.e. they don't override \"this\" or \"arguments\", like other functions do)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1570920327.253500",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1570920818.000000"
        },
        "client_msg_id": "412c53bb-9b94-4f63-88f4-acdf56293358",
        "text": "<@UCUSW7WVD> Io didn’t support rewriting the interpreter from within itself, but as it had no keywords and has code-as-data with a single AST node type, you can easily do a lot of dynamic things that may be difficult even in languages written in themselves (such as control structures).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wb\/A=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " Io didn’t support rewriting the interpreter from within itself, but as it had no keywords and has code-as-data with a single AST node type, you can easily do a lot of dynamic things that may be difficult even in languages written in themselves (such as control structures)."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1570920799.253700",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1570921003.000000"
        },
        "client_msg_id": "c33bd5f0-009b-46a6-8c03-7582400e11bb",
        "text": "Taking on the responsibility of dealing with varied current and future machine architectures and OS conventions (calling, dynamic libraries, etc) seems like a lot of (never ending) effort that may not have much to do with what makes a language useful\/interesting unless it’s goal is to be a systems language.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "122D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Taking on the responsibility of dealing with varied current and future machine architectures and OS conventions (calling, dynamic libraries, etc) seems like a lot of (never ending) effort that may not have much to do with what makes a language useful\/interesting unless it’s goal is to be a systems language."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1570921230.254200",
        "client_msg_id": "acdc3fe4-6139-4d81-8eb2-fdbc122f2600",
        "text": "<@UCUSW7WVD> I think we can separate the problematic \"self brain surgery\" method of changing the internals of a Smalltalk image, from the benefits of a language and environment that is able to fully self-represent and self-introspect itself. I think that your \"status signalling\" criticism applies only to the former. Here's a paper, \"Bootstrapping Reflective Systems: The Case of Pharo\", describing how Pharo solves the \"self brain surgery\" problem in Smalltalk while retaining the ability to fully describe itself and evolve itself. <https:\/\/citeseerx.ist.psu.edu\/viewdoc\/download?doi=10.1.1.452.6952&amp;rep=rep1&amp;type=pdf>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4NpG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I think we can separate the problematic \"self brain surgery\" method of changing the internals of a Smalltalk image, from the benefits of a language and environment that is able to fully self-represent and self-introspect itself. I think that your \"status signalling\" criticism applies only to the former. Here's a paper, \"Bootstrapping Reflective Systems: The Case of Pharo\", describing how Pharo solves the \"self brain surgery\" problem in Smalltalk while retaining the ability to fully describe itself and evolve itself. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/citeseerx.ist.psu.edu\/viewdoc\/download?doi=10.1.1.452.6952&amp;rep=rep1&amp;type=pdf",
                                "text": "https:\/\/citeseerx.ist.psu.edu\/viewdoc\/download?doi=10.1.1.452.6952&rep=rep1&type=pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1",
                    "UC2A2ARPT"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570922910.255200",
        "client_msg_id": "b4eac961-faed-4148-95d6-4c81573aeef7",
        "text": "<@UJN1TAYEQ> I don't understand the distinction you're making. How can you change the lowest-level internals of a system without it being like brain surgery, whether self- or otherwise? There seems to be some border around what you mean by \"fully self-represent\" and \"entire system is written\", but I can't see where it is. But maybe this needs a separate thread in  <#C5U3SEW6A|linking-together>. It's not a huge disagreement that I feel a need to explore.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2WN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " I don't understand the distinction you're making. How can you change the lowest-level internals of a system without it being like brain surgery, whether self- or otherwise? There seems to be some border around what you mean by \"fully self-represent\" and \"entire system is written\", but I can't see where it is. But maybe this needs a separate thread in  "
                            },
                            {
                                "type": "channel",
                                "channel_id": "C5U3SEW6A"
                            },
                            {
                                "type": "text",
                                "text": ". It's not a huge disagreement that I feel a need to explore."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1570924824.255800",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1570927493.000000"
        },
        "client_msg_id": "f4fcecc7-8b89-430b-81be-e3c9b285bbb7",
        "text": "... Sorry that took forever and is long-winded, but those are my main projects in ... something larger than a nutshell :P\n\nI also have a \"Renderer\" for rendering basic graphics in a declarative way (which I'm using for my other projects, but it's also generally useful).\n\nAnd a \"Circuit\" simulator I'm making PURELY just to demonstrate blurring the lines between code and interaction, etc., as I've described in my previous reply above",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TTw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... Sorry that took forever and is long-winded, but those are my main projects in ... something larger than a nutshell :P\n\nI also have a \"Renderer\" for rendering basic graphics in a declarative way (which I'm using for my other projects, but it's also generally useful).\n\nAnd a \"Circuit\" simulator I'm making PURELY just to demonstrate blurring the lines between code and interaction, etc., as I've described in my previous reply above"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1570925495.256100",
        "client_msg_id": "291783bc-7787-45e7-a9dc-bdcf8651a4c6",
        "text": "In Smalltalk, if you try to refactor critical low-level parts of the system, you can easily crash the system, because the code you are refactoring is running while you are performing the refactor. In Pharo, you accomplish this by making a copy of the system, and modifying the copy. It's described in the 2014 paper I linked. This paper mentions some limitations (eg, on making changes to how SmallInteger and the boolean values work), due to the original system and the copy sharing the same VM data structures and byte code format, but there's been a lot of new work on the Pharo bootstrapping system since then that I haven't read about yet. Maybe some of these limitations have been removed. It seems plausible that there is some boundary, but I don't know where the theoretical limits are.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wz4fu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Smalltalk, if you try to refactor critical low-level parts of the system, you can easily crash the system, because the code you are refactoring is running while you are performing the refactor. In Pharo, you accomplish this by making a copy of the system, and modifying the copy. It's described in the 2014 paper I linked. This paper mentions some limitations (eg, on making changes to how SmallInteger and the boolean values work), due to the original system and the copy sharing the same VM data structures and byte code format, but there's been a lot of new work on the Pharo bootstrapping system since then that I haven't read about yet. Maybe some of these limitations have been removed. It seems plausible that there is some boundary, but I don't know where the theoretical limits are."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1570926777.256800",
        "client_msg_id": "874df664-8a6d-45a9-8639-150bf673be16",
        "text": "I now see that one of the problems being researched here is how to upgrade a running software system without rebooting it. The 2014 \"hazelnut\" bootstrapping system for Pharo that I cited above has been replaced by the \"espell\" system, which is described as \"a language runtime virtualization infrastructure\".",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "J0sOo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I now see that one of the problems being researched here is how to upgrade a running software system without rebooting it. The 2014 \"hazelnut\" bootstrapping system for Pharo that I cited above has been replaced by the \"espell\" system, which is described as \"a language runtime virtualization infrastructure\"."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1570947400.258800",
        "client_msg_id": "250E7391-790E-46CE-8673-6AF8B90A876B",
        "text": "Jonathan Blow showed up in the comments on the HN Bel post with some excellent thought-clarifying questions: <https:\/\/news.ycombinator.com\/item?id=21237636>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570947400.258800",
        "reply_count": 29,
        "reply_users_count": 9,
        "latest_reply": "1571272163.411500",
        "reply_users": [
            "UCUSW7WVD",
            "UEQ6M68H0",
            "UA14TGLTC",
            "UC2A2ARPT",
            "ULM3U6275",
            "UJN1TAYEQ",
            "UNV27TUKA",
            "UJBAJNFLK",
            "UF5PAGQQ4"
        ],
        "replies": [
            {
                "user": "UCUSW7WVD",
                "ts": "1570949506.259100"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1570955801.259400"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1570967065.259800"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1570979236.261400"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570980002.261600"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570980593.261800"
            },
            {
                "user": "ULM3U6275",
                "ts": "1570981184.263800"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570981533.264000"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1570982842.264300"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571012929.268000"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571013059.268300"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1571013138.268500"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571013409.268700"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1571018953.269900"
            },
            {
                "user": "ULM3U6275",
                "ts": "1571021756.271900"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1571022527.272100"
            },
            {
                "user": "UC2A2ARPT",
                "ts": "1571025619.277100"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1571025842.277400"
            },
            {
                "user": "UNV27TUKA",
                "ts": "1571064511.280600"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1571081940.283800"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1571082006.284000"
            },
            {
                "user": "UJN1TAYEQ",
                "ts": "1571088883.285400"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1571116481.285700"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1571122241.286400"
            },
            {
                "user": "UF5PAGQQ4",
                "ts": "1571125553.286600"
            },
            {
                "user": "ULM3U6275",
                "ts": "1571170213.360900"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1571193444.374500"
            },
            {
                "user": "ULM3U6275",
                "ts": "1571271347.410900"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1571272163.411500"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NCA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Jonathan Blow showed up in the comments on the HN Bel post with some excellent thought-clarifying questions: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/news.ycombinator.com\/item?id=21237636"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1570949506.259100",
        "client_msg_id": "2009a02b-371e-4e10-adb9-0cf6926a6fed",
        "text": "Seems like a classic case of software conservative meeting a software liberal (<https:\/\/gist.github.com\/cornchz\/3313150>). Or a big-team programmer meeting a small-team programmer. Or a shipping-software programmer meeting a sketching-prototypes programmer.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1570947400.258800",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DBHM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Seems like a classic case of software conservative meeting a software liberal ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/gist.github.com\/cornchz\/3313150"
                            },
                            {
                                "type": "text",
                                "text": "). Or a big-team programmer meeting a small-team programmer. Or a shipping-software programmer meeting a sketching-prototypes programmer."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UE0ETTCG7"
                ],
                "count": 1
            }
        ]
    }
]