[
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1745002221.698389",
        "client_msg_id": "fec65237-3569-4c47-8327-43e7aeeb9343",
        "text": "&gt; The goal should be to produce notations so concise that whole programs fit in one eye-full,\nyes. Maybe not entire programs, because of non-reducible amount of states in non-trivial programs, but yes.\n&gt; \"syntax is a view\"\nyes\n&gt; I express this belief mostly by creating s-expression-based SCNs in Lisp.\nyes. Not that many 'usual' text-based things are hard to cram into s-expressions.\nTrivial things are expressible with no extra work, but few extra parens.\nLarger but manageable things can be just string arg (that racket-algol example, or infamous SQL strings).\nBut there is always just \"flat s-expr with hundred args\" approach, especially when you can express DSL's literal tokens in your fav LISP's literals: chars, strings, symbols, numbers, bools, keywords, vecs, lists, maps, sets.\nFor example, clojure's `(let [a 1] a)` is a DSL too, since in the rest of the language same level tokens have independent scope: in `(+ x y)` - `y` does not have `x` in scope.\nBut replace `+` with `let` and `x` with bindings vector, and suddenly `y` has in scope whatever is on the left:\n`(+ x y)`  -&gt; `(let bindings y)` -&gt; `(let [y 1] y)`\n(ofc every macro is a DSL).\nI guess my point is you can ride s-expr macros pretty far even without reaching for multiple compilers, especially if DSLs are tiny.\n\nre: IDE support - this seems relevant: <https:\/\/www.jetbrains.com\/help\/idea\/using-language-injections.html#language_annotation>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0343f70ca57",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-07-04\/7377091009748_d0343f70ca57c18eeb41_72.png",
            "first_name": "misha",
            "real_name": "misha",
            "display_name": "misha",
            "team": "T5TCAFTA9",
            "name": "misha.akovantsev",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1742096636.964039",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wzbzx",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The goal should be to produce notations so concise that whole programs fit in one eye-full,"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yes. Maybe not entire programs, because of non-reducible amount of states in non-trivial programs, but yes.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"syntax is a view\""
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yes\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I express this belief mostly by creating s-expression-based SCNs in Lisp."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yes. Not that many 'usual' text-based things are hard to cram into s-expressions.\nTrivial things are expressible with no extra work, but few extra parens.\nLarger but manageable things can be just string arg (that racket-algol example, or infamous SQL strings).\nBut there is always just \"flat s-expr with hundred args\" approach, especially when you can express DSL's literal tokens in your fav LISP's literals: chars, strings, symbols, numbers, bools, keywords, vecs, lists, maps, sets.\nFor example, clojure's "
                            },
                            {
                                "type": "text",
                                "text": "(let [a 1] a)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is a DSL too, since in the rest of the language same level tokens have independent scope: in "
                            },
                            {
                                "type": "text",
                                "text": "(+ x y)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - "
                            },
                            {
                                "type": "text",
                                "text": "y",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " does not have "
                            },
                            {
                                "type": "text",
                                "text": "x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in scope.\nBut replace "
                            },
                            {
                                "type": "text",
                                "text": "+",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with "
                            },
                            {
                                "type": "text",
                                "text": "let",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with bindings vector, and suddenly "
                            },
                            {
                                "type": "text",
                                "text": "y",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " has in scope whatever is on the left:\n"
                            },
                            {
                                "type": "text",
                                "text": "(+ x y)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  -> "
                            },
                            {
                                "type": "text",
                                "text": "(let bindings y)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " -> "
                            },
                            {
                                "type": "text",
                                "text": "(let [y 1] y)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n(ofc every macro is a DSL).\nI guess my point is you can ride s-expr macros pretty far even without reaching for multiple compilers, especially if DSLs are tiny.\n\nre: IDE support - this seems relevant: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.jetbrains.com\/help\/idea\/using-language-injections.html#language_annotation"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]