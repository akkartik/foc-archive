[
    {
        "user": "U5TCAFTD3",
        "type": "message",
        "ts": "1551526031.023200",
        "client_msg_id": "5d77be06-2efa-4857-826c-a84198a00046",
        "text": "I think <@U6KQ2S410> and <@UEF95M2RH> would have things to add here. Jonathan on adding the database to code, and migrations, and Michael on making code data structure operations fast by using optimizations from the db literature",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7c31dc735c6c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-09-11\/433781465829_7c31dc735c6c1257fe1f_72.jpg",
            "first_name": "Steve",
            "real_name": "Steve Krouse",
            "display_name": "stevekrouse",
            "team": "T5TCAFTA9",
            "name": "stevekrouse",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551508329.022600",
        "parent_user_id": "UCKRZS3DZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yqm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think "
                            },
                            {
                                "type": "user",
                                "user_id": "U6KQ2S410"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "user",
                                "user_id": "UEF95M2RH"
                            },
                            {
                                "type": "text",
                                "text": " would have things to add here. Jonathan on adding the database to code, and migrations, and Michael on making code data structure operations fast by using optimizations from the db literature"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAL7940NM",
        "type": "message",
        "ts": "1551526452.023400",
        "client_msg_id": "bfee5a7a-70f2-4787-b2f5-6db3b8981074",
        "text": "You mean like programming your business logic against Abstract Data Types (<https:\/\/en.m.wikipedia.org\/wiki\/Abstract_data_type>) and choosing appropriate implementations (dbs \/ data structures) afterwards?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43873346f949",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-13\/399377633206_43873346f949174e340e_72.jpg",
            "first_name": "Felix",
            "real_name": "Felix Kohlgrüber",
            "display_name": "Felix Kohlgrüber",
            "team": "T5TCAFTA9",
            "name": "felix.kohlgrueber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551508329.022600",
        "parent_user_id": "UCKRZS3DZ",
        "attachments": [
            {
                "title": "Abstract data type",
                "title_link": "https:\/\/en.m.wikipedia.org\/wiki\/Abstract_data_type",
                "from_url": "https:\/\/en.m.wikipedia.org\/wiki\/Abstract_data_type",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/",
                "text": "In computer science, an abstract data type (ADT) is a mathematical model for data types, where a data type is defined by its behavior (semantics) from the point of view of a user of the data, specifically in terms of possible values, possible operations on data of this type, and the behavior of these operations. This contrasts with data structures, which are concrete representations of data, and are the point of view of an implementer, not a user.\nFormally, an ADT may be defined as a \"class of objects whose logical behavior is defined by a set of values and a set of operations\"; this is analogous to an algebraic structure in mathematics. What is meant by \"behavior\" varies by author, with the two main types of formal specifications for behavior being axiomatic (algebraic) specification and an abstract model; these correspond to axiomatic semantics and operational semantics of an abstract machine, respectively. Some authors also include the computational complexity (\"cost\"), both in terms of time (for computing operations) and space (for representing values). In practice many common data types are not ADTs, as the abstraction is not perfect, and users must be aware of issues like arithmetic overflow that are due to the representation. For example, integers are often stored as fixed width values (32-bit or 64-bit binary numbers), and thus experience integer overflow if the maximum value is exceeded.\nADTs are a theoretical concept in computer science, used in the design and analysis of algorithms, data structures, and software systems, and do not correspond to specific features of computer languages—mainstream computer languages do not directly support formally specified ADTs. However, various language features correspond to certain aspects of ADTs, and are easily confused with ADTs proper; these include abstract types, opaque data types, protocols, and design by contract. ADTs were first proposed by Barbara Liskov and Stephen N. Zilles in 1974, as part of the development of the CLU language.",
                "fallback": "wikipedia: Abstract data type",
                "service_icon": "https:\/\/cfr.slack-edge.com\/bfaba\/img\/unfurl_icons\/wikipedia.png",
                "id": 1,
                "original_url": "https:\/\/en.m.wikipedia.org\/wiki\/Abstract_data_type"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vr+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You mean like programming your business logic against Abstract Data Types ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.m.wikipedia.org\/wiki\/Abstract_data_type"
                            },
                            {
                                "type": "text",
                                "text": ") and choosing appropriate implementations (dbs \/ data structures) afterwards?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCKRZS3DZ",
        "type": "message",
        "ts": "1551527622.023700",
        "client_msg_id": "0f48b391-40d5-4cf9-9fa9-85defc2ac610",
        "text": "Imagine that you work with job queue, and write business logic around it.\n\nThere might be three different configurations of the same app:\n\n1) in-memory queue\n2) queue via table in postgresql\n3) queue in redis\n\nYou can use any of those without touching business logic that you've written, simply by changing configuration.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "222a2870915d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-15\/861537614034_222a2870915d24ec10cc_72.jpg",
            "first_name": "Vladimir",
            "real_name": "Vladimir Gordeev",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gordeev.vladimir.v",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551508329.022600",
        "parent_user_id": "UCKRZS3DZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CSN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Imagine that you work with job queue, and write business logic around it.\n\nThere might be three different configurations of the same app:\n\n1) in-memory queue\n2) queue via table in postgresql\n3) queue in redis\n\nYou can use any of those without touching business logic that you've written, simply by changing configuration."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1551553463.032700",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1551563330.000000"
        },
        "client_msg_id": "2e620533-5596-4a9f-bd11-b6c10f349d68",
        "text": "I recently added some thoughts to a \"Christopher Alexander\" channel. But the channel is invite-only (oops!), so here it all is again in a thread (see replies) where it is discoverable.\n\n(Note: C.A. is the source of software Design Patterns, and inspired a whole software \"Patterns\" movement. This largely failed, but Agile came (in part) out of the aftermath)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551553463.032700",
        "reply_count": 19,
        "reply_users_count": 6,
        "latest_reply": "1564757907.168000",
        "reply_users": [
            "UAVCC2X70",
            "UA14TGLTC",
            "UCUSW7WVD",
            "UG9NE2W0Z",
            "UFV8P4472",
            "UC21F8Q48"
        ],
        "replies": [
            {
                "user": "UAVCC2X70",
                "ts": "1551562513.093000"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1551562761.094200"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1551562786.094500"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1551562815.094700"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1551562846.094900"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1551562877.095100"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1551562911.095300"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1551578356.097700"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1551650845.122000"
            },
            {
                "user": "UG9NE2W0Z",
                "ts": "1551802187.202500"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1551850165.212400"
            },
            {
                "user": "UFV8P4472",
                "ts": "1551980889.218500"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1552008329.220400"
            },
            {
                "user": "UC21F8Q48",
                "ts": "1552338298.277000"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1552342755.277600"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1552536742.314500"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1564590351.113400"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1564756904.167800"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1564757907.168000"
            }
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1551562790.000000",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e9eo0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I recently added some thoughts to a \"Christopher Alexander\" channel. But the channel is invite-only (oops!), so here it all is again in a thread (see replies) where it is discoverable.\n\n(Note: C.A. is the source of software Design Patterns, and inspired a whole software \"Patterns\" movement. This largely failed, but Agile came (in part) out of the aftermath)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "clap",
                "users": [
                    "UAJ9DV971",
                    "UA14TGLTC",
                    "UCKRZS3DZ",
                    "UCUSW7WVD"
                ],
                "count": 4
            },
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1551561954.091000",
        "client_msg_id": "52882082-dd4c-4401-a59f-018352438f55",
        "text": "Is there a specific comment you are referring to <@UCKRZS3DZ> Most recently I tweeted a bit about how DBs shouldn't be a separate service: <https:\/\/twitter.com\/chatur_shalabh\/status\/1090677577918775296>. In general I agree with your idea. In theory switching out a queue implementation is possible with class or module based abstraction but the 'coupling' of the higher level code is still deeper. E.g. the code that uses a simple list looks very different from something that uses a class that abstracts away writes to a queue service. Can we make it look like the simple case, but separately (in a separate layer?) map the higher level operations to the next lower level details, such as list X is local, list Y is a remote queue implemented here, etc.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551508329.022600",
        "parent_user_id": "UCKRZS3DZ",
        "attachments": [
            {
                "fallback": "<https:\/\/twitter.com\/chatur_shalabh|@chatur_shalabh>: <https:\/\/twitter.com\/brianhempel|@brianhempel> We need persistence, yes, but this is a system feature - does it need to be the job of an encapsulated sub-system? Consider the consistency needed outside the DB - between different copies of essentially the *same object* across the whole system - client devices, app servers, 1\/",
                "ts": 1548872773,
                "author_name": "Shalabh Chaturvedi",
                "author_link": "https:\/\/twitter.com\/chatur_shalabh\/status\/1090677577918775296",
                "author_icon": "https:\/\/pbs.twimg.com\/profile_images\/867701642149363713\/azQekfoT_normal.jpg",
                "author_subname": "@chatur_shalabh",
                "text": "<https:\/\/twitter.com\/brianhempel|@brianhempel> We need persistence, yes, but this is a system feature - does it need to be the job of an encapsulated sub-system? Consider the consistency needed outside the DB - between different copies of essentially the *same object* across the whole system - client devices, app servers, 1\/",
                "service_name": "twitter",
                "service_url": "https:\/\/twitter.com\/",
                "from_url": "https:\/\/twitter.com\/chatur_shalabh\/status\/1090677577918775296",
                "id": 1,
                "original_url": "https:\/\/twitter.com\/chatur_shalabh\/status\/1090677577918775296",
                "footer": "Twitter",
                "footer_icon": "https:\/\/a.slack-edge.com\/80588\/img\/services\/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o19",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is there a specific comment you are referring to "
                            },
                            {
                                "type": "user",
                                "user_id": "UCKRZS3DZ"
                            },
                            {
                                "type": "text",
                                "text": " Most recently I tweeted a bit about how DBs shouldn't be a separate service: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/twitter.com\/chatur_shalabh\/status\/1090677577918775296"
                            },
                            {
                                "type": "text",
                                "text": ". In general I agree with your idea. In theory switching out a queue implementation is possible with class or module based abstraction but the 'coupling' of the higher level code is still deeper. E.g. the code that uses a simple list looks very different from something that uses a class that abstracts away writes to a queue service. Can we make it look like the simple case, but separately (in a separate layer?) map the higher level operations to the next lower level details, such as list X is local, list Y is a remote queue implemented here, etc."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1551562513.093000",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1551563019.000000"
        },
        "client_msg_id": "b59be7d3-aaa2-4042-9069-562642cd5f8b",
        "text": "One thing that's great about C.A.'s work \/ philosophies, is not just that it ties mechanism &amp; structure to things like life and purpose and well-being, but that the links are more than just nice ideas; they are verifiable, and consistent. There is a very real link between technical goodness and moral goodness. The properties that make living things \"alive\" work the same way in built things as well. Etc.\n\nThese \"real connections\" (I'll call them that) between seemingly unrelated areas &amp; concerns, show up everywhere! It's why I've taken sudden interest other areas where this crops up: built architecture, urban planning, interior design, etc. What I've noticed is that much of what is wrong\/missing in software, is actually part of a larger problem that affects *many* facets of the modern world. And, by finding solutions and patterns in other areas, we can improve software (or use software to improve the world) in similar ways.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551553463.032700",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xit",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One thing that's great about C.A.'s work \/ philosophies, is not just that it ties mechanism & structure to things like life and purpose and well-being, but that the links are more than just nice ideas; they are verifiable, and consistent. There is a very real link between technical goodness and moral goodness. The properties that make living things \"alive\" work the same way in built things as well. Etc.\n\nThese \"real connections\" (I'll call them that) between seemingly unrelated areas & concerns, show up everywhere! It's why I've taken sudden interest other areas where this crops up: built architecture, urban planning, interior design, etc. What I've noticed is that much of what is wrong\/missing in software, is actually part of a larger problem that affects "
                            },
                            {
                                "type": "text",
                                "text": "many",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " facets of the modern world. And, by finding solutions and patterns in other areas, we can improve software (or use software to improve the world) in similar ways."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1551562761.094200",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1551563861.000000"
        },
        "client_msg_id": "381658c9-27af-4122-82cd-7513ddb201cd",
        "text": "An example principle is that the best way to create a \"good\" \"place\" is by fostering an open, communal, trusting, and humane environment, and not by forcing, restricting, and securing. (\"Good\" can mean safe, productive, adaptable, etc. \"Place\" can be a home, community, workplace, or even software code).\n\nJane Jacobs (an urban planner) noted this: fences, private corridors, locked doors, people keeping \"safely\" to themselves, increasing police presence ... these things *raise* crime and isolation and danger. Openness, communal exchange, visibility, etc. create more security and enhance life. Part of that is related to people feeling like they \"own\" a place psychologically and emotionally, which creates a community that automatically keeps itself safe and comfortable. Etc.\n\nThe corralary with software code is that you can NOT create \"better\" code by relying on mechanisms that lock down and restrict. Better off creating an environment to encourages openness and trust; code that is \"habitable\" and a happy place to \"live\" in. After all, good software is about understanding the human model and making THAT as good as it can be, with the mechanism only in service to that end.\n\nLinda Rising explores that connection between this \"Quality without a name\" (as C.A. calls it) in the real world, and in software:\n\n<https:\/\/www.researchgate.net\/publication\/265427581_The_Road_Christopher_Alexander_and_Good_Software_Design>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551553463.032700",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0orz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An example principle is that the best way to create a \"good\" \"place\" is by fostering an open, communal, trusting, and humane environment, and not by forcing, restricting, and securing. (\"Good\" can mean safe, productive, adaptable, etc. \"Place\" can be a home, community, workplace, or even software code).\n\nJane Jacobs (an urban planner) noted this: fences, private corridors, locked doors, people keeping \"safely\" to themselves, increasing police presence ... these things "
                            },
                            {
                                "type": "text",
                                "text": "raise",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " crime and isolation and danger. Openness, communal exchange, visibility, etc. create more security and enhance life. Part of that is related to people feeling like they \"own\" a place psychologically and emotionally, which creates a community that automatically keeps itself safe and comfortable. Etc.\n\nThe corralary with software code is that you can NOT create \"better\" code by relying on mechanisms that lock down and restrict. Better off creating an environment to encourages openness and trust; code that is \"habitable\" and a happy place to \"live\" in. After all, good software is about understanding the human model and making THAT as good as it can be, with the mechanism only in service to that end.\n\nLinda Rising explores that connection between this \"Quality without a name\" (as C.A. calls it) in the real world, and in software:\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.researchgate.net\/publication\/265427581_The_Road_Christopher_Alexander_and_Good_Software_Design"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1551562786.094500",
        "client_msg_id": "b69f561c-b2c9-4fd3-8d7b-1399ee984309",
        "text": "On the topic of (what C.A. calls) \"Living Structure\" and bootstrapping:\n\nI (and others here) have determined that part of the problem with the way most software is created (and its usability) is that it's very rigid and locked down. I see common themes of code being made of actual structure that can be manipulated directly (versus text); removing the separation between code &amp; data, or between the thing being created and the tool used to create it, or programming language and program, or language and tool\/UI.\n\nC.A. describes the modern way of building and designing things as trying to find a good configuration (e.g. a blueprint, or model, or business requirements), and then creating the thing from that rigid form. The result is never \"living structure\" (e.g. cannot be properly adapted to unique contexts and needs, and cannot evolve as those things change). In contrast, he suggests a process of \"unfolding wholeness\", where a thing evolves step by step directly in the context where it is to be used or occupied. It is \"whole\" at each step, and differentiations are introduced gradually to fit the context. This is in stark contrast to mass production of modular units, for example.\n\nApplied to software, this means that the tool, or the model, or the design process, or whatever, must evolve with the software (perhaps even with the user), otherwise you are left with something rigid that cannot perfectly fit the context. Essentially, I'm drawing a parallel between \"unfolding wholeness\" (aka structure preserving transformations) and bootstrapping. And not just bootstrapping a language, but also a tool, a UI, ... everything.\n\n*All* things that can be called \"living structure\" exhibit such properties. So, the ability for software to be created and manipulated as \"unfolding wholeness\" through structure preserving transformations (e.g. extreme bootstrapping at all levels) ... This is key to creating the \"living structure\" that software can be. Both as LS itself, and also in that it can be used to create LS -- that is, people can create whatever they want, however they want, have it for the context uniquely ... and that also has strong implications for changing the way that the modern world functions as a whole. So the potential for living structure is enormous ... And recursive!\n\nC.A. identified that recursiveness, too. In all living structure, there are things called \"centers\", which are essentially defined as connections of other centers that form a stronger whole center together. The livingness (or wholeness) of any center is recursively dependent on how alive or whole it's inner centers are. Living structure, is made of living structure. And living structure can only be created by\/from other living structure.\n\nSo back to programming, this means that in order for code to be living structure, then even the tools used to make the code need to be living structure. And if you want software that can be used to create \"living structure\" in the world, then that software itself must also be living structure.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551553463.032700",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YFl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On the topic of (what C.A. calls) \"Living Structure\" and bootstrapping:\n\nI (and others here) have determined that part of the problem with the way most software is created (and its usability) is that it's very rigid and locked down. I see common themes of code being made of actual structure that can be manipulated directly (versus text); removing the separation between code & data, or between the thing being created and the tool used to create it, or programming language and program, or language and tool\/UI.\n\nC.A. describes the modern way of building and designing things as trying to find a good configuration (e.g. a blueprint, or model, or business requirements), and then creating the thing from that rigid form. The result is never \"living structure\" (e.g. cannot be properly adapted to unique contexts and needs, and cannot evolve as those things change). In contrast, he suggests a process of \"unfolding wholeness\", where a thing evolves step by step directly in the context where it is to be used or occupied. It is \"whole\" at each step, and differentiations are introduced gradually to fit the context. This is in stark contrast to mass production of modular units, for example.\n\nApplied to software, this means that the tool, or the model, or the design process, or whatever, must evolve with the software (perhaps even with the user), otherwise you are left with something rigid that cannot perfectly fit the context. Essentially, I'm drawing a parallel between \"unfolding wholeness\" (aka structure preserving transformations) and bootstrapping. And not just bootstrapping a language, but also a tool, a UI, ... everything.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "All",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " things that can be called \"living structure\" exhibit such properties. So, the ability for software to be created and manipulated as \"unfolding wholeness\" through structure preserving transformations (e.g. extreme bootstrapping at all levels) ... This is key to creating the \"living structure\" that software can be. Both as LS itself, and also in that it can be used to create LS -- that is, people can create whatever they want, however they want, have it for the context uniquely ... and that also has strong implications for changing the way that the modern world functions as a whole. So the potential for living structure is enormous ... And recursive!\n\nC.A. identified that recursiveness, too. In all living structure, there are things called \"centers\", which are essentially defined as connections of other centers that form a stronger whole center together. The livingness (or wholeness) of any center is recursively dependent on how alive or whole it's inner centers are. Living structure, is made of living structure. And living structure can only be created by\/from other living structure.\n\nSo back to programming, this means that in order for code to be living structure, then even the tools used to make the code need to be living structure. And if you want software that can be used to create \"living structure\" in the world, then that software itself must also be living structure."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UFV8P4472"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1551562815.094700",
        "client_msg_id": "5984c696-1ec0-4f1a-8685-8eb6f3ed0131",
        "text": "(continuing from previous)\n\nNow this is all true of literal living structure -- living organisms. There are multiple levels of wholeness \/ centers: systems, organs, all the way down to cells. At every level, these are said to be living and whole, and can only be so because they are made of smaller living wholes. You are not your cells, but each individual cell can be considered to be \"alive\" and whole. But within the cell, there are whole things, which -- through an unfolding (iterative) process -- produce living structure (both because they constitute it, and perform processes that create it, and also cause it to function). Think of it: everything the body needs to function, or grow, or adapt, or generate new life ... It's all part of the body itself! The same is true at the cellular level. The cell contains all the mechanisms and processes it needs to bootstrap itself.\n\nThere is debate about what does or does not count as \"life\" -- particularly, are viruses \"alive\"? Isn't it fascinating that the determining factor is that they do not contain everything they need to be self-sufficient \/ self-generating? Unlike \"living\" cells, they are not \"whole\", because they rely on external means to make them \"alive\". ... And yet, they do manage to do things, and regenerate themselves; isn't that alive? ... Well, it's the living structure in other cells that causes that to happen. They are not whole, and not wholely alive. At the least, it's fair to say they contain (or are themselves) *bits* of living structure.\n\nPrograms are like viruses. They contain\/are the \"code\" (DNA) *for* a process, but they do not themselves contain the machinery for running, duplicating, and modifying that code. You need an editor, a processor, a compiler (ribosomes, enzymes) to do those things.\n\nAnd those things (complier, editor, etc.) are not alive either, because they also rely on others tools to be created or modified.\n\nSo what would it mean for code \/ software to be \"alive\" or counted as \"living structure\" -- and why does it matter?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551553463.032700",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "liXmo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(continuing from previous)\n\nNow this is all true of literal living structure -- living organisms. There are multiple levels of wholeness \/ centers: systems, organs, all the way down to cells. At every level, these are said to be living and whole, and can only be so because they are made of smaller living wholes. You are not your cells, but each individual cell can be considered to be \"alive\" and whole. But within the cell, there are whole things, which -- through an unfolding (iterative) process -- produce living structure (both because they constitute it, and perform processes that create it, and also cause it to function). Think of it: everything the body needs to function, or grow, or adapt, or generate new life ... It's all part of the body itself! The same is true at the cellular level. The cell contains all the mechanisms and processes it needs to bootstrap itself.\n\nThere is debate about what does or does not count as \"life\" -- particularly, are viruses \"alive\"? Isn't it fascinating that the determining factor is that they do not contain everything they need to be self-sufficient \/ self-generating? Unlike \"living\" cells, they are not \"whole\", because they rely on external means to make them \"alive\". ... And yet, they do manage to do things, and regenerate themselves; isn't that alive? ... Well, it's the living structure in other cells that causes that to happen. They are not whole, and not wholely alive. At the least, it's fair to say they contain (or are themselves) "
                            },
                            {
                                "type": "text",
                                "text": "bits",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of living structure.\n\nPrograms are like viruses. They contain\/are the \"code\" (DNA) "
                            },
                            {
                                "type": "text",
                                "text": "for",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a process, but they do not themselves contain the machinery for running, duplicating, and modifying that code. You need an editor, a processor, a compiler (ribosomes, enzymes) to do those things.\n\nAnd those things (complier, editor, etc.) are not alive either, because they also rely on others tools to be created or modified.\n\nSo what would it mean for code \/ software to be \"alive\" or counted as \"living structure\" -- and why does it matter?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1551562846.094900",
        "client_msg_id": "b62b298e-e027-456f-90a3-1cf457cfc04d",
        "text": "(continued from previous)\n\n... It would mean that a program (or other software entity) contains all the mechanism needed to edit, view, run, and replicate (e.g. generate or serialize) itself.\n\nFor any software artifact (e.g. a game or a drawing or a document), you are limited by what some tool let's you do. You can either accept that, or pick a different tool, or painstakingly invent a new tool ... which still leaves you stuck as before, albeit with different features.\n\nBut if the thing is its own editor and modeler and viewer, etc., then you can use it to change itself, and adapt it to fit your needs. As you make changes to the tool-in-the-thing, you also gain the ability to use the new changes to keep making more changes. There you have unfolding wholeness, and structure-preserving transformations.\n\nThe idea is that there then becomes no excuse to not have the most (or at least, reasonably) ideal tools, visualization, structure, etc. for whatever.\n\nNow the point is not necessarily for some software artifact to be fully moldable (cool, but so what?), but to make that power accessible so that software can be used in new meaningful ways, perhaps to change the world (e.g. ability to create the world we want to live in ... technologically, but also socially, mentally, etc.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551553463.032700",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "j\/Bv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(continued from previous)\n\n... It would mean that a program (or other software entity) contains all the mechanism needed to edit, view, run, and replicate (e.g. generate or serialize) itself.\n\nFor any software artifact (e.g. a game or a drawing or a document), you are limited by what some tool let's you do. You can either accept that, or pick a different tool, or painstakingly invent a new tool ... which still leaves you stuck as before, albeit with different features.\n\nBut if the thing is its own editor and modeler and viewer, etc., then you can use it to change itself, and adapt it to fit your needs. As you make changes to the tool-in-the-thing, you also gain the ability to use the new changes to keep making more changes. There you have unfolding wholeness, and structure-preserving transformations.\n\nThe idea is that there then becomes no excuse to not have the most (or at least, reasonably) ideal tools, visualization, structure, etc. for whatever.\n\nNow the point is not necessarily for some software artifact to be fully moldable (cool, but so what?), but to make that power accessible so that software can be used in new meaningful ways, perhaps to change the world (e.g. ability to create the world we want to live in ... technologically, but also socially, mentally, etc.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1551562877.095100",
        "client_msg_id": "5e265f83-65b8-4106-8762-067a934c5c19",
        "text": "What all that in mind, have a look at:\n\n* His address at OOPSLA '97: <https:\/\/youtu.be\/98LdFA-_zfA>\n\n* This (very cheesey, but good) video (especially how it correlates to software at 11:15 - 14:45): <https:\/\/youtu.be\/NAjz0INs3Lc>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551553463.032700",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R38x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What all that in mind, have a look at:\n\n* His address at OOPSLA '97: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/youtu.be\/98LdFA-_zfA"
                            },
                            {
                                "type": "text",
                                "text": "\n\n* This (very cheesey, but good) video (especially how it correlates to software at 11:15 - 14:45): "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/youtu.be\/NAjz0INs3Lc"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1551562911.095300",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1551564334.000000"
        },
        "client_msg_id": "f05844d5-a1e7-4668-beb0-0e016f858e76",
        "text": "More on \"patterns\":\n\nWhat the software world calls \"Design Patterns\" are directly derived from C.A.'s \"Pattern Languages\". However, they completely missed the boat as to what patterns are about and where the focus should be.\n\n\"Spaces for the soul\" from 14:45 - 15:35 (second link in previous post) highlights the overlap and the difference: We got the \"solving common architectural problems\" part, but missed the part about those \"architectural problems\" being about creating a structure or environment that best serves it's users -- it's not about the physical structure, but the spaces *between* the walls, and letting the patterns of events and interactions of it's occupants be what shapes it -- because that *is* the architecture (e.g. a place to gather, a place to eat, a place to work -- asking what kind of \"place to _\" would you like to live in, and then building it). It's not about the structure, the structure is just an outline of the important stuff happening in that space!\n\nAnd you might say \"So what?\" that DPs and PLs don't match. The fact is that it didn't start that way: There was a whole \"patterns\" movement on software with that intent, the remainder of which has survived as \"The Hillside Group\", which has been putting on PLOP (PLs of programming) conferences since then, which has more or less succeeded OOPSLA.\n\nSo for example, some of us are interested in visual representations for software (as opposed to textual code). What if that meant a great way to visualize the interactions that I'd like to be able to perform as an end user? That could make software much easier to understand on both sides of the fence, and put that power in more people's hands.\n\nSo imagine such a tool, and imagine a growing practice of identifying recurring patterns of events that \"work\" for creating good software -- \"good\" in the ways that matter. That's what \"patterns\" were about, and could very well be the future of software design.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551553463.032700",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hMR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "More on \"patterns\":\n\nWhat the software world calls \"Design Patterns\" are directly derived from C.A.'s \"Pattern Languages\". However, they completely missed the boat as to what patterns are about and where the focus should be.\n\n\"Spaces for the soul\" from 14:45 - 15:35 (second link in previous post) highlights the overlap and the difference: We got the \"solving common architectural problems\" part, but missed the part about those \"architectural problems\" being about creating a structure or environment that best serves it's users -- it's not about the physical structure, but the spaces "
                            },
                            {
                                "type": "text",
                                "text": "between",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the walls, and letting the patterns of events and interactions of it's occupants be what shapes it -- because that "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the architecture (e.g. a place to gather, a place to eat, a place to work -- asking what kind of \"place to _\" would you like to live in, and then building it). It's not about the structure, the structure is just an outline of the important stuff happening in that space!\n\nAnd you might say \"So what?\" that DPs and PLs don't match. The fact is that it didn't start that way: There was a whole \"patterns\" movement on software with that intent, the remainder of which has survived as \"The Hillside Group\", which has been putting on PLOP (PLs of programming) conferences since then, which has more or less succeeded OOPSLA.\n\nSo for example, some of us are interested in visual representations for software (as opposed to textual code). What if that meant a great way to visualize the interactions that I'd like to be able to perform as an end user? That could make software much easier to understand on both sides of the fence, and put that power in more people's hands.\n\nSo imagine such a tool, and imagine a growing practice of identifying recurring patterns of events that \"work\" for creating good software -- \"good\" in the ways that matter. That's what \"patterns\" were about, and could very well be the future of software design."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1551578356.097700",
        "client_msg_id": "06b2e08b-1274-4a4b-9d0f-396719549976",
        "text": "I was most reminded of Christopher Alexander when traveling in Romania.  The Transylvanian Saxon villages conform quite perfectly to the rolling hilly landscape – like a well adapted organism.  A road always follows the river.  Houses are cells lining this capillary, all oriented in the same way, with a uniform layout of rooms, garden, and field extending up the hill out the back following the function of domestic labor.  Every morning the cows come down the road, every evening they head back up to their respective houses, etc.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1551553463.032700",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OV+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was most reminded of Christopher Alexander when traveling in Romania.  The Transylvanian Saxon villages conform quite perfectly to the rolling hilly landscape – like a well adapted organism.  A road always follows the river.  Houses are cells lining this capillary, all oriented in the same way, with a uniform layout of rooms, garden, and field extending up the hill out the back following the function of domestic labor.  Every morning the cows come down the road, every evening they head back up to their respective houses, etc."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]