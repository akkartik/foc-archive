[
    {
        "user": "U013ZLJARC7",
        "type": "message",
        "ts": "1660720438.081409",
        "client_msg_id": "6d08a63a-6d96-4a15-9634-395e971550f5",
        "text": "<@U02028JHX37> it's mostly a non-problem, tbh. One common thing in these sorts of environments is just interactively changing the shape of the data by evaluating a line or two of code interactively. If it's the kind of thing one might need to do again later, the code gets saved off to the side in a comment. In this way, the admin interface to your program is the code itself until you actually want a separate tool for whatever reason.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8ea58fc41bd6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-10-13\/6057269405632_8ea58fc41bd6baa7dda6_72.png",
            "first_name": "",
            "real_name": "Jack Rusher",
            "display_name": "Jack Rusher",
            "team": "T5TCAFTA9",
            "name": "jack529",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1659731101.023949",
        "parent_user_id": "UAJKEBGP8",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IrSvB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U02028JHX37"
                            },
                            {
                                "type": "text",
                                "text": " it's mostly a non-problem, tbh. One common thing in these sorts of environments is just interactively changing the shape of the data by evaluating a line or two of code interactively. If it's the kind of thing one might need to do again later, the code gets saved off to the side in a comment. In this way, the admin interface to your program is the code itself until you actually want a separate tool for whatever reason."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1660728132.135439",
        "client_msg_id": "733aebed-6ee2-4c0e-a091-9fd7827d2798",
        "text": "The classic paper on state machines for Software is Harel’s.  The classic problem of state machines is “the state explosion problem”. Harel’s StateCharts takes care of that problem. My reading of the original <https:\/\/guitarvydas.github.io\/2020\/12\/09\/StateCharts.html|StateChart Paper>  (<@U03E4LY27FS> et al).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1660664383.942219",
        "parent_user_id": "U03LMRE6MQE",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "62m6g",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The classic paper on state machines for Software is Harel’s.  The classic problem of state machines is “the state explosion problem”. Harel’s StateCharts takes care of that problem. My reading of the original "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/guitarvydas.github.io\/2020\/12\/09\/StateCharts.html",
                                "text": "StateChart Paper"
                            },
                            {
                                "type": "text",
                                "text": "  ("
                            },
                            {
                                "type": "user",
                                "user_id": "U03E4LY27FS"
                            },
                            {
                                "type": "text",
                                "text": " et al)."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1660730539.855559",
        "client_msg_id": "192d0966-5f8e-46ee-8484-d441f35722bc",
        "text": "@personaldynamicmedia\n&gt; I’m not sure I fully understand how you classified each of those languages, especially Scheme and Smalltalk,\n@jackrusher\n&gt; The two lists of languages don’t make any sense to me. Can you expand on how you think Smalltalk is more of a compiler appeasement language relative to Self?\n*observation*: Classes are but optimizations of Prototypes.\n\n*further*...\n\n*observation*: Inheritance is backwards to what we want.  A unit of code should be understandable in a stand-alone manner.  A “child” should not affect a “parent’s” unit of code.  Instancing a “child” from a “parent” class should - in no way - alter the behaviour of the parent class.  A child must not override methods of a parent.  *theory*: delegation, not overriding.\n*observation*: Inheritance (of any kind, prototype inheritance or class-based inheritance) is simply DRY (Don’t Repeat Yourself).  A good editor should do inheritance automatically without putting the burden on Programmers (see, also, Lisp macros, Paul Bassett’s [Framing Software Reuse](<https:\/\/www.amazon.ca\/Framing-Software-Reuse-Lessons-World\/dp\/013327859X> ))\n*observation* DRY is of 2 kinds: (1) semantic (Design) reuse, and, (2) code reuse\n*observation* Smalltalkers tell me that inheritance for (2) code reuse is bad.\n*observation* Harel StateCharts conquer the “state explosion problem” by using delegation and encapsulation.  Harel StateCharts use delegation instead of inheritance.  My take on the original <https:\/\/guitarvydas.github.io\/2020\/12\/09\/StateCharts.html|StateChart paper>\n*observation* Sector Lisp - I thought that I hated FP, but Sector Lisp convinced me that FP can be beautiful and small.  Why is Sector Lisp many, many orders of magnitude smaller than other Programming Languages and Operating Systems?  *theory*: Sector Lisp stays within the “sweet spot” of the FP paradigm and doesn’t try to be an all-in-one solution to every programming problem.\n*observation* Sector Lisp’s Garbage Collector (invented by Tunney) is 40 bytes.  SIC: bytes, not K, not M, not G, not T. <https:\/\/guitarvydas.github.io\/2022\/01\/13\/GC-in-SectorLisp.html|My take on Sector Lisp GC>\n*theory* Sector Lisp’s smallness cannot be due only to Assembler Parlour Tricks.  Something deeper must be involved.\n*theory* We need languages that plumb “build and forget” solutions.  Plumbing ≣ composition.  UNIX pipelines are an example of this.  Surely, we can do better.\n*observation* Functions employ LIFOs, UNIX pipelines employ FIFOs.\n*observation* Functions calling functions cannot be pipelines (LIFO vs FIFO)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1659731101.023949",
        "parent_user_id": "UAJKEBGP8",
        "attachments": [
            {
                "from_url": "https:\/\/guitarvydas.github.io\/2022\/01\/13\/GC-in-SectorLisp.html",
                "ts": 1642032000,
                "id": 1,
                "original_url": "https:\/\/guitarvydas.github.io\/2022\/01\/13\/GC-in-SectorLisp.html",
                "fallback": "Computing Simplicity: GC in SectorLisp",
                "text": "Description of the behaviour of GC in SectorLisp.",
                "title": "GC in SectorLisp",
                "title_link": "https:\/\/guitarvydas.github.io\/2022\/01\/13\/GC-in-SectorLisp.html",
                "service_name": "Computing Simplicity"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hukp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "@personaldynamicmedia\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I’m not sure I fully understand how you classified each of those languages, especially Scheme and Smalltalk,"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n@jackrusher\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The two lists of languages don’t make any sense to me. Can you expand on how you think Smalltalk is more of a compiler appeasement language relative to Self?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": Classes are but optimizations of Prototypes.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "further",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "...\n\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": Inheritance is backwards to what we want.  A unit of code should be understandable in a stand-alone manner.  A “child” should not affect a “parent’s” unit of code.  Instancing a “child” from a “parent” class should - in no way - alter the behaviour of the parent class.  A child must not override methods of a parent.  "
                            },
                            {
                                "type": "text",
                                "text": "theory",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": delegation, not overriding.\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": Inheritance (of any kind, prototype inheritance or class-based inheritance) is simply DRY (Don’t Repeat Yourself).  A good editor should do inheritance automatically without putting the burden on Programmers (see, also, Lisp macros, Paul Bassett’s [Framing Software Reuse]("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.amazon.ca\/Framing-Software-Reuse-Lessons-World\/dp\/013327859X"
                            },
                            {
                                "type": "text",
                                "text": " ))\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " DRY is of 2 kinds: (1) semantic (Design) reuse, and, (2) code reuse\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Smalltalkers tell me that inheritance for (2) code reuse is bad.\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Harel StateCharts conquer the “state explosion problem” by using delegation and encapsulation.  Harel StateCharts use delegation instead of inheritance.  My take on the original "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/guitarvydas.github.io\/2020\/12\/09\/StateCharts.html",
                                "text": "StateChart paper"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Sector Lisp - I thought that I hated FP, but Sector Lisp convinced me that FP can be beautiful and small.  Why is Sector Lisp many, many orders of magnitude smaller than other Programming Languages and Operating Systems?  "
                            },
                            {
                                "type": "text",
                                "text": "theory",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": Sector Lisp stays within the “sweet spot” of the FP paradigm and doesn’t try to be an all-in-one solution to every programming problem.\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Sector Lisp’s Garbage Collector (invented by Tunney) is 40 bytes.  SIC: bytes, not K, not M, not G, not T. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/guitarvydas.github.io\/2022\/01\/13\/GC-in-SectorLisp.html",
                                "text": "My take on Sector Lisp GC"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "theory",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Sector Lisp’s smallness cannot be due only to Assembler Parlour Tricks.  Something deeper must be involved.\n"
                            },
                            {
                                "type": "text",
                                "text": "theory",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " We need languages that plumb “build and forget” solutions.  Plumbing ≣ composition.  UNIX pipelines are an example of this.  Surely, we can do better.\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Functions employ LIFOs, UNIX pipelines employ FIFOs.\n"
                            },
                            {
                                "type": "text",
                                "text": "observation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Functions calling functions cannot be pipelines (LIFO vs FIFO)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UUQ2EQW21",
        "type": "message",
        "ts": "1660734784.784359",
        "edited": {
            "user": "UUQ2EQW21",
            "ts": "1660734834.000000"
        },
        "client_msg_id": "299798a9-1664-4532-ac58-cc11b6496ce1",
        "text": "&gt; 1. Programming languages themselves contain ideas, and ideas about how to make better programming languages are very much in scope for FoC efforts. This is especially true when we consider the environment in which a language is embedded, rather than reducing it to syntax + denotational semantics.\nYes, I was thinking more about how to 'implement' those new things; languages or otherwise, to be efficient.\n\n&gt; 2. It was phrased in such a way that it seemed like it was trying to shut down <@UGWUJUZHT>'s thread. (Probably not your intention!)\nCertainly not; just a too-brief reaction to the post!\n\n&gt; A question about \"you can achieve that just as easily with most languages\" — do you think it would be \"just as easy\" to build Erlang's OTP or write a real-time scheduler in Ruby?\nThat is a very fair point; maybe using a C extension :wink: Perhaps 'you can achieve the most in the quickest time using a language you know'.  i.e. I could probably build a scheduler the fastest in C++; and you (speculating) might build one faster in Lisp than Ruby.... etc.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g2266cacc8f3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Chris",
            "real_name": "Chris Maughan",
            "display_name": "Chris Maughan",
            "team": "T5TCAFTA9",
            "name": "mornymorny",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1660622143.650149",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GsJe",
                "elements": [
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Programming languages themselves contain ideas, and ideas about how to make better programming languages are very much in scope for FoC efforts. This is especially true when we consider the environment in which a language is embedded, rather than reducing it to syntax + denotational semantics."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 1
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nYes, I was thinking more about how to 'implement' those new things; languages or otherwise, to be efficient.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "2. It was phrased in such a way that it seemed like it was trying to shut down "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": "'s thread. (Probably not your intention!)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Certainly not; just a too-brief reaction to the post!\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A question about \"you can achieve that just as easily with most languages\" — do you think it would be \"just as easy\" to build Erlang's OTP or write a real-time scheduler in Ruby?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That is a very fair point; maybe using a C extension "
                            },
                            {
                                "type": "emoji",
                                "name": "wink",
                                "unicode": "1f609"
                            },
                            {
                                "type": "text",
                                "text": " Perhaps 'you can achieve the most in the quickest time using a language you know'.  i.e. I could probably build a scheduler the fastest in C++; and you (speculating) might build one faster in Lisp than Ruby.... etc."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "this is a _very_ _light_ coding environment, but I turn to it often when working on light math, dividing up costs of trips, napkin math for finances etc. To me, what is so powerful is that, in plain text you can define the value of a variable as well as state its type: ‘$200.00 in CAD’ etc, and that the right gutter shows calculations, live. The app in the screenshots is <https:\/\/numi.app\/|Numi>. I know <https:\/\/soulver.app\/> is a comparable app as well —",
        "files": [
            {
                "id": "F03UU2PPTQ8",
                "mode": "hidden_by_limit"
            },
            {
                "id": "F03UU2RFC3A",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "U03RH5DFJ57",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CC2jR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this is a "
                            },
                            {
                                "type": "text",
                                "text": "very",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "light",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " coding environment, but I turn to it often when working on light math, dividing up costs of trips, napkin math for finances etc. To me, what is so powerful is that, in plain text you can define the value of a variable as well as state its type: ‘$200.00 in CAD’ etc, and that the right gutter shows calculations, live. The app in the screenshots is "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/numi.app\/",
                                "text": "Numi"
                            },
                            {
                                "type": "text",
                                "text": ". I know "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/soulver.app\/"
                            },
                            {
                                "type": "text",
                                "text": " is a comparable app as well —"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1660796226.808469",
        "client_msg_id": "d2faee95-88cf-481f-8292-e59797dcf47a",
        "thread_ts": "1660796226.808469",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1660808100.701249",
        "reply_users": [
            "UJBAJNFLK"
        ],
        "replies": [
            {
                "user": "UJBAJNFLK",
                "ts": "1660808100.701249"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    }
]