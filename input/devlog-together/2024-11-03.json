[
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1730627183.074749",
        "client_msg_id": "bf9a1f0d-5ad6-451b-92db-af5a29f00fab",
        "text": "That's a frequent criticism I hear when I try to convince colleagues to go for re-editable (rather then re-usable) software.\n\nI believe this should be automatable, though perhaps require adapted tooling. The hard part is keeping track of forks as they are made. For a single person this just requires adopting some discipline, but for groups it probably requires some mechanism to register forks in some central place.\n\nAny thoughts on this? I guess you are in the \"individual\" category for now.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1730402897.670529",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "g59TB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That's a frequent criticism I hear when I try to convince colleagues to go for re-editable (rather then re-usable) software.\n\nI believe this should be automatable, though perhaps require adapted tooling. The hard part is keeping track of forks as they are made. For a single person this just requires adopting some discipline, but for groups it probably requires some mechanism to register forks in some central place.\n\nAny thoughts on this? I guess you are in the \"individual\" category for now."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1730646519.632749",
        "client_msg_id": "d3644cab-4500-4636-a5d5-bce4525ab279",
        "text": "&gt; ... The hard part is keeping track of forks as they are made. ...\nFWIW: I don't know of a solution for this kind of problem, but, things like <https:\/\/research.cs.queensu.ca\/home\/cordy\/Papers\/CR-NiCad-Tool-ICPC11.pdf|NiCaD> make me believe that steps towards solving this kind of thing are possible. I find `git` to be a bother when I'm re-editing code, hacking and exploring problem spaces. I don't know before-hand where I'm going nor what I'm going to do next. I need a tool that auto-saves a tree of branches of my explorations without needing me to stop and stroke git, trying to predict when I will want to save a change vs. backtracking, trying something else, and, cleaning up after myself. I need `emacs` to create and commit a new git branch every time I do a save.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1730402897.670529",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "u8NbB",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... The hard part is keeping track of forks as they are made. ..."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FWIW: I don't know of a solution for this kind of problem, but, things like "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/research.cs.queensu.ca\/home\/cordy\/Papers\/CR-NiCad-Tool-ICPC11.pdf",
                                "text": "NiCaD"
                            },
                            {
                                "type": "text",
                                "text": " make me believe that steps towards solving this kind of thing are possible. I find "
                            },
                            {
                                "type": "text",
                                "text": "git",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to be a bother when I'm re-editing code, hacking and exploring problem spaces. I don't know before-hand where I'm going nor what I'm going to do next. I need a tool that auto-saves a tree of branches of my explorations without needing me to stop and stroke git, trying to predict when I will want to save a change vs. backtracking, trying something else, and, cleaning up after myself. I need "
                            },
                            {
                                "type": "text",
                                "text": "emacs",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to create and commit a new git branch every time I do a save."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1730647641.293649",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1730648800.000000"
        },
        "client_msg_id": "d2c2f230-084d-4925-abee-62b80ddd3fe1",
        "text": "<@UJBAJNFLK> Yeah, this is the key question to the whole approach, isn't it? I have a few responses:\n\n• The conventional approach is to trust a third party to make sure changes are applied everywhere they should be. That isn't going well. Software is full of regressions.\n• The conventional approach is to bundle a bunch of unrelated code higgledy-piggledy as features in shared codebases. That isn't going well. It remains challenging to ensure a bug is fixed in every applicable combination of features.\n• Paradoxically the best way to avoid the drawbacks of reeditable software is to avoid editing it too much. The goal of my prolific spawning of forks is to keep each fork simple and stable as far as possible. The root of my tree, for example, only gets modified for bugfixes these days. And bugfixes are growing more rare, particularly in the subtree since <https:\/\/akkartik.name\/post\/programming-2024|my recent big rewrite>. Though I'm still maintaining previous subtrees, which brings me to..\n• The conventional approach is to let old configurations go stale. Once you've written a paper you don't bother updating its code. You can do that just as well with this approach, just with greater transparency, jettisoning outdated configurations to obviously outdated forks. I've been taking on more pain than I need to, just to get a sense of problems beyond an individual scale.\n• I think we can build tools for reducing the pain of fixing merge conflicts repeatedly in a bunch of forks. Git can remember and replay merge conflicts, but currently only in a single fork. I track new version control programs like Pijul and jj because they may help with this use case by starting from more principled foundations. (It's unclear so far if they do.) So it's important not to compare the fully mature state of conventional software with the embryo of a new approach. (Has anyone experimented with training AI to fix merge conflicts? Delegate the boring parts of building, not the fun parts.)\n• I do have some tools for speeding things up. (My tool for keeping track of forks is just a flat file containing a topologically sorted list of directories to iterate through. Each directory keeps track of its upstream in git config.) It takes me 1-2 hours to pull a patch through all my forks. Where the tools are lacking, I prioritize the quality of the result over some periodic tedium.\nBottomline for now: the conventional way to make software is better in one way: it lets us all sit around, stewing in incompetence, pointing fingers at each other, safe in the knowledge that nobody will blame any single one of us directly for most problems. The conventional way is worse in one way: there's no good way for the individual who truly _cares_ about the quality of their work to carve out an area to cultivate. In my approach they can start managing their own forks, do the tedious work needed to stamp out bugs once and for all, and to avoid regressions.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1730402897.670529",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ok1Ov",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " Yeah, this is the key question to the whole approach, isn't it? I have a few responses:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The conventional approach is to trust a third party to make sure changes are applied everywhere they should be. That isn't going well. Software is full of regressions."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The conventional approach is to bundle a bunch of unrelated code higgledy-piggledy as features in shared codebases. That isn't going well. It remains challenging to ensure a bug is fixed in every applicable combination of features."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Paradoxically the best way to avoid the drawbacks of reeditable software is to avoid editing it too much. The goal of my prolific spawning of forks is to keep each fork simple and stable as far as possible. The root of my tree, for example, only gets modified for bugfixes these days. And bugfixes are growing more rare, particularly in the subtree since "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https:\/\/akkartik.name\/post\/programming-2024",
                                        "text": "my recent big rewrite"
                                    },
                                    {
                                        "type": "text",
                                        "text": ". Though I'm still maintaining previous subtrees, which brings me to.."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The conventional approach is to let old configurations go stale. Once you've written a paper you don't bother updating its code. You can do that just as well with this approach, just with greater transparency, jettisoning outdated configurations to obviously outdated forks. I've been taking on more pain than I need to, just to get a sense of problems beyond an individual scale."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I think we can build tools for reducing the pain of fixing merge conflicts repeatedly in a bunch of forks. Git can remember and replay merge conflicts, but currently only in a single fork. I track new version control programs like Pijul and jj because they may help with this use case by starting from more principled foundations. (It's unclear so far if they do.) So it's important not to compare the fully mature state of conventional software with the embryo of a new approach. (Has anyone experimented with training AI to fix merge conflicts? Delegate the boring parts of building, not the fun parts.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I do have some tools for speeding things up. (My tool for keeping track of forks is just a flat file containing a topologically sorted list of directories to iterate through. Each directory keeps track of its upstream in git config.) It takes me 1-2 hours to pull a patch through all my forks. Where the tools are lacking, I prioritize the quality of the result over some periodic tedium."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nBottomline for now: the conventional way to make software is better in one way: it lets us all sit around, stewing in incompetence, pointing fingers at each other, safe in the knowledge that nobody will blame any single one of us directly for most problems. The conventional way is worse in one way: there's no good way for the individual who truly "
                            },
                            {
                                "type": "text",
                                "text": "cares",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " about the quality of their work to carve out an area to cultivate. In my approach they can start managing their own forks, do the tedious work needed to stamp out bugs once and for all, and to avoid regressions."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "I've built a single file notebook export format in Observable userspace. Convert an Observable notebook into a single file. Self-replicating notebooks. You don't even need a local webserver to run them, they work in a `file:\/\/` context. You _can_ put them on a webserver if you want. This is complement the userspace notebook source<https:\/\/futureofcoding.slack.com\/archives\/C03RR0W5DGC\/p1729454226172819| editor>. I still have some more work on this to consider it fully working (e.g. FileAttachment support), but today I finally reached the milestone that the exporter can export an operational version of itself.",
        "files": [
            {
                "id": "F07VBFUJU72",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "U02E4DAQGSZ",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lBEAM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've built a single file notebook export format in Observable userspace. Convert an Observable notebook into a single file. Self-replicating notebooks. You don't even need a local webserver to run them, they work in a "
                            },
                            {
                                "type": "text",
                                "text": "file:\/\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " context. You "
                            },
                            {
                                "type": "text",
                                "text": "can",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " put them on a webserver if you want. This is complement the userspace notebook source"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C03RR0W5DGC\/p1729454226172819",
                                "text": " editor"
                            },
                            {
                                "type": "text",
                                "text": ". I still have some more work on this to consider it fully working (e.g. FileAttachment support), but today I finally reached the milestone that the exporter can export an operational version of itself."
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1730665419.389349",
        "edited": {
            "user": "U02E4DAQGSZ",
            "ts": "1730667847.000000"
        },
        "client_msg_id": "38509afe-93cc-43c7-b10c-3c5a972cab52",
        "thread_ts": "1730665419.389349",
        "reply_count": 5,
        "reply_users_count": 3,
        "latest_reply": "1731242186.779779",
        "reply_users": [
            "UCUSW7WVD",
            "U02E4DAQGSZ",
            "U05UK5T7LPP"
        ],
        "replies": [
            {
                "user": "UCUSW7WVD",
                "ts": "1730739377.371929"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1730745073.420129"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1731103223.044009"
            },
            {
                "user": "U05UK5T7LPP",
                "ts": "1731175462.293989"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1731242186.779779"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJBAJNFLK",
                    "U06DZDM8C93",
                    "U05UK5T7LPP"
                ],
                "count": 3
            },
            {
                "name": "exploding_head",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "cake",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    }
]