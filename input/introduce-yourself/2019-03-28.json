[
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1553793976.000600",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1553794428.000000"
        },
        "client_msg_id": "05971161-6d6a-4166-aadd-8918953abda0",
        "text": "Hi Wouter, welcome! We chatted a bit about Lobster's `while` sometime back. I still find Lobster one of the most promising languages, just don't have time to explore or work with it :smile:. One really interesting feature is the typing (is there a name for this? verified duck typing? flow based?) The ability to write fairly flexible code with only a  few annotations, and the compiler will verify (whole program analysis?) that there is no AttributeError. Specifically each branch is specialized for invocation with different types. It appears you end up with Python like semantics and code patterns, except AttributeErrors are checked at compile time? Even the null checks are very nice because if something can be null or a number, you can just do\n```\nif a:\n  a += 1\n```\nAnd the compiler wont complain. No 'unpacking sum type' is necessary, and no danger of accidentally doing `a+=1` in an unchecked branch (compiler will complain). This is kind of a sweet spot between the current mainstream static and dynamic typing ideas. Is this a correct understanding of the features?\n\nWhare areas of Lobster are under active development?\n\n(For folks interested in the type system see <https:\/\/htmlpreview.github.io\/?https:\/\/raw.githubusercontent.com\/aardappel\/lobster\/master\/lobster\/docs\/type_checker.html>)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553729620.097600",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Rfaj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi Wouter, welcome! We chatted a bit about Lobster's "
                            },
                            {
                                "type": "text",
                                "text": "while",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " sometime back. I still find Lobster one of the most promising languages, just don't have time to explore or work with it "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            },
                            {
                                "type": "text",
                                "text": ". One really interesting feature is the typing (is there a name for this? verified duck typing? flow based?) The ability to write fairly flexible code with only a  few annotations, and the compiler will verify (whole program analysis?) that there is no AttributeError. Specifically each branch is specialized for invocation with different types. It appears you end up with Python like semantics and code patterns, except AttributeErrors are checked at compile time? Even the null checks are very nice because if something can be null or a number, you can just do"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "if a:\n  a += 1\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And the compiler wont complain. No 'unpacking sum type' is necessary, and no danger of accidentally doing "
                            },
                            {
                                "type": "text",
                                "text": "a+=1",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in an unchecked branch (compiler will complain). This is kind of a sweet spot between the current mainstream static and dynamic typing ideas. Is this a correct understanding of the features?\n\nWhare areas of Lobster are under active development?\n\n(For folks interested in the type system see "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/htmlpreview.github.io\/?https:\/\/raw.githubusercontent.com\/aardappel\/lobster\/master\/lobster\/docs\/type_checker.html"
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1553794399.000900",
        "client_msg_id": "1adbba83-51e7-4721-b8b6-584b24b1b78d",
        "text": "Also I really like that control structures are just functions. This is a more controversial idea, I believe, because folks argue we should only have a small set of well known control flows. But I think this is really powerful and also keeps the language core really small.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553729620.097600",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KzGm6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also I really like that control structures are just functions. This is a more controversial idea, I believe, because folks argue we should only have a small set of well known control flows. But I think this is really powerful and also keeps the language core really small."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1553830901.001500",
        "client_msg_id": "1104df38-bb7a-4a70-855e-a8ce93c81bf3",
        "text": "Yup, you have a pretty good picture of the type system. The goal is Python like comfort and productivity with a C# or even Rust-like safety net :slightly_smiling_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553729620.097600",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H8kuz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yup, you have a pretty good picture of the type system. The goal is Python like comfort and productivity with a C# or even Rust-like safety net "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1553830966.001700",
        "client_msg_id": "51aaf049-abd5-4906-9e39-5db92ff6bdf7",
        "text": "The magic in the type system is that it does flow sensitive specialization, so the type checking is relative to the compile-time call-graph, as if it evaluates each possible path for every type combination",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553729620.097600",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5Ln",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The magic in the type system is that it does flow sensitive specialization, so the type checking is relative to the compile-time call-graph, as if it evaluates each possible path for every type combination"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1553833383.001900",
        "client_msg_id": "4fe68e80-9ef3-424d-b5ae-85132ed74b7b",
        "text": "One area that changed recently (and I yet have to document) is memory management: I implemented a lifetime\/borrow checker similar to Rust, but unlike Rust it is mostly transparent to the programmer. In the base case it results in compile-time reference counting. Also it gained \"zero-cost abstraction\" in the sense that it has inline structs now",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553729620.097600",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VUl69",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One area that changed recently (and I yet have to document) is memory management: I implemented a lifetime\/borrow checker similar to Rust, but unlike Rust it is mostly transparent to the programmer. In the base case it results in compile-time reference counting. Also it gained \"zero-cost abstraction\" in the sense that it has inline structs now"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U8A5MS6R1",
                    "UA14TGLTC",
                    "UBSMEUXAA"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1553833523.002100",
        "client_msg_id": "941d540d-635f-4a78-a6c7-96891f5cdf99",
        "text": "Also the beginnings of concurrency, in fully distributed, coordinated tuple space fashion",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553729620.097600",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZKJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also the beginnings of concurrency, in fully distributed, coordinated tuple space fashion"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1553836630.002400",
        "client_msg_id": "1f6b7152-b98f-4926-9703-2296c43326b1",
        "text": "Sounds awesome. Modules would be nice too :smile:.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553729620.097600",
        "parent_user_id": "UHDQ62M4P",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T9T",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sounds awesome. Modules would be nice too "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]