[
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1634112688.327700",
        "client_msg_id": "d62a7fe6-7c2f-4412-b3f6-53b050a36eca",
        "text": "\"See how far you can go\" is an interesting challenge",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1631829268.080200",
        "parent_user_id": "UBN9AFS0N",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7bYj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"See how far you can go\" is an interesting challenge"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1634112746.327900",
        "client_msg_id": "1be0420f-5ea2-48b2-aeef-8179d84ff7c8",
        "text": "solving the same problem on different tools sounds interesting to me, if anyone has more ideas then the 7GUIs I linked let me know, will check hedy's tasks",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1631829268.080200",
        "parent_user_id": "UBN9AFS0N",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wEw8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "solving the same problem on different tools sounds interesting to me, if anyone has more ideas then the 7GUIs I linked let me know, will check hedy's tasks"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UUB7RA7PF",
        "type": "message",
        "ts": "1634115681.328100",
        "edited": {
            "user": "UUB7RA7PF",
            "ts": "1634115724.000000"
        },
        "client_msg_id": "d1481785-2243-4c6b-b951-8e5dda5aa69f",
        "text": "Thanks <@UCUSW7WVD>! Tutorial is a part of what we recognized so far as a happy path for the newcomers. First they install Wasp, then they create a new dummy app with it (takes just one command to generate it), then they run it and see some results, and then they continue to tutorial where we guide them step by step in building a Todo app, where each chapter introduces a new feature \/ complexity to the app. As you said, it is about increasing complexity with every step. What is important is that every step ends with a victory, a feeling of success.\nYou list of tasks sounds good! Have you considered maybe keeping them all in the same context? Instead of each step introducing a new kind of app, maybe it could be just a single app that they are improving on in each step? To preserve the context and reduce friction? And they feel like they are building this thing, instead of throw-away exercises?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2fdcf29b225b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-02-26\/971836171367_2fdcf29b225b02e66825_72.png",
            "first_name": "Martin",
            "real_name": "Martin Sosic",
            "display_name": "Martin",
            "team": "T5TCAFTA9",
            "name": "sosic.martin",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1631829268.080200",
        "parent_user_id": "UBN9AFS0N",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Zf7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": "! Tutorial is a part of what we recognized so far as a happy path for the newcomers. First they install Wasp, then they create a new dummy app with it (takes just one command to generate it), then they run it and see some results, and then they continue to tutorial where we guide them step by step in building a Todo app, where each chapter introduces a new feature \/ complexity to the app. As you said, it is about increasing complexity with every step. What is important is that every step ends with a victory, a feeling of success.\nYou list of tasks sounds good! Have you considered maybe keeping them all in the same context? Instead of each step introducing a new kind of app, maybe it could be just a single app that they are improving on in each step? To preserve the context and reduce friction? And they feel like they are building this thing, instead of throw-away exercises?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "text": "Is there some research\/articles worth checking about the usage of icons in user interfaces?\n\nLooking at 3D softwares like Maya, or VS Code's right panel icons; I sometimes have a hard time understanding why we've come to rely on icons so much when they're almost never readable without an extra effort of hovering on them or clicking on them to know more about them.\n\nPhotoshop is the guiltiest of all in this category, and you also have softwares like Figma, where all possible operations tend to be grouped under just a few icons, and clicking on those icons opens a dropdown that contains icon + description, which makes everything really easy to understand.\n\nCould there be some reasonable explanation beyond lack of space?\n\nIn contrast, Windows Explorer took a different approach, where it occupies more space, but every single option is cristal clear even for the most untrained eye.\nNot sure how close this is to the FoC; but definitely close enough to the future of software visual design I believe.",
        "files": [
            {
                "id": "F02JE4A6CF2",
                "mode": "hidden_by_limit"
            },
            {
                "id": "F02HQER9F19",
                "mode": "hidden_by_limit"
            },
            {
                "id": "F02HHNB2KJA",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "U018HK8QM2R",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Qh6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is there some research\/articles worth checking about the usage of icons in user interfaces?\n\nLooking at 3D softwares like Maya, or VS Code's right panel icons; I sometimes have a hard time understanding why we've come to rely on icons so much when they're almost never readable without an extra effort of hovering on them or clicking on them to know more about them.\n\nPhotoshop is the guiltiest of all in this category, and you also have softwares like Figma, where all possible operations tend to be grouped under just a few icons, and clicking on those icons opens a dropdown that contains icon + description, which makes everything really easy to understand.\n\nCould there be some reasonable explanation beyond lack of space?\n\nIn contrast, Windows Explorer took a different approach, where it occupies more space, but every single option is cristal clear even for the most untrained eye.\nNot sure how close this is to the FoC; but definitely close enough to the future of software visual design I believe."
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1634167410.336500",
        "client_msg_id": "1e30013c-0544-4a1c-8ecb-fa7df7cd59c8",
        "thread_ts": "1634167410.336500",
        "reply_count": 8,
        "reply_users_count": 4,
        "latest_reply": "1634755341.409000",
        "reply_users": [
            "UBN9AFS0N",
            "U02JDAYKW7J",
            "U01ULEWACPP",
            "U01661S9F34"
        ],
        "replies": [
            {
                "user": "UBN9AFS0N",
                "ts": "1634200305.338300"
            },
            {
                "user": "UBN9AFS0N",
                "ts": "1634200373.338600"
            },
            {
                "user": "UBN9AFS0N",
                "ts": "1634200402.338900"
            },
            {
                "user": "U02JDAYKW7J",
                "ts": "1634206795.339200"
            },
            {
                "user": "U01ULEWACPP",
                "ts": "1634238105.353400"
            },
            {
                "user": "U01661S9F34",
                "ts": "1634241831.353700"
            },
            {
                "user": "U01ULEWACPP",
                "ts": "1634270932.355500"
            },
            {
                "user": "U01ULEWACPP",
                "ts": "1634755341.409000"
            }
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "user": "UMVFWPZ36",
        "type": "message",
        "ts": "1634171771.336800",
        "client_msg_id": "c4648888-4f2e-44ce-8a22-1a289ccd64b4",
        "text": "I also took a crack at this 2 years ago. We called it \"anyfix\"\/\"omnifix\". It's fun to see these other implementations with names like Interfix and Mixfix!\n\nThe use case for us was talking to medical care providers and discovering that many would invent their own written shorthands (grammars) for jotting down EMR data while working with patients, which would often have out-of-order parameters (20 inches 10lbs or 10lbs 20 inches etc). IIRC ambiguity was the exception rather than the rule. We figured if it's very clear to humans what the intent is the parser should be able to figure it out too.\n\nIt was rather easy to implement in Tree Notation, which is a whitespace based syntax where each row is a node split into cells. The line parser first determines what kind of node the line is, and then a cell parser determines what the type of each cell is. A node definition states the cell types expected and whether to use a prefix\/postfix\/omnifix parser. Simple tests (such as regex) are then used to detect the type of each word in the omnifix case.\n\nIn theory this puts the onus of avoiding ambiguity on the language designer, but in practice (IIRC from our small experiments) it was surprisingly easy to avoid. It seemed that usually when you have 2 params with the same type, it was often better to take a list instead.\n\nA really dumb toy demo for our implementation: <https:\/\/jtree.treenotation.org\/designer\/#standard%20poop>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd558604a21",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-22\/1871363334903_cbd558604a21b23211c3_72.png",
            "first_name": "",
            "real_name": "Breck Yunits",
            "display_name": "Breck Yunits",
            "team": "T5TCAFTA9",
            "name": "breck7",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1633919351.305800",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A9=wM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I also took a crack at this 2 years ago. We called it \"anyfix\"\/\"omnifix\". It's fun to see these other implementations with names like Interfix and Mixfix!\n\nThe use case for us was talking to medical care providers and discovering that many would invent their own written shorthands (grammars) for jotting down EMR data while working with patients, which would often have out-of-order parameters (20 inches 10lbs or 10lbs 20 inches etc). IIRC ambiguity was the exception rather than the rule. We figured if it's very clear to humans what the intent is the parser should be able to figure it out too.\n\nIt was rather easy to implement in Tree Notation, which is a whitespace based syntax where each row is a node split into cells. The line parser first determines what kind of node the line is, and then a cell parser determines what the type of each cell is. A node definition states the cell types expected and whether to use a prefix\/postfix\/omnifix parser. Simple tests (such as regex) are then used to detect the type of each word in the omnifix case.\n\nIn theory this puts the onus of avoiding ambiguity on the language designer, but in practice (IIRC from our small experiments) it was surprisingly easy to avoid. It seemed that usually when you have 2 params with the same type, it was often better to take a list instead.\n\nA really dumb toy demo for our implementation: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/jtree.treenotation.org\/designer\/#standard%20poop"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    }
]