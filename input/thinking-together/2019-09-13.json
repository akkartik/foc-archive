[
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1568364655.297600",
        "client_msg_id": "80077185-22ec-4de4-a562-5369c1669caa",
        "text": "Since you've started this, I'm going to jump in instead of getting :popcorn: .. :smile:\nI think we can learn from both OO and FP, but being purist is always a mistake.\nThere.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Sabdr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Since you've started this, I'm going to jump in instead of getting "
                            },
                            {
                                "type": "emoji",
                                "name": "popcorn",
                                "unicode": "1f37f"
                            },
                            {
                                "type": "text",
                                "text": " .. "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            },
                            {
                                "type": "text",
                                "text": "\nI think we can learn from both OO and FP, but being purist is always a mistake.\nThere."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1568387468.307600",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1568387508.000000"
        },
        "client_msg_id": "76747114-D3E1-49A5-84A0-78BDE005F368",
        "text": "One minor point: FP isn't even remotely similar to what the low level execution model of the hardware is. (I'm thinking mostly of the CPU, since you could make an argument that GPU parallel cores are slightly more FP-ish.) This difference means we need to translate our FP code to the CPU execution model, and translate feedback back. The FP translation is generally more lossy and incidentally complex than other language models. For instance, how will you know whether you're optimally using the branch predictor? In C and assembly, you know because you wrote every branch. In higher level procedural \/ OO languages, it's more likely that your branching constructs map to predictable low-level code. In FP, it's that much harder to know. In something like Prolog, all bets are off.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X6D1N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One minor point: FP isn't even remotely similar to what the low level execution model of the hardware is. (I'm thinking mostly of the CPU, since you could make an argument that GPU parallel cores are slightly more FP-ish.) This difference means we need to translate our FP code to the CPU execution model, and translate feedback back. The FP translation is generally more lossy and incidentally complex than other language models. For instance, how will you know whether you're optimally using the branch predictor? In C and assembly, you know because you wrote every branch. In higher level procedural \/ OO languages, it's more likely that your branching constructs map to predictable low-level code. In FP, it's that much harder to know. In something like Prolog, all bets are off."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UE0ETTCG7"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UD3R8FKAN",
        "type": "message",
        "ts": "1568389742.308000",
        "edited": {
            "user": "UD3R8FKAN",
            "ts": "1568389750.000000"
        },
        "client_msg_id": "91b79f44-f47d-460e-8476-a6781986ee31",
        "text": "Anyone going to the Dark launch party tonight?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gef4d12b293f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/def4d12b293fcad449ccc4cfafe86dc6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0000-72.png",
            "first_name": "",
            "real_name": "Gregory M Travis",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "greg.m.travis",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568338998.295600",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oVhi7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Anyone going to the Dark launch party tonight?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1568393872.308300",
        "client_msg_id": "cbd8fda1-c2ed-43d7-979a-748d8d59768c",
        "text": "Yeah, I don't lie awake worrying about that.. :smile:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0bjy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I don't lie awake worrying about that.. "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHWC9PXBL",
        "type": "message",
        "ts": "1568394961.310200",
        "client_msg_id": "9A9403D6-D28A-4F40-A3A2-0C451AFD267E",
        "text": "at the very least i support the idea that monads (and other category theoretic concepts) are much easier to understand in a dynamic OOP model, where you add interfaces to a datatype that enforce constraints ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "Garth",
            "real_name": "Garth Goldwater",
            "display_name": "garth",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FRDmt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "at the very least i support the idea that monads (and other category theoretic concepts) are much easier to understand in a dynamic OOP model, where you add interfaces to a datatype that enforce constraints"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UHWC9PXBL",
        "type": "message",
        "ts": "1568394980.310900",
        "client_msg_id": "33984AE5-0B48-4276-8023-3A2ACC657745",
        "text": "so much so that you end up using them without knowing it",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "Garth",
            "real_name": "Garth Goldwater",
            "display_name": "garth",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CO0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "so much so that you end up using them without knowing it"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568397296.311400",
        "client_msg_id": "f570a763-a31d-44f4-ae0a-77071403e067",
        "text": "The term \"FP\" is only loosely defined, so it's better to be more precise when attacking\/defending it (or exploring relative strengths\/weaknesses, for the less combative).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/0r9c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The term \"FP\" is only loosely defined, so it's better to be more precise when attacking\/defending it (or exploring relative strengths\/weaknesses, for the less combative)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568397783.311600",
        "client_msg_id": "11b4be23-30e8-4743-bf01-997284990988",
        "text": "<@UC2A2ARPT> \"FP isn't even remotely similar to what the low level execution model of the hardware is.\" That's certainly true for lazy evaluation in Haskell. Most functional languages use strict evaluation, though. Curv is a referentially transparent, pure functional language, and one reason I chose that is to make it easier to generate code for the GPU. However, Curv also has mutable local variables, assignments and a `while` statement. I include those things to simplify the programming model for imperative programmers, and so that I can transliterate GLSL into Curv without converting loops to tail recursion, etc. So Ivan's statement isn't really true of Curv.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gp7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " \"FP isn't even remotely similar to what the low level execution model of the hardware is.\" That's certainly true for lazy evaluation in Haskell. Most functional languages use strict evaluation, though. Curv is a referentially transparent, pure functional language, and one reason I chose that is to make it easier to generate code for the GPU. However, Curv also has mutable local variables, assignments and a "
                            },
                            {
                                "type": "text",
                                "text": "while",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " statement. I include those things to simplify the programming model for imperative programmers, and so that I can transliterate GLSL into Curv without converting loops to tail recursion, etc. So Ivan's statement isn't really true of Curv."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1568398152.311800",
        "client_msg_id": "a2eb54f1-1405-461d-99c3-c9735c2c9428",
        "text": "How is Curv referentially transparent and pure in the presence of mutable local variables and assignment?\n\nThat fact that you're finding it useful to include imperative constructs suggests exactly the opposite, that <@UC2A2ARPT>'s statement _is_ true of Curv.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fSAC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How is Curv referentially transparent and pure in the presence of mutable local variables and assignment?\n\nThat fact that you're finding it useful to include imperative constructs suggests exactly the opposite, that "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": "'s statement "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " true of Curv."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1568398366.312100",
        "client_msg_id": "0334094c-a684-4207-974a-1e46606f5d72",
        "text": "How does Curv do with CPU cache lines? Are you able to control data usage patterns to make sure you're keeping stuff in L1 as much as possible?\n\nMy point isn't that FP (as a philosophy) is \"bad\", or even that common functional language implementations have poor performance. Rather, it's that FP languages like Haskell, Clojure, and Scala, and other non-imperative \/ high-level \/ managed languages like Prolog, Smalltalk, Java, JavaScript, etc., tend to make it a _primary_ design goal to abstract away low-level hardware details. They regard that as incidental complexity, or as a security risk, or as a source of error and confusion. I have trouble with that, because I write very (very) performance-sensitive code. So for me, one of the primary goals of FP \/ declarative \/ managed languages (broadly) is diametrically opposed to one of my primary concerns.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A0m0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How does Curv do with CPU cache lines? Are you able to control data usage patterns to make sure you're keeping stuff in L1 as much as possible?\n\nMy point isn't that FP (as a philosophy) is \"bad\", or even that common functional language implementations have poor performance. Rather, it's that FP languages like Haskell, Clojure, and Scala, and other non-imperative \/ high-level \/ managed languages like Prolog, Smalltalk, Java, JavaScript, etc., tend to make it a "
                            },
                            {
                                "type": "text",
                                "text": "primary",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " design goal to abstract away low-level hardware details. They regard that as incidental complexity, or as a security risk, or as a source of error and confusion. I have trouble with that, because I write very (very) performance-sensitive code. So for me, one of the primary goals of FP \/ declarative \/ managed languages (broadly) is diametrically opposed to one of my primary concerns."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1568398671.312300",
        "client_msg_id": "40a207a3-039b-4f7c-a8cd-c9763d43ebca",
        "text": "I recognize that FP (as a philosophy) has a long list of concrete benefits compared to other paradigms. What's missing is the caveat — those benefits apply iff the things that FP language designers regard as incidental complexities are actually incidental. In games, they often aren't. That's why you see folks like John Carmack praising Racket and immutability (or as C++ people call it, \"const correctness\" ugh) and pure functions. They're useful ideas. But those same folks continue to write C++, or C. They borrow the good parts of FP philosophy, but don't bother with true FP languages because those languages _by necessity_ put a big wedge between the programmer and the CPU.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SaYgd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I recognize that FP (as a philosophy) has a long list of concrete benefits compared to other paradigms. What's missing is the caveat — those benefits apply iff the things that FP language designers regard as incidental complexities are actually incidental. In games, they often aren't. That's why you see folks like John Carmack praising Racket and immutability (or as C++ people call it, \"const correctness\" ugh) and pure functions. They're useful ideas. But those same folks continue to write C++, or C. They borrow the good parts of FP philosophy, but don't bother with true FP languages because those languages "
                            },
                            {
                                "type": "text",
                                "text": "by necessity",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " put a big wedge between the programmer and the CPU."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568398869.312500",
        "client_msg_id": "f521ac18-0b50-4efc-bfba-c5ad68047613",
        "text": "<@UC2A2ARPT> My main focus is to abstract away from the hardware and make programming easier, so I agree with you. Some theoretician probably has a way to write efficient device drivers in an FP language, but it's not something I'm aware of.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+Rb9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " My main focus is to abstract away from the hardware and make programming easier, so I agree with you. Some theoretician probably has a way to write efficient device drivers in an FP language, but it's not something I'm aware of."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568399198.312700",
        "client_msg_id": "9ef36d5e-d5ff-4176-b5ff-614622907c24",
        "text": "<@UCUSW7WVD> Curv has immutable values, and all functions are pure. It has a referentially transparent expression language, in which the order of evaluation can't be exposed by side effects, and it has a statement language that is imperative. I don't know what paradigm this language belongs to. I call it a pure functional language, but FP culture rejects imperative style programming, so people may argue that it can't be FP, even though it has all the properties I listed.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X5JcX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " Curv has immutable values, and all functions are pure. It has a referentially transparent expression language, in which the order of evaluation can't be exposed by side effects, and it has a statement language that is imperative. I don't know what paradigm this language belongs to. I call it a pure functional language, but FP culture rejects imperative style programming, so people may argue that it can't be FP, even though it has all the properties I listed."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1568399320.312900",
        "client_msg_id": "20f0dfd9-366a-49f2-815f-0ab806c04ef8",
        "text": "That sounds a bit like how people categorize Scala — multi-paradigm, where one of those paradigms is functional.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2fJht",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That sounds a bit like how people categorize Scala — multi-paradigm, where one of those paradigms is functional."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFS53UWE5",
        "type": "message",
        "ts": "1568402894.313300",
        "client_msg_id": "9eab1e4c-b080-432a-9101-b883ad43f071",
        "text": "<@UL3EE9WR1> XD",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a88832bbbfe7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-12\/1359700849458_a88832bbbfe7c26df530_72.jpg",
            "first_name": "John",
            "real_name": "John Austin",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "kleptine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568338998.295600",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wMDL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UL3EE9WR1"
                            },
                            {
                                "type": "text",
                                "text": " XD"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFS53UWE5",
        "type": "message",
        "ts": "1568402910.313500",
        "client_msg_id": "0e6fffdf-35cd-466d-a770-76265fc3c482",
        "text": "<@UD3R8FKAN> I'll be there!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a88832bbbfe7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-12\/1359700849458_a88832bbbfe7c26df530_72.jpg",
            "first_name": "John",
            "real_name": "John Austin",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "kleptine",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568338998.295600",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sUFY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UD3R8FKAN"
                            },
                            {
                                "type": "text",
                                "text": " I'll be there!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UD3R8FKAN"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U6FKVSVCK",
        "type": "message",
        "ts": "1568403386.313700",
        "client_msg_id": "a2851747-5716-42bf-b0ed-8572d500c7ed",
        "text": "I don't think that FP tends to be less performant is a particularly strong argument against it. Razor's-edge performance isn't a requirement in order for a language to be useful to people— look at Python, which is ~200 times slower than C, but wildly popular, and IMO a joy to use.\n\nI don't think it's a positive thing if a system makes you think about its internal details in order to use it; that makes it less easy to wield, and just generally it's poor encapsulation. Yes, there are performance critical applications where you do need to micromanage every instruction, and those demand very low level languages\/systems. But I'd argue those cases are quite rare, and lie in a problem space that is just about perfectly disjoint from the kind of system we could call a \"bicycle for the mind\".",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cad501b70b26",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-07\/786673147216_cad501b70b26e7666ed0_72.png",
            "first_name": "Tim",
            "real_name": "Tim Babb",
            "display_name": "tbabb",
            "team": "T5TCAFTA9",
            "name": "tbabb",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5h+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't think that FP tends to be less performant is a particularly strong argument against it. Razor's-edge performance isn't a requirement in order for a language to be useful to people— look at Python, which is ~200 times slower than C, but wildly popular, and IMO a joy to use.\n\nI don't think it's a positive thing if a system makes you think about its internal details in order to use it; that makes it less easy to wield, and just generally it's poor encapsulation. Yes, there are performance critical applications where you do need to micromanage every instruction, and those demand very low level languages\/systems. But I'd argue those cases are quite rare, and lie in a problem space that is just about perfectly disjoint from the kind of system we could call a \"bicycle for the mind\"."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U6FKVSVCK",
        "type": "message",
        "ts": "1568403548.314000",
        "client_msg_id": "b2c19dfd-9801-4d17-8a47-7ba1fd593fc9",
        "text": "I see the \"FoP problem\" as needing to push in the direction of \"a computer is a magic box that automatically does what you ask it\", and \"but what are my cache lines doing?!\" is very nearly the opposite direction :slightly_smiling_face:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cad501b70b26",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-07\/786673147216_cad501b70b26e7666ed0_72.png",
            "first_name": "Tim",
            "real_name": "Tim Babb",
            "display_name": "tbabb",
            "team": "T5TCAFTA9",
            "name": "tbabb",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/u2jl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I see the \"FoP problem\" as needing to push in the direction of \"a computer is a magic box that automatically does what you ask it\", and \"but what are my cache lines doing?!\" is very nearly the opposite direction "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U7C7B75R6",
                    "U5STGTB3J"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UD3R8FKAN",
        "type": "message",
        "ts": "1568403882.314300",
        "client_msg_id": "8d57e8ae-e1e7-47b4-93cd-e7a876081677",
        "text": "Cool, I'll be the other guy staring into space thinking about DAGs",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gef4d12b293f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/def4d12b293fcad449ccc4cfafe86dc6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0000-72.png",
            "first_name": "",
            "real_name": "Gregory M Travis",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "greg.m.travis",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568338998.295600",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t8cdh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Cool, I'll be the other guy staring into space thinking about DAGs"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1568409608.314700",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1568410091.000000"
        },
        "client_msg_id": "9aaf7099-b96e-4687-a883-60b4de34217d",
        "text": "<@UCUSW7WVD> I have no formal arguments (and can’t recall ever hearing any for either side). My experience and intuition (for what they’re worth) suggest that immutable objects are useful in some places (like strings &amp; number arguments, immutable proxies to protect ownership, pass by copy for distributed objects, etc), but counter productive in most cases (particularly when trying to enforce these policies on the whole system). By counter productive, I mean people will take longer to produce working code and will produce worse (less understandable, maintainable, scalable, flexible) code when they are required to update all references to an object to change it, at least outside of the realm of some narrow math focused components.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "L=LZO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I have no formal arguments (and can’t recall ever hearing any for either side). My experience and intuition (for what they’re worth) suggest that immutable objects are useful in some places (like strings & number arguments, immutable proxies to protect ownership, pass by copy for distributed objects, etc), but counter productive in most cases (particularly when trying to enforce these policies on the whole system). By counter productive, I mean people will take longer to produce working code and will produce worse (less understandable, maintainable, scalable, flexible) code when they are required to update all references to an object to change it, at least outside of the realm of some narrow math focused components."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1568411668.315300",
        "client_msg_id": "77cbdf00-f0f8-409d-91f5-2fb64e6903bc",
        "text": "<@U6FKVSVCK> I'm not making a Python. I make FoC tools for people who make detailed, highly-interactive games that run on the web. I also make FoC tools that, themselves, are more like games than text documents. So _for me and the users of my tools_ performance is paramount, and every iota counts. I borrow the ideas of FP where they benefit my needs and don't impose a cost, but in general they're directly opposed to one of my primary concerns.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DKKk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U6FKVSVCK"
                            },
                            {
                                "type": "text",
                                "text": " I'm not making a Python. I make FoC tools for people who make detailed, highly-interactive games that run on the web. I also make FoC tools that, themselves, are more like games than text documents. So "
                            },
                            {
                                "type": "text",
                                "text": "for me and the users of my tools",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " performance is paramount, and every iota counts. I borrow the ideas of FP where they benefit my needs and don't impose a cost, but in general they're directly opposed to one of my primary concerns."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U6FKVSVCK"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1568411773.315600",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1568412005.000000"
        },
        "client_msg_id": "ae8b7735-5275-406b-ac11-71cc59506f1f",
        "text": "Gang — the goal of this thread, as established by <@UCUSW7WVD>, is to lay out an _attack_ on FP. We're a community of people that, broadly speaking, are all so intimately familiar with FP that we all know the myriad benefits it offers compared to OO, procedural, etc. In present company, FP doesn't need defending.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Boyd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Gang — the goal of this thread, as established by "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": ", is to lay out an "
                            },
                            {
                                "type": "text",
                                "text": "attack",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " on FP. We're a community of people that, broadly speaking, are all so intimately familiar with FP that we all know the myriad benefits it offers compared to OO, procedural, etc. In present company, FP doesn't need defending."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UHWC9PXBL",
                    "U85HCL7JP",
                    "U8A5MS6R1"
                ],
                "count": 4
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1568411821.315800",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1568411908.000000"
        },
        "client_msg_id": "2daa5500-b6ba-4bd8-900b-593c316e2e35",
        "text": "We _should_ also be the best people to know which skeletons are in the FP closet. Let's have fun pulling them out and dusting them off! Let's not take such an attack personally, and defend the fact that we're (broadly speaking) making good use of FP in our own work. Nobody here needs to be \"converted\".",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Y97j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "We "
                            },
                            {
                                "type": "text",
                                "text": "should",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " also be the best people to know which skeletons are in the FP closet. Let's have fun pulling them out and dusting them off! Let's not take such an attack personally, and defend the fact that we're (broadly speaking) making good use of FP in our own work. Nobody here needs to be \"converted\"."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U6FKVSVCK",
        "type": "message",
        "ts": "1568412085.316500",
        "client_msg_id": "790d86e4-bc99-4ae6-87b4-cecc7b196ea2",
        "text": "<@UC2A2ARPT> True. In the domain of high-perf applications, I completely agree with you. :slightly_smiling_face:\n\nTo the point of \"FP's biggest skeletons\", I think <@ULM3U6275> hits the nail on the head— some problems are best naturally expressed with mutability, and when you give that up, things get messy. That really does feel like a usability\/ergonomics problem to me, and I think it's hard to fix.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cad501b70b26",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-07\/786673147216_cad501b70b26e7666ed0_72.png",
            "first_name": "Tim",
            "real_name": "Tim Babb",
            "display_name": "tbabb",
            "team": "T5TCAFTA9",
            "name": "tbabb",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uX2D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " True. In the domain of high-perf applications, I completely agree with you. "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": "\n\nTo the point of \"FP's biggest skeletons\", I think "
                            },
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " hits the nail on the head— some problems are best naturally expressed with mutability, and when you give that up, things get messy. That really does feel like a usability\/ergonomics problem to me, and I think it's hard to fix."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UL3CJ7YKC"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1568412947.316900",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1568417779.000000"
        },
        "client_msg_id": "a3bcb034-5077-4fc9-832e-bea4176eb3c7",
        "text": "It seems like there’s a strong parallel between the immutability vs mutability debate and the static vs dynamic types debate. Most people seem to feel everything must be one or the other, instead of the ideal being to use each where useful. I think they’re all useful in different situations. My beef with “FP” is only with the focus on immutability absolutism.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "v4V+f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It seems like there’s a strong parallel between the immutability vs mutability debate and the static vs dynamic types debate. Most people seem to feel everything must be one or the other, instead of the ideal being to use each where useful. I think they’re all useful in different situations. My beef with “FP” is only with the focus on immutability absolutism."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568413955.317300",
        "client_msg_id": "a872317c-c56b-4706-9abc-410cc5264966",
        "text": "For general purpose programming in a pure FP language, that typically requires garbage collection. This has a performance cost that the C\/C++\/Rust communities consider unacceptable. (GC is not an *absolute* requirement. Curv uses reference counting, at a cost in expressiveness: there's no way in the language to create cyclic data structures.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vtd2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For general purpose programming in a pure FP language, that typically requires garbage collection. This has a performance cost that the C\/C++\/Rust communities consider unacceptable. (GC is not an "
                            },
                            {
                                "type": "text",
                                "text": "absolute",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " requirement. Curv uses reference counting, at a cost in expressiveness: there's no way in the language to create cyclic data structures.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UNDU8JWKZ",
        "type": "message",
        "ts": "1568414149.318300",
        "client_msg_id": "78316546-f097-40f1-893b-ed086d417b75",
        "text": "I'll be there as well - looking forward to tonight",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g25725ca7309",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/25725ca7309831b06d61d0a96c9cc6bb.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png",
            "first_name": "Misha",
            "real_name": "Misha Taylor",
            "display_name": "taylorific",
            "team": "T5TCAFTA9",
            "name": "mischataylor",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568338998.295600",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e2G9v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'll be there as well - looking forward to tonight"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568414454.318500",
        "client_msg_id": "4b30be7e-8d7a-4835-acb2-34ec7409203b",
        "text": "Haskell is the only well known functional language that requires immutability. Older functional languages, and current members of the functional family, like O'Caml and F#, support mutable objects. So, in terms of \"skeletons\", I think it's better to ask what are the limitations of programming in a pure functional style, without using mutable objects. (As a language designer, I also want to ask if there are missing features that would make pure functional programming easier or more widely applicable.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hPX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Haskell is the only well known functional language that requires immutability. Older functional languages, and current members of the functional family, like O'Caml and F#, support mutable objects. So, in terms of \"skeletons\", I think it's better to ask what are the limitations of programming in a pure functional style, without using mutable objects. (As a language designer, I also want to ask if there are missing features that would make pure functional programming easier or more widely applicable.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UD3R8FKAN",
        "type": "message",
        "ts": "1568414649.318700",
        "client_msg_id": "66e46cb4-09ca-4a61-bc8e-7909045ac9ed",
        "text": "Alas I have twisted my ankle and probably can't make it :disappointed:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gef4d12b293f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/def4d12b293fcad449ccc4cfafe86dc6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0000-72.png",
            "first_name": "",
            "real_name": "Gregory M Travis",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "greg.m.travis",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568338998.295600",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+zwxK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Alas I have twisted my ankle and probably can't make it "
                            },
                            {
                                "type": "emoji",
                                "name": "disappointed",
                                "unicode": "1f61e"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U6FKVSVCK",
        "type": "message",
        "ts": "1568414751.318900",
        "edited": {
            "user": "U6FKVSVCK",
            "ts": "1568415724.000000"
        },
        "client_msg_id": "5701e3d9-5cec-4cd2-ba2c-dc0a40b17d8b",
        "text": "<@ULM3U6275> I share your distaste for absolutism. When it makes sense, I think languages should not impose a particular style of code-organization on the programmer; that's a design choice for them to make. Classic example: Java saying \"OOP is hot, thou shalt make every single part of thine program into OOP\"— yuck, even though OOP can be an excellent way to organize some (parts of) programs.\n\nMy own project is a pure FP node-and-wire tool, and I wish \"FP vs imperative\" was a choice to be selected by the programmer, not imposed. But the moment nodes have side-effects, the entire system becomes impossible to reason about (data dependencies appear that are not visible as wires; execution order is determined only by wire-dependency, so the behavior would collapse to non-determinism), so the choice to allow side effects is disastrous for usability. I do offer some niceties like an \"imperative loop\" node, which contains a network which transforms the previous loop iteration state to the next one. It's still side-effect free, but is less mind-bendy than recursion. Overall I think it is a necessary evil to make a system with simple, limited parts that are easy to reason about.\n\n<@UJN1TAYEQ> Does \"immutable\" not imply \"acyclic\"?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cad501b70b26",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-07\/786673147216_cad501b70b26e7666ed0_72.png",
            "first_name": "Tim",
            "real_name": "Tim Babb",
            "display_name": "tbabb",
            "team": "T5TCAFTA9",
            "name": "tbabb",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/ZG7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " I share your distaste for absolutism. When it makes sense, I think languages should not impose a particular style of code-organization on the programmer; that's a design choice for them to make. Classic example: Java saying \"OOP is hot, thou shalt make every single part of thine program into OOP\"— yuck, even though OOP can be an excellent way to organize some (parts of) programs.\n\nMy own project is a pure FP node-and-wire tool, and I wish \"FP vs imperative\" was a choice to be selected by the programmer, not imposed. But the moment nodes have side-effects, the entire system becomes impossible to reason about (data dependencies appear that are not visible as wires; execution order is determined only by wire-dependency, so the behavior would collapse to non-determinism), so the choice to allow side effects is disastrous for usability. I do offer some niceties like an \"imperative loop\" node, which contains a network which transforms the previous loop iteration state to the next one. It's still side-effect free, but is less mind-bendy than recursion. Overall I think it is a necessary evil to make a system with simple, limited parts that are easy to reason about.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " Does \"immutable\" not imply \"acyclic\"?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UKFNXF0F9",
        "type": "message",
        "ts": "1568421467.000200",
        "client_msg_id": "066e0257-404a-47a6-832f-88b8620a2c97",
        "text": "I echo this view as well. Any one can give a explanation why it is easier from cognition perspective?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5651704a60f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/15651704a60f7ef1539f9b1fa2506188.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png",
            "first_name": "",
            "real_name": "taowen",
            "display_name": "taowen",
            "team": "T5TCAFTA9",
            "name": "taowen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568156672.259300",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/UJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I echo this view as well. Any one can give a explanation why it is easier from cognition perspective?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UKFNXF0F9",
        "type": "message",
        "ts": "1568421749.000400",
        "client_msg_id": "ec79bf09-6d2a-486b-924a-d4d2a45048a7",
        "text": "Depending on global state or global service (like service locator pattern) is considered a bad practice. The mainstream idea likes clear and explicit \"signature\" to be able to compose \"safely\". What is the counter-argument here?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5651704a60f",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/15651704a60f7ef1539f9b1fa2506188.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png",
            "first_name": "",
            "real_name": "taowen",
            "display_name": "taowen",
            "team": "T5TCAFTA9",
            "name": "taowen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568156672.259300",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T+y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Depending on global state or global service (like service locator pattern) is considered a bad practice. The mainstream idea likes clear and explicit \"signature\" to be able to compose \"safely\". What is the counter-argument here?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568421827.000600",
        "client_msg_id": "2a86c351-d539-48f0-9316-e5b6e6a782e9",
        "text": "Shared mutable state imposes a global complexity tax on all of the code in a program. This \"tax\" makes programs harder to reason about, and inhibits compiler optimizations. Not all language features impose a tax on code that doesn't use it. That's why some people are \"absolutist\" about this feature.  At the PWL conference yesterday, there was a beautiful and insightful presentation about how to reason formally about these kinds of issues in programming language design, so that it's not just a matter of taste or opinion. I can't reproduce all the arguments here. <https:\/\/pwlconf.org\/2019\/shriram-krishnamurthi\/>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "attachments": [
            {
                "service_name": "PWLConf",
                "title": "Shriram Krishnamurthi | Papers We Love Conference 2019",
                "title_link": "https:\/\/pwlconf.org\/2019\/shriram-krishnamurthi\/",
                "text": "On the Expressive Power of Programming Languages with Shriram Krishnamurthi | September 12, 2019 in St. Louis, Missouri",
                "fallback": "PWLConf: Shriram Krishnamurthi | Papers We Love Conference 2019",
                "image_url": "https:\/\/pwlconf.org\/images\/2019\/shriram-krishnamurthi.jpg",
                "image_width": 250,
                "image_height": 250,
                "from_url": "https:\/\/pwlconf.org\/2019\/shriram-krishnamurthi\/",
                "image_bytes": 143228,
                "service_icon": "https:\/\/pwlconf.org\/favicon.ico",
                "id": 1,
                "original_url": "https:\/\/pwlconf.org\/2019\/shriram-krishnamurthi\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4=xn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Shared mutable state imposes a global complexity tax on all of the code in a program. This \"tax\" makes programs harder to reason about, and inhibits compiler optimizations. Not all language features impose a tax on code that doesn't use it. That's why some people are \"absolutist\" about this feature.  At the PWL conference yesterday, there was a beautiful and insightful presentation about how to reason formally about these kinds of issues in programming language design, so that it's not just a matter of taste or opinion. I can't reproduce all the arguments here. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/pwlconf.org\/2019\/shriram-krishnamurthi\/"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "face_palm",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1568422282.000900",
        "client_msg_id": "688f172d-8c48-4877-a0ad-81c61db0db63",
        "text": "<@U6FKVSVCK> Haskell supports cyclic immutable data structures, which are constructed using recursive definitions.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "i6h",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U6FKVSVCK"
                            },
                            {
                                "type": "text",
                                "text": " Haskell supports cyclic immutable data structures, which are constructed using recursive definitions."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U6FKVSVCK"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "ULM3U6275",
        "type": "message",
        "ts": "1568423376.004800",
        "client_msg_id": "C6F4B430-263E-412C-91F3-063145F9437D",
        "text": "<@UJN1TAYEQ> “makes programs harder to reason about” for whom? I can tell you that I don’t find it easier to program that way. Am I wrong about myself? ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g588e3d3aa94",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png",
            "first_name": "Steve",
            "real_name": "Steve Dekorte",
            "display_name": "Steve Dekorte",
            "team": "T5TCAFTA9",
            "name": "steve447",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LoaY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " “makes programs harder to reason about” for whom? I can tell you that I don’t find it easier to program that way. Am I wrong about myself?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1568424860.010000",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1568445420.000000"
        },
        "client_msg_id": "f7295a6b-f330-4aee-93d2-fb22d97cca41",
        "text": "I like imperative programming too, so _touché_!\n\nBut this thread actually started about OO vs FP rather than any absolutism. I tend to find FP ideas more useful than OO ones, and I find my programs are better when I try to limit mutation. So I don't think OO vs FP is like static vs dynamic typing at all. FP ideas seem strictly superior to OO.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Y+D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like imperative programming too, so "
                            },
                            {
                                "type": "text",
                                "text": "touché",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "!\n\nBut this thread actually started about OO vs FP rather than any absolutism. I tend to find FP ideas more useful than OO ones, and I find my programs are better when I try to limit mutation. So I don't think OO vs FP is like static vs dynamic typing at all. FP ideas seem strictly superior to OO."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1568425107.010200",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1568425142.000000"
        },
        "client_msg_id": "0783ab05-c6ab-41a6-b221-da8fc00a9940",
        "text": "The best parts of OO feel complementary to FP. In the large, OO provides some guidance on how to organize code, while FP provides constraints. The best object-based designs use lots of stateless objects, I think. So the two feel like positive vs negative space, not necessarily in opposition.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1567954767.205900",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UzRYN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The best parts of OO feel complementary to FP. In the large, OO provides some guidance on how to organize code, while FP provides constraints. The best object-based designs use lots of stateless objects, I think. So the two feel like positive vs negative space, not necessarily in opposition."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UNDU8JWKZ",
        "type": "message",
        "ts": "1568430233.010900",
        "client_msg_id": "d576e794-6299-4b63-a966-6a0f3593bb1a",
        "text": "Great blog post Paul wrote on Dark - pretty much matches up with what he said tonight : <https:\/\/medium.com\/darklang\/how-dark-deploys-code-in-50ms-771c6dd60671>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g25725ca7309",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/25725ca7309831b06d61d0a96c9cc6bb.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png",
            "first_name": "Misha",
            "real_name": "Misha Taylor",
            "display_name": "taylorific",
            "team": "T5TCAFTA9",
            "name": "mischataylor",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1568338998.295600",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CauEU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great blog post Paul wrote on Dark - pretty much matches up with what he said tonight : "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/medium.com\/darklang\/how-dark-deploys-code-in-50ms-771c6dd60671"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]