[
    {
        "user": "U02RBSADCMS",
        "type": "message",
        "ts": "1643739282.862219",
        "edited": {
            "user": "U02RBSADCMS",
            "ts": "1643740700.000000"
        },
        "client_msg_id": "506ae9d4-47bd-4402-893f-74e02ed586eb",
        "text": "Hi everyone!\n\nJust wanted to share my story and idea and maybe find someone that's been on similar thoughts or that is interested. Here comes a wall of text. Feel free to ask questions!\n\nI've been thinking of a new form of computer communication for years now. My goals have been among others implicit abstractions similar to interfaces which include reusability, simple hardware and network integration, automatic data structure handling and implicit parallelization. I've been reading theoretical computer science on master level and was first very fascinated by LISP and Scheme, but after working in Business Intelligence and with analysis cubes and DAX for 2 years, my thoughts have been inspired by the idea of dimensions and the power that abstraction provide. However, I think DAX is very limited. What I've arrived at is a concept I call dimensional programming. By nature it is declarative and entirely based on setting dependencies between dimensions. My approach has similarities to algebra in how equality work in contrast to imperative programming. Although, it come with some distinct differences for handling dimension \"types\" effectively.\n\nThe primary idea is to model a computer as a space of input and output dimensions. Input dimensions being keyboard, mouse, camera, microphone, files etc. Output dimensions: monitor, speaker, files etc. Depending on the source or sink several dimensions are integrated, e.g. a monitor require xy-axis for pixels bound to rgb-color. A program effectively becomes a point that moves through this hyper space, propelled by time (which I believe is not a new idea).\n\nThe programming process consists of creating dependencies between input dimension and new intermediate dimensions until they reach output dimensions. The time dimension is key for most functionality and can be used to create virtual imperative programming when required. The programming engine is tasked with creating a program that guarantee the dependency between input and output dimensions for whenever the output dimension must show. This removes the programmers responsibility of saying when things should operate. Function calls and events are chosen, handled and optimized by the compiler.\n\nIt is possible to create dependent spaces of several dimensions to create basically modules. We then connect other dimensions to the ends (dimensions) to the module and then adapt the behavior. One of the charm with such modules are that they can be complex but we only need to compile and run the parts that has dependencies between input and output dimensions. Types are not a thing. Instead points are mapped between dimensions or based on the shape of a dimension, such as its cardinality which can be used accumulate things over time. Arithmetic is handled by dependencies from the number dimension onto itself based on operators. The fact that dimensions don't really use types seem to create this abstraction criteria I was looking for.\n\nCompilation wise, input and output dimensions are implemented through an interface to provide deltas or full changes for the compiler to optimize the program with. The interface should be sophisticated enough to map to REST APIs or other programming languages or data sources.\n\nThere are plenty of theoretical difficulties with foremost avoiding circular dependencies. This has been a big trouble, but seems to be solvable null points of each dimension where no dependency exist as well as only considering direct chains of dependencies.\n\nThere are some very cool implications with these thoughts of dimensions. A number is just a dimension. A list of numbers is just a number dimension that depends on another discrete dimension. If statements are just points in spaces of one or more dimension causing other dependencies. Logical operations naturally convert in to something more like set theory. The current thought of syntax is very compact requiring few to none keywords. It mostly just looks like common list syntax and rely on pattern matching.\n\nI'm in a fairly late stage theoretically and are aiming at creating a proof of concept soon, probably binding the console input field dimension accumulated over time to the output over the time dimension. But I'm also looking at using Vulcan to implement a monitor output dimension.\n\n\nThere seem to be many other interesting potentials for the future:\n-We can have a computer dimension and program dimensions which allow very straight forward syntax for having programs communicating with each other across the internet.\n- We could get implicit inversion of dependency mappings, effectively making it possible to run programs or dependencies backwards (which could lead to program branching, but there is theory for that too).\n- I've also considered how to visualize such a program. Any pair of dimensions can for example be plotted on a regular 2D graph. In a sense the entire program is defined before it runs, although we can't know certain input dimension states ahead of time. It causes potentials for visual exploration and debugging.\n\nOverall there is a lot of work to do and I will try to get the POC out to show a more concrete example, but until then I'm happy to talk about it!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "83ca575f3f7f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-02-01\/3040481020067_83ca575f3f7f1b6f14ce_72.jpg",
            "first_name": "Noah",
            "real_name": "Noah Tell",
            "display_name": "Noah Tell",
            "team": "T5TCAFTA9",
            "name": "noah.tell",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1643739282.862219",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1644186231.325779",
        "reply_users": [
            "U030JL9M8SH",
            "U02RBSADCMS"
        ],
        "replies": [
            {
                "user": "U030JL9M8SH",
                "ts": "1644126342.361149"
            },
            {
                "user": "U02RBSADCMS",
                "ts": "1644186231.325779"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rTb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi everyone!\n\nJust wanted to share my story and idea and maybe find someone that's been on similar thoughts or that is interested. Here comes a wall of text. Feel free to ask questions!\n\nI've been thinking of a new form of computer communication for years now. My goals have been among others implicit abstractions similar to interfaces which include reusability, simple hardware and network integration, automatic data structure handling and implicit parallelization. I've been reading theoretical computer science on master level and was first very fascinated by LISP and Scheme, but after working in Business Intelligence and with analysis cubes and DAX for 2 years, my thoughts have been inspired by the idea of dimensions and the power that abstraction provide. However, I think DAX is very limited. What I've arrived at is a concept I call dimensional programming. By nature it is declarative and entirely based on setting dependencies between dimensions. My approach has similarities to algebra in how equality work in contrast to imperative programming. Although, it come with some distinct differences for handling dimension \"types\" effectively.\n\nThe primary idea is to model a computer as a space of input and output dimensions. Input dimensions being keyboard, mouse, camera, microphone, files etc. Output dimensions: monitor, speaker, files etc. Depending on the source or sink several dimensions are integrated, e.g. a monitor require xy-axis for pixels bound to rgb-color. A program effectively becomes a point that moves through this hyper space, propelled by time (which I believe is not a new idea).\n\nThe programming process consists of creating dependencies between input dimension and new intermediate dimensions until they reach output dimensions. The time dimension is key for most functionality and can be used to create virtual imperative programming when required. The programming engine is tasked with creating a program that guarantee the dependency between input and output dimensions for whenever the output dimension must show. This removes the programmers responsibility of saying when things should operate. Function calls and events are chosen, handled and optimized by the compiler.\n\nIt is possible to create dependent spaces of several dimensions to create basically modules. We then connect other dimensions to the ends (dimensions) to the module and then adapt the behavior. One of the charm with such modules are that they can be complex but we only need to compile and run the parts that has dependencies between input and output dimensions. Types are not a thing. Instead points are mapped between dimensions or based on the shape of a dimension, such as its cardinality which can be used accumulate things over time. Arithmetic is handled by dependencies from the number dimension onto itself based on operators. The fact that dimensions don't really use types seem to create this abstraction criteria I was looking for.\n\nCompilation wise, input and output dimensions are implemented through an interface to provide deltas or full changes for the compiler to optimize the program with. The interface should be sophisticated enough to map to REST APIs or other programming languages or data sources.\n\nThere are plenty of theoretical difficulties with foremost avoiding circular dependencies. This has been a big trouble, but seems to be solvable null points of each dimension where no dependency exist as well as only considering direct chains of dependencies.\n\nThere are some very cool implications with these thoughts of dimensions. A number is just a dimension. A list of numbers is just a number dimension that depends on another discrete dimension. If statements are just points in spaces of one or more dimension causing other dependencies. Logical operations naturally convert in to something more like set theory. The current thought of syntax is very compact requiring few to none keywords. It mostly just looks like common list syntax and rely on pattern matching.\n\nI'm in a fairly late stage theoretically and are aiming at creating a proof of concept soon, probably binding the console input field dimension accumulated over time to the output over the time dimension. But I'm also looking at using Vulcan to implement a monitor output dimension.\n\n\nThere seem to be many other interesting potentials for the future:\n-We can have a computer dimension and program dimensions which allow very straight forward syntax for having programs communicating with each other across the internet.\n- We could get implicit inversion of dependency mappings, effectively making it possible to run programs or dependencies backwards (which could lead to program branching, but there is theory for that too).\n- I've also considered how to visualize such a program. Any pair of dimensions can for example be plotted on a regular 2D graph. In a sense the entire program is defined before it runs, although we can't know certain input dimension states ahead of time. It causes potentials for visual exploration and debugging.\n\nOverall there is a lot of work to do and I will try to get the POC out to show a more concrete example, but until then I'm happy to talk about it!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "wave",
                "users": [
                    "UC2A2ARPT",
                    "UMV4B97GT",
                    "UJBAJNFLK",
                    "U013ZLJARC7",
                    "U01ULEWACPP",
                    "U02TRJEC469",
                    "UA14TGLTC"
                ],
                "count": 7
            },
            {
                "name": "wave::skin-tone-4",
                "users": [
                    "UCUSW7WVD",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    }
]