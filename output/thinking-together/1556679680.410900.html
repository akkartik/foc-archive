<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1556679680.410900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2019-04-30 20:01</span><br/>
Data types are also units of abstraction. Unfortunately though, "objects" in imperative OOP languages often do not form "simple" abstractions. How do you measure the complexity of an abstraction? Well, the important details of a "simple" abstraction can be described in a few sentences at most. Concise descriptions correlate with ease of comprehension. In the case of OOP languages, objects that hold mutable references to each other cannot be described so concisely, because to describe such an object necessitates a full description of the network of references that it has access to. This is because you can't describe what data an object stores or retrieves without describing the data of other objects it has access to, and you can't describe how the object behaves without specifying the behaviours of other objects that it might trigger or be triggered by.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
