[
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1527577552.000054",
        "text": "I deeply share the feeling that the existing systems restrict (and bias) our thinking in certain ways. 'Compiling down' a program is itself a specific 'frame of thinking' - i.e. one must write a 'program' in full, like a paper, and 'submit' to a another program to be verified and\/or compiled. As one alternative, you could imagine incrementally specifying constraints while a solver constructs the system you are describing live and shows you the effects live.\n\nAnother aspect that comes to mind when working with large systems is why do we describe exactly one 'os process' as a program, which we then deploy as one small piece of a larger system (~100s of distinct processes interacting with each other)? The way we reason about and construct one process is so different than the larger system, but in the end the computation power is no different. Is it possible to define the larger system as 'one program' that we can reason about? How would we update a smaller part of such a system?\n\nYet another aspect is the single view - the program is considered to have a single canonical view (typically text based) - is this a good model?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1527341083.000032",
        "parent_user_id": "UAVRZE1UG",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "y7IJK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I deeply share the feeling that the existing systems restrict (and bias) our thinking in certain ways. 'Compiling down' a program is itself a specific 'frame of thinking' - i.e. one must write a 'program' in full, like a paper, and 'submit' to a another program to be verified and\/or compiled. As one alternative, you could imagine incrementally specifying constraints while a solver constructs the system you are describing live and shows you the effects live.\n\nAnother aspect that comes to mind when working with large systems is why do we describe exactly one 'os process' as a program, which we then deploy as one small piece of a larger system (~100s of distinct processes interacting with each other)? The way we reason about and construct one process is so different than the larger system, but in the end the computation power is no different. Is it possible to define the larger system as 'one program' that we can reason about? How would we update a smaller part of such a system?\n\nYet another aspect is the single view - the program is considered to have a single canonical view (typically text based) - is this a good model?"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]