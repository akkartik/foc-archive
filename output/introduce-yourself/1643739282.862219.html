<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #introduce-yourself</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2022-02-01/3040481020067_83ca575f3f7f1b6f14ce_72.jpg" style="float:left"/>
      <a href="../introduce-yourself/1643739282.862219.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Noah Tell</b>
<span style="margin:2em; color:#606060">2022-02-01 10:14</span><br/>
Hi everyone!<br/><br/>Just wanted to share my story and idea and maybe find someone that's been on similar thoughts or that is interested. Here comes a wall of text. Feel free to ask questions!<br/><br/>I've been thinking of a new form of computer communication for years now. My goals have been among others implicit abstractions similar to interfaces which include reusability, simple hardware and network integration, automatic data structure handling and implicit parallelization. I've been reading theoretical computer science on master level and was first very fascinated by LISP and Scheme, but after working in Business Intelligence and with analysis cubes and DAX for 2 years, my thoughts have been inspired by the idea of dimensions and the power that abstraction provide. However, I think DAX is very limited. What I've arrived at is a concept I call dimensional programming. By nature it is declarative and entirely based on setting dependencies between dimensions. My approach has similarities to algebra in how equality work in contrast to imperative programming. Although, it come with some distinct differences for handling dimension "types" effectively.<br/><br/>The primary idea is to model a computer as a space of input and output dimensions. Input dimensions being keyboard, mouse, camera, microphone, files etc. Output dimensions: monitor, speaker, files etc. Depending on the source or sink several dimensions are integrated, e.g. a monitor require xy-axis for pixels bound to rgb-color. A program effectively becomes a point that moves through this hyper space, propelled by time (which I believe is not a new idea).<br/><br/>The programming process consists of creating dependencies between input dimension and new intermediate dimensions until they reach output dimensions. The time dimension is key for most functionality and can be used to create virtual imperative programming when required. The programming engine is tasked with creating a program that guarantee the dependency between input and output dimensions for whenever the output dimension must show. This removes the programmers responsibility of saying when things should operate. Function calls and events are chosen, handled and optimized by the compiler.<br/><br/>It is possible to create dependent spaces of several dimensions to create basically modules. We then connect other dimensions to the ends (dimensions) to the module and then adapt the behavior. One of the charm with such modules are that they can be complex but we only need to compile and run the parts that has dependencies between input and output dimensions. Types are not a thing. Instead points are mapped between dimensions or based on the shape of a dimension, such as its cardinality which can be used accumulate things over time. Arithmetic is handled by dependencies from the number dimension onto itself based on operators. The fact that dimensions don't really use types seem to create this abstraction criteria I was looking for.<br/><br/>Compilation wise, input and output dimensions are implemented through an interface to provide deltas or full changes for the compiler to optimize the program with. The interface should be sophisticated enough to map to REST APIs or other programming languages or data sources.<br/><br/>There are plenty of theoretical difficulties with foremost avoiding circular dependencies. This has been a big trouble, but seems to be solvable null points of each dimension where no dependency exist as well as only considering direct chains of dependencies.<br/><br/>There are some very cool implications with these thoughts of dimensions. A number is just a dimension. A list of numbers is just a number dimension that depends on another discrete dimension. If statements are just points in spaces of one or more dimension causing other dependencies. Logical operations naturally convert in to something more like set theory. The current thought of syntax is very compact requiring few to none keywords. It mostly just looks like common list syntax and rely on pattern matching.<br/><br/>I'm in a fairly late stage theoretically and are aiming at creating a proof of concept soon, probably binding the console input field dimension accumulated over time to the output over the time dimension. But I'm also looking at using Vulcan to implement a monitor output dimension.<br/><br/><br/>There seem to be many other interesting potentials for the future:<br/>-We can have a computer dimension and program dimensions which allow very straight forward syntax for having programs communicating with each other across the internet.<br/>- We could get implicit inversion of dependency mappings, effectively making it possible to run programs or dependencies backwards (which could lead to program branching, but there is theory for that too).<br/>- I've also considered how to visualize such a program. Any pair of dimensions can for example be plotted on a regular 2D graph. In a sense the entire program is defined before it runs, although we can't know certain input dimension states ahead of time. It causes potentials for visual exploration and debugging.<br/><br/>Overall there is a lot of work to do and I will try to get the POC out to show a more concrete example, but until then I'm happy to talk about it!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1644126342.361149"></a>
      <img src="https://avatars.slack-edge.com/2022-01-28/3018689780341_11852bf7656bc8f94125_72.jpg" style="float:left"/>
      <a href="../introduce-yourself/1643739282.862219.html#1644126342.361149" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Meng Weng Wong</b>
<span style="margin:2em; color:#606060">2022-02-05 21:45</span><br/>
sounds cool, were you inspired by functional programming and relational algebra / logic?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1644186231.325779"></a>
      <img src="https://avatars.slack-edge.com/2022-02-01/3040481020067_83ca575f3f7f1b6f14ce_72.jpg" style="float:left"/>
      <a href="../introduce-yourself/1643739282.862219.html#1644186231.325779" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Noah Tell</b>
<span style="margin:2em; color:#606060">2022-02-06 14:23</span><br/>
Yes absolutely. It is in many ways similar to functional programming, but I'd say it is "looser" as you don't get this strict hierarchy of functions. I suppose it could analogically be called "equational programming" as you can often utilize implicit inversion strategies that make natural syntax for things like relational algebra. In fact a big focus has been to unify logic and relational algebra as I find them to be homogenous. "Union" being "or", while "intersection" being "and" etc.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
