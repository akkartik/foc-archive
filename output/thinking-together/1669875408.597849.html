<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2022-03-23/3286745266387_1092a4f970985ebc8d2b_72.png" style="float:left"/>
      <a href="../thinking-together/1669875408.597849.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Christopher Shank</b>
<span style="margin:2em; color:#606060">2022-11-30 22:16</span><br/>
What’s the relationship between domain-specific programing (i.e DSLs) and end-user programming?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1669876480.147009"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1669875408.597849.html#1669876480.147009" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-11-30 22:34</span><br/>
End users care more about their domain than about programming. A DSL is a step towards the point of view of a domain expert.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1669878848.501169"></a>
      <img src="https://avatars.slack-edge.com/2022-03-23/3286745266387_1092a4f970985ebc8d2b_72.png" style="float:left"/>
      <a href="../thinking-together/1669875408.597849.html#1669878848.501169" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Christopher Shank</b>
<span style="margin:2em; color:#606060">2022-11-30 23:14</span><br/>
Thanks for sharing <span style="background-color:#ccf">@Konrad Hinsen</span>, I’m trying to tease out the differences between the two! <br/><br/>Some follow up questions: Is end user programming inherently domain specific? What is the boundary between a domain expert vs. an end user?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1669881584.981919"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1669875408.597849.html#1669881584.981919" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-11-30 23:59</span><br/>
First, a warning: I really dislike the term "end user". End of what?<br/><br/>That said, I see the space of what is often called "end user programming" as really two spaces: "domain expert programming", and "daily life progrmaming". The latter is to-dos, shopping lists, smart home automation, writing letters, etc. The realm of HyperCard.<br/><br/>These two categories almost coincide with desktop vs. smartphone use today.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1669901067.450379"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1669875408.597849.html#1669901067.450379" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-12-01 05:24</span><br/>
FYI Observations:<br/>• Programming = providing details to a solution in a way that even a machine can perform the steps<br/>• End-user programming = UX<br/>• Rhetorical questions: Are Spreadsheets DSLs?  Are Spreadsheets UXs?  What about Hypercard?<br/>• DSL == programmers’ solution to the “languages are hard to build” problem<br/>• if languages were easy to build, we wouldn’t need to bother with DSLs<br/>• we could just build micro-languages for each problem<br/>• [recursive descent parsing in the past ; now, PEG, Ohm-JS]<br/>• when doing consulting, I would always assume that my clients knew their domain better than I did<br/>• my job was to provide them with ways to automate their knowledge and give them a 10x boost in productivity<br/>• I would try to “invent” a language that mimicked the way that the clients thought about their domain, yet I tried to make every part of that “language” compilable<br/>• instructions in the form of “text” is only one kind of programming language (very 1950s) <br/>• many non-programmers use whiteboards and dry-erase markers instead of programming languages<br/>• programmers think in details and want to use all 10 fingers, users want to skip over details (“elision”) and use swipes and voice and game controllers and “easy-to-use” HCI devices<br/>• notations (aka “programming languages”) for programmers are vastly different from notations for users <br/>• example: FEDEX bar-code-reader hand-held-device marries high tech (bar codes and lasers) in an HCI that makes it easy-to-use in the field ; how was this programmed into being?  Did someone have a vision then hire a bank of engineers (software and hardware architects and engineers and implementors), or, was there an easy-to-use intermediate micro-language that let the envisioner implement / mock-up the MVP without engineers?  Could we have designed this more easily today?
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
