<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-05-26 10:06</span><br/>
SAD theorem<br/><br/>As programs grow complex, you will be repeatedly forced to either:<br/><br/>maintain some <b>State,</b><br/>perform some computations <b>Again,</b><br/>or <b>Duplicate</b> some code.<br/><br/>Has anyone encountered a formulation like this in the literature?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622052235.022100"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622052235.022100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2021-05-26 11:03</span><br/>
S and A seem to relate to caching, the D talks about code, but if it talked about data it would definitely be about cache invalidation :stuck_out_tongue:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622053311.022300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622053311.022300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-05-26 11:21</span><br/>
I'm only concerned about the code architecture. S and A are about caching only to the extent that all data structures are caches (a reasonable view)<br/><br/>I'm going to flesh out a concrete case study. But if y'all think of any papers that may be relevant please throw them here.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622054892.022600"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622054892.022600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2021-05-26 11:48</span><br/>
right now I can only think of "On the criteria to be used in decomposing systems into modules" by parnas
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622055181.023400"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622055181.023400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2021-05-26 11:53</span><br/>
<a href="https://www.semanticscholar.org/paper/N-degrees-of-separation%3A-multi-dimensional-of-Tarr-Ossher/2618f43d7ada40c94e91d9abbba4456799a7e927">https://www.semanticscholar.org/paper/N-degrees-of-separatio&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622057526.024800"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622057526.024800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2021-05-26 12:32</span><br/>
Maybe of interest:<br/><br/>NiCad Clone Detector <a href="https://www.researchgate.net/publication/221219568_The_NiCad_clone_detector">https://www.researchgate.net/publication/221219568_The_NiCad_clone_detector</a><br/><br/>Framing Software Reuse <a href="https://www.amazon.ca/Framing-Software-Reuse-Lessons-World/dp/013327859X">https://www.amazon.ca/Framing-Software-Reuse-Lessons-World/dp/013327859X</a>)<br/><br/>My thoughts on RY as a Programming Primitive<br/><a href="https://guitarvydas.github.io/2021/05/24/RY-Repeat-Yourself-as-a-PL-Primitive.html">https://guitarvydas.github.io/2021/05/24/RY-Repeat-Yourself-&hellip;</a><br/><br/>StateCharts<br/><a href="https://guitarvydas.github.io/2020/12/09/StateCharts.html">https://guitarvydas.github.io/2020/12/09/StateCharts.html</a>)<br/><br/>StateCharts II<br/><a href="https://guitarvydas.github.io/2021/02/25/statecharts-(again).html">https://guitarvydas.github.io/2021/02/25/statecharts-(again).html</a>)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622077005.026300"></a>
      <img src="https://secure.gravatar.com/avatar/15651704a60f7ef1539f9b1fa2506188.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622077005.026300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>taowen</b>
<span style="margin:2em; color:#606060">2021-05-26 17:56</span><br/>
we might say, there is no such thing called "state" once upon a time. "state" is a illusion invented to decouple computation.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622078083.026500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622078083.026500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-05-26 18:14</span><br/>
<span style="background-color:#ccf">@taowen</span> Spotted just now:<br/><br/>&gt; a filesystem is a kind of network protocol that allows for communicating across time<br/><a href="https://tiny.tilde.website/@astrid/103554056156344583">https://tiny.tilde.website/@astrid/103554056156344583</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622078370.026800"></a>
      <img src="https://secure.gravatar.com/avatar/15651704a60f7ef1539f9b1fa2506188.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622078370.026800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>taowen</b>
<span style="margin:2em; color:#606060">2021-05-26 18:19</span><br/>
or a abstraction to generalize the past, no matter how many events happened in what order, we can always generalize it as "same state", to simplify the integration
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622090502.027300"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622090502.027300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-05-26 21:41</span><br/>
Seen from a purely computational perspective, yes. But state is also a feature of our physical universe, and can thus be an important aspect of <em>models</em> of the physical world. Much of the OO vs. FP debate could be eliminated if both sides made a clear distinction between state as part of the model and computational state as an optimization technique.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622124581.027600"></a>
      <img src="https://avatars.slack-edge.com/2020-01-04/893378739792_34e7a55348e8c86c1901_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622124581.027600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jared Windover</b>
<span style="margin:2em; color:#606060">2021-05-27 07:09</span><br/>
S and A do seem like things that can be traded against each other, but I'm having a hard time seeing how D comes in. How does duplicated code trade against State? Is the idea that the branch of code you find yourself in implicitly encodes the state?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622125343.027800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622125343.027800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-05-27 07:22</span><br/>
Say you perform some complex function (rendering some structured data to screen) and then need the result of a sub-computation (where did <em></em>_ get drawn?) You could either save some state during the computation (render) or redo a slice of it (a pretend-render function that duplicates some of the logic in render).<br/><br/>Perhaps higher-order functions will help here? I have a tendency to forget them after 2 years of programming in machine code.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622125853.028000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622125853.028000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-05-27 07:30</span><br/>
Oh, reusing a HOF would correspond to doing some potentially complex computation again for the complex traversal logic. This reminds me of the Scrap Your Boilerplate papers from the Haskell world.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622135596.028500"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622135596.028500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-05-27 10:13</span><br/>
This feels very related to the primary thesis of Out of the Tar Pit
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622304307.031200"></a>
      <a href="../thinking-together/1622048775.021900.html#1622304307.031200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-05-29 09:05</span><br/>
<span style="background-color:#ccf">@Chris Granger</span> Thank you for bringing up <em>Out of the Tar Pit</em>! I've tried several times to appreciate it, and mostly failed to do so in the past[1]. Your nudge in this context got me to do so one more time, and I got a lot further. This time I went past the preliminaries in chapters 1-7 which had given me a lot of trouble before, and focused on their solution outline in chapters 8-10.<br/><br/>I don't think I'd ever noticed before that their FRP is not Conal Elliott's FRP! Functional <em>Relational</em> Programming, not Functional Reactive Programming. Did everybody else know this? This is the kind of stuff that reminds me that my brain is just a jumble of wires, and all my seeming insights are illusory. I'll call it a Moseley-Marks or MM system, just to get past the camouflage.<br/><br/>Have there been any attempts to build an MM system? Pretty much every FRP mention out there seems to be reactive rather than relational. The closest I got was systems inspired directly by Codd rather than MM: <a href="https://wiki.c2.com/?TutorialDee">https://wiki.c2.com/?TutorialDee</a><br/><br/>Anyways, once I pruned away the stuff I was distracted by in the past, I see now a kernel of ideas that seem very useful. It's not essential vs accidental complexity that an MM system manages, because I'm skeptical of our ability to separate those categories, but rather functional invariants vs cross-cutting concerns:<br/><br/>• Base state consisting of immutable value types and relations between them (subsets of points in tuple space).<br/>• Functions over value types.<br/>• Derived relations that aren't needed to describe the problem, but useful to a specific implementation.<br/>• Integrity constraints for base and derived relations.<br/>• Hints on what to store, what order to store it, indexes, etc. A Prolog-like search strategy would fit in here, I think.<br/>The critical new insight for me: this doesn't have to be an all-encompassing framework. Calling it Functional makes it hard to see that I can actually use the framework even in an imperative setting. Set up a phase of a program where it goes through deriving relations from the input, then query the relation store in various ways to create the desired output. Unlike properties like referential transparency, a little impurity here doesn't actually make it impossible to assess the remainder. I can imagine a fairly conventional language toolchain that adds a <tt>relvar</tt> type, along with operations to insert into, query and clear relational variables. Use them in the "lumpy" parts of your program, where you're tempted to duplicate code or no obvious new abstractions present themselves. The toolchain could even give feedback in a complexity score every time it rebuilds a program. The only new domain-independent constraint: you can't mutate a value in the relation store.<br/><br/>This framework feels enormously useful once I stop expecting it to be a silver bullet, and start thinking of it instead as <em>a stepping stone to the right architecture</em>. A dynamically typed store of global state that is easy to query. The problem with mutable global state is really just one of UX: it's too easy to get into situations where mutations get squirreled away where they're easy to forget. Creating immutable copies and local variables can lead to the same pathologies; <em>they just tend to do so less often</em>. Given the gradual nature of the benefits, requiring 100% purity to get any benefits feels like a bad trade. The MM system permits more graceful trade-offs.<br/><br/>[1] My opinion of it as of last week, mostly honed in the course of discussions here: <a href="https://lobste.rs/s/1yfrup/into_tar_pit#c_3ikuv9">https://lobste.rs/s/1yfrup/into_tar_pit#c_3ikuv9</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622318190.031900"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622318190.031900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2021-05-29 12:56</span><br/>
&gt; I don't think I'd ever noticed before that their FRP is not Conal Elliott's FRP! Functional <em>Relational</em> Programming, not Functional Reactive Programming. Did everybody else know this?<br/><b>nod</b><br/><br/>&gt; Have there been any attempts to build an MM system?<br/>Last time I asked / researched this, I only heard/saw "no" beyond the example in the paper. I think a lot of folks (myself included) have made feints in that direction, before diverting off elsewhere for whatever reason.<br/><br/>&gt; It's not essential vs accidental complexity that an MM system manages, <b>because I'm skeptical of our ability to separate those categories</b><br/>Need one of those room-scale ":100:" buttons I can jump up and down on.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622340174.032500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622340174.032500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2021-05-29 19:02</span><br/>
I think that the Cell language is MM inspired. I'd guess heavily inspired, except that the author doesn't cite the tarpit paper. <a href="http://cell-lang.net/">http://cell-lang.net/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622349149.035000"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622349149.035000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-05-29 21:32</span><br/>
Many versions of Eve were essentially MM systems that tried out different points in the implementation space. From pure log + view to various forms of mutable. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622373659.035300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622373659.035300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-05-30 04:20</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> <a href="http://cell-lang.net/relations.html">http://cell-lang.net/relations.html</a> cites the paper!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622634140.037500"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622634140.037500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2021-06-02 04:42</span><br/>
A couple of years ago I posted the following somewhere, maybe here:<br/><em><em></em></em>_<br/><br/>Clearly shared mutable state is not even negotiable in programming, otherwise we'd have no disks, no databases, no GUIs, no 3D worlds, no social media.. basically nothing apart from addition and the like.<br/><br/>But poor ole' shared mutable state is the victim of two fallacies:<br/><br/>(a) Imperative programming gets messy when trying to do concurrency and several threads of control have access to shared mutable state, giving rise to the fallacy that it's the shared mutable state's fault, not the many threads having write access.<br/><br/>(b) Functional programming is clean and does concurrency in a way you can predict, but it doesn't have a concept of shared mutable state, giving rise to the fallacy that shared mutable state must be bad because FP is clean and doesn't have it.<br/><br/>But shared mutable state isn't bad: all we need to do is (a) prevent concurrent write access, and (b) combine FP and shared mutable state in a clean model.<br/><br/>---<br/><br/>Well these ideas go back at least to 1978 with Backus in his Turing Award lecture (<a href="https://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf">https://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf</a>) in the form of "Applicative State Transition". A variant was outlined in "Out of the Tar Pit" as "Functional Relational Programming".<br/><br/>The model is incredibly simple: <em>just take a state and transform it to the next state using a clean declarative rule/transformation/rewrite/function/reduction</em>.<br/><br/>This can be done in parallel as long as you manage partitions of the state per thread.<br/><br/>---<br/><br/>One consequence of this model is that the FP part must terminate: hence it's not itself Turing Complete and is probably in the class of Primitive Recursive: all recursions must have a terminating condition, all lists must be finite, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622643804.037700"></a>
      <img src="https://secure.gravatar.com/avatar/f521cc065bb724c90c57c263ec7ee857.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622643804.037700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Naveen Michaud-Agrawal</b>
<span style="margin:2em; color:#606060">2021-06-02 07:23</span><br/>
&gt;  A dynamically typed store of global state that is easy to query.<br/>That seems to be the basis of the RealTalk system too (from DynamicLand)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622658803.038100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622658803.038100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-06-02 11:33</span><br/>
<span style="background-color:#ccf">@Duncan Cragg</span><br/>&gt; Imperative programming gets messy when trying to do concurrency<br/>It's also extremely easy to make a mess with a single thread and lots of global variables. I think you're on to something, but you have perhaps gone too far in the other direction.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1622930374.041300"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1622930374.041300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2021-06-05 14:59</span><br/>
Although I mostly agree with your conclusions, I disagree with the premise:<br/>&gt; Clearly shared mutable state is not even negotiable in programming, otherwise we'd have no disks, no databases, no GUIs, no 3D worlds, no social media.. basically nothing apart from addition and the like.<br/>I would say that "state" is what's required to model dynamical systems. Physical systems have state. That's what's non-negotiable.<br/><br/>The term "shared mutable state" describes a particular way of modelling state in a programming language. It's the style of imperative/object-oriented programming where you represent state using mutable global variables or shared mutable objects. In these languages, functions are not pure mathematical values, because they can contain internal references to mutable objects or mutable global variables, and calling a function can have the side effect of reading or writing shared mutable state. In these languages, data structures can contain references to shared mutable objects.  (The alternative is data structures whose elements are pure, immutable values.) This is what the word "shared" means in "shared mutable state".<br/><br/>You mention fallacies. The fallacies I've seen in internet discussions (not specifically in this thread) are:<br/>• That pure functional programming is impossible, if you want to write programs that manipulate external state. The best you can do is create a language with a large functional subset, but you still need shared mutable state to model external state, so you need a hybrid language to do anything practical.<br/>• That Haskell is a lie. It's impossible to write a pure functional program that does I/O, you need side effects for that, and you need shared mutable state to interact with external state. Therefore Haskell has these features, even if the Haskell community denies it. Some weird type theoretic mumbo jumbo is being used to obscure what is really going on.<br/>• That there is no alternative to Haskell, and monads, and the IO monad, and tons of category theory, if you want to write pure functional programs that do I/O or that process external state. <br/>• That imperative style programming is incompatible with pure functional programming. The FP police want to take away your mutable variables and while loops, and force you to learn tail recursion. Well yes, they do want to do that, but that's a cultural preference, it's not logically necessary. There is no conflict between imperative programming with mutable <em>local</em> variables and while loops, vs pure functions. The caller of the function doesn't care how the loops are implemented internally. It is only mutable <em>global</em> variables that cause observable side effects during a function call, and shared mutable state. You see, at one extreme, you have the FP police, who want to stamp out the sin of imperative programming. And at the other extreme, you have the imperative defenders, who point out that Haskell monadic programs (do expressions) look suspiciously like imperative programs, thereby "proving" that Haskell is a lie. I don't accept any of that.<br/>Something that I think sustains these fallacies is that there is a serious shortage of good, practical, easy to use, easy to understand, general purpose languages for programming without shared mutable state. If such languages don't exist now, it's easy to imagine that they never will exist in the future. Haskell is frankly so overly complex, terrifying, dogmatic, and impractical that it casts a negative light on the field. Elm is pretty good: easy to learn and use, no shared mutable state and no monads, but it's a domain specific language that is only used for GUIs. So there is a lot of work to do, and new languages to design, before these ideas can become truly mainstream, before people stop claiming these ideas are impossible.<br/><br/>What I would like to see, or what I would like to build if no one beats me to it, is an easy to learn and use, dynamically typed, image based, live programming environment similar to Smalltalk or Lisp, except with no shared mutable state. What makes this interesting is that Lisp was the original language where everything is an object reference, and Smalltalk took this idea even further with object oriented programming, where everything is a reference to a <b>mutable</b> object. So let's build the same kind of environment except without shared mutable state: just pure values and pure functions.<br/><br/>My goal in exploring these ideas is, I think, a bit different from the FP community. I want to make programming easier, and programs easier to understand. To accomplish that, I want to eliminate "spooky action at a distance", and eliminate the need for non-local reasoning when reading and writing programs and understanding their behaviour. Shared mutable state, as I have defined it, entails spooky action at a distance, it is very nonlocal, so I want to eliminate it for that reason. I'm not interested in "mathematical purity" as an end in itself.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1623037292.066200"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1623037292.066200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2021-06-06 20:41</span><br/>
Mutable state is not the problem.<br/><br/>We want mutable state, but, we also want isolation.<br/><br/>In the spirit of hierarchical isolation, I’ve squirrelled my further discussion on this away into a hierarchical sub-node: <a href="https://guitarvydas.github.io/2021/06/06/Isolation-II.html">https://guitarvydas.github.io/2021/06/06/Isolation-II.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1623045043.066700"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1623045043.066700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-06-06 22:50</span><br/>
What's strange about the idea of hierarchical isolation is that wherever it's introduced, people seem to appreciate it (I remember hierarchical namespaces arriving in Python), and yet it's quite frequently forgotten in new designs. For example package managers. All package namespaces I have seen are flat.<br/>Another issue with hierarchical namespaces is who defines the names. We tend to make names an integral feature of artefacts, be they functions, classes, or packages. Name clashes are then inevitable over time. I think we'd be better off if names were assigned by a single authority (person, team, whatever) at each node in the hierarchy. Hard to be sure because as far as I know that has never been tried in practice.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1623068147.075900"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1623068147.075900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2021-06-07 05:15</span><br/>
a) failed experiments provide more information than successful experiments ; your observation implies that “something” is not “good enough” with that approach (maybe psychological)<br/><br/>b) true isolation = data isolation + control-flow isolation<br/><br/>(<br/><br/>[0] For example, CALL/RETURN does not isolate control-flow, it implies sequential operation, e.g. ‘var x = obj.method (...)’ is sequential ; Relational programming does not imply sequential operation (all control flow is handled by the engine), UNIX threads do not imply sequential operation (uber control flow is handled by the dispatcher), etc.).<br/><br/>.(<br/><br/>.[1] (meta) I am trying to respond in a hierarchical manner...<br/><br/>..(<br/><br/>..[2] fn(a)-&gt;b implies sequential operation ; the parameters are delivered in a “sequential block”, and the return value is delivered in a “sequential block” and the caller waits for a result.<br/><br/>...(<br/><br/>...[3] The caller does/can not care if the callee (a) lives-then-dies, or, (b) lives forever ((a) is function-like, (b) is server-like).<br/><br/>....(<br/><br/>....[4] Saying “x.fn(...)” implies that you know too much about “x”. That knowledge is hard-wired into the calling code and makes it hard to change later, aka accidental dependency (suggestion: all methods have only one calling syntax and all methods have the “same” parameter list syntactically (with the same type (!))<br/><br/>.....(<br/><br/>.....[5] The suggestion is not to delete type-checking, but to move it elsewhere (we already do that with compilers-&gt;opcodes (compilers can be viewed as type filters that strip away semantic information to produce untyped opcodes))<br/><br/>......(<br/><br/>......[6] In ‘var x = obj.method (...)’, you do not get to choose whether the operation is concurrent or sequential, the choice is made for you and baked into your code (aka accidental dependency (aka accidentally not-isolated)).<br/><br/><br/>))))))
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1623086310.080300"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1622048775.021900.html#1623086310.080300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-06-07 10:18</span><br/>
All valid points, but I suspect that the underlying cause for most of them is a systematic neglect of hierarchical modularity since the dawn of software development. Probably for good reasons, historically, but now it's hard to get away from the habits of the past.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
