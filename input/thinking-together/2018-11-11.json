[
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1541924440.201800",
        "client_msg_id": "d502c5c9-4ffa-4287-af73-edbc6a7b52ae",
        "text": "Yes, an actor system (messages passing) is a more precise thing than OO (messages sort of, classes sort of, the word \"encapsulation\" which may or may not refer to anything).\n\nIn the Quora discussion, Fidelman makes an interesting point about \"four separate processes touched each object\".  When the domain has a strong sequential\/hierarchical quality (e.g. a card game with turns and multiple phases in each turn), it's nice to use coroutines, two conceptual task trees: progress within the game modeled by one, state transitioning events flowing through another.  I guess even UNIX pipes work a bit like this: each program having its own thread with data passing through.  With extra plumbing, enough for the data to loop back around, well...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541745698.096700",
        "parent_user_id": "UA14TGLTC",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "s3E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, an actor system (messages passing) is a more precise thing than OO (messages sort of, classes sort of, the word \"encapsulation\" which may or may not refer to anything).\n\nIn the Quora discussion, Fidelman makes an interesting point about \"four separate processes touched each object\".  When the domain has a strong sequential\/hierarchical quality (e.g. a card game with turns and multiple phases in each turn), it's nice to use coroutines, two conceptual task trees: progress within the game modeled by one, state transitioning events flowing through another.  I guess even UNIX pipes work a bit like this: each program having its own thread with data passing through.  With extra plumbing, enough for the data to loop back around, well..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE0ETTCG7",
        "type": "message",
        "ts": "1541941716.202300",
        "client_msg_id": "64F3AB10-237E-4D7E-89F8-7917EBF29F01",
        "text": "Got it yeah that makes sense, but it brings up some follow-up questions like does that mean the GUI toolkit (e.g., equivalent of AppKit on macOS) is also part of Smalltalk? (Also it’s both funny and sad to think that iOS essentially is Unix without the terminal...)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8d5fa305f272",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-24\/1392332871012_8d5fa305f272f9d0c9e3_72.jpg",
            "first_name": "Roben",
            "real_name": "Roben Kleene",
            "display_name": "robenkleene",
            "team": "T5TCAFTA9",
            "name": "services",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541780906.114900",
        "parent_user_id": "UE0ETTCG7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "q1nLQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Got it yeah that makes sense, but it brings up some follow-up questions like does that mean the GUI toolkit (e.g., equivalent of AppKit on macOS) is also part of Smalltalk? (Also it’s both funny and sad to think that iOS essentially is Unix without the terminal...)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA8HY8R7B",
        "type": "message",
        "ts": "1541944707.202500",
        "client_msg_id": "7e94be49-91a2-48c0-9446-61e12a010a04",
        "text": "Since everything is very graphical the toolkits are very deeply ingrained. But Squeak eg has two: MVC (the original) and Morphic (the now default, ported from Self).\nFor me, Morphic is one of the strongest reasons for using Smalltalk. Makes all graphical tasks much more fun than in any other software platform I've ever used.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g7db3c1ad975",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e7db3c1ad975b0355d3047ca8acb7c54.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png",
            "first_name": "Nikolas",
            "real_name": "Nikolas Martens",
            "display_name": "Nikolas",
            "team": "T5TCAFTA9",
            "name": "nikolas.m",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541780906.114900",
        "parent_user_id": "UE0ETTCG7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "scw2+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Since everything is very graphical the toolkits are very deeply ingrained. But Squeak eg has two: MVC (the original) and Morphic (the now default, ported from Self).\nFor me, Morphic is one of the strongest reasons for using Smalltalk. Makes all graphical tasks much more fun than in any other software platform I've ever used."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U9ULPG0UA",
        "type": "message",
        "ts": "1541955927.202900",
        "client_msg_id": "6aa9e7c3-1624-4b14-8a3e-8f9d588f0ce8",
        "text": "The problem with OOP: everyone is so focused on building programs by modelling dogs and mammals, but they missed the fact that programs are more like verbs instead of nouns.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3c036b10dc41",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-11-08\/474908639235_3c036b10dc41ea25346a_72.jpg",
            "first_name": "",
            "real_name": "Caleb Helbling",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "caleb.helbling",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541955927.202900",
        "reply_count": 7,
        "reply_users_count": 5,
        "latest_reply": "1542094012.212500",
        "reply_users": [
            "UA8HY8R7B",
            "UBN9AFS0N",
            "UC6997THT",
            "UE0ETTCG7",
            "UCGAK10LS"
        ],
        "replies": [
            {
                "user": "UA8HY8R7B",
                "ts": "1541960342.203000"
            },
            {
                "user": "UBN9AFS0N",
                "ts": "1541960535.203200"
            },
            {
                "user": "UC6997THT",
                "ts": "1542010871.207300"
            },
            {
                "user": "UA8HY8R7B",
                "ts": "1542024436.207500"
            },
            {
                "user": "UE0ETTCG7",
                "ts": "1542042798.207800"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1542060383.210200"
            },
            {
                "user": "UA8HY8R7B",
                "ts": "1542094012.212500"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GmF8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The problem with OOP: everyone is so focused on building programs by modelling dogs and mammals, but they missed the fact that programs are more like verbs instead of nouns."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA8HY8R7B",
        "type": "message",
        "ts": "1541960342.203000",
        "client_msg_id": "57a6d535-4287-4e44-930e-d53117201c51",
        "text": "For me using objects as verbs turned out to work really well to model complex domains =)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g7db3c1ad975",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e7db3c1ad975b0355d3047ca8acb7c54.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png",
            "first_name": "Nikolas",
            "real_name": "Nikolas Martens",
            "display_name": "Nikolas",
            "team": "T5TCAFTA9",
            "name": "nikolas.m",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541955927.202900",
        "parent_user_id": "U9ULPG0UA",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yEB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For me using objects as verbs turned out to work really well to model complex domains =)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1541960535.203200",
        "client_msg_id": "aebec575-c0a4-458c-b819-6b0b85f93cd5",
        "text": "related, maybe you already read it <http:\/\/steve-yegge.blogspot.com\/2006\/03\/execution-in-kingdom-of-nouns.html>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541955927.202900",
        "parent_user_id": "U9ULPG0UA",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gZgy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "related, maybe you already read it "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/steve-yegge.blogspot.com\/2006\/03\/execution-in-kingdom-of-nouns.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC",
                    "U9ULPG0UA"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1541961447.203500",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1541961477.000000"
        },
        "client_msg_id": "97b486a5-85eb-4f2f-9bc0-169a85180130",
        "text": "<@UA8HY8R7B> - I have a question about Squeak. What are the key differences between Pharo and Squeak today? I understand Squeak was the original one and they share the VM. Where do they diverge in principles and purpose, etc?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541780906.114900",
        "parent_user_id": "UE0ETTCG7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rw5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA8HY8R7B"
                            },
                            {
                                "type": "text",
                                "text": " - I have a question about Squeak. What are the key differences between Pharo and Squeak today? I understand Squeak was the original one and they share the VM. Where do they diverge in principles and purpose, etc?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U5TCAFTD3",
        "type": "message",
        "ts": "1541961550.203800",
        "client_msg_id": "8a02b7fe-a010-4c2c-adc9-5bec2a696dd1",
        "text": "(I'm interviewing a pharo person on the podcast soon so this convo is very helpful for that. Keep it up!)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7c31dc735c6c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-09-11\/433781465829_7c31dc735c6c1257fe1f_72.jpg",
            "first_name": "Steve",
            "real_name": "Steve Krouse",
            "display_name": "stevekrouse",
            "team": "T5TCAFTA9",
            "name": "stevekrouse",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541780906.114900",
        "parent_user_id": "UE0ETTCG7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HV9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(I'm interviewing a pharo person on the podcast soon so this convo is very helpful for that. Keep it up!)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U8A5MS6R1",
                    "UE0ETTCG7"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1541962677.204000",
        "client_msg_id": "d45b359f-3072-4bd1-8add-f7660770cb8d",
        "text": "Sorry for adding to the confusion around OO vs actors. I'm fine with using 'actors'. The point I was trying to make was that 'just actors' aren't sufficient - there's no good reasoning model for the emergent system state and behavior - each actor state can just change willy nilly. But combine the actor model with the pseudo time idea and the functional transform idea and now we have something easier to reason about. The idea is that each message has a virtual timestamp and any time an actor processes a message, it produces a new version of itself 'functionally' while emitting messages with the next monotonic timestamps. The timestamp is also used in versioning the actors. So a specific timestamp represents the state of the whole system because it identifies a specific version of each actor (much like a commit id represents state of the whole tree in git).\n<@UCKRZS3DZ> proposed a similar idea earlier and I wrote a bit more detail in here: <https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1539812270000100?thread_ts=1539804704.000100&amp;cid=C5T9GPWFL>\n\nImportantly, my motivation for this isn't to just 'manage large systems', but to have a model that works both in the small _and_ in the large. We shouldn't have to give up powerful reasoning methods in the large, and there is plenty of concurrent logic in the small.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541745698.096700",
        "parent_user_id": "UA14TGLTC",
        "attachments": [
            {
                "from_url": "https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1539812270000100?thread_ts=1539804704.000100&amp;cid=C5T9GPWFL",
                "fallback": "[October 17th, 2018 2:37 PM] shalabh.chaturvedi: Very interesting. This here is a key observation, I believe:\n\n&gt;  If actors depend only from their input (received messages), then we can have live time-travel code editing. We can record all IO for processes, select moment in the middle, change code of process and start execution again. Create a new branch of history.\n\nI'm going to dig into this aspect a bit, and ignore the others for now, because it is the part I find most interesting.\n\nBasically computation processes are modeled as this transform:\n\n`messageIn + objectX@v1 --&gt; objectX@v2 + messageOut`\n\nAnd this is reliable, repeatable transform - aka 'functional'. This is the start of managed time.. if you keep the object history, you can go back to the older version and then replay the inputs to get exactly the same subsequent state. An interesting write-up about these ideas is: <https:\/\/www.quora.com\/Why-is-functional-programming-seen-as-the-opposite-of-OOP-rather-than-an-addition-to-it>\n\nExcerpts:\n&gt; this would allow “real objects” to be world-lines of their stable states and they could get to their next stable state in a completely functional manner.\n\n&gt; You really only want views to be allowed on stable objects\n\nThe above point is important, while the object is 'processing' the message, it doesn't process other messages, so it is only visible in its stable, consistent states.\n\nNow how do these individual objects compose as peers? Some ideas are in Pseudo Time (David Reed) and Virtual Time (David Jefferson). The main idea is to embed a 'pseudo time' in each and every message. So each object transformation propagates monotonically increasing pseudo times to the emitted messages. Now perhaps we can revert entire clusters of objects to previous, consistent states and replay some messages. If messages leave our system into a different world (e.g. the 'file system world' - then we've already lost) -- but if the whole system consists of objects modeled and incorporates the pseudo time, you can basically roll back any object (in theory). The pseudo time tracks which 'timeline' objects are part of, globally. (In practice even if you can't roll back, you'll know exactly where the system becomes inconsistent.)\n\nIMO this is the essence of the idea behind MVCC, git and datomic too, but they limit the idea to a subset of the system - just a dead data structure, and operate on it from the outside.\n\nThere are lot of details that would need to be worked out, e.g. if and how objects compose to form larger encapsulated structures? How is the object state and functional transform actually represented? Etc.",
                "ts": "1539812270.000100",
                "author_id": "U8A5MS6R1",
                "author_subname": "Shalabh Chaturvedi",
                "channel_id": "C5T9GPWFL",
                "is_msg_unfurl": true,
                "is_reply_unfurl": true,
                "text": "Very interesting. This here is a key observation, I believe:\n\n&gt;  If actors depend only from their input (received messages), then we can have live time-travel code editing. We can record all IO for processes, select moment in the middle, change code of process and start execution again. Create a new branch of history.\n\nI'm going to dig into this aspect a bit, and ignore the others for now, because it is the part I find most interesting.\n\nBasically computation processes are modeled as this transform:\n\n`messageIn + objectX@v1 --&gt; objectX@v2 + messageOut`\n\nAnd this is reliable, repeatable transform - aka 'functional'. This is the start of managed time.. if you keep the object history, you can go back to the older version and then replay the inputs to get exactly the same subsequent state. An interesting write-up about these ideas is: <https:\/\/www.quora.com\/Why-is-functional-programming-seen-as-the-opposite-of-OOP-rather-than-an-addition-to-it>\n\nExcerpts:\n&gt; this would allow “real objects” to be world-lines of their stable states and they could get to their next stable state in a completely functional manner.\n\n&gt; You really only want views to be allowed on stable objects\n\nThe above point is important, while the object is 'processing' the message, it doesn't process other messages, so it is only visible in its stable, consistent states.\n\nNow how do these individual objects compose as peers? Some ideas are in Pseudo Time (David Reed) and Virtual Time (David Jefferson). The main idea is to embed a 'pseudo time' in each and every message. So each object transformation propagates monotonically increasing pseudo times to the emitted messages. Now perhaps we can revert entire clusters of objects to previous, consistent states and replay some messages. If messages leave our system into a different world (e.g. the 'file system world' - then we've already lost) -- but if the whole system consists of objects modeled and incorporates the pseudo time, you can basically roll back any object (in theory). The pseudo time tracks which 'timeline' objects are part of, globally. (In practice even if you can't roll back, you'll know exactly where the system becomes inconsistent.)\n\nIMO this is the essence of the idea behind MVCC, git and datomic too, but they limit the idea to a subset of the system - just a dead data structure, and operate on it from the outside.\n\nThere are lot of details that would need to be worked out, e.g. if and how objects compose to form larger encapsulated structures? How is the object state and functional transform actually represented? Etc.",
                "author_name": "Shalabh Chaturvedi",
                "author_link": "https:\/\/futureprogramming.slack.com\/team\/U8A5MS6R1",
                "author_icon": "https:\/\/avatars.slack-edge.com\/2018-05-23\/369161290803_b1ceff98109db50c5f3e_48.jpg",
                "mrkdwn_in": [
                    "text"
                ],
                "id": 1,
                "original_url": "https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1539812270000100?thread_ts=1539804704.000100&amp;cid=C5T9GPWFL",
                "footer": "Thread in Slack Conversation"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AyYvH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sorry for adding to the confusion around OO vs actors. I'm fine with using 'actors'. The point I was trying to make was that 'just actors' aren't sufficient - there's no good reasoning model for the emergent system state and behavior - each actor state can just change willy nilly. But combine the actor model with the pseudo time idea and the functional transform idea and now we have something easier to reason about. The idea is that each message has a virtual timestamp and any time an actor processes a message, it produces a new version of itself 'functionally' while emitting messages with the next monotonic timestamps. The timestamp is also used in versioning the actors. So a specific timestamp represents the state of the whole system because it identifies a specific version of each actor (much like a commit id represents state of the whole tree in git).\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UCKRZS3DZ"
                            },
                            {
                                "type": "text",
                                "text": " proposed a similar idea earlier and I wrote a bit more detail in here: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1539812270000100?thread_ts=1539804704.000100&amp;cid=C5T9GPWFL",
                                "text": "https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1539812270000100?thread_ts=1539804704.000100&cid=C5T9GPWFL"
                            },
                            {
                                "type": "text",
                                "text": "\n\nImportantly, my motivation for this isn't to just 'manage large systems', but to have a model that works both in the small "
                            },
                            {
                                "type": "text",
                                "text": "and",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in the large. We shouldn't have to give up powerful reasoning methods in the large, and there is plenty of concurrent logic in the small."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCKRZS3DZ",
        "type": "message",
        "ts": "1541963160.204400",
        "client_msg_id": "8783ef22-27e8-49ed-96f9-d007027b6d4e",
        "text": "<@U8A5MS6R1> There is also Bloom project: <http:\/\/bloom-lang.net\/faq\/>\nAnd paper about Dedalus: <https:\/\/www2.eecs.berkeley.edu\/Pubs\/TechRpts\/2009\/EECS-2009-173.pdf>\nIt is somewhat related.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "222a2870915d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-15\/861537614034_222a2870915d24ec10cc_72.jpg",
            "first_name": "Vladimir",
            "real_name": "Vladimir Gordeev",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gordeev.vladimir.v",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541745698.096700",
        "parent_user_id": "UA14TGLTC",
        "attachments": [
            {
                "service_name": "Bloom Programming Language",
                "title": "FAQ",
                "title_link": "http:\/\/bloom-lang.net\/faq\/",
                "text": "What is Bloom?  What is BOOM? Bloom is a programming language for the cloud and other distributed computing systems. BOOM is the research project at UC Berkeley that is developing Bloom, as part of…",
                "fallback": "Bloom Programming Language: FAQ",
                "thumb_url": "https:\/\/s0.wp.com\/i\/blank.jpg",
                "ts": 1300666284,
                "from_url": "http:\/\/bloom-lang.net\/faq\/",
                "thumb_width": 200,
                "thumb_height": 200,
                "service_icon": "http:\/\/bloom-lang.net\/wp-content\/uploads\/2011\/03\/favicon-2.ico",
                "id": 1,
                "original_url": "http:\/\/bloom-lang.net\/faq\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Cd=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " There is also Bloom project: "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/bloom-lang.net\/faq\/"
                            },
                            {
                                "type": "text",
                                "text": "\nAnd paper about Dedalus: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www2.eecs.berkeley.edu\/Pubs\/TechRpts\/2009\/EECS-2009-173.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\nIt is somewhat related."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UA8HY8R7B",
        "type": "message",
        "ts": "1541964715.205000",
        "client_msg_id": "f3a2aa02-b479-4dc6-9560-b7afdf0f4cdb",
        "text": "<@U8A5MS6R1> Pharo is a fork of Squeak. I have the impression that the Pharo people try to modernize Smalltalk and move at a faster pace, but compromising the \"purity\" of Squeak. So I would say it's mostly philosophical differences but also a bunch of resulting technical ones. Quora has two good comments on that as well: <https:\/\/www.quora.com\/What-is-the-difference-between-Squeak-and-Pharo>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g7db3c1ad975",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e7db3c1ad975b0355d3047ca8acb7c54.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png",
            "first_name": "Nikolas",
            "real_name": "Nikolas Martens",
            "display_name": "Nikolas",
            "team": "T5TCAFTA9",
            "name": "nikolas.m",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541780906.114900",
        "parent_user_id": "UE0ETTCG7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HCwQl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " Pharo is a fork of Squeak. I have the impression that the Pharo people try to modernize Smalltalk and move at a faster pace, but compromising the \"purity\" of Squeak. So I would say it's mostly philosophical differences but also a bunch of resulting technical ones. Quora has two good comments on that as well: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.quora.com\/What-is-the-difference-between-Squeak-and-Pharo"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U85HCL7JP",
        "type": "message",
        "ts": "1541995639.205600",
        "client_msg_id": "cde8e343-d560-4f39-8884-714296c840e5",
        "text": "A couple of videos (from the Ruby community):\n- <https:\/\/www.youtube.com\/watch?v=eGaKZBr0ga4>\n- <https:\/\/www.youtube.com\/watch?v=HOuZyOKa91o>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c5d8f6a2266",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-25\/1286770110448_0c5d8f6a2266551a36f2_72.jpg",
            "first_name": "",
            "real_name": "Daniel Garcia",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "daniel.garcia.carmona",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541780906.114900",
        "parent_user_id": "UE0ETTCG7",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "MountainWest RubyConf 2014 - But Really, You Should Learn Smalltalk",
                "title_link": "https:\/\/www.youtube.com\/watch?v=eGaKZBr0ga4",
                "author_name": "Confreaks",
                "author_link": "https:\/\/www.youtube.com\/user\/Confreaks",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/eGaKZBr0ga4\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: MountainWest RubyConf 2014 - But Really, You Should Learn Smalltalk",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/eGaKZBr0ga4?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/www.youtube.com\/watch?v=eGaKZBr0ga4",
                "service_icon": "https:\/\/a.slack-edge.com\/2089\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=eGaKZBr0ga4"
            },
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "7 minutes of Pharo Smalltalk for Rubyists",
                "title_link": "https:\/\/www.youtube.com\/watch?v=HOuZyOKa91o",
                "author_name": "Avdi Grimm",
                "author_link": "https:\/\/www.youtube.com\/user\/4vdi",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/HOuZyOKa91o\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: 7 minutes of Pharo Smalltalk for Rubyists",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/HOuZyOKa91o?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/www.youtube.com\/watch?v=HOuZyOKa91o",
                "service_icon": "https:\/\/a.slack-edge.com\/2089\/img\/unfurl_icons\/youtube.png",
                "id": 2,
                "original_url": "https:\/\/www.youtube.com\/watch?v=HOuZyOKa91o"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X1M",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A couple of videos (from the Ruby community):\n- "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=eGaKZBr0ga4"
                            },
                            {
                                "type": "text",
                                "text": "\n- "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=HOuZyOKa91o"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1541999748.206000",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1541999782.000000"
        },
        "client_msg_id": "cb2fe2bb-c78c-4f4b-9595-80383e3e26fd",
        "text": "<@U8A5MS6R1> Actor systems aren’t replayable (deterministic) because they are inherently concurrent, and the time it takes to process, send, and receive messages is undefined (the global order of message receipt can vary between runs). However you can easily travel back in time as you suggest by logging all of the messages that actors receive along with snapshots of their state. IIRC this doesn’t have anything to do with managed time, however. “Managed time” as defined by Sean McDirmid and Jonathon Edwards (see “Programming with Managed Time”) and as used by Alan Kay refers to giving the programmer control over when memory mutation gets committed. Managed time is only relevant when looking beneath the actor model abstraction, when you’re looking at how an imperative computation that defines an actor’s state transition can be managed. It’s an approach to managing imperative programming in general. Therefore if actor state transitions are functional, then managed time isn’t needed.\n\nI agree that logging the execution of an actor system is good for debugging. If you haven’t seen how Elm does it already, I’d recommend checking it out (<https:\/\/www.youtube.com\/watch?v=oNogm31F2mo>). An Elm program is essentially one big actor that communicates with other anonymous actors through “ports”. When you put an Elm program into debug mode, the state of the program\/actor is logged for every message \/ state transition. You can click through this history to “rewind” the program to an earlier state, and see how each message changes the state. If I understand you correctly, this is essentially the experience you’re looking for.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541745698.096700",
        "parent_user_id": "UA14TGLTC",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "Debugging in Elm 0.18",
                "title_link": "https:\/\/www.youtube.com\/watch?v=oNogm31F2mo",
                "author_name": "Evan Czaplicki",
                "author_link": "https:\/\/www.youtube.com\/user\/eZap3",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/oNogm31F2mo\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Debugging in Elm 0.18",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/oNogm31F2mo?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/www.youtube.com\/watch?v=oNogm31F2mo",
                "service_icon": "https:\/\/a.slack-edge.com\/2089\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=oNogm31F2mo"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qVf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " Actor systems aren’t replayable (deterministic) because they are inherently concurrent, and the time it takes to process, send, and receive messages is undefined (the global order of message receipt can vary between runs). However you can easily travel back in time as you suggest by logging all of the messages that actors receive along with snapshots of their state. IIRC this doesn’t have anything to do with managed time, however. “Managed time” as defined by Sean McDirmid and Jonathon Edwards (see “Programming with Managed Time”) and as used by Alan Kay refers to giving the programmer control over when memory mutation gets committed. Managed time is only relevant when looking beneath the actor model abstraction, when you’re looking at how an imperative computation that defines an actor’s state transition can be managed. It’s an approach to managing imperative programming in general. Therefore if actor state transitions are functional, then managed time isn’t needed.\n\nI agree that logging the execution of an actor system is good for debugging. If you haven’t seen how Elm does it already, I’d recommend checking it out ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=oNogm31F2mo"
                            },
                            {
                                "type": "text",
                                "text": "). An Elm program is essentially one big actor that communicates with other anonymous actors through “ports”. When you put an Elm program into debug mode, the state of the program\/actor is logged for every message \/ state transition. You can click through this history to “rewind” the program to an earlier state, and see how each message changes the state. If I understand you correctly, this is essentially the experience you’re looking for."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC6997THT",
        "type": "message",
        "ts": "1542008176.206400",
        "client_msg_id": "d48d5098-6fef-48b0-85c9-0c17fae425b7",
        "text": "<@UCGR73CAY>, thank for your powerpoint on A* but it's pretty incomprehensible to me. It doesn't appear to be a visual programming language in the traditional sense where a visual programming language is clear at a glance to a non-programmer how things are working. Maybe that's not the definition of a visual programming language for others though.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "f3eb3ca69d86",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-08-13\/414472553296_f3eb3ca69d86feb77929_72.png",
            "first_name": "Gregg",
            "real_name": "Gregg Tavares",
            "display_name": "gman",
            "team": "T5TCAFTA9",
            "name": "slack1",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541742837.092100",
        "parent_user_id": "UC6997THT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "b\/GA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGR73CAY"
                            },
                            {
                                "type": "text",
                                "text": ", thank for your powerpoint on A* but it's pretty incomprehensible to me. It doesn't appear to be a visual programming language in the traditional sense where a visual programming language is clear at a glance to a non-programmer how things are working. Maybe that's not the definition of a visual programming language for others though."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC6997THT",
        "type": "message",
        "ts": "1542008318.206600",
        "client_msg_id": "75c9e641-67e0-419b-8130-f6e62eddc36b",
        "text": "As for Swift, can someone tell me what makes it special? At a glance it seemed to fit in the Java\/C#\/Kotlin category. Nothing stuck out that made it seem like more then that to me except it's by apple and so will get attention regardless of merit. (Not saying it's not full of merits, only that even if it wasn't it would be praised by apple fans :stuck_out_tongue: )",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "f3eb3ca69d86",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-08-13\/414472553296_f3eb3ca69d86feb77929_72.png",
            "first_name": "Gregg",
            "real_name": "Gregg Tavares",
            "display_name": "gman",
            "team": "T5TCAFTA9",
            "name": "slack1",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541742837.092100",
        "parent_user_id": "UC6997THT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kXcTe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As for Swift, can someone tell me what makes it special? At a glance it seemed to fit in the Java\/C#\/Kotlin category. Nothing stuck out that made it seem like more then that to me except it's by apple and so will get attention regardless of merit. (Not saying it's not full of merits, only that even if it wasn't it would be praised by apple fans "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue",
                                "unicode": "1f61b"
                            },
                            {
                                "type": "text",
                                "text": " )"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC6997THT",
        "type": "message",
        "ts": "1542008636.206800",
        "client_msg_id": "01d8d063-3783-43fc-a4d8-9f8caab11d86",
        "text": "One random thought that stuck out to me lately related to this. Many years ago Joel Spolsky wrote this article, Making Wrong code look Wrong\n\n<https:\/\/www.joelonsoftware.com\/2005\/05\/11\/making-wrong-code-look-wrong\/>\n\nI always loved that article and thought I should apply it but I never did and I never met anyone else that applied it. I wonder if the reasons are similar to the reasons some of the ideas in this thread are less applied.\n\nThe part about apps hungarian is arguably manually making types, the same type of types that something like F# or haskell give you for almost free. I'm not sure F# or haskell actually make the reasons for that type of naming entirely irrelevant. Of course the compiles will catch all the errors but when writing the code will I know the type at a glance or do I have to scan up and down the code to figure out what type this things is or rely on some ide to pop up the type somewhere.\n\nStill, it's interesting that the idea seemed great and I still didn't do it. What's wrong me?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "f3eb3ca69d86",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-08-13\/414472553296_f3eb3ca69d86feb77929_72.png",
            "first_name": "Gregg",
            "real_name": "Gregg Tavares",
            "display_name": "gman",
            "team": "T5TCAFTA9",
            "name": "slack1",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541742837.092100",
        "parent_user_id": "UC6997THT",
        "attachments": [
            {
                "service_name": "Joel on Software",
                "title": "Making Wrong Code Look Wrong",
                "title_link": "https:\/\/www.joelonsoftware.com\/2005\/05\/11\/making-wrong-code-look-wrong\/",
                "text": "Way back in September 1983, I started my first real job, working at Oranim, a big bread factory in Israel that made something like 100,000 loaves of bread every night in six giant ovens the size of…",
                "fallback": "Joel on Software: Making Wrong Code Look Wrong",
                "thumb_url": "https:\/\/i0.wp.com\/www.joelonsoftware.com\/wp-content\/uploads\/2016\/12\/11969842.jpg?fit=400%2C400&ssl=1",
                "ts": 1115770502,
                "from_url": "https:\/\/www.joelonsoftware.com\/2005\/05\/11\/making-wrong-code-look-wrong\/",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https:\/\/i0.wp.com\/www.joelonsoftware.com\/wp-content\/uploads\/2016\/12\/11969842.jpg?fit=180%2C180&#038;ssl=1",
                "id": 1,
                "original_url": "https:\/\/www.joelonsoftware.com\/2005\/05\/11\/making-wrong-code-look-wrong\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "82ZvZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One random thought that stuck out to me lately related to this. Many years ago Joel Spolsky wrote this article, Making Wrong code look Wrong\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.joelonsoftware.com\/2005\/05\/11\/making-wrong-code-look-wrong\/"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI always loved that article and thought I should apply it but I never did and I never met anyone else that applied it. I wonder if the reasons are similar to the reasons some of the ideas in this thread are less applied.\n\nThe part about apps hungarian is arguably manually making types, the same type of types that something like F# or haskell give you for almost free. I'm not sure F# or haskell actually make the reasons for that type of naming entirely irrelevant. Of course the compiles will catch all the errors but when writing the code will I know the type at a glance or do I have to scan up and down the code to figure out what type this things is or rely on some ide to pop up the type somewhere.\n\nStill, it's interesting that the idea seemed great and I still didn't do it. What's wrong me?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1542009036.207100",
        "client_msg_id": "ca3c4cf5-2748-4987-a8b9-9d7dc438af39",
        "text": "In Haskell, I think people generally annotate often enough that they don't get confused, soft of a vector for factoring functions.  More often it's the compiler that gets \"confused\" trying to unify a typo in the most majestic of ways.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1541742837.092100",
        "parent_user_id": "UC6997THT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "F\/Q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Haskell, I think people generally annotate often enough that they don't get confused, soft of a vector for factoring functions.  More often it's the compiler that gets \"confused\" trying to unify a typo in the most majestic of ways."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]