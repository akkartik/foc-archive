[
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1757062112.414959",
        "client_msg_id": "74af2d40-66ef-44dd-b95b-05c7f6c99f35",
        "text": "I mostly agree with this analysis. The main challenge I see to coming up with better architectures at various levels is the inertia of existing software that we all depend on. Better architecture needs to come with a transition path from current technology.\n\nYou mention containers as one example. They allow to turn a blob of current technology into a relatively isolated component (relatively because in practice, most containers I see need access to the host's local file system). But communication between containers, and thus building systems from containers, is still at a prototype level at best. And the techniques we use to make containers from software components are baroque and brittle as well.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1757043859.922179",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fdMSY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I mostly agree with this analysis. The main challenge I see to coming up with better architectures at various levels is the inertia of existing software that we all depend on. Better architecture needs to come with a transition path from current technology.\n\nYou mention containers as one example. They allow to turn a blob of current technology into a relatively isolated component (relatively because in practice, most containers I see need access to the host's local file system). But communication between containers, and thus building systems from containers, is still at a prototype level at best. And the techniques we use to make containers from software components are baroque and brittle as well."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U096YUBC3KP",
        "type": "message",
        "ts": "1757121589.447339",
        "client_msg_id": "1cb56fd3-a0fc-472d-9fb7-a01931b34239",
        "text": "I'd have preferred some more specifics here. For example, while I haven't touched much electrical engineering since university, I remember spending a lot of time looking at pinouts and timing diagrams to work out how to conform to the API a particular chip needed. How is that different to type checking?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cbd73c13a9fb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-07-24\/9258602927281_cbd73c13a9fbc1999873_72.jpg",
            "first_name": "Daniel",
            "real_name": "Daniel Buckmaster",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "daniel961",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1757043859.922179",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A6nDj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd have preferred some more specifics here. For example, while I haven't touched much electrical engineering since university, I remember spending a lot of time looking at pinouts and timing diagrams to work out how to conform to the API a particular chip needed. How is that different to type checking?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1757124962.131949",
        "client_msg_id": "3138de27-a147-4bac-8903-9701463287eb",
        "text": "<@UJBAJNFLK> I agree, but I don't see the challenge as being very daunting. The answers lie in plain sight. I think we saw the early glimmers of solutions in the 1970s\/1980s, e.g. with things like UNIX processes.\n\nThe original point of programming languages was to cause hardware to act in certain ways. The idea of \"a programming language\" was a caveman approach to programming hardware, necessitated by the limitations of early hardware, storage devices, etc. There was a pre-Cambrian explosion of various ways to build small programming paradigms, e.g. Forth, Lisp, Icon, Prolog, Smalltalk, etc., etc. Even FP was invented early on, but was sneered at for being too bloatful (today, it's still bloatful, but monetarily cheaper). One of the best ideas for programming hardware - UNIX and other O\/Ss - were kinda side-stepped as fundamental programming paradigms in the rush to push FP forward.\n\nThe word \"programming\" has been repurposed to mean using only one of the possible options - FP, PVRsubroutine-based (\"functions\") - to program hardware. In fact, FP's sweet spot is that of converting hardware into calculators, but our \"we've always done it this way\" mentality has pushed non-FP concepts into FP and into CPU chips. CompSci has become the study of how to further push FP forward as THE single chosen notation for programming.\n\nIt appears that the basics of UNIX-y processes have been overlooked. CompSci relies on the existence of processes as scaffolding for FP, but overlooks the option to use these very principles as the substrate for program development, i.e. pure dataflow disentangled from accompanying control flow, total isolation, multi-language (actually multi-paradigm) and instead concentrates on pushing forward the outdated concepts of \"programming languages\".\n\nThe 0D \/ PBP stuff I've been tinkering with shows that processes can be liberated from heavy-weight concepts using more modern, but very common techniques (closures, queues, GC). OhmJS shows that we can rapidly build less-pathetic syntaxes than what we had in early paradigm-specific languages. T2T shows that we don't have to build compilers any more (we just need to build transpilers that map new languages onto already-existing compilers). The 0D \/ PBP stuff also shows that we can treat off-the-shelf drawing editors like program editors without being enslaved by 600 year old Gutenberg type-setting ideas. The current 0D \/ PBP stuff shows that we can use multiple languages in creating a single program (e.g. in one case, I built an SCN that used Prolog  + Javascript + bash)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1757043859.922179",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ekpJb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " I agree, but I don't see the challenge as being very daunting. The answers lie in plain sight. I think we saw the early glimmers of solutions in the 1970s\/1980s, e.g. with things like UNIX processes.\n\nThe original point of programming languages was to cause hardware to act in certain ways. The idea of \"a programming language\" was a caveman approach to programming hardware, necessitated by the limitations of early hardware, storage devices, etc. There was a pre-Cambrian explosion of various ways to build small programming paradigms, e.g. Forth, Lisp, Icon, Prolog, Smalltalk, etc., etc. Even FP was invented early on, but was sneered at for being too bloatful (today, it's still bloatful, but monetarily cheaper). One of the best ideas for programming hardware - UNIX and other O\/Ss - were kinda side-stepped as fundamental programming paradigms in the rush to push FP forward.\n\nThe word \"programming\" has been repurposed to mean using only one of the possible options - FP, PVRsubroutine-based (\"functions\") - to program hardware. In fact, FP's sweet spot is that of converting hardware into calculators, but our \"we've always done it this way\" mentality has pushed non-FP concepts into FP and into CPU chips. CompSci has become the study of how to further push FP forward as THE single chosen notation for programming.\n\nIt appears that the basics of UNIX-y processes have been overlooked. CompSci relies on the existence of processes as scaffolding for FP, but overlooks the option to use these very principles as the substrate for program development, i.e. pure dataflow disentangled from accompanying control flow, total isolation, multi-language (actually multi-paradigm) and instead concentrates on pushing forward the outdated concepts of \"programming languages\".\n\nThe 0D \/ PBP stuff I've been tinkering with shows that processes can be liberated from heavy-weight concepts using more modern, but very common techniques (closures, queues, GC). OhmJS shows that we can rapidly build less-pathetic syntaxes than what we had in early paradigm-specific languages. T2T shows that we don't have to build compilers any more (we just need to build transpilers that map new languages onto already-existing compilers). The 0D \/ PBP stuff also shows that we can treat off-the-shelf drawing editors like program editors without being enslaved by 600 year old Gutenberg type-setting ideas. The current 0D \/ PBP stuff shows that we can use multiple languages in creating a single program (e.g. in one case, I built an SCN that used Prolog  + Javascript + bash)"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]