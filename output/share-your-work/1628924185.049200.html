<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../share-your-work/1628924185.049200.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robin Allison</b>
<span style="margin:2em; color:#606060">2021-08-13 23:56</span><br/>
I'd like to make a general point: Arbitrary mathematical statements formulated symbolically can be formulated with concrete dynamic variables instead (by which I mean concrete values you can change and whose instances are all kept in sync). Here is an example of this with the pythagorean theorem. <a href="https://www.youtube.com/watch?v=QemB5t94slc">https://www.youtube.com/watch?v=QemB5t94slc</a> Normally it would read "If a,b, and c are the lengths of the two legs and the hypotenuse respectively of a right triangle then a^2+b^2=c^2". However, this is equivalent to an expression with dynamic variables, as illustrated in the video. Any instance of the general theorem can be achieved by altering the values of the dynamic variables to that particular instance. Moreover, no matter how the values of the formulation with dynamic variables is altered the resulting statement will always be an instance of the pythagorean theorem because the values at different locations are always kept in sync. Thus, insofar as the two formulations have the same instances, the two are equivalent. (also, modulo the fact that the present scrubbing mechanism can only produce integers).<br/><br/>This is part of a broader set of ideas I'm exploring. I'm trying to develop a theory of what I'm terming "formal dynamic mathematics." By dynamic mathematics I mean mathematics employing dynamic variables, and which aren't necessarily "mathematical objects" (any sort of set) but could be interactive visual elements such as a line segment which you can move around and whose length you can alter or metamathematical objects such as variable names. These sorts of variables abound in geogebra, bret victors work, apparatus (Toby Schachman), and pane (Joshua Horowitz), among other 'live' systems. I think we would benefit from a more systematic understanding of the interface primitives that go into them.<br/><br/>We can roughly analyze these applications in terms of three primitives: transclusion, evaluation, and varriers. By transclusion I mean the live copying of the contents of one part of a page into another part of the page. Having a transclusion from one region to another and another back again ensures that those two regions will always have the same value, effectively yielding a variable without a name or a value. Evaluation is a relation between different regions of a page where the values in different regions of the page are operated on and displayed in another location.  Finally, varriers are primitives having values and modes of interaction. A scrubbable number is an example of a varrier. (apologies for the neologism; suggestions for better words or similar vocabulary is welcome)<br/><br/>Just as normal formal mathematics is built out of its own primitives (sequences of symbols and rules of inference) formal dynamic mathematics is built out of the above primitives. Inferences rules can be formalized as evaluation schemas so constructions in these systems are proofs.<br/><br/>Although this kind of math could be used to design end user programming systems, I'm mostly interested in its application to math itself, as an extension of the language of math at a fundamental level. An idea I've been exploring this year substantially has been how to develop an entirely visual language (save for the logical connectives of propositional and predicate calculus) for vector algebra, without any symbols, and in particular to be able to state and prove the pythagorean theorem from axioms. (This problem was pretty much posed by Hamish Todd about a year ago).  Dynamic variables and varriers (for visual vectors) easily let you do away with symbolic variables. This reduces the problem to devising a visualization for concrete static terms built with functions. We can easily visualize terms like (1,2)+(3,5), and proj_{(1,1)}(4,5) but visualizations for more complex terms generally seem ad hoc. I think there is a solution here, but it's a matter of understanding why there isn't an ideal solution, and I don't understand that well enough at this point to share.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1629565204.059600"></a>
      <img src="https://avatars.slack-edge.com/2024-10-07/7839204665394_bc2773fc791e2b5def2b_72.png" style="float:left"/>
      <a href="../share-your-work/1628924185.049200.html#1629565204.059600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pablo Donato</b>
<span style="margin:2em; color:#606060">2021-08-21 10:00</span><br/>
Thank you for sharing! I really love the idea of interactive formal theory as a strict generalization of traditional formal theory, with its own metatheory built on fundamental interface primitives. Hereafter are some thoughts on the primitives you proposed (and other things).<br/><br/>You said <b>transclusion</b> maps to the concept of variable in logic, but stripped of its naming mechanism. I wonder how you compensate for this loss? I believe having the ability to observe live updates through direct manipulation is not enough to capture the functionality of naming. Indeed there will often be an infinite domain of updates, and thus when you discover the system you cannot be sure that there isn't some particular update that results in different contents for the two regions. One solution would be to have clear visual indicators that distinguish transclusion from evaluation relations between regions, which might just be a manifestation of the special status of identity morphisms in category theory (which in turn correspond to the variables of type theory).<br/><br/><b>Evaluation</b> looks like reactive evaluation of (pure) functions. How do you represent the function itself though in this paradigm? Do you have some kind of intensional description, or is it purely extensional as in Conal Elliott's <a href="https://www.youtube.com/watch?v=faJ8N0giqzw">Tangible Functional Programming</a>, where you can only compose from a base of primitive combinators? Is it related to the problem you raise of devising a visualization for concrete static terms built with functions? This is something I've thought about as the "generic notation problem", and as you say I firmly believe there is no ideal solution. I would even argue that a large part of mathematical creativity boils down to finding optimal representations, in the sense that our brains can manipulate without too much pain adequately general classes of objects, given adequately general purposes.<br/><br/>To follow on your linear algebra examples, <a href="https://www.youtube.com/watch?v=kYB8IZa5AuE&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab&amp;index=3">3blue1brown explains</a> how matrices are a nice syntax for linear maps, given you're interested in performing calculations on them; but his dynamic animations of the plane as an infinite 2D grid are way better at giving you an intuition of the nature and regularities that characterize linear maps in the first place. And examples abound in the history of mathematics where the invention of a clever notation opened up a whole new area of inquiry (think of the birth of algebraic geometry with <a href="https://en.wikipedia.org/wiki/Algebraic_geometry#Before_the_16th_century">cartesian coordinates</a>, or modern calculus with <a href="https://en.wikipedia.org/wiki/Calculus#Modern">Leibniz's infinitesimals</a>).<br/><br/>So it even seems <em>counterproductive</em> to me to look for a generic notation, since the more general the class of object it captures, the less efficient it will be for our brain to process. What we can do however, and this is somewhat of a trend here on FoC, is design a <em>system for building notations</em>. It could be some kind of API mediating between high-level graphical representations and their low-level logical encoding, a sort of "Notation Server Protocol". The only example I can think of that comes close to this is the <a href="https://hal.inria.fr/hal-01261698/document">FIGUE engine</a> developed at INRIA for the (now abandoned) <a href="https://www-sop.inria.fr/croap/ctcoq/ctcoq-eng.html">CtCoq project</a>, which was quite visionary since it is now <em>25 years old</em>.<br/><br/><b>Varriers</b> remind me of the <a href="https://web.eecs.umich.edu/~comar/livelits-tyde.pdf">livelits</a> of Hazel, although pushing the analogy would mean that they can themselves incorporate transclusions and evaluations, which might be too powerful for what you have in mind.<br/><br/>To conclude these lengthy reflections, a little bit of self-promotion: I am currently designing a visual language for building proofs in propositional logic, based on a biochemical metaphor of charged ions and cell membranes. For the moment I am more focused on its proof-theoretical properties, but it might prove to be quite intuitive if implemented right, and would make your language completely visual :slightly_smiling_face:. Interestingly its extension to predicate logic could also make use of the concept of transclusion...
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1630036861.000200"></a>
      <img src="https://secure.gravatar.com/avatar/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../share-your-work/1628924185.049200.html#1630036861.000200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robin Allison</b>
<span style="margin:2em; color:#606060">2021-08-26 21:01</span><br/>
<span style="background-color:#ccf">@Pablo Donato</span>  Thanks for the thoughtful response!<br/><br/>"You said transclusion maps to the concept of variable in logic, but stripped of its naming mechanism. I wonder how you compensate for this loss? I believe having the ability to observe live updates through direct manipulation is not enough to capture the functionality of naming. Indeed there will often be an infinite domain of updates, and thus when you discover the system you cannot be sure that there isn't some particular update that results in different contents for the two regions. One solution would be to have clear visual indicators that distinguish transclusion from evaluation relations between regions, which might just be a manifestation of the special status of identity morphisms in category theory (which in turn correspond to the variables of type theory)."<br/><br/>    To jump ahead a little here, what I'm really after is applying these primitives back onto symbolic math, or to use them in combination with visuals. I think to do math without any symbolic variables would probably be more challenging in many contexts, but in order to develop these ideas I don't want symbolic variables to be a crutch. So at this point it is more of an artificial restriction I'm imposing to generate general principles.<br/><br/>    That said, one idea is to really lean into "visible connections" component of transclusion as Ted Nelson would put it. That is, instead of the primitive being solely visible through the behavior it produces, there is an actual line or something connecting them that you can see. This may still not be as functional as naming variables, but its sufficient for expressing formal math without named variables, no? (I'm not trying to do without function symbols at this point)<br/><br/>    So I think transclusion plays very well by itself. But once you start mixing it with evaluation I'm not sure how to distinguish them exactly. The two ideas floating around in my mind are (1) evaluation is something associated to particular regions which you still have contents transcluded into, its just that those contents are immediately operated on, and (2) evaluation is an arrow between regions and transclusion is just the identity. (Also, whats this about identity morphisms in category theory corresponding to variables in type theory? Is that like identity morphisms correspond to objects correspond to variables?)<br/><br/>"Evaluation looks like reactive evaluation of (pure) functions. How do you represent the function itself though in this paradigm? Do you have some kind of intensional description, or is it purely extensional as in Conal Elliott's Tangible Functional Programming, where you can only compose from a base of primitive combinators?"<br/><br/>    Hmm, my logic/cs knowledge might not be up to snuff for these questions. I'm not entirely familiar with the intensional/extensional distinction, and I only have a shallow understanding of Conal's paper, but saying its composing from a base of primitive combinators sounds about right.<br/><br/>    Evaluation also might not be the best term for the kind of primitive I'm thinking about because often there isn't any expression that is being evaluated. Maybe "dynamic functions" would be a better term? For instance you would have an evaluation that "evaluates" the vector (2,3) to the visual vector in the xy plane. So at least some of these functions are primitives.<br/><br/>    I also see how it would be desirable to be able to be able to construct these evaluation relations symbolically, although I haven't thought about how you would do this. But my suspicion is that there should be primitive combinators that let you build evaluation relations from symbolic relations.<br/><br/>"Is it related to the problem you raise of devising a visualization for concrete static terms built with functions? This is something I've thought about as the "generic notation problem", and as you say I firmly believe there is no ideal solution. I would even argue that a large part of mathematical creativity boils down to finding optimal representations, in the sense that our brains can manipulate without too much pain adequately general classes of objects, given adequately general purposes."<br/><br/>    I wouldn't say its so related to this problem. Its related insofar as a visualization for terms of vector algebra is an evaluation relation. So there is the question of how to regard these evaluation relations generally and the question of which evaluation relation to use for visualizing terms of vector algebra.<br/><br/>    If the visualization of a composite term depends only on the visualization of subterms and the visualization displays each of the intermediate values then static visualizations of concrete terms give you dynamic visualizations of abstract terms. I think its interesting to ask about properties of visualizations that we wouldn't normally consider, e.g. visualizing "proj_c(a+b)" not as the usual image, but with vectors a, b, c, that you can change, and vectors value(a+b), and value(proj_c(a+b)) that dynamically change depending on those values (i.e. every vector eminates from the origin). Using this schema are you able to recover the symbolic expression? I believe you can, but only if you have a known set of functions you are visualizing. Otherwise behavior alone isn't sufficient and you need to have some explicit way of referencing the dynamic functions that build up the visual term.<br/><br/>    My interest in these visual proofs is a little stranger than I think it appears. I'm not so interested in the visualizations for their own sake, but as a source of patterns for new formal relations. I think interactive visualizations can not only serve as an independent formalism for vector algebra, but that they naturally express certain kinds of formal relations that surpass the expressivity of normal symbolic math and this is something that can be imported back into and enrich symbolic math. I see this as connected with expressing intertextual math or math involving many different formalisms at once and being able to move between them. This is really unsubstantiated at this point, but that's what I'm trying to work towards. Super weird right?<br/><br/>"So it even seems counterproductive to me to look for a generic notation, since the more general the class of object it captures, the less efficient it will be for our brain to process. What we can do however, and this is somewhat of a trend here on FoC, is design a system for building notations. It could be some kind of API mediating between high-level graphical representations and their low-level logical encoding, a sort of "Notation Server Protocol". The only example I can think of that comes close to this is the FIGUE engine developed at INRIA for the (now abandoned) CtCoq project, which was quite visionary since it is now 25 years old."<br/><br/>    I feel like this is such a minimum of what is needed, but that we don't is a little mind blowing. But it also makes sense. Efforts to formalize math on computers are overwhelmingly aimed at ensuring there are no serious gaps in the dizzying heights of pure math, e.g. the recent liquid tensor experiment. It's not to transform how people think about math. If your goal is merely verification then you don't need that kind of an API.<br/><br/>"To conclude these lengthy reflections, a little bit of self-promotion: I am currently designing a visual language for building proofs in propositional logic, based on a biochemical metaphor of charged ions and cell membranes. For the moment I am more focused on its proof-theoretical properties, but it might prove to be quite intuitive if implemented right, and would make your language completely visual :slightly_smiling_face:. Interestingly its extension to predicate logic could also make use of the concept of transclusion..."<br/><br/>    Awesome, you better share more at some point though!
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
