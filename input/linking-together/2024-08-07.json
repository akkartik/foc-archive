[
    {
        "user": "U03CEGR3HSL",
        "type": "message",
        "ts": "1723036486.004619",
        "client_msg_id": "15693118-1152-455a-8895-aa4b2b26c1a4",
        "text": "<@U06SS0DHZD1> I'm trying to say that I find the whole concept of subjectivity irrelevant to this discussion, since the functions and procedures we are discussing are 100% deterministic, meaning they can be translated with absolute fidelity. \n\nTo take a broader perspective, it also makes intuitive sense that there are functions that cannot be computed, because there are an uncountable number of functions but there are a countable number of programs. \n\nIt also makes intuitive sense that the halting problem cannot be solved, because if it could it would allow us to trivially answer many deep problems, including many unsolved problems. \n\nFor example, we do not know if there are any odd perfect numbers. If we had a solution to the halting problem, we could write a program that tests all odd numbers and halts if it finds one that is perfect. We could then use our halts function to determine whether this program will ever find an odd perfect number. \n\nOr consider the Collatz Conjecture. Take a number. If it's even, divide by two. If it's odd, multiply by 3 and add 1. With enough repetition, do all positive integers converge to one? \n\nIf we had a halts function, we could use it to write another function that determines whether an integer converges to one. We could then use that function to write a program that halts if it finds a number that does not converge to one. We could then use our halts function to determine whether that function halts and thus the truth of the conjecture. \n\nIt would also be possible to write a program that tests all possible solutions to Fermat's Last Theorem and halts if it finds one. Again, our hypothetical halts function could tell us whether the theorem is true or false.\n\nThe sheer power of such a function to easily solve so many questions that have remained unanswered for so long, questions which vary widely in the structure and concepts involved, makes it seem too good to be true.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g7fd1bd5c536",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Personal",
            "real_name": "Personal Dynamic Media",
            "display_name": "Personal Dynamic Media",
            "team": "T5TCAFTA9",
            "name": "personaldynamicmedia",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722203618.856599",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YhjWH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U06SS0DHZD1"
                            },
                            {
                                "type": "text",
                                "text": " I'm trying to say that I find the whole concept of subjectivity irrelevant to this discussion, since the functions and procedures we are discussing are 100% deterministic, meaning they can be translated with absolute fidelity. \n\nTo take a broader perspective, it also makes intuitive sense that there are functions that cannot be computed, because there are an uncountable number of functions but there are a countable number of programs. \n\nIt also makes intuitive sense that the halting problem cannot be solved, because if it could it would allow us to trivially answer many deep problems, including many unsolved problems. \n\nFor example, we do not know if there are any odd perfect numbers. If we had a solution to the halting problem, we could write a program that tests all odd numbers and halts if it finds one that is perfect. We could then use our halts function to determine whether this program will ever find an odd perfect number. \n\nOr consider the Collatz Conjecture. Take a number. If it's even, divide by two. If it's odd, multiply by 3 and add 1. With enough repetition, do all positive integers converge to one? \n\nIf we had a halts function, we could use it to write another function that determines whether an integer converges to one. We could then use that function to write a program that halts if it finds a number that does not converge to one. We could then use our halts function to determine whether that function halts and thus the truth of the conjecture. \n\nIt would also be possible to write a program that tests all possible solutions to Fermat's Last Theorem and halts if it finds one. Again, our hypothetical halts function could tell us whether the theorem is true or false.\n\nThe sheer power of such a function to easily solve so many questions that have remained unanswered for so long, questions which vary widely in the structure and concepts involved, makes it seem too good to be true."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06SS0DHZD1",
        "type": "message",
        "ts": "1723061779.482539",
        "client_msg_id": "20d8dce4-d653-4de4-ae34-5bfab8df43a0",
        "text": "&gt; <@U06SS0DHZD1> I'm trying to say that I find the whole concept of subjectivity irrelevant to this discussion, since the functions and procedures we are discussing are 100% deterministic, meaning they can be translated with absolute fidelity. \n&gt; \nIs it though? How would you approach my last question then? The one about \"prints No\" function.\n\n&gt; It also makes intuitive sense that the halting problem cannot be solved, because if it could it would allow us to trivially answer many deep problems, including many unsolved problems. \n&gt; \nNobody is saying that the solution would be trivial. The author of the video is just saying that the Turing's argument (and it's extensions) seem to be fundamentally flawed.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "287ba5559ee1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-04-04\/6922823105585_287ba5559ee1cedd6b98_72.png",
            "first_name": "Marek",
            "real_name": "Marek Rogalski",
            "display_name": "maf",
            "team": "T5TCAFTA9",
            "name": "mafikpl",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722203618.856599",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rwNe3",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U06SS0DHZD1"
                            },
                            {
                                "type": "text",
                                "text": " I'm trying to say that I find the whole concept of subjectivity irrelevant to this discussion, since the functions and procedures we are discussing are 100% deterministic, meaning they can be translated with absolute fidelity. \n"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIs it though? How would you approach my last question then? The one about \"prints No\" function.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It also makes intuitive sense that the halting problem cannot be solved, because if it could it would allow us to trivially answer many deep problems, including many unsolved problems. \n"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nNobody is saying that the solution would be trivial. The author of the video is just saying that the Turing's argument (and it's extensions) seem to be fundamentally flawed."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U0258UX5F1C"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U03CEGR3HSL",
        "type": "message",
        "ts": "1723063029.443559",
        "client_msg_id": "9fa193b5-afaa-4db0-b36e-91f8a2e74ec4",
        "text": "<@U06SS0DHZD1> \n&gt; Is it though? How would you approach my last question then? The one about \"prints No\" function.\n&gt; \nIf you write the function first, and commit to a particular Oracle when you write it, then I can create an Oracle that gives the correct answer for that particular function. All that proves is that the behavior of that one function is decidable. It does not invalidate the proof that it is not possible to create a generalized Oracle that always computes, in finite time, an accurate answer to the question of whether a program prints out \"no.\"\n\nOn the other hand, if I hypothesize an Oracle that accurately determines whether a program prints out \"no,\" for any Oracle that I hypothesize it is possible to construct at least one program for which it gives an incorrect answer, meaning that no such Oracle can exist.\n\nThe fact that the program could be on a different computer or could be written in a different language does not change the fact that a program can always be written for which the Oracle gives the wrong answer. My point is that order matters here. FIRST you must commit to an Oracle and THEN you can create a program for which it fails. Subjectivity provides a way to write the program first and then create an Oracle that works for a particular class of programs, but it does not address the core argument that assuming the existence of an Oracle leads to a contradiction.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g7fd1bd5c536",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Personal",
            "real_name": "Personal Dynamic Media",
            "display_name": "Personal Dynamic Media",
            "team": "T5TCAFTA9",
            "name": "personaldynamicmedia",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722203618.856599",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "axpys",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U06SS0DHZD1"
                            },
                            {
                                "type": "text",
                                "text": " \n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is it though? How would you approach my last question then? The one about \"prints No\" function.\n"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIf you write the function first, and commit to a particular Oracle when you write it, then I can create an Oracle that gives the correct answer for that particular function. All that proves is that the behavior of that one function is decidable. It does not invalidate the proof that it is not possible to create a generalized Oracle that always computes, in finite time, an accurate answer to the question of whether a program prints out \"no.\"\n\nOn the other hand, if I hypothesize an Oracle that accurately determines whether a program prints out \"no,\" for any Oracle that I hypothesize it is possible to construct at least one program for which it gives an incorrect answer, meaning that no such Oracle can exist.\n\nThe fact that the program could be on a different computer or could be written in a different language does not change the fact that a program can always be written for which the Oracle gives the wrong answer. My point is that order matters here. FIRST you must commit to an Oracle and THEN you can create a program for which it fails. Subjectivity provides a way to write the program first and then create an Oracle that works for a particular class of programs, but it does not address the core argument that assuming the existence of an Oracle leads to a contradiction."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U03CEGR3HSL",
        "type": "message",
        "ts": "1723063461.323959",
        "client_msg_id": "de88d977-8007-474f-b4a2-f4cfccb8c3c8",
        "text": "Let me put it this way. If you give me an Oracle written in Python that analyzes Pascal programs and tells me whether they print \"no\" then I can translate that Oracle into Pascal and construct a program for which it gives the wrong answer. Even with the benefit of subjectivity, the Oracle still fails.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g7fd1bd5c536",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Personal",
            "real_name": "Personal Dynamic Media",
            "display_name": "Personal Dynamic Media",
            "team": "T5TCAFTA9",
            "name": "personaldynamicmedia",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1722203618.856599",
        "parent_user_id": "U018S42NMMM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Wab17",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Let me put it this way. If you give me an Oracle written in Python that analyzes Pascal programs and tells me whether they print \"no\" then I can translate that Oracle into Pascal and construct a program for which it gives the wrong answer. Even with the benefit of subjectivity, the Oracle still fails."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]