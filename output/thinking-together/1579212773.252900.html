<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2020-01-16 14:12</span><br/>
On “missing” values, null and undefined aren’t the same as an empty string. For example, if there’s an object for a person’s name that has a middle name field, does empty string mean 1) “we know that this person has no middle name”, 2) “we don’t know” or 3) we haven’t yet been asked or tried to input this”? Another example is when you want an undefined attribute to inherit from some delegate. Empty string can’t serve this purpose because it may mean “we know this value is an empty string” instead of “we want this value to be inherited”.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579212996.255300"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579212996.255300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2020-01-16 14:16</span><br/>
the delegate thing isn't something covered in the Twitter thread AFAIR
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579212998.255600"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579212998.255600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-16 14:16</span><br/>
There was a good Rich Hickey talk about this a little over a year ago, if memory serves. He critiqued the use of Maybe in Haskell to represent something that either has a non-empty value, or does not have a value, for the reasons stated. Can't remember which talk, but I can probably look it up if there's interest.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579213041.255800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579213041.255800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-16 14:17</span><br/>
Unlike zero, which was invented very early in maths, how come we never needed the empty string until we started working with computers?<br/><br/>There could be one, two or fifty different reasons a value is missing - it depends on the problem domain. There is no universal understanding for how these reasons maps onto the empty string, null or any other undefined object that's provided.<br/><br/>The only right solution seems to be to have a domain specific enum for the missing reason, and use an empty string as the value.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579213108.256100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579213108.256100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-16 14:18</span><br/>
I elaborate in this comment: <a href="https://josjong.com/2017/10/16/null-vs-empty-strings-why-oracle-was-right-and-apple-is-not/#comment-79">https://josjong.com/2017/10/16/null-vs-empty-strings-why-ora&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579213234.256600"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579213234.256600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-16 14:20</span><br/>
This talk? <a href="https://www.youtube.com/watch?v=YR5WdGrpoug">https://www.youtube.com/watch?v=YR5WdGrpoug</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579221903.258400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579221903.258400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-16 16:45</span><br/>
&gt; <span style="background-color:#ccf">@Shalabh</span> "Unlike zero, which was invented very early in maths, how come we never needed the empty string until we started working with computers?"<br/>?? The empty string was invented by mathematicians long before the first programmable computer was built. Axel Thue invented string rewriting systems in 1914, so the idea is at least that old.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579222528.258800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579222528.258800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-16 16:55</span><br/>
Sure. But compare 0 in mathematics to the empty string in text. We've had the notion of missing information but no actual literal form for it. Some countries you write 'NA' in forms, others you write '-' or maybe just scribble in margins about why something is blank.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579222571.259000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579222571.259000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-16 16:56</span><br/>
The best way to encode a missing value depends on the programming language.<br/><br/>A <tt>Maybe</tt> type (or <tt>Either</tt> type) is the best solution, if you are using Haskell, because then your code is compatible with all of the Haskell infrastructure that supports the use of <tt>Maybe</tt> types, and you don't want to force other Haskell programmers to have to write glue code to interface with your non-idiomatic API.<br/><br/>If you are programming in Clojure, then Maybe types are not the best way to represent this concept. Clojure isn't Haskell. If you are using a Clojure map, then omitting a field from the map is a better way to indicate missing data. I think that Rich Hickey's talk is directed at Clojure programmers, not at Haskell programmers, in order to explain why you shouldn't blindly import Haskell idioms into Clojure, when Clojure has its own idioms.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579223037.259300"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579223037.259300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2020-01-16 17:03</span><br/>
I feel this discussion points to how what we call values don’t include all the information we end up needing to track surrounding typical values. We need something more like slots with arbitrary attributes, a value being just one of them. Others might be things like: What’s the default value? What it’s type(s)? How should it get initialized? What are the valid set of, range of, or validator function for this value? Should we persist this value? Is it editable? What are it’s permissions? Do we own it or link to it? How should it be copied when needed? Should it be persisted? etc. These are properties of the slot, not the value it references.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579224012.260100"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579224012.260100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-16 17:20</span><br/>
Of course, now we're deep into the data-modelling bikeshed. Aren't those pieces of metadata just values in themselves? What if we care about the metadata of the metadata? Which systems have done a good job resolving this? RDF / semantic web? EAV[T]?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579224838.260500"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579224838.260500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2020-01-16 17:33</span><br/>
Right, though not necessarily meta in the class sense as these properties may be specific to the instance of the object which owns the value. My point is that it may not be appropriate to try to encode too much meta data (as we might be tempted to do with an empty string) into a value. Most languages and object systems lack abstractions around this, and end up scattering this meta info in difficult to work with ways throughout the code. Databases have similar problems.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579232040.000500"></a>
      <img src="https://secure.gravatar.com/avatar/acd8b29c5cd9153ba8f87532661ce874.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579232040.000500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>westoncb</b>
<span style="margin:2em; color:#606060">2020-01-16 19:34</span><br/>
Slots + attributes feels more like the right way of thinking about it than anything else I've come across.<br/><br/>A variation: rather than using explicit attributes, there may be a system that understands the history and current state of slots: whether it's empty or full, whether it was always that way, how many times it has changed—whatever. It tracks what's happening/happened to slots.<br/><br/>I think it's just shifting the problem into computation rather than data, so maybe not useful :slightly_smiling_face: But it's what I thought of after reading <span style="background-color:#ccf">@Ivan Reese</span>'s comment.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579242253.020700"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579242253.020700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2020-01-16 22:24</span><br/>
In programming we generally have an aversion to ambiguity and like everything to be well defined. That’s not surprising because whenever we have ambiguity, it usually leads to exceptions, crashes, undefined behavior, or hard to track down bugs.<br/><br/>As a consequence we came up with a solution: get rid of ambiguity. We introduced more specific types that make the formerly ambiguous cases explicit and/or limit the possible values to those we know to work with only. We added type checkers that prevent us from compiling ambiguity into our programs.<br/><br/>So now, if your function needs two integers to work, it only works with integers. If you have a string “5” and want to stick it in there, you’ll need another function that’s been specifically designed to convert a string into an integer, which includes a “not possible” scenario and so you’re forced to deal with that scenario. That’s all great and clearly works better than what we had before.<br/><br/>Sometimes I wonder if that “let’s make everything more explicit” solution was maybe not the best one and we should’ve thought more into the opposite direction, about how we can keep the ambiguity, but figure out better ways to deal with it.<br/><br/>After all, humans deal with ambiguity quite well. If you read this post and you don’t know what “ambiguity“ means, your comprehension process doesn’t crash and you can finish reading the whole post just fine. You’re even trying to make sense of what it could mean based on the context. Or you can look it up later and then it probably makes sense without you having to read the whole post again.<br/><br/>I think this is also something that makes programming hard to learn — we’re not used to having to make everything explicit. Most of the world works just fine with lots of ambiguity. Sure, sometimes that approach causes problems too, but look how far we got with it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579248572.021600"></a>
      <img src="https://secure.gravatar.com/avatar/acd8b29c5cd9153ba8f87532661ce874.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579248572.021600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>westoncb</b>
<span style="margin:2em; color:#606060">2020-01-17 00:09</span><br/>
That brings to mind two things for me:<br/><br/>1. More flexible notions of equivalence, rather than just equality when e.g. comparing types. Liskov substitution is one example, and "duck typing" is I guess a kind of extreme. The first works to enable context-dependent equality: i.e. in some specific context, we can use a looser notion of equality; the second one works toward equal for "all intents and purposes". Additional strategies could probably be found in each of those categories though. I could see something like neural net recognizers being used for more flexible equivalence definitions as being in the equal for all intents and purposes category, for example.<br/>2. Deferred / partial / placeholder definitions. It seems like a big part of how we deal with ambiguity when learning things is something like: we come across a term/concept that we don't understand while reading something—and it's not a problem. We just invent a unique placeholder symbol for that thing and accumulate multiple tentative definitions which each gain or lose support as you learn more. The 'placeholder' symbol in our minds has something like a tentativeness value associated to it: we can keep using the symbol, but we take into account the uncertainty of its meaning/value.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579248892.021800"></a>
      <img src="https://secure.gravatar.com/avatar/acd8b29c5cd9153ba8f87532661ce874.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579248892.021800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>westoncb</b>
<span style="margin:2em; color:#606060">2020-01-17 00:14</span><br/>
The only programming systems I can imagine using those concepts in a very deep way would have to depend on some kind of backtracking behavior though: trying out multiple routes in attempt to sort out the ambiguity automatically.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579289862.025300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579289862.025300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-17 11:37</span><br/>
The precise gear like fittings required are also a problem when building things. Say if I have a Point object from one library that I connect to a Canvas from another library (either via direct manipulation or code). The interfaces must match <b>precisely</b> (same language, same field names) for it to even work, otherwise it is a total failure. But consider how there are only a few ways that the Point shape could even 'fit' with a Canvas like object. The Point has two fields which are single dimensional each. The canvas has at least two dimensions + maybe color. I have to precisely hand code the mapping, but it seems like the system could provide some obvious mappings for me instead and let me choose? The current models of composition are mostly 'gear like tight' or nothing. Maybe we need some models of composition that incorporate some kind of negotiation? What does this interplay look like?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579297640.036300"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579297640.036300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2020-01-17 13:47</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span> “Sometimes I wonder if that “let’s make everything more explicit” solution was maybe not the best one and we should’ve thought more into the opposite direction, about how we can keep the ambiguity, but figure out better ways to deal with it.”<br/><br/>I agree. An example that comes to mind is the use of constructors and immutable objects by people obsessed with objects never being in an invalid state. I’ve found it much easier to have classes that you instantiate and then call a few configuration methods to get them into a valid state than ones that attempt to have a constructor for each of the combinatorial explosion of valid initial configuration states. Much better to have an object that can report what’s wrong with its state. <br/><br/><br/>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579308068.040700"></a>
      <img src="https://secure.gravatar.com/avatar/acd8b29c5cd9153ba8f87532661ce874.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579308068.040700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>westoncb</b>
<span style="margin:2em; color:#606060">2020-01-17 16:41</span><br/>
Shalabh, that made me think of something: in your Point example the problem is to find an automatic translation/mapping function so that some <em>data</em> is structured correctly when moved into a different context.<br/><br/>Seems like the other half of that is being able to move <em>behaviors</em> into new contexts. Seems like finding translations of behaviors automatically is a similar problem optimizing compilers have: searching among programs with equivalent semantics, but some different 'secondary' effects. But rather than optimizing performance here, we're looking for some kind of format compatibility...
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579308859.040900"></a>
      <img src="https://secure.gravatar.com/avatar/acd8b29c5cd9153ba8f87532661ce874.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579308859.040900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>westoncb</b>
<span style="margin:2em; color:#606060">2020-01-17 16:54</span><br/>
The gear analogy also makes me think: what is an alternate model at that level which would do better with imprecision/ambiguity?<br/><br/>An image that came to mind: the gears were instead composed of tiny little particles and in certain conditions they could be broken up, gear teeth knocked off etc.—but this always happens in the context of something like an annealing process where the objects coming apart are in a higher energy state, and will settle into some alternate/compatible equilibrium state after.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579309098.041100"></a>
      <img src="https://secure.gravatar.com/avatar/acd8b29c5cd9153ba8f87532661ce874.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579309098.041100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>westoncb</b>
<span style="margin:2em; color:#606060">2020-01-17 16:58</span><br/>
So the runtime for the language takes on some similarities to this sort of physical simulation (custom-tailored of course), so conditions for entering energetic vs. settled states are always consistently enforced—it's just an aspect of the background medium for the language's execution.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579353104.073800"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579353104.073800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2020-01-18 05:11</span><br/>
I don't talk specifically about ambiguity in this post, but you might see where I'm coming from when reading this: <a href="https://stefan-lesser.com/2020/01/17/categories-structure-our-world/">https://stefan-lesser.com/2020/01/17/categories-structure-our-world/</a><br/><br/>In essence, we can talk about <tt>cat</tt>s, although none of us will have exactly the same concept in mind. Nevertheless, we usually understand each other. Only in rare cases or with more abstract concepts does this become an issue.<br/><br/>In programming we focus probably too much about defining the value and its type so narrowly that there is no room for interpretation. Although there usually still is. The concept of integer is very different from the type Int in your favorite programming language. For instance, your programming language likely only considers a finite range of integers an Int; perhaps it has another type to represent arbitrary size integers.<br/><br/>I see a huge opportunity in hiding this kind of complexity. It will likely not have any performance benefits, but putting these computation cycles to work to no longer make people distinguish between Int32 or Int64 or Int and Float, or Int and String seems like a path to massively simplify programming for people trying to learn it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579389139.133800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579389139.133800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-18 15:12</span><br/>
<span style="background-color:#ccf">@westoncb</span> the alternative to gear-like is biology-like which is what Alan Kay has also talked about. Tissues don't have to fit perfectly but if one emits some chemicals that the other has some receptors for, then you get some interaction. There is some fundamental compatibility built-in - the actual mechanisms of messaging for instance. For useful processes, there would also have to be some shared notion of what different messages mean. But there is also tolerance for imperfect fits - unidentified messages may be just ignored and accumulate - perhaps picked up by other neighboring cells that do respond to these.<br/><br/>BTW an interesting thing from biology I saw a long, long time ago: two cells from heart tissue may 'pulse' at different rates independently, but when touching each other, they pulse in synchrony. This is so unlike the kinds of compositions we see in computers where aggregation has to be hand wired.<br/><br/>I think you're right that the extension of this idea is to 'run any behavior' in a new context. I suppose behavior-as-program is just data for the 'host'.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579390039.134200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579390039.134200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-18 15:27</span><br/>
&gt; <span style="background-color:#ccf">@Stefan Lesser</span> "I see a huge opportunity in hiding this kind of complexity. It will likely not have any performance benefits, but putting these computation cycles to work to no longer make people distinguish between Int32 or Int64 or Int and Float, ... seems like a path to massively simplify programming for people trying to learn it."<br/>I agree with this, and I'm doing it in my project for that reason. Curv has a single numeric type, the "number", which is represented internally as a float64. No need to explain why 1 and 1.0 are different objects, or why (in Ruby) 7/2 is 3 but 7.0/2.0 is 3.5. Javascript works this way. It's an old idea. Dartmouth BASIC worked this way, in the mid 1970's. APL worked this way in the mid 1960's.<br/><br/>Where I encounter a problem with having a single Number type is when I want to work with huge, multi-dimensional arrays, which blow up memory if all numbers are 64 bits. In this case, I need to exert precise control over how array elements are laid out in memory. I need <b>representation types</b> like UInt32, Float32, and UNorm8 (a number between 0 and 1, represented using 8 bits, so that 0x00 is 0, 0xFF is 1, 0x55 is 1/3, and so on. This last one is used for representing RGB values in a pixel array. So now I can create a "typed array", where I use a representation type to specify how abstract values are mapped onto bit patterns in memory. This is a low level programming interface, and is only needed by developers who are developing libraries that use efficient internal representations for data. This interface shouldn't be needed by typical end users, who only need to understand about abstract values like "numbers". So there is a way to do low level programming without inflicting all of the concerns of low level programmers onto end users who are just using high level library interfaces.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579463552.184800"></a>
      <img src="https://avatars.slack-edge.com/2019-04-10/604262911488_be27878783b4b23a5ed4_72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579463552.184800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Niko Autio</b>
<span style="margin:2em; color:#606060">2020-01-19 11:52</span><br/>
Approach I like is to use separated operators for different functions. For example: 7 / 2 = 3.5, 7 // 2 = 3, 1 + 2 = 3, "1" ++ "2" = "12".<br/>When you limit ambiguity on one side it's much more safe to allow "1" + "2" = 3 because we know that '+' is always mathematical plus operator.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579468936.185200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579468936.185200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-19 13:22</span><br/>
<span style="background-color:#ccf">@Niko Autio</span> I agree, it's the only sensible and correct way to design math operators. There is a paper by John Reynolds that formalizes the design principle using category theory.<br/><br/>If you introduce a coercion between strings and numbers, then you have a problem, because there isn't a one to one correspondence between strings and numbers. There are multiple string representations for each number. For example, 1==1.0 and 01==1, but "1" != "1.0" and "01" != "1". So now your equality operator is broken, and the way to fix it, according to this principle, is to do what Perl 5 does, and provide different equality operators for numbers and strings. In other words, a coercion between numbers and strings doesn't simplify anything, it just pushes language complexity from one place to another.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579469565.186900"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579469565.186900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2020-01-19 13:32</span><br/>
<span style="background-color:#ccf">@Niko Autio</span> What’s the behavior if the values are of different types?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579470293.187200"></a>
      <img src="https://avatars.slack-edge.com/2019-04-10/604262911488_be27878783b4b23a5ed4_72.png" style="float:left"/>
      <a href="../thinking-together/1579212773.252900.html#1579470293.187200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Niko Autio</b>
<span style="margin:2em; color:#606060">2020-01-19 13:44</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> yea that's true. And to be precise coercion between strings and numbers parts wasn't included to things I like :sweat_smile:<br/><br/><span style="background-color:#ccf">@Steve Dekorte</span> "/" is float -&gt; float -&gt; float so if any input is integer they are converted to float. "//" is int -&gt; int -&gt; int and if you are trying to insert float you should &lt;placeholder for some trade-off&gt; :grin:<br/><br/>But one thing I have been considered is implicit write &amp; explicit read separation. So you could write implicit way: "1" + "2" but derived form of that code would be int.parse("1") + int.parse("2").<br/>Something like: <a href="https://www.beslogic.com/wp-content/uploads/2018/05/type-inference.png">https://www.beslogic.com/wp-content/uploads/2018/05/type-inference.png</a><br/>Still challenge is that such visualization separations doesn't fit too well on text edit.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
