[
    {
        "user": "U03CEGR3HSL",
        "type": "message",
        "ts": "1660888406.320979",
        "client_msg_id": "cebea924-9543-44e7-b915-f2fe6068664b",
        "text": "On the criteria to be used in decomposing systems into modules by D. L. Parnas\n<https:\/\/dl.acm.org\/doi\/10.1145\/361598.361623|https:\/\/dl.acm.org\/doi\/10.1145\/361598.361623>\n\nThis is one of my favorite papers, and the basic concept that each design decision should be hidden within a module of some sort, where \"module\" can mean anything from a collection of procedures to a language specific feature, has served me well for many years.\n\nAlso, the principle that programs should be broken up by concern and not by the order in which things happen has informed my design decisions for a long time.\n\nHas this paper's approach informed anyone else's design over the years? If so, how?\n\nWhat principles do the rest of you use to make your programs more resilient against changes in the specifications?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g7fd1bd5c536",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png",
            "first_name": "Personal",
            "real_name": "Personal Dynamic Media",
            "display_name": "Personal Dynamic Media",
            "team": "T5TCAFTA9",
            "name": "personaldynamicmedia",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1660888406.320979",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1661995221.570889",
        "reply_users": [
            "UKFNXF0F9",
            "U03CEGR3HSL",
            "U0378MDUG1Y"
        ],
        "replies": [
            {
                "user": "UKFNXF0F9",
                "ts": "1661818878.451259"
            },
            {
                "user": "U03CEGR3HSL",
                "ts": "1661819090.670089"
            },
            {
                "user": "U0378MDUG1Y",
                "ts": "1661995221.570889"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f6Fb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On the criteria to be used in decomposing systems into modules by D. L. Parnas\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/dl.acm.org\/doi\/10.1145\/361598.361623",
                                "text": "https:\/\/dl.acm.org\/doi\/10.1145\/361598.361623"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThis is one of my favorite papers, and the basic concept that each design decision should be hidden within a module of some sort, where \"module\" can mean anything from a collection of procedures to a language specific feature, has served me well for many years.\n\nAlso, the principle that programs should be broken up by concern and not by the order in which things happen has informed my design decisions for a long time.\n\nHas this paper's approach informed anyone else's design over the years? If so, how?\n\nWhat principles do the rest of you use to make your programs more resilient against changes in the specifications?"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]