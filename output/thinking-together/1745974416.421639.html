<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2025-04-29 17:53</span><br/>
I finally got around to Dave Ackley's latest video report on robust-first computing which <span style="background-color:#ccf">@Andreas S.</span> shared <a href="../linking-together/1745855290.195199.html">here</a>, and it prompted me to zoom out and think about the territory of computation and what we know of it so far in the year 2025. Right now I imagine it as a 3D terrain. Along one axis, analogous to a <a href="https://en.wikipedia.org/wiki/Multiview_orthographic_projection">plan view</a>, I see the following coarse <em>technical</em> approaches to structuring computation, each equally valid:<br/>• Computation as the orchestration of precise instructions.<br/>• Computation as the learning of matrix weights.<br/>• Computation as the orchestration of fuzzy, imprecise cellular automata. Ackley's approach.<br/>I think that's it? Are there others?<br/><br/>Along an orthogonal axis, analogous to an elevation view, I see <em>social</em> approaches to organizing the means of computation. So far we only have open questions here:<br/>• Does computational infrastructure necessarily require authoritarian dictators or at best feudal lords and vassals? Or is it possible to have something analogous to a democratic approach?<br/>• Can we reduce inequality between the haves and have-nots of tech knowledge and computer whispering?<br/>• Can we design incentives to keep computation working over time, in a secure and trustworthy way? (Can computation ever be biased less towards offense, can defense be viable?)<br/>• Can we design incentives to make the means of computation sustainable in their impact on the environment?<br/>And along a second orthogonal axis, analogous to a side view, I imagine ways to connect up computation with other fields of human endeavor. Here there has been much progress, though I am running out of steam:<br/>• Learning from the arts to improve visual and auditory design, e.g. typography.<br/>• Learning from math to better model the world, e.g. numerical methods.<br/>• Learning from the social sciences to nudge groups of people in productive and unproductive directions. Coevolving populations with these lessons that will inevitably grow robust to such nudging.<br/>• ...?<br/>Feel free to point out gaps, additional axes, add examples..
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1745993981.943749"></a>
      <img src="https://avatars.slack-edge.com/2024-04-04/6922823105585_287ba5559ee1cedd6b98_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1745993981.943749" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Marek Rogalski</b>
<span style="margin:2em; color:#606060">2025-04-29 23:19</span><br/>
In the end computers tend to end up executing precise instructions anyway. The first approach that you listed is the bedrock abstraction that the second and third approaches are built on top. In principle it's possible to build machines that would implement other approaches natively but doing so is rarely practical (1, 2 &amp; 3-d cellular automata are some of the exceptions).<br/><br/>I think the question that you asked ("are there others") is the main reason many of us are here :slightly_smiling_face: From the back of my memory, there is:<br/>• quantum computing (another case where building a native computer is essential)<br/>• spiking neural networks<br/>• expert systems, also fuzzy ones<br/>• fpga-style logic networks<br/>• a few cryptographic approaches (ethereum / unison / white-box cryptography / zero-knowledge proofs)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1745994487.028119"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1745994487.028119" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2025-04-29 23:28</span><br/>
There is a lot of passive mechanical computation in existence.<br/><br/>For an underwater robot we added floats to the bottom of our rotating wifi antenna so the antenna went vertical when on the water surface (maximizing range) but folded flat when underwater (reduce drag for locomotion).<br/>This is a genuine computational device relying on a non-linearity and "programmed" by positioning hinges and orientated w.r.t. gravity and the environment to get a designed behaviour.<br/><br/>A toilet flush is quite a complicated but common one. I consider these closed loop control systems but the feedback computation is done without silicon, which is often <em><b>much</b></em> more robust albiet limited in expressivity. They don't require electricity to run, but in these two examples they <em>are</em> _powered_ but with kinetic energy (and they lose energy via heat losses like everything powered).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746025061.236739"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746025061.236739" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-04-30 07:57</span><br/>
For the first axis, there are probably many candidates, depending on how "mainstream" we require them to be. Quantum computing is an obvious candidate, as <span style="background-color:#ccf">@Marek Rogalski</span> pointed out. There are also more exotic ideas, such as the <a href="https://www.lix.polytechnique.fr/~fvalenci/papers/cham.pdf">Chemical Abstract Machine</a> . On the other hand, I'd remove "learning of matrix weights" from the list as long as it is implemented strictly in terms of the preceding technique in the list. Just to punish laziness.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746025247.789359"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746025247.789359" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-04-30 08:00</span><br/>
We could also admit human crowds as computational agents, and then decide that markets are a form of computation. Perhaps the fundamental question is what defines computation within a wider framing, e.g. "information processing".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746026325.504339"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746026325.504339" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2025-04-30 08:18</span><br/>
I don't care too much that one metaphor is built in terms of another, or which kind is most fundamental. That kind of reductionism seems unimportant here.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746081832.489059"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746081832.489059" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-04-30 23:43</span><br/>
I agree. But if you want to map out the space of computation, you have to say somewhere what you mean by computation, at least roughly.<br/><br/>I have witnessed two heated debates, between academics of different disciplines, on the question "is the brain a computer?" In both cases, it turned out after some rounds of shouting at each other that each participants had a different view of what "computer" means. At one extreme, it was "a physical system capable of processing information", at the other extreme it was a deterministic system with a clear separation of hardware and software layers.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746082708.540329"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746082708.540329" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2025-04-30 23:58</span><br/>
Yeah. Perhaps it would help to clarify that I'm thinking in this thread about the experience of getting some desired behavior. What does the inner experience of "programming" feel like. So the technical part of my OP was, you can program by engaging with syntax and semantics, or by running tons of data through an algorithm to tweak weights, or by whatever mechanism Dave Ackley is doing that I don't understand but definitely seems much more fault tolerant than syntax and semantics.<br/><br/>Expert systems and relevance work do feel like first-class different experiences. Maybe related to neural networks? In all 3 the feedback loop seems definitely dilated. There's no equivalent of adding a semi-colon in response to an error message..<br/><br/>I don't know enough about quantum computers to know what the activity of programming them feels like. So open question. Is it just libraries that run on a coprocessor with weird time complexity properties, and some barriers to adjusting function boundaries (to avoid observing at the wrong time)? Or is there more to the experience?<br/><br/>FPGAs don't immediately feel different in the same way. My rough sense is you compile the same conventional languages to commands that configure logic gates. It's akin to compiling down to Verilog. Though there's some weirdness in terms of seemingly simple things in software that explode to take up tons of gates. That might make programming them feel different.<br/><br/>Similarly, DAOs on blockchains seem like regular programming, just less flexible? Once it goes on the ledger it's hard/impossible to change.. They're probably slower, but we also have lots of experience with slow languages :slightly_smiling_face: ZK proofs do feel fundamentally different.<br/><br/>I have some sympathy for the idea that analog computation and reversible computation feel like their own experience. But I don't know enough to be sure.<br/><br/>I also have some sympathy for the idea that programming a game feels very different than other kinds of programming even if you're using similar languages and tools. There's a level of mechanism design and tuning for playability that's gestalt rather than detail-oriented in a way that I've never quite been able to grok. And that barrier is always an indication it's a whole different activity.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746085275.462299"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746085275.462299" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2025-05-01 00:41</span><br/>
OK more on target then: programming an LLM system is quite a different beast (build benchmarks, iterate on prompt, think about context, lots of second guessing the LLMs thought process)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746086574.419789"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746086574.419789" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2025-05-01 01:02</span><br/>
Programming with an LLM seems a little bit like being a manager. Which gets to <span style="background-color:#ccf">@Konrad Hinsen</span>'s idea of other people as a substrate to delegate work to. Arguably the oldest programming of all.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746095679.378429"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746095679.378429" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2025-05-01 03:34</span><br/>
Using an LLM (1) is different to building a system around LLMs (2).  1. is managerial. 2. is herding cats and involves a lot of probabilistic reasoning.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746111357.294129"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746111357.294129" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2025-05-01 07:55</span><br/>
Is 2 what you meant in your previous comment? I don't quite understand this kind of system building. Say more?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746113708.974489"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746113708.974489" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2025-05-01 08:35</span><br/>
Yeah, building a system that uses an LLM internally ends up more like applied science. In normal programming you get deterministic results. When you embed an LLM you get this thing that kinda does what you want some of the time, so you have to deal with the rate of failure in a methodical way, and you tweak things to improve the rate of failure. So its quite a different way of programming.<br/>This is different than using an LLM, coz in that situation you have a goal and you are both coordinating to achieve that goal, so some of the work gets done by you (e.g. code assistance). If you are giving an LLM powered product to lots of people, you have more unknowns and you can't apply test-driven-development or anything like that. So its different. Its still development, but its quite different to distributed systems where the rate of failure is relatively low and there are clear reasons why it behaves the way it did. LLMs you are programming where every function call is a roll of the dice modified by free text. The methodical way of taming that is evals at scale, which doesn't fit in a CI process, costs money etc. etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1746165781.684539"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1745974416.421639.html#1746165781.684539" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-05-01 23:03</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> Focusing on the experience makes this a much clearer exercise!<br/><br/>For quantum computing, the main experience is the paperwork of getting access to one. Once you do, it feels much like batch processing in the past: you submit your program via some front-end (a standard computer), and wait for the result. The program has syntax much like a standard program, but its semantics are wildly different.<br/><br/>Analog computing is more interesting. It feels much more like doing an experiment in a lab than like running software.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
