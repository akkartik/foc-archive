<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2020-01-07 00:26</span><br/>
<a href="https://gbracha.blogspot.com/2020/01/the-build-is-always-broken.html">https://gbracha.blogspot.com/2020/01/the-build-is-always-broken.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578418204.053100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578418204.053100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-01-07 09:30</span><br/>
It's not so much a rebuttal as an alternative worldview. I don't see a concrete advantage given for this approach that merits the word 'broken'.<br/><br/>On the other hand, there <b>is</b> a thread of research on the advantages of creating software to constantly exercise disaster recovery: <a href="https://en.wikipedia.org/wiki/Crash-only_software">https://en.wikipedia.org/wiki/Crash-only_software</a><br/><br/>It speaks particularly to me ever since I watched <em>Jurassic Park</em> at a formative age :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578434328.002200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578434328.002200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-07 13:58</span><br/>
I value the benefits of live programming, so I mostly agree. However, Bracha takes the absolutist position that "the real problem is that the very concept of <em>the build</em> is broken." and "It's high time we build a new, brave, build-free world." This is mistaken, because live programming doesn't always work. There are some situations where the live programming environment's ability to update the running system state to match the new code breaks down. It can happen when you change an important data structure that a lot of currently running code depends on. It's then that you need the ability to "tear down and reconstruct the skyscraper". So we need to preserve the ability to rebuild the world from scratch, and exercise it frequently enough so that it doesn't become irretrievably broken.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578437157.002500"></a>
      <img src="https://avatars.slack-edge.com/2020-04-19/1070853245589_9c42167d8bfa4cbf26ad_72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578437157.002500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nuno Leiria</b>
<span style="margin:2em; color:#606060">2020-01-07 14:45</span><br/>
I don't think it's a given that it breaks down. You change an important data structure and the old code still uses the previous layout until it has been changed to the new one. It breaks down as things currently stand but you could completely re-engineer a new world where it doesn't. What the trade offs would be for that to happen, that's a better question.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578441187.004000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578441187.004000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-07 15:53</span><br/>
I can prove this is impossible by case analysis.<br/>• Case 1, the executable machine-code file that you must run in order to start the live programming IDE (the "kernel") is built from immutable source that cannot be live edited from inside the live programming environment. This decision simplifies the design of the IDE. However, it means that you need a traditional build system to build the kernel. All of the Smalltalks have this property, by the way. You can't live edit the Smalltalk VM from inside of Smalltalk.<br/>• Case 2, the source code for the kernel executable is live editable from inside the IDE. Nobody has ever done this. It might be impossible: there is probably always some irreducible kernel that cannot be live edited. If it is possible (not proven), then it's probably very complicated, and there will be bugs. Nobody has demonstrated the ability to write complex software that is guaranteed bug free. Bugs have been found in software that has been "proven" to be correct. These IDE bugs can lead to the executable that you must run to start the kernel getting out of sync with the source code. So you need a traditional build system as a backup to recover from this situation, and if you don't have it, then you are screwed. If you have a traditional build system for the kernel, but you don't continually test it as the software changes, then when you finally have an emergency situation, the build system won't work, and you are screwed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578461064.009700"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578461064.009700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-07 21:24</span><br/>
There will always be rebuilds and restarts, whether you have 'build systems' or not.<br/><br/>The first question is:  at what granularity do we rebuild and restart?<br/><br/>What if every change meant you had to rebuild the entire system image (kernel+userspace) and reboot? Too coarse? With present day systems we can rebuild a binary and restart the OS process. State external to the process is preserved (BTW, the backward compatibility problem of data structure still exists). But what if you change one function? Can we just build and re-integrate just the function into the running process?<br/><br/>The second question is: how manual is the rebuild and restart process?<br/><br/>Most build systems need to be manually invoked. Sometimes we wrap them with file-watchers to rebuild whenever something changes. This is similar to re-running a script vs updating a cell in Excel. Why not have the continuous rebuild be always available with, say, controlled snapshots?<br/><br/>Emitting machine code for optimization or kernel etc. is completely separate. Any program can be written to emit machine code and store it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578461613.012500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578461613.012500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-07 21:33</span><br/>
Bracha doesn't talk about this but I think the build system idea is connected to the the idea of binaries/processes/apps: i.e. the output of the build. The pattern of using this is <em>build</em> -&gt; output artifact -&gt;  <em>run</em>. If you look at systems where:<br/>a) the 'runnable unit' of the OS isn't Unix process sized, but something smaller, and<br/>b) the running/not-running dichotomy isn't primary (e.g. you have auto-persisted system image),<br/>then the build system model doesn't seem particularly interesting.<br/>There's the recent twitter thread about Lisp machines, if you're looking for a specific example: <a href="https://twitter.com/RainerJoswig/status/1213484071952752640">https://twitter.com/RainerJoswig/status/1213484071952752640</a><br/><br/>Since one of the problems of 'editing live' is that you can crash running things pretty badly, I think snapshotting and rollback become critical in this mode of operation.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578520123.065100"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578520123.065100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-01-08 13:48</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> One day i was visiting Project Mac, the operating system team at MIT. Bob Frankston (the future co-inventor of the spreadsheet) was one of the team members, and while in his cubicle how was demonstrating how the MULTICS operating system (the competitor to UNIX, and superior in most technical aspects) had dynamic linking, which meant that at any moment you could swap out kernel modules. He was experimenting with a new memory manager, and turned it on, while dozens of other people were using that Machine (this was time sharing days). It crashed immediately, and all the people in the other cubicles yelled out in anguish as the system was now down. Dynamic linking is a supremely powerful technique, but rather dangerous as this example shows.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578546999.079100"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578546999.079100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2020-01-08 21:16</span><br/>
Same deal with Smalltalk.  "Guess the image is ruined, better revert to yesterday's."  The real solution would be sand-boxed changes (only want to modify part of the system right now) and good revision control.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578675377.098400"></a>
      <img src="https://secure.gravatar.com/avatar/b19534d8a57758546bdc252eefecc432.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0010-72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578675377.098400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dafydd Rees</b>
<span style="margin:2em; color:#606060">2020-01-10 08:56</span><br/>
Just wait until you put a breakpoint into the method in the abstract window class that redraws windows…. Nobody would ever do that in Smalltalk… :flushed:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578675478.098700"></a>
      <img src="https://secure.gravatar.com/avatar/b19534d8a57758546bdc252eefecc432.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0010-72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578675478.098700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dafydd Rees</b>
<span style="margin:2em; color:#606060">2020-01-10 08:57</span><br/>
I do think though, that the image-based approach is a great way to learn programming - and it’s easier to think concretely and then level up gradually with abstractions. It’s also good for modelling things - have your interactive model be directly manipulatable - a la the naked objects approach.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578676649.100900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578676649.100900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-10 09:17</span><br/>
There's a difference between system-in-use and system-under-development. There's a difference between SUD-liveness and the SUD and SIU being the same system. When you have liveness you could just live edit your system in use, but you don't have to. E.g. you could spin up a 'nested smalltalk' and put a breakpoint in that one.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578677619.101500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578677619.101500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-01-10 09:33</span><br/>
Sure, but it's interesting to point out seams where composability breaks down. Smalltalk lets you open any class, and set a breakpoint anywhere in it. Why do some combinations of those actions not work? How many such combinations exist?<br/><br/>The whole argument of Smalltalk is that you don't need to worry about the distinction between inside and outside, SIU and SUD.<br/><br/>To me it seems analogous to your point about sort in shell scripts vs C.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578679645.102200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578679645.102200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-10 10:07</span><br/>
Yes, I see the point in the first paragraph. Don't see the analogy (yet).<br/><br/>Perhaps a slightly better distinction than SIU/SUD is calling these kernel-like parts and non-kernel parts, of the system? I see this similar to how you'd probably use a sandbox when developing a kernel module, even if your kernel allows dynamically reloading kernel modules. Seems like this space needs more exploration - like how do you identify the parts that you <b>shouldn't</b> live reload, and how you pin these..<br/><br/>This reminds me of a nice essay on designing in Erlang (which supports live reloading), which talked about think about Erlang processes as different 'rings', e.g. ring0 is the kernel - most critical processes - and so on. Unfortunately, I can't find it now.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578679887.102400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578679887.102400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-10 10:11</span><br/>
If we want a system that is live editable "all the way down", then the situation is more complicated than just SUD vs SIU, or kernel vs user-space. A full system has many layers. If we are live editing the code at layer N, then the SUD and SIU can share layers 0..N-1, but we fork layers N and above. If we are live editing the GPU driver, we need 2 physical GPUs, one connected to the SUD and one connected to the SIU. We can crash the GPU connected to the driver we are live editing without losing our development environment. If we are live editing the window manager, we don't need two GPUs, the SUD and SIU can share the same GPU driver instance. If we are live editing a declarative description of a new window theme, then, as long as the window theme API is "safe", we don't need to fork the window system to apply the new theme.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578682355.106300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578682355.106300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-01-10 10:52</span><br/>
<span style="background-color:#ccf">@Shalabh</span>, the analogy:<br/><br/><li> Unix is all about reuse, about doing one thing and doing it well. Except that doesn't always work.<br/><li> Smalltalk is all about being able to modify the environment from within the environment. Except that doesn't always work.<br/><br/>&gt; Perhaps a slightly better distinction than SIU/SUD is calling these kernel-like parts and non-kernel parts, of the system? I see this similar to how you'd probably use a sandbox when developing a kernel module, even if your kernel allows dynamically reloading kernel modules. Seems like this space needs more exploration - like how do you identify the parts that you shouldn't live reload, and how you pin these..<br/>Can I make a similar claim for Unix? :slightly_smiling_face: We know how to identify the parts that can't reuse things: processes that don't use the same shared libraries.<br/><br/>I think both are reasonable points, but they're bolted on to the underlying uniformity. So they provide apology but don't really address the two criticisms above.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578682732.106500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578682732.106500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-01-10 10:58</span><br/>
Here's a relevant paragraph from the paper I've been working on, that I wrote before this thread. I'm curious if anybody here would quibble with it.<br/><br/>&gt; Mu's strategies borrow much from past work. For example, Forth systems emphasize parsimonious dependencies but give up on safety in the process. Smalltalk systems emphasize safety while exposing a large fraction of their internals. However, there usually remains a kernel that requires exiting Smalltalk to modify. Lisp Machines built up all the way from custom hardware while remaining safe. Lisp, Forth and Smalltalk all emphasize uniform notation, though they also have strong and divergent opinions on what that notation should be. While they all expose their internals to modification in various structured ways, it seems easy for small modifications to their internals to cause regressions both subtle and catastrophic. Modification requires expertise of all the scenarios their environments are designed to handle, expertise that can only be obtained out of band from the tools themselves.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578694940.107900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578385588.031500.html#1578694940.107900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2020-01-10 14:22</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> re analogy - ah I see!<br/><br/>Agree that 'more is needed'. Protections around Smalltalk's powerful meta-features has definitely been brought up but never really fixed afaik.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
