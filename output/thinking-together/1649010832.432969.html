<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/bc993d98fe7bf26c048ac0818a598d4d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0001-72.png" style="float:left"/>
      <a href="../thinking-together/1649010832.432969.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mark Dewing</b>
<span style="margin:2em; color:#606060">2022-04-03 11:33</span><br/>
I'm interested in using call graphs/control flow in a hierarchical way to understand programs better.  The problem is there seems to be two extremes - high level diagrams done manually and low level call graphs generated by tools.   A manual drawing with boxes and arrows is often used when describing a program at the highest level.  While it works, one question is how to move to the next level of detail?  Someone has to do that manually as well.  These diagrams aren't connected to the source and can get out of date.  The structure is going to change slowly at the highest level and so keeping up-to-date manually isn't that much trouble.  More detailed levels, though, can change more frequently and keeping them up-to-date is more work.   At the other extreme, tools to generate callgraphs give all the functions.  They can filter by time, number of calls or call stack depth, but those doesn't necessarily correlate to what's important conceptually.   I'm wondering if there's any work on anything between these two extremes?  Both in generating it and visualizing it. (Searching online for 'hierarchical call graph' gives research on automated and machine learning approaches to discovering a hierarchy - interesting as research, but not what I'm after here.  I would prefer something manual like adding program annotations or creating filtering terms - something that can be automated as part of a build or CI process.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1649032112.155239"></a>
      <img src="https://secure.gravatar.com/avatar/8449ebbf703fcee4e1eadc3e78478f01.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0026-72.png" style="float:left"/>
      <a href="../thinking-together/1649010832.432969.html#1649032112.155239" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Cameron Yick</b>
<span style="margin:2em; color:#606060">2022-04-03 17:28</span><br/>
Re work in between the extremes of fully automated vs manual - check out Gail Murphy’s paper from 1995 about “reflexion” models, which were used to bridge this exact gap, and was tested by engineers who had to refactor Microsoft Excel. The core idea was to <br/><br/>• define “patterns” for components <br/>• make an autogenerated graph of relations between those components<br/>• Have the system expert manually set a graph for their expectations for what 2 should look like <br/>• Diff 2 and 3<br/>I talked about this paper and related work in this talk in 2019: <a href="https://github.com/hydrosquall/code-maps-frontend">https://github.com/hydrosquall/code-maps-frontend</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1649032380.204519"></a>
      <img src="https://avatars.slack-edge.com/2021-12-14/2826386958343_1ab8763ceb219317febf_72.jpg" style="float:left"/>
      <a href="../thinking-together/1649010832.432969.html#1649032380.204519" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Krasner</b>
<span style="margin:2em; color:#606060">2022-04-03 17:33</span><br/>
I would also look into the GRAIL (graphical programming language) system developed at RAND in the 1960s. A <a href="https://wiki.c2.com/?GrailSystem">link</a> to some of the technical documentation, but you can find video demos of it online. Plenty of good ideas there, few of which have been fully realized since then.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1649067297.382049"></a>
      <img src="https://avatars.slack-edge.com/2021-11-22/2751712832389_8f8e6ba44e899c90d59c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1649010832.432969.html#1649067297.382049" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Andrew Condon</b>
<span style="margin:2em; color:#606060">2022-04-04 03:14</span><br/>
I’m interested in whatever you find about this - i’ve been building something to make direct manipulation of graphs with the hope that the immense “re-factorability” of Haskell &amp; PureScript code would not be offset quite so much by tedious and error-prone line editing of code. (You can look at the demo linked in the README here and see some of possibilities. <a href="https://github.com/afcondon/purescript-d3-tagless-II">https://github.com/afcondon/purescript-d3-tagless-II</a>)<br/>i’m using module and package graph data from the PureScript toolchain, but hope to get at least one level deeper to function calls and type definitions by using the AST someday.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
