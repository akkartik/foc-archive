<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-06-08 11:07</span><br/>
Is this a known result in PL theory? "The set of stable minimum models returned in response to a query in a goal-directed stable model constraint answer set programming language entail, taken together, a stable model constraint answer set program for answering only that query."
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654712123.224909"></a>
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1654712123.224909" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-06-08 11:15</span><br/>
I may be phrasing it wrong. Not a theorist. But this just occurred to me, and it seems intuitive. If true, it means I could let my users compile their encodings into lightning-fast code without sacrificing any reasoning capabilities for expert system applications. Which would be huge.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654717390.843519"></a>
      <img src="https://avatars.slack-edge.com/2022-05-27/3589814658547_fd3b904fdc456648ecb2_72.jpg" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1654717390.843519" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Václav Blažej</b>
<span style="margin:2em; color:#606060">2022-06-08 12:43</span><br/>
For not being a theorist the question seems to be built successfully convoluted enough. Can you pose the proposition more clearly?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654718056.964149"></a>
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1654718056.964149" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-06-08 12:54</span><br/>
Sure. If you ask your software "what are all the fact patterns (inputs) that could support this output", and it tells you, can you use that list of possible valid fact patterns to do pattern matching between other inputs and the valid fact patterns, getting the same result as if you had asked the original program whether the inputs were valid.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654718223.709239"></a>
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1654718223.709239" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-06-08 12:57</span><br/>
Most systems cannot answer that first question, but the one I'm using can, and I'm wondering if that is effectively a means to compile a logic program and a query into more efficient code for answering only that specific query.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654790807.626299"></a>
      <img src="https://avatars.slack-edge.com/2022-04-29/3447576657367_f58a6508f11105e0d0be_72.png" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1654790807.626299" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alex Cruise</b>
<span style="margin:2em; color:#606060">2022-06-09 09:06</span><br/>
Stumbled on this, somewhat relevant <a href="https://arxiv.org/pdf/2003.07438.pdf">https://arxiv.org/pdf/2003.07438.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654790846.396449"></a>
      <a href="../thinking-together/1654711669.779349.html#1654790846.396449" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alex Cruise</b>
<span style="margin:2em; color:#606060">2022-06-09 09:07</span><br/>

    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654831932.698139"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1654831932.698139" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2022-06-09 20:32</span><br/>
My parser failed on your original question and on the rephrasing, but there's probably something interesting here.  So on the rephrasing, it's the second half.  How can there be "other inputs" not included in the list of "all inputs"?  (I mean there is more than one way to try to interpret "other" here.)  What follows doesn't "the same result as if you had asked the original program whether the inputs were valid" help.  Here "the" is ambiguous since we're talking about all the ones that led to a given output <b>and</b> other inputs too.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654833095.129749"></a>
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1654833095.129749" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-06-09 20:51</span><br/>
Fair. I neglected to mention that the answers from the first question are abstract, expressed as constraints. For example, if your code is the rules of Rock Paper Scissors, your first abstract query might be "how can someone win a two player game", and the abstract answers are in the form " the first player throws rock, and the second player throws scissors, and the first player wins". That would be one of the three possible abstract models that answer the hypothetical query. Now I know William and Jason played a game, and I know William threw rock. If what I want to know is who won a game, I have two options. I can run the same query again against the rules, with the concrete facts I have, and ask it to presume only that Jason threw something. Or, I can attempt to unify against the abstract models returned by the first query. Either way, the same two results will be returned. The one where Jason threw scissors, and the one where Jason threw paper. The complexity of the first query is exponential with regard to the complexity of the rules and the number of hypothetical inputs. The complexity of the second query is linear with the number of models I got from the first one, and exponential with the number of hypothesized inputs only. All the complexity that comes from the rules is avoided. I think. Maybe. :joy:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654850145.675449"></a>
      <img src="https://avatars.slack-edge.com/2019-02-14/551655871797_2624b1e78c0a9eaed529_72.jpg" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1654850145.675449" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Knott</b>
<span style="margin:2em; color:#606060">2022-06-10 01:35</span><br/>
I think the complexity is just pushed into the number of models, so while the second query is linear in respect of this, I think this is still exponential with regards to the original parameters (number of unknown inputs).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654854872.646929"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1654854872.646929" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2022-06-10 02:54</span><br/>
In general there’s no free lunch, but in general you aren’t in the general case.<br/><br/>The advantage of talking about the “models” like you have here is that matching against a given one is easy.  The disadvantage is that most programs, even not very interesting programs, are associated with a large number.  So you’re better off using a more compact formalism.  Probabilistic graphical models come to mind.<br/><br/>Often there’s a sweet spot where rules in the code are relatively simple and the data structures encode irregularity without being too big.  I shared a good example the other day.<br/><br/>Suppose you have a grid of squares and each square can be part of a path.  So seven labels: ┗,  ━, ┓, ┛, ┃, ┏, and blank.  You want to enumerate all closed loops.  You can simplify the problem by increasing the grid size to just represent horizontal edges, vertical edges, and intersections.<br/><br/>Lastly, the Yoneda Lemma formalizes the idea that you can characterize a thing by its relationships to similar things.  In practice you can use it to help figure out the right category of similar things or the right features to characterize or both simultaneously.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1655143617.737309"></a>
      <img src="https://secure.gravatar.com/avatar/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1654711669.779349.html#1655143617.737309" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jason Morris</b>
<span style="margin:2em; color:#606060">2022-06-13 11:06</span><br/>
So what I hear you saying is that it might work, but may not be computationally advantageous. Which I will test, but for my particular sort of problem, the search trees tend to be deep and wide, and the method makes both very expensive. The alternative would have less width and near-zero depth. I'm all but certain it would be faster. I'm just not certain it is semantically identical for all queries... But I suppose I will find out eventually. Thanks, both.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
