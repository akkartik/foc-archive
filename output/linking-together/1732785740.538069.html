<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2024-11-28 01:22</span><br/>
<a href="https://www.youtube.com/watch?v=y1y2BIAOwAY">What machines want</a>, by <span style="background-color:#ccf">@Dave Ackley</span>. The subtitle <b>"<a href="https://www.youtube.com/watch?v=y1y2BIAOwAY">Bottom up engineering for robust-first computing</a>"</b> is more informative. It's about building computing systems that remain robust under scale.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1732786170.581959"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1732786170.581959" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2024-11-28 01:29</span><br/>
There's an important point there that many people seem to ignore (or deny): deterministic computation (i.e. formal systems) doesn't scale. You can stay small and deterministic, or you can go for scale and then you better watch out for robustness if you care about what your computation produces.<br/><br/>I see this tension coming up frequently in discussions of computational reproducibility. On the one hand, there are people who say that computation is a deterministic tool that we need to keep deterministic by more careful bookkeeping about software components. Others argue that computation is a form of experiment that is never fully deterministic, so tech churn just adds a bit to the already existing noise. Both sides are right, but don't realize that they are talking about different scales of computation.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1732793736.306399"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1732793736.306399" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2024-11-28 03:35</span><br/>
I believe that the biggest scale at which we should be deterministic is a single small object.<br/><br/>And even that should not even be imperative determinisim, but declarative.<br/><br/>Just a data point for the discussion!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1732794950.571549"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1732794950.571549" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2024-11-28 03:55</span><br/>
What's a "small object" for you? A Raspberry Pi? A laptop? Something else? And your "should" comes from which perspective? Technical limitations? Human limitations? Something else?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1732799895.231549"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1732799895.231549" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2024-11-28 05:18</span><br/>
:grin: OK, I mean small data object like a contact, paragraph, sensor value, invoice line item, etc. That answer being about data not hardware may impact the list of challenges you would have followed up with, but to answer anyway: my "should" is just me being me, in the same way every "should" is based on personal perspective, and even feeling. And I think none of your "limitations" are involved!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1732800018.292939"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1732800018.292939" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2024-11-28 05:20</span><br/>
I haven't watched the video (I'm not a video watching type, prefer skimmable text!) but isn't this the prof who does cellular automata related work? That nature of machine paradigm fits my philosophy pretty closely.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1732813521.419839"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1732813521.419839" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2024-11-28 09:05</span><br/>
I agree that probabilistic emergent computation has the potential to be more energy efficient and ultimately scale better (see the brain). However, its also much more difficult to debug and understand, so in a engineering sense it kinda scales worse because it does not really compose (or decompose) in an easy to grok way. It resists divide and conquer problem solving. Brains are crap calculators.<br/><br/>More generally, I see too many people giving up on making things deterministic early. People forget the database scales incredibly well vertically and that thanks to transactions you can hide all the vulgarities of distributed computation behind a database channel. And thanks to Spanner and atomic clock, its even possible to scale it horizontally with a ton of money if you really need to serve everybody on the planet consistently with low latency. I think the reason we can build out crazy solutions like Spanner is because the deterministic engineering discipline can solve a narrow problem and then fit it into everything that needs it. Emergent computation is slower to evolve perhaps? Maybe an analogue is the written word, you can communicate globally knowledge orally via local-to-local, but its much better faster using libraries and the printing press coz they scale across time and space losslessly.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1732864968.068239"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1732864968.068239" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2024-11-28 23:22</span><br/>
I agree that emergent computation is a different beast than traditional Turing-style computation. Much like quantum computing. None of these newcomers will fully replace what we have today. I expect us to end up with multiple coexisting computation paradigms.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1732954052.055669"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1732954052.055669" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2024-11-30 00:07</span><br/>
What doesn't scale is complexity. Growing in size, as in a large database, or high-performance computing, is manageable.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1733158319.337529"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1733158319.337529" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2024-12-02 08:51</span><br/>
neural architectures have random dropout in their training which makes them suitable to the probabilistic computational paradigm quite well.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1733189243.194309"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../linking-together/1732785740.538069.html#1733189243.194309" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2024-12-02 17:27</span><br/>
&gt; Spanner<br/>As a counterpoint, the cost of global strict serializability in spanner can be so high that you need caches and other denormalized stores for acceptable performance. Now, adding even one cache immediately defeats any consistency properties because (spanner + cache) does not have the same consistency as spanner alone. Also, you cant run analytics on spanner either so you need another copy in an analytics database. All these extensions introduce complexity into the system and need hand-written code to deal with consistency corner cases.<br/><br/>In fact I think the dbs that "scale" are a great example of how strong determinism doesn't scale. What I think would work better is give up strict serializability across the system, but <em>track</em> the various inconsistencies. Maybe we can have a managed eventually consistent system (rather than an ad-hoc one). One way of doing this might be to allow different versions of the same object to exist in different parts of the system, but use version ids or logical timestamps to track the history and relation. Allow divergence where needed but use local rules to resolve them. This requires some core principles, like how to use logical timestamps across the entire system, but does not require the whole system itself to be serializable.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
