<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-12-10 12:23</span><br/>
Another thing: I am curious how do you resonate with “Erlang + BEAM + OTP vs Java + JVM + Akka” stacks?<br/><br/>I have almost 0 knowledge on it, read some basic articles on the comparison, but I’d really like to see what are your thoughts on that in this channel.<br/><br/>Any theoretical or practical pennies are welcome :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576015974.311300"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576015974.311300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-10 14:12</span><br/>
the BEAM has green threads, preemptive multitasking for processes, and per process heaps/GC.<br/><br/>the JVM doesn't have native green threads, actors build on top are cooperative and has a global heap. I can expand if you want :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576016019.311500"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576016019.311500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-10 14:13</span><br/>
also the BEAM is immutable, messages are copied when sent, actors on the JVM can send mutable objects and then you loose some guarantees, because another actor can corrupt your state.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576016047.311700"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576016047.311700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-10 14:14</span><br/>
the BEAM has builtin process monitoring, and transparent processes (you can send a message to a process identifier without caring if it's in the same node or somewhere else), builtin clustering through distributed erlang.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576016091.311900"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576016091.311900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-10 14:14</span><br/>
most of BEAM features have some JVM equivalents, but the BEAM is built from the ground up to solve those problems
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576016337.312300"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576016337.312300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-10 14:18</span><br/>
akka (jvm) and orleans (.net) are the closest things, personally I like orleans more
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576016371.312500"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576016371.312500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-10 14:19</span><br/>
but I'm not really used to the .net ecosystem so it's hard to try for me. But F# looks really interesting
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576022117.317800"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576022117.317800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-12-10 15:55</span><br/>
<span style="background-color:#ccf">@Mariano Guerra</span> Ahh that is really useful! Especially the fact orleans is something similar! Thanks a lot!<br/><br/>Could you please expand on these? :)<br/>• “Actors build on top are <b>cooperative</b>”<br/>• “messages are copied when sent” - how is that not possible on jvm/akka? It is, right? Or with some downside opposed to the erlang version?<br/>• “most of BEAM features have some JVM equivalents, but the BEAM is built from the ground up to solve those problems” - Is it possible that on the long run virtually all features will be implemented on JVM and with the perf + ecosystem difference BEAM will slowly fade away? If you would not bet on that, why?<br/>• “I like orleans more” - that is interesting! Why is that?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576026127.343000"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576026127.343000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-12-10 17:02</span><br/>
In Erlang/BEAM the runtime partitions the memory into isolated heaps. Cross heap references are not possible. All code evaluation is done by the runtime so all objects created only refer to the local heap. If you send something over to another heap, it is copied. This is similar to how Unix processes have isolated heaps.<br/><br/>The JVM is one big heap and any object cam refer to any other object anywhere. The runtime itself doesn't prevent any references. Now if you implement a framework on top that creates partitioned heaps and allows copying - you can only get so far. There will always be holes and once you use any shared library outside your framework, all bets are off. This kind of isolation is very hard to retrofit. Python has the same limitation (as Java).<br/><br/>A similar thing happens with lightweight threads. The Erlang runtime decides which heap/process (each heap is associated with a process) gets to run for how many steps. Then it can run another process for some steps. The multiplexing is preemptive so no tight loop can starve other processes. With user threads in Java, the code is supposed to call <tt>yield</tt> or something like that every so often and only then control goes back to the main loop which will schedule another thread. You can have starvation and latency spikes. Again this is hard to retrofit. The only preemptive scheduling available in JVM uses the (heavy) system threads.<br/><br/>FWIW, I think the Erlang isolated heap lightweight process model is great. Go copied the lightweight process (with preemptive scheduling) but it still uses a single heap.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576053831.352400"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576053831.352400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-11 00:43</span><br/>
<span style="background-color:#ccf">@Pezo - Zoltan Peto</span> Shalab explained preemptive/cooperative above :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576061560.354100"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576061560.354100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2019-12-11 02:52</span><br/>
<span style="background-color:#ccf">@Shalabh</span> Awesome! Thanks! <br/><br/><span style="background-color:#ccf">@Mariano Guerra</span> What about your orleans, why do you like it the most? :)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576062233.354400"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576062233.354400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-11 03:03</span><br/>
the concept of virtual actors, actors that "always" exist and the lifetime is handled transparently by the runtime, this means you can send a message to an actor and don't care if it doesn't exist yet, just crashed, was suspended or is being migrated to another node, the runtime will take care of finding it and delivering the message. The same with runtime support for actor state persistence.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1576062271.354600"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1576009389.307100.html#1576062271.354600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-11 03:04</span><br/>
Now that I think about it, it sounds like distributed smalltalk :stuck_out_tongue:
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
