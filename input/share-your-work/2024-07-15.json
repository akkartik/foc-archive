[
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1721034459.463199",
        "client_msg_id": "4c828c51-c4fe-42e9-bedc-519913ad007d",
        "text": "I have seen that parable before... let me search my memory... oh yes, there it is. The Bible. Old Testament. About people planning to build a tower to the sky, and God perturbing their plans by making them speak different languages.\n\nSo now I am wondering how good that analogy is. Is it hubris to believe that a small group of people can solve big problems that are, to a large part, social rather than technical? Is tech in itself hubris? Which God (or higher principle of life, for those of us who prefer the abstract) has made us incapable of working together at scale to calm our hubris?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1720864532.019509",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SH99j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have seen that parable before... let me search my memory... oh yes, there it is. The Bible. Old Testament. About people planning to build a tower to the sky, and God perturbing their plans by making them speak different languages.\n\nSo now I am wondering how good that analogy is. Is it hubris to believe that a small group of people can solve big problems that are, to a large part, social rather than technical? Is tech in itself hubris? Which God (or higher principle of life, for those of us who prefer the abstract) has made us incapable of working together at scale to calm our hubris?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "U5STGTB3J"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U04AKE9FV1U",
        "type": "message",
        "ts": "1721042152.752889",
        "client_msg_id": "226058c0-64f1-4192-9de2-c2843b954861",
        "text": "not code per say, but AI philosophy <https:\/\/www.machine-ethics.net\/podcast\/what-scares-you-about-ai-vol.2\/>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gd3c56d33c02",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/d3c56d33c02d01a5be8dd7e241d1ab6c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0007-72.png",
            "first_name": "Ben",
            "real_name": "Ben Byford",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "hello619",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FyZRg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "not code per say, but AI philosophy "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.machine-ethics.net\/podcast\/what-scares-you-about-ai-vol.2\/"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1721058786.871539",
        "client_msg_id": "e596132a-039f-4a77-8d65-9da0b6a91290",
        "text": "Maybe I should add some context to my comment. I have been thinking for a while (couple of years!) about the role of automation, industrialization, formal systems etc. in human societies. The hubris in all of these is the idea of scaling, in particular scaling to \"everything\", meaning a complete application domain. An automated\/deterministic process that grows too much becomes a risk for the ecosystem it is embedded in because it has inevitable side effects that were not part of the deployment plant. That is the analogy to building a tower to the sky.\nIn tech, there was the idea in the 1970s that programming systems like Lisp or Smalltalk should not only manage an entire device (that is actually quite reasonable), but also that once we figure out \"the best\" such system, it should naturally be adopted by everyone. Today, we understand the requirement of diversity in ecosystems much better, and such ideas seem outdated. And yet, we still produce programming languages and application frameworks that pretend to universality, and in particular make no effort to be interoperable with the other species in their ecosystems.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1720864532.019509",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hJ0OA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe I should add some context to my comment. I have been thinking for a while (couple of years!) about the role of automation, industrialization, formal systems etc. in human societies. The hubris in all of these is the idea of scaling, in particular scaling to \"everything\", meaning a complete application domain. An automated\/deterministic process that grows too much becomes a risk for the ecosystem it is embedded in because it has inevitable side effects that were not part of the deployment plant. That is the analogy to building a tower to the sky.\nIn tech, there was the idea in the 1970s that programming systems like Lisp or Smalltalk should not only manage an entire device (that is actually quite reasonable), but also that once we figure out \"the best\" such system, it should naturally be adopted by everyone. Today, we understand the requirement of diversity in ecosystems much better, and such ideas seem outdated. And yet, we still produce programming languages and application frameworks that pretend to universality, and in particular make no effort to be interoperable with the other species in their ecosystems."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1721070141.272579",
        "client_msg_id": "6890f606-147e-4f4d-9225-ee4e0253b070",
        "text": "Completely orthogonal to Konrad’s comments, I perceive there to be a deep technical issue. Typically, a new technology first gets used in old-fashioned ways. The first use for electric motors was to pump water up hills to create streams that could be used to run water-wheel-based factories.\n\nOur initial use of “computers” is riddled with old-fashioned concepts, like filing cabinets, desktops, and equations written in text on 2D paper - to run fancy calculators for moon-shots and military targeting. Modern uses for computers look entirely different. IMO, these are all asynchronous, distributed and massively parallel, like internet, robotics, gaming, GUIs, blockchain, etc.\n\nOur IDEs for “programming” are overly-biased by 1950s beliefs, like using linear, sequential, synchronous, function-based language to control and to reprogram electronic machines.\n\nIronically, the programmers in the parable do not realize that they are quibbling about menial issues and not addressing the fact that all of their languages are essentially the same. Syntax is cheap, paradigms are important. From a paradigm perspective, all of their languages force them to address problems in only one way - using the synchronous, function-based paradigm.\n\n“Coding” is usually built upon scaffolding for the synchronous, function-based paradigm. CPU subroutines are not functions. To erect the edifice of function-based programming, recursion and thread-safety on top of electronic, CPU-based machines, one needs to begin by adding extra software - often known as operating systems. This edifice requires millions of lines of “code” to exist before getting out of the starting gate. “Coding” is not equivalent to “programming” nor “reprogramming”, because only one paradigm is encouraged. Again, the interesting problems of the modern day mostly involve asynchrony.\n\nProgrammers need several new notations that do not force them to begin solving problems by using the synchronous, function-based paradigm.\n\nModern programmers only know how to code, not how to program.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1720864532.019509",
        "parent_user_id": "U5STGTB3J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1nOFs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Completely orthogonal to Konrad’s comments, I perceive there to be a deep technical issue. Typically, a new technology first gets used in old-fashioned ways. The first use for electric motors was to pump water up hills to create streams that could be used to run water-wheel-based factories.\n\nOur initial use of “computers” is riddled with old-fashioned concepts, like filing cabinets, desktops, and equations written in text on 2D paper - to run fancy calculators for moon-shots and military targeting. Modern uses for computers look entirely different. IMO, these are all asynchronous, distributed and massively parallel, like internet, robotics, gaming, GUIs, blockchain, etc.\n\nOur IDEs for “programming” are overly-biased by 1950s beliefs, like using linear, sequential, synchronous, function-based language to control and to reprogram electronic machines.\n\nIronically, the programmers in the parable do not realize that they are quibbling about menial issues and not addressing the fact that all of their languages are essentially the same. Syntax is cheap, paradigms are important. From a paradigm perspective, all of their languages force them to address problems in only one way - using the synchronous, function-based paradigm.\n\n“Coding” is usually built upon scaffolding for the synchronous, function-based paradigm. CPU subroutines are not functions. To erect the edifice of function-based programming, recursion and thread-safety on top of electronic, CPU-based machines, one needs to begin by adding extra software - often known as operating systems. This edifice requires millions of lines of “code” to exist before getting out of the starting gate. “Coding” is not equivalent to “programming” nor “reprogramming”, because only one paradigm is encouraged. Again, the interesting problems of the modern day mostly involve asynchrony.\n\nProgrammers need several new notations that do not force them to begin solving problems by using the synchronous, function-based paradigm.\n\nModern programmers only know how to code, not how to program."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]