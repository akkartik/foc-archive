<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-29 22:46</span><br/>
It is amusing to me that his laptop has an Erlang sticker, when Joe Armstrong, the inventor had such a dim view of the Actor model. There is a lively reunion on YouTube of three famous senior UK computer scientists who each selected a different technology to pursue. One was Hewitt, the actor model, and Armstrong, and Hoare who had some other paradigm i forget which. Anyway they had a debate about what were the results, and Armstrong ripped them to shreds because he pointed out that is system worked and theirs didn't actually work. Pharo has the best IDE i have ever seen, but the underlying language smalltalk was DOA (dead on arrival). The original editions of the smalltalk book by Goldberg are worth a lot, because sensible people like me who bought that book tossed it out because the language is so clunky and hard to read, and frankly absurd. You send the message PLUS to the number 3 along with another operator 2, and then the 3 updates itself to 5. That isn't too far out, but when you get to bitmap manipulation, the model really gets ugly.<br/><br/> The actor model creates not only huge numbers of little islands of state, but then compounds that mistake by creating a message passing system that is hell to debug. In any toolchain that becomes hypercomplex to understand, there are always exceptional people who claim it is no problem, but if you take a big actor model program, and pass it to another programmer, they will have zero chance of understanding it. It becomes a nightmare of dependencies and cross-connections, just like the human body.<br/><br/>I only make these possibly inflammatory remarks to warn people to look up Armstrong's talk, and think twice about wasting your time on a model that has such a legacy of failure.    If someone would like to debate this with me, we can have Steve Krouse act as referee, and hold a fire extinguisher nearby so when you burst into flames you won't be permanently harmed ;-&gt;
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572415496.360500"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572415496.360500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-29 23:04</span><br/>
I don’t think Smalltalk numbers are, as you suggest, mutable. Also, Erlang, as I understand it, uses a mutable state actor model.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572425567.361200"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572425567.361200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 01:52</span><br/>
Erlang is close to the actor model but not exactly, the creators didn't know about its existence until they already implemented the first erlang prototypes.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572425602.361400"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572425602.361400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 01:53</span><br/>
Erlang is immutable, the way erlang processes keep state is simply by recursing passing the next state to themselves
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572425723.361600"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572425723.361600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-10-30 01:55</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> If you believe that Smalltalk was a failure because it applied its OO approach even to arithmetic, you will have to explain why Python, which does exactly the same (up to syntactic sugar) has worked so well for so many people.<br/><span style="background-color:#ccf">@Steve Dekorte</span> Smalltalk numbers are indeed immutable, as are characters and booleans but perhaps not much else. The value of immutability was discovered after Smalltalk, and that's perhaps one of its main defects. Pharo is introducing immutability, though in an unusual way (you can set an object to be immutable but also back to mutable).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572440360.362400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572440360.362400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-30 05:59</span><br/>
If your goal is truly to motivate people to watch Armstrong's talk, then post a link to it. Trolling the forum with ill informed, inflammatory bullshit is not a good way to spread whatever message you derived from Armstrong's talk. Instead, you are just pissing everybody off.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572449278.365200"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572449278.365200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-30 08:27</span><br/>
<span style="background-color:#ccf">@Mariano Guerra</span> Erlang processes see one another as mutable actors, don’t they?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572449311.365500"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572449311.365500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 08:28</span><br/>
in the sense that internal state may be mutated by sending messages? yes
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572449342.365700"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572449342.365700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 08:29</span><br/>
but state is only accesible from the actor itself and "mutated in time", that is, returning a new immutable state after handling a message
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572454660.373100"></a>
      <a href="../thinking-together/1572414362.359200.html#1572454660.373100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-30 09:57</span><br/>
But there is no referential transparency between actors(processes), correct? The reference that one actor has to another does not change in order to reference the new state, so wrt state between actors we have exactly the situation as we do with mutable objects messaging one another in smalltalk. The two differences (which are both interesting) is the enhanced isolation of actors internal state from one another and that actors have message queues and their own threads of execution - both of which make actors more pure in the OO sense as state and processing are more encapsulated.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572455175.373500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572455175.373500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-10-30 10:06</span><br/>
<span style="background-color:#ccf">@Steve Dekorte</span>’s comment is spot on. Externally, when you send a message to an Erlang process you don't know what 'version' it's at. So it looks like this mutable bundle of state you're interacting with. This is very similar to any other actor model. The only thing is a process has more control of when it accepts new messages and can do so when it has reached a consistent state.<br/><br/>Here's an interesting comment from Joe Armstrong:<br/>&gt; Then, my thesis supervisor said "But you're wrong, Erlang is extremely object oriented". He said object oriented languages aren't object oriented. I might think, though I'm not quite sure if I believe this or not, but Erlang might be the only object oriented language because the 3 tenets of object oriented programming are that it's based on message passing, that you have isolation between objects and have polymorphism.<br/><br/>Source: <a href="https://www.infoq.com/interviews/johnson-armstrong-oop/">https://www.infoq.com/interviews/johnson-armstrong-oop/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572456072.373800"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572456072.373800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 10:21</span><br/>
<span style="background-color:#ccf">@Steve Dekorte</span> yes
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572456203.374000"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572456203.374000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 10:23</span><br/>
I was just highlighting that state is not mutable in erlang (nothing is mutable on the erlang vm), but yes, you can keep a reference to the same process and it will "mutate", it's the only thing that can change state while you hold the same reference if I remember correctly
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572456498.376500"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572456498.376500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-30 10:28</span><br/>
“State is not mutable in Erlang” If the way people wrote Erlang only involved a single process/actor, I would agree.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572456587.376700"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572456587.376700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-10-30 10:29</span><br/>
Oh I think another important aspect of Erlang processes is that each is 'single threaded' in the sense there can only be one control flow happening inside at one time - any other messages sent it it will wait.  This is a nice property because you can think locally and ensure it always reaches some consistent state.<br/><br/>Re state - if you write into a db from a process (dets/mnesia?) - you're still dealing with mutable state again.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572456703.376900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572456703.376900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-10-30 10:31</span><br/>
BTW I always thought of Erlang as very close to the actor model, intentionally or unintentionally. So I'm a bit confused about the assertion that Armstrong held a dim view of the actor model. I think I found the panel discussion referred to (haven't finished watching yet): <a href="https://www.youtube.com/watch?v=37wFVVVZlVU">https://www.youtube.com/watch?v=37wFVVVZlVU</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572456904.377200"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572456904.377200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 10:35</span><br/>
usually people make the distinction between "sequential erlang", the language and its semantics that you write as modules and functions and "Erlang/OTP" the concurrency primitives and patterns used to organize processes into systems, the immutability is in the sequential part (the language) the "mutability" is in the platform
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572457704.379200"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572457704.379200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-30 10:48</span><br/>
Yes, or have any interaction (i/o) with the actual world at all, but who needs users, keyboards, mice, touch screens, user interfaces, files, databases, sensors, or network communications? ;)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572458462.379500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572458462.379500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-10-30 11:01</span><br/>
The immutable model, single assignment, etc does affect how you write code in the small, based on my very limited experience with Erlang. The main thing I liked was things aren't going to just change underneath you - within your process of course. Its kind of like working in a single threaded isolated heap. But you know when you're looking outside the process that you'll may get anything. Also you don't usually synchronously look outside your process. You just send a message and are done. Then later, you may get a message related to one you sent.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572469244.379900"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572469244.379900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-30 14:00</span><br/>
In the talk above the Hoare and Hewitt are somewhat smug, and Armstrong upbraids them because he points out his system actually built shipping products that worked well. Their approaches did not work.  It is easy to lump Erlang/Elixir into a category with other languages, but it is a unique beast; with a very clever runtime that creates a stack and heap for each micro-process. This allows you to reboot a process, and not have some godawful pile of a million tiny chunks of memory that have to be marked and swept. When it comes to massive multithreading, there is only two ways to do it: a super meticulously hand-crafted runtime, or use the runtime that Erlang/Elixir have, because it solves an immensely difficult problem.<br/><br/>If you take the straight actor model, and combine non-reversibility with  concurrency, your system will be incredibly fragile. That is Armstrong's point. He wasn't a theoretician like Hewitt and Hoare, but someone building real high volume things, not toys.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572471412.380200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572471412.380200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-30 14:36</span><br/>
Armstrong has a lot of good videos up. They are entertaining and informative. One thing to remember though is that Erlang was banned inside Ericsson, where it was created, and that banning is probably related to the poor transferability score that Erlang possesses. If you notice that Elixir is having much greater acceptance, because some would describe the Erlang syntax as opaque. A program in commercial use lasts decades, and the ability to transfer code from one person to the next is a major factor in language selection. This means sticking with popular languages, but also avoiding ones like LISP, FORTH, and APL which have super low transferability.  It would be great to hear from people who used to work at Ericsson as to why exactly it was banned. There was no question that his system worked well, and was robust; but maybe it was too hard to maintain and thus fragile in the end? There is a lot of information in failure, and i wish people would be more honest about the failures of the past; this is how you get wisdom.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572474176.380500"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572474176.380500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 15:22</span><br/>
<a href="https://twitter.com/JaneWalerud/status/1189461281184636928">https://twitter.com/JaneWalerud/status/1189461281184636928</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572474183.380800"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572474183.380800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 15:23</span><br/>
that thread explains why
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572474209.381000"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572474209.381000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-30 15:23</span><br/>
Erlang is used a lot again inside Ericsson since it was open sourced and the ban was lifted
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572482335.382300"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572482335.382300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-30 17:38</span><br/>
Companies like Autodesk which uses Autolisp as the core language of their system (the only  large company i am aware of basing their technology on LISP) doesn't care if their language is popular. It is their secret weapon and makes AutoCad infinitely programmable. My question remains, what were the technical factors behind the decision to ban Erlang? Plenty of companies use a custom-made secret sauce to generate their products (Facebook uses Hack for front end if i am not mistaken, a derivative of PHP). When you dominate a sector using your tools, why would you ban the tool? Ericsson was kicking butt back in 1998, and still is a top-3 player in Telecom infrastructure equipment. So little information leaks out of companies about why things did or did not pan out. We usually have to wait 20 years or more to find out the true story.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572506344.385200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572506344.385200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-31 00:19</span><br/>
Some of you guys give me a hard time about how long my responses are. Sorry i don't have the time to make them shorter. The reason i dumped a bucket of icewater on Leandro's lecture, is that he hasn't done his homework. Unlike 99% of the people on this forum, i was programming when the InMos Transputer came out, and i downloaded the user manual for Occam and tried to learn it (impossible). And remember the Connection Machine that was going to revolutionize the world? Only a genius like Danny Hillis could get that thing to say "hello world". Or how about the recent disaster, the Adapteva Parallela machine? The hardware was great; you have thousands of independent processors, with an orders of magnitude improvement in CPU power vs. energy consumption. It failed miserably even though the hardware worked, because nobody could debug their programs!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572511945.385500"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572511945.385500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-10-31 01:52</span><br/>
It was not mainly technical, it was a strategic decision, Jane was at Ericsson and helped open source it, I think she explain it a little more in some   other talks you can find in youtube, I've spoken with Joe and Robert about it and they tell similar things
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572546653.412700"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572546653.412700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-31 11:30</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> I agree programmability is important, but historically it seems to get trumped by economic concerns. For example, I programmed a CM2 and Fortran90 was actually easier than Fortan to use. The problem was you had to wait in a queue with other users to run your program, which was often slower than using your workstation (if your program could fit on your workstation). What killed traditional supercomputers were compute clusters, which were actually harder to program but cheaper and therefore more accessible. Likewise, GPUs are harder to program but are far cheaper for the compute power.<br/><br/>I suspect Smalltalk would be ubiquitous today had they made the core free and sold libraries and consulting services. Instead they chose to price it well outside of what typical users could afford, thinking that programmability justified the high cost.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572548856.414300"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572548856.414300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-31 12:07</span><br/>
<span style="background-color:#ccf">@Steve Dekorte</span> The traditional supercomputers were effectively a DOD sponsored product, and succeeded/failed based on the funding of that group. The average firm can't even use a supercomputer. But the Inmos transputer was cheap, and so was the Adapteva Parallela. So it wasn't about cost, but tooling. One thing often overlooked is that our entire mathematics tradition starting from Greek proof, is based on a single line of reasoning, applied sequentially, and we humans do not yet possess the mathematical knowledge that permits easy parallel thinking. The minute you have more than 100 processes operating at once, you can't even fit the threads on the screen, so visualizing and tracking it becomes extremely cumbersome and confusing. I suspect that once we have screens that are 100 million pixels - and we are getting there, it should be easier to handle. For comparison purposes the upcoming Apple 6K monitor has 20 million pixels. There are some types of projects that just demand a lot of pixels to do properly.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572552878.430600"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572552878.430600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-31 13:14</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> “The traditional supercomputers were effectively a DOD sponsored product,” Yes, and the lab I worked at was DOD funded too but it was still moving everything to workstation compute clusters by the mid 1990s because they wanted to make the best use of their funding.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1572553145.430800"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1572414362.359200.html#1572553145.430800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-31 13:19</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> “The minute you have more than 100 processes operating at once, you can’t even fit the threads on the screen” That’s true, though IME the problem is more the model used. I think the Lua authors put it well:<br/><br/>“…we did not (and still do not) believe in the standard multithreading model, which is preemptive concurrency with shared memory: we still think that no one can write correct programs in a language where ‘a=a+1’ is not deterministic.” (from The Evolution of Lua)<br/><br/>Eliminating either shared memory (with actors) or preemptive concurrency (with coroutines) goes a long way towards solving these problems, yet these solutions are strongly resisted in the mainstream programming culture.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
