<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1588448354.425100.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-05-02 12:39</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> Spending most of my day every day dealing with 100 million intrusion attempts each 24 hours, i am only too familiar with internet security flaws. However, it is the basic protocols of the internet that are at fault, not how they are implemented. It is a fact that the early internet had zero concern with security, given that it ran on private leased lines between the universities.  I remember visiting MIT at the dawn of the internet, and there was a terminal hooked between boston and berkeley. You could chat back and forth; it was fairly useless until the WWW came along.<br/><br/>You are perhaps not familiar with Modula-2 which was Prof. Wirth's 10 year later sequel to Pascal. In Modula-2 you can specify whether or not a called function has access to modify data, and along with other clever and simple features you can make rock solid programs that are as tight as it can be. And to claim that pure functional program is the answer to anything is not factual. If you are building a Chess game program, the state of the board is going to change, and any attempt to evade changing the state of the board is merely hiding the state changes somewhere. Minimizing the number of state variables, and making sure there is no redundancy (which is the source of many errors) is a virtue, but to pursue utter purity in avoiding state makes your program unable to do any useful work. John Backus who invented FP, who gave a lecture i attended in 1973 on his Functional language called Red at the time, was unable to finish his work, and his prior creation FORTRAN did battle with COBOL (and losing to an inferior language). He had the goal of interchangeable parts, but did not achieve it.<br/><br/>There is little evidence that FP is bringing about an era of interchangable parts, and making it easier to maintain large programs, two of the most important unsolved problems in computer engineering. My own project revolves around using deduction, something nearly forgotten as it was last seen in the 70's in PROLOG. Since all programs must eventually map their syntax into the underlying instructions of the Intel or ARM processors, the only difference between 2 languages can be the convenience, conciseness, shareability, and maintainability of the notation. There are languages like FORTH that trade everything for brevity, but nobody programs in FORTH because it is unmaintainable. The ability to share components in the FP languages I have seen is not exemplary. The idiocy of having millions of programmers reinvent the same programs over and over is quite absurd. Look at Google's code pile; they must be close to 10 billion lines, it is ridiculous. I can't recall a time when i found some nice chunk of code on Github and was able to use it. There are billions of lines there, but it is all disorganized, full of dependencies i don't want to carry, and of unknown quality and reliability. So to ensure things work i end up writing almost everything myself. People like me are part of the problem, but i don't have access to a marketplace of nice little widgets like Apple's iTunes App Store has for full apps. That would be a really useful thing.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
