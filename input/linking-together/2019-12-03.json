[
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1575363339.336900",
        "client_msg_id": "184db41d-cf2a-4eb3-8a8c-69585d6ca737",
        "text": "I agree with you, but a particular part of what you said applies to at most a half of the world \"We learn to read left to right, and the habit of reading right to left is so unnatural\" emphasis on \"unnatural\". The idea that triggered that (eurocentric :P) word is the space of unexplored \"natural\" programming languages for people that read right to left and chinese and chinese-like languages :slightly_smiling_face: do chinese learn APL faster? can they build an APL with chinese characters and spare the need to learn new symbols? do APL symbols translate directly to the meanings of the greek letters? do greeks enjoy APL? what other programming languages would appear if designed in places with a different language\/alphabet\/writing system?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575263959.333500",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qNy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree with you, but a particular part of what you said applies to at most a half of the world \"We learn to read left to right, and the habit of reading right to left is so unnatural\" emphasis on \"unnatural\". The idea that triggered that (eurocentric :P) word is the space of unexplored \"natural\" programming languages for people that read right to left and chinese and chinese-like languages "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " do chinese learn APL faster? can they build an APL with chinese characters and spare the need to learn new symbols? do APL symbols translate directly to the meanings of the greek letters? do greeks enjoy APL? what other programming languages would appear if designed in places with a different language\/alphabet\/writing system?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1575363423.337100",
        "client_msg_id": "eeab7fdf-97c9-489c-984a-4645bea892fa",
        "text": "For example, I have read APL tutorials but never wrote more than a line on it, but the idea of having adverbs was really interesting to me, what other concepts  from languages other than english and western ones can we use on new programming languages?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575263959.333500",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "414iT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For example, I have read APL tutorials but never wrote more than a line on it, but the idea of having adverbs was really interesting to me, what other concepts  from languages other than english and western ones can we use on new programming languages?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHWC9PXBL",
        "type": "message",
        "ts": "1575386935.337500",
        "client_msg_id": "eeb0044a-4ffd-4bc2-88a6-6f4e1f5fef45",
        "text": "&gt; internally, the parameters are named fork and spoon; externally, the first parameter is markerless and the second parameter is identified by a clothes peg.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "Garth",
            "real_name": "Garth Goldwater",
            "display_name": "garth",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575173611.326800",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vhx7",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "internally, the parameters are named fork and spoon; externally, the first parameter is markerless and the second parameter is identified by a clothes peg."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHWC9PXBL",
        "type": "message",
        "ts": "1575386941.337700",
        "client_msg_id": "0e5f3532-6f7b-4dfd-8c8f-ae23a613ed3a",
        "text": "this is beautiful",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "Garth",
            "real_name": "Garth Goldwater",
            "display_name": "garth",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575173611.326800",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xrrh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this is beautiful"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHWC9PXBL",
        "type": "message",
        "ts": "1575386978.337900",
        "client_msg_id": "ba0c6a74-6680-439a-ad7d-ac60e2e199e6",
        "text": "all the hallmarks of late night graduate student existential crisis",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g0d754210ed4",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/10d754210ed4e4706eba3d063cdf99f0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "Garth",
            "real_name": "Garth Goldwater",
            "display_name": "garth",
            "team": "T5TCAFTA9",
            "name": "garth",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575173611.326800",
        "parent_user_id": "UJN1TAYEQ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PeV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "all the hallmarks of late night graduate student existential crisis"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1575408335.338400",
        "client_msg_id": "5585c6dc-291d-4a24-b42b-c6acbc6fb9e8",
        "text": "Chinese is a cumbersome language, and several times in the last century the govt. considered dropping it entirely. Unfortunately it is not a 1 symbol is 1 word language; most words are made out of at least 2 symbols next to each other, and the ambiguity in the language is therefore rather intense, because they don't use spaces between words, so one has to guess which pairs go together. Learning Chinese is the equivalent of learning 5 european languages. Ezra Pound wrote a great essay on why Chinese is so superior for Poetry, which it is; no language is more poetic and capable of subtlety. No question that knowing pictographic languages makes APL seem like child's play; once you have learned thousands of Chinese symbols that are often only slightly different, APL with its very distinct symbol set of under 100 characters is baby stuff.  And don't forget that APL written in Arabic style would be typed in right to left, but executed left to right, the reverse of that language's normal order, so this is not a Eurocentric issue; you write APL in your normal word order, but it is executed in reverse. Same problem with LISP, which you read from the inside out, which is also highly unnatural, and is often referred to as an \"insidious parenthetical notation\".  APL was so perverse in its conception that he even included overstruck characters, which one can imagine all the editing complexities that introduces for a tiny gain. Mathematicians frankly delight in obscurity, I wonder how the Parisian mayoral candidate is doing; he is a Field medal mathematician, the first one to run for a major office to my knowledge.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575263959.333500",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ot=5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Chinese is a cumbersome language, and several times in the last century the govt. considered dropping it entirely. Unfortunately it is not a 1 symbol is 1 word language; most words are made out of at least 2 symbols next to each other, and the ambiguity in the language is therefore rather intense, because they don't use spaces between words, so one has to guess which pairs go together. Learning Chinese is the equivalent of learning 5 european languages. Ezra Pound wrote a great essay on why Chinese is so superior for Poetry, which it is; no language is more poetic and capable of subtlety. No question that knowing pictographic languages makes APL seem like child's play; once you have learned thousands of Chinese symbols that are often only slightly different, APL with its very distinct symbol set of under 100 characters is baby stuff.  And don't forget that APL written in Arabic style would be typed in right to left, but executed left to right, the reverse of that language's normal order, so this is not a Eurocentric issue; you write APL in your normal word order, but it is executed in reverse. Same problem with LISP, which you read from the inside out, which is also highly unnatural, and is often referred to as an \"insidious parenthetical notation\".  APL was so perverse in its conception that he even included overstruck characters, which one can imagine all the editing complexities that introduces for a tiny gain. Mathematicians frankly delight in obscurity, I wonder how the Parisian mayoral candidate is doing; he is a Field medal mathematician, the first one to run for a major office to my knowledge."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UBN9AFS0N"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1575419535.338700",
        "client_msg_id": "3a4d6d58-7638-4636-9ebf-4f4fcb8865f6",
        "text": "&gt; the idea of having adverbs was really interesting to me\n\"verb\" and \"adverb\" are just non-standard terminology for standard concepts. In functional programming, a verb is a function, and an adverb is a combinator (a function that takes a function as an argument, and returns another function as a result. For example, in functional languages, \"map\" is a combinator, which is exactly equivalent to the \"each\" adverb in APL.\n\nBut if you look at the actual syntax of APL (or K), you see something interesting, which might relate to natural language. I don't think that left-to-right vs right-to-left evaluation order is a big deal. Almost every language has right-associative infix operators, APL just has more of them. What I find more interesting is that identifiers and operator symbols are treated the same way: they can be interpreted either as infix operators, or as arguments to an adverb. I don't see that in any other language family. APL classifies each named object as a noun, verb or adverb, and that classification affects how expressions are parsed. An adverb takes one or two verbs as arguments, and a verb takes one or two nouns as arguments. And that's interesting.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575263959.333500",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3UIie",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the idea of having adverbs was really interesting to me"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"verb\" and \"adverb\" are just non-standard terminology for standard concepts. In functional programming, a verb is a function, and an adverb is a combinator (a function that takes a function as an argument, and returns another function as a result. For example, in functional languages, \"map\" is a combinator, which is exactly equivalent to the \"each\" adverb in APL.\n\nBut if you look at the actual syntax of APL (or K), you see something interesting, which might relate to natural language. I don't think that left-to-right vs right-to-left evaluation order is a big deal. Almost every language has right-associative infix operators, APL just has more of them. What I find more interesting is that identifiers and operator symbols are treated the same way: they can be interpreted either as infix operators, or as arguments to an adverb. I don't see that in any other language family. APL classifies each named object as a noun, verb or adverb, and that classification affects how expressions are parsed. An adverb takes one or two verbs as arguments, and a verb takes one or two nouns as arguments. And that's interesting."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1575420019.339000",
        "client_msg_id": "69e0fb8c-e806-430a-8111-2672713ec9f9",
        "text": "One thing that's frustrated me about APL and descendants is that tutorials never discuss the grammar. As you point out, there _is_ a grammar. It's not just all associating the same way.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575263959.333500",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7V2ow",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One thing that's frustrated me about APL and descendants is that tutorials never discuss the grammar. As you point out, there "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a grammar. It's not just all associating the same way."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1575421303.339200",
        "client_msg_id": "dda62989-14f1-4734-bbc3-0dc18f099487",
        "text": "APL has nothing to do with Chinese. APL is extended mathematical notation. The idea of using symbols for mathematical operations comes from math. As for the number of symbolic operators, it's comparable to other math-based programming languages. I believe that Haskell (a math-inspired language) has more symbolic operators than any of the languages in the APL family. K is at the low end of this scale, with 26 distinct symbolic operator names. K uses identifiers like 'sin', 'cos', 'tan' for additional operators outside the core set. Even C has more: 28 symbolic operator names, not including the compounds +=, -=, etc. For another comparison, I looked at Julia, which is another math-oriented programming language. I stopped counting at 40, and I didn't include compound operators like += and .^, but there are a lot.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575263959.333500",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Oy8K",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "APL has nothing to do with Chinese. APL is extended mathematical notation. The idea of using symbols for mathematical operations comes from math. As for the number of symbolic operators, it's comparable to other math-based programming languages. I believe that Haskell (a math-inspired language) has more symbolic operators than any of the languages in the APL family. K is at the low end of this scale, with 26 distinct symbolic operator names. K uses identifiers like 'sin', 'cos', 'tan' for additional operators outside the core set. Even C has more: 28 symbolic operator names, not including the compounds +=, -=, etc. For another comparison, I looked at Julia, which is another math-oriented programming language. I stopped counting at 40, and I didn't include compound operators like += and .^, but there are a lot."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1575423123.339400",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1575423465.000000"
        },
        "client_msg_id": "d5e4832a-3002-4c37-8d00-16d217a1908e",
        "text": "> you have to read it right to left, which is foreign to all normal people\nIn standard mathematical notation, function call notation is read right to left:\n```   h(g(f(x)))```\nIn languages from the APL family, you use exactly the same notation, but the parentheses are optional, so you can also write:\n```   h g f x```\nIf you really believe that the problem with the above notation is that it is read right to left, then you should change Beads to have left-to-right function call notation.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575263959.333500",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MKb\/",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "you have to read it right to left, which is foreign to all normal people"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In standard mathematical notation, function call notation is read right to left:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "   h(g(f(x)))"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In languages from the APL family, you use exactly the same notation, but the parentheses are optional, so you can also write:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "   h g f x"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you really believe that the problem with the above notation is that it is read right to left, then you should change Beads to have left-to-right function call notation."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1575425130.339900",
        "client_msg_id": "23677d52-1646-4c93-bff1-6ec82f34ed3e",
        "text": "Also related to right-to-left evaluation:\nMy language, Curv, is a pure functional language, and programs often consist of deeply nested function calls. A single expression can be spread over many lines. Reading such programs bottom-to-top and right-to-left is a problem, so I introduced left-to-right function call notation, which in my case looks like this:\n```x &gt;&gt; f &gt;&gt; g &gt;&gt; h    is the same as    h(g(f(x))```\nIn practice, programs written in this style feel just like pipelines in the Unix shell. It's nice. Many other functional languages also have a left-to-right pipeline operator.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1575263959.333500",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DTZ=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also related to right-to-left evaluation:\nMy language, Curv, is a pure functional language, and programs often consist of deeply nested function calls. A single expression can be spread over many lines. Reading such programs bottom-to-top and right-to-left is a problem, so I introduced left-to-right function call notation, which in my case looks like this:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "x >> f >> g >> h    is the same as    h(g(f(x))"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In practice, programs written in this style feel just like pipelines in the Unix shell. It's nice. Many other functional languages also have a left-to-right pipeline operator."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]