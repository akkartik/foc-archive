[
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1566372487.180600",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1566372518.000000"
        },
        "client_msg_id": "c9f2a695-e57a-4ec5-b966-9ef866024819",
        "text": "<https:\/\/twitter.com\/brianhempel\/status\/1163807830031425536> <@UC21F8Q48> via <@U6KQ2S410>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "attachments": [
            {
                "fallback": "<https:\/\/twitter.com\/brianhempel|@brianhempel>: <https:\/\/twitter.com\/prathyvsh|@prathyvsh> A PL variant of this is Clayton Lewis's argument against quantitative measurement in PL evaluation, because the real landscape is too big to meaningfully sample. \"Methods in User Oriented Design of Programming Languages\" (PPIG 2017) <http:\/\/ppig.org\/sites\/ppig.org\/files\/2017-PPIG-28th-lewis.pdf> <https:\/\/pbs.twimg.com\/media\/ECatC6GXYAATLZW.jpg>",
                "ts": 1566308383,
                "author_name": "Brian Hempel",
                "author_link": "https:\/\/twitter.com\/brianhempel\/status\/1163807830031425536",
                "author_icon": "https:\/\/pbs.twimg.com\/profile_images\/744065437554577409\/9aOaF7Ch_normal.jpg",
                "author_subname": "@brianhempel",
                "text": "<https:\/\/twitter.com\/prathyvsh|@prathyvsh> A PL variant of this is Clayton Lewis's argument against quantitative measurement in PL evaluation, because the real landscape is too big to meaningfully sample. \"Methods in User Oriented Design of Programming Languages\" (PPIG 2017) <http:\/\/ppig.org\/sites\/ppig.org\/files\/2017-PPIG-28th-lewis.pdf> <https:\/\/pbs.twimg.com\/media\/ECatC6GXYAATLZW.jpg>",
                "service_name": "twitter",
                "service_url": "https:\/\/twitter.com\/",
                "from_url": "https:\/\/twitter.com\/brianhempel\/status\/1163807830031425536",
                "image_url": "https:\/\/pbs.twimg.com\/media\/ECatC6GXYAATLZW.jpg",
                "image_width": 1200,
                "image_height": 1055,
                "image_bytes": 117894,
                "id": 1,
                "original_url": "https:\/\/twitter.com\/brianhempel\/status\/1163807830031425536",
                "footer": "Twitter",
                "footer_icon": "https:\/\/a.slack-edge.com\/80588\/img\/services\/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Fcmy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/twitter.com\/brianhempel\/status\/1163807830031425536"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UC21F8Q48"
                            },
                            {
                                "type": "text",
                                "text": " via "
                            },
                            {
                                "type": "user",
                                "user_id": "U6KQ2S410"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566376698.181400",
        "client_msg_id": "d16bca65-f087-4904-b8fc-a0839ae96584",
        "text": "The Clayton Lewis paper is very interesting. There are some people in the programming language community that swear that programming is an unmeasurable activity, and that we cannot give a numerical score to a language in some dimension, like ease of use, or mean time to repair by someone other than the author which is the number i am optimizing for in my designs. I disagree with this attitude. We can indeed measure it classrooms and industry projects pretty directly. Once your sample size gets large enough, and you get past toy problems, the virtues or flaws of a language become glaringly apparent. I worked on a project for IBM at the very tail end of the Thomas J. Watson, Jr. era, and under Watson's regime, every important project at IBM had 3 different teams working on it, as a form of internal contest. This is obviously quite expensive, but it kept the teams in a competitive mindset. The winner of the contest who came in first and best was rewarded with extra funding, and losing teams like sports teams transferred staff around. Unfortunately by the time i worked on this project, IBM's management had deteriorated into what is now very common in children's sports where \"everyone is a winner\". They lacked guts to declare a winner, and IBM although is still a very company has almost no impact any more on the computer industry. They are a mere shadow of their former selves. When you have three different teams, and they use different languages for the same detailed specification, we saw Modula-2 outperform C by more than 2:1 on man-hours (which translates to cost), and 12 months instead of 18. Half the people in 3\/4 the time translates to a 3:1 advantage of Modula-2 over C. The third project never even finished in time so one could argue it was even better than 3:1.\n\nI believe that for a specified task, for each different language, you can rank and estimate the time it will take to implement, and also estimate how hard it will be to repair and update the project. No question that animating cats is easy in Scratch, and very easy to maintain, and it would be cumbersome to that task in Java. The reason we have so many languages to choose from is because we are making such a wide variety of software. I know of many projects which are impossible to do in anything but Mathematica, because it symbolic solving language, and unlike any other conventional language.\n\nI fought unsuccessfully to get other companies and teams to adopt Modula-2. They did not care if it offered consistent, significant advantages, because it wasn't what everyone else is using. Human beings are herd animals, and the glacial pace of improvement in software is due in part to the stubbornness and herd instinct of humans. Here we are more than 30 years after Modula-2, and Javascript a little while ago added to their syntax a slightly botched subset of the Modula2 module system, and that's considered an exciting feature that is taking years to roll out into the browsers. As of today, you can only run local modules in Safari, because Chrome considers it a security risk. It is so frustrating to see things from decades, slowly rolling out drip by drip.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6Q\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The Clayton Lewis paper is very interesting. There are some people in the programming language community that swear that programming is an unmeasurable activity, and that we cannot give a numerical score to a language in some dimension, like ease of use, or mean time to repair by someone other than the author which is the number i am optimizing for in my designs. I disagree with this attitude. We can indeed measure it classrooms and industry projects pretty directly. Once your sample size gets large enough, and you get past toy problems, the virtues or flaws of a language become glaringly apparent. I worked on a project for IBM at the very tail end of the Thomas J. Watson, Jr. era, and under Watson's regime, every important project at IBM had 3 different teams working on it, as a form of internal contest. This is obviously quite expensive, but it kept the teams in a competitive mindset. The winner of the contest who came in first and best was rewarded with extra funding, and losing teams like sports teams transferred staff around. Unfortunately by the time i worked on this project, IBM's management had deteriorated into what is now very common in children's sports where \"everyone is a winner\". They lacked guts to declare a winner, and IBM although is still a very company has almost no impact any more on the computer industry. They are a mere shadow of their former selves. When you have three different teams, and they use different languages for the same detailed specification, we saw Modula-2 outperform C by more than 2:1 on man-hours (which translates to cost), and 12 months instead of 18. Half the people in 3\/4 the time translates to a 3:1 advantage of Modula-2 over C. The third project never even finished in time so one could argue it was even better than 3:1.\n\nI believe that for a specified task, for each different language, you can rank and estimate the time it will take to implement, and also estimate how hard it will be to repair and update the project. No question that animating cats is easy in Scratch, and very easy to maintain, and it would be cumbersome to that task in Java. The reason we have so many languages to choose from is because we are making such a wide variety of software. I know of many projects which are impossible to do in anything but Mathematica, because it symbolic solving language, and unlike any other conventional language.\n\nI fought unsuccessfully to get other companies and teams to adopt Modula-2. They did not care if it offered consistent, significant advantages, because it wasn't what everyone else is using. Human beings are herd animals, and the glacial pace of improvement in software is due in part to the stubbornness and herd instinct of humans. Here we are more than 30 years after Modula-2, and Javascript a little while ago added to their syntax a slightly botched subset of the Modula2 module system, and that's considered an exciting feature that is taking years to roll out into the browsers. As of today, you can only run local modules in Safari, because Chrome considers it a security risk. It is so frustrating to see things from decades, slowly rolling out drip by drip."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UHDQ62M4P"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UC21F8Q48",
        "type": "message",
        "ts": "1566400523.181600",
        "client_msg_id": "9270f76b-bbba-4039-813a-c6c56b66c328",
        "text": "Thanks for the story, <@UEQ6M68H0>. It’s so rare to hear actual head-to-head stories between languages! Maybe quantitative measurement isn’t impossible, but in practice it probably is for basically everyone. IBM had money to hire multiple teams for multiple months, but academics and people on this Slack do not. (And even in your story, a scientific purist could complain that it wasn’t a _real_ randomized controlled trial (RCT): the purist would want to control for different managers and team dynamics. Find 20 managers, randomly assign engineers to managers, assign 10  teams to C, 10 to Modula-2, and task them all with the same project. Does the lack of an RCT nullify your 3:1 productivity result? Only to an RCT-statistical purist! But in practice I’m sure you have reason to believe your 3:1 result because you saw the day-to-day details of actually building the project. Measuring only project duration doesn’t capture those details. So I guess that’s what qualitative methods like the “Cognitive Dimensions of Notation” help you do: they help you observe those details, so you get finer resolution sampling, and that’s what Lewis argues for.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d79ba47b2952",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-08-03\/410049852848_d79ba47b2952e74a99d9_72.jpg",
            "first_name": "Brian",
            "real_name": "Brian Hempel",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "brianhempel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7ovn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for the story, "
                            },
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": ". It’s so rare to hear actual head-to-head stories between languages! Maybe quantitative measurement isn’t impossible, but in practice it probably is for basically everyone. IBM had money to hire multiple teams for multiple months, but academics and people on this Slack do not. (And even in your story, a scientific purist could complain that it wasn’t a "
                            },
                            {
                                "type": "text",
                                "text": "real",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " randomized controlled trial (RCT): the purist would want to control for different managers and team dynamics. Find 20 managers, randomly assign engineers to managers, assign 10  teams to C, 10 to Modula-2, and task them all with the same project. Does the lack of an RCT nullify your 3:1 productivity result? Only to an RCT-statistical purist! But in practice I’m sure you have reason to believe your 3:1 result because you saw the day-to-day details of actually building the project. Measuring only project duration doesn’t capture those details. So I guess that’s what qualitative methods like the “Cognitive Dimensions of Notation” help you do: they help you observe those details, so you get finer resolution sampling, and that’s what Lewis argues for.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGR73CAY",
        "type": "message",
        "ts": "1566407955.181800",
        "client_msg_id": "cc2552cd-ce1d-4b4d-b716-34fbbb72cf40",
        "text": "Good idea Edward, I think I will skip the wristwatch and move on to snake next.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "bc46d9e86f7d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-26\/5176774456644_bc46d9e86f7dc3780301_72.jpg",
            "first_name": "Corey",
            "real_name": "Corey Montella",
            "display_name": "Corey",
            "team": "T5TCAFTA9",
            "name": "cmontella",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565150123.115400",
        "parent_user_id": "UCGR73CAY",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zs35c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good idea Edward, I think I will skip the wristwatch and move on to snake next."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1566409163.182100",
        "client_msg_id": "453afb06-bc76-4a3f-8bbe-aab096e4d956",
        "text": "<@UEQ6M68H0> we may be herd animals, but we additionally slow down progress by not agreeing what progress looks like, so we stay with the status quo because it is the only thing that has momentum",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2l=v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " we may be herd animals, but we additionally slow down progress by not agreeing what progress looks like, so we stay with the status quo because it is the only thing that has momentum"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1566409240.182300",
        "client_msg_id": "1575e5fb-689e-413c-bc88-08816c4e42e0",
        "text": "yes, the whole world getting excited about small improvements in JS sometimes feels like everyone getting excited about slightly rounder wooden wheels on horse carts :wink:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZlIns",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yes, the whole world getting excited about small improvements in JS sometimes feels like everyone getting excited about slightly rounder wooden wheels on horse carts "
                            },
                            {
                                "type": "emoji",
                                "name": "wink",
                                "unicode": "1f609"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1566409352.182500",
        "client_msg_id": "d7ac4a8a-69d4-497a-984c-09a4889d7a06",
        "text": "And yes, you can measure, particularly these large quantities of students implementing the same medium size problem seems interesting. The problem is with the conclusions, they may hold for some small subset of that above diagram and not all",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BUQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And yes, you can measure, particularly these large quantities of students implementing the same medium size problem seems interesting. The problem is with the conclusions, they may hold for some small subset of that above diagram and not all"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1566409464.182700",
        "client_msg_id": "ef7d49f1-4e12-46c0-84ea-66160f07bf54",
        "text": "I think for every \"obvious\" progress you can conclude from a study, there are always legitimate reasons why it would be the opposite of progress for some part of that graph",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7R3Pw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think for every \"obvious\" progress you can conclude from a study, there are always legitimate reasons why it would be the opposite of progress for some part of that graph"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1566409654.182900",
        "client_msg_id": "0d1b21af-a754-449c-91ff-b6b88e9f0748",
        "text": "for example, there's a lot of people that think that everyone switching to GC languages would be progress, and I would personally strongly disagree (&lt;- don't take this as the start of a GC debate, it is just an example). Same with static typing, functional programming, some testing or SE methodology, etc etc",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yJr0\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "for example, there's a lot of people that think that everyone switching to GC languages would be progress, and I would personally strongly disagree (<- don't take this as the start of a GC debate, it is just an example). Same with static typing, functional programming, some testing or SE methodology, etc etc"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHDQ62M4P",
        "type": "message",
        "ts": "1566410048.183100",
        "client_msg_id": "27b70d91-57f5-4841-a4b5-36bdf354ffbb",
        "text": "It's funny, programming is such a huge field now (both in terms of breath of subject matter and the amount of people involved) and has a decent length cultural history, that we're running into similar issues as other fields in terms of making progress. I guess the advantage we have is that often sub-groups can make progress without needing the whole world to follow along (you can have type safety in your own project mostly even if the rest of the world doesn't want it, which is easier than say, solving pollution in the real world). But the price we pay for that is crazy levels of fragmentation, duplication, and interfacing pains.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "465336060ae8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-27\/582042668721_465336060ae83dc74288_72.jpg",
            "first_name": "Wouter",
            "real_name": "Wouter van Oortmerssen",
            "display_name": "Wouter",
            "team": "T5TCAFTA9",
            "name": "aardappel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4LY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's funny, programming is such a huge field now (both in terms of breath of subject matter and the amount of people involved) and has a decent length cultural history, that we're running into similar issues as other fields in terms of making progress. I guess the advantage we have is that often sub-groups can make progress without needing the whole world to follow along (you can have type safety in your own project mostly even if the rest of the world doesn't want it, which is easier than say, solving pollution in the real world). But the price we pay for that is crazy levels of fragmentation, duplication, and interfacing pains."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "In the large project i was working on (approx. 100 man years), we had the choice of C or Modula-2. Modula-2 has an almost exact mapping 1:1 with C. C has arithmetic, logical operations, records, arrays, function calls, and the classic control flow statements like loops, if, switch. So from a feature point of view Modula-2 only offered a few additional features. So people ignored it. But what they failed to realize at the time, and still continue to fail to realize, is that from a practical standpoint programming is all about avoiding human error. You can write 1000 lines of code in a certain number of hours, but how long until all the errors are removed? This is where the majority of time is spent, and when you have a whole bunch of people changing the same code base at the same time, that multiplies the possibility for errors. Modula-2 offered more protection for the programmer. It caught errors that C at the time did not catch",
        "files": [
            {
                "id": "FMN4YGA30",
                "mode": "tombstone"
            }
        ],
        "upload": true,
        "user": "UEQ6M68H0",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ncL6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the large project i was working on (approx. 100 man years), we had the choice of C or Modula-2. Modula-2 has an almost exact mapping 1:1 with C. C has arithmetic, logical operations, records, arrays, function calls, and the classic control flow statements like loops, if, switch. So from a feature point of view Modula-2 only offered a few additional features. So people ignored it. But what they failed to realize at the time, and still continue to fail to realize, is that from a practical standpoint programming is all about avoiding human error. You can write 1000 lines of code in a certain number of hours, but how long until all the errors are removed? This is where the majority of time is spent, and when you have a whole bunch of people changing the same code base at the same time, that multiplies the possibility for errors. Modula-2 offered more protection for the programmer. It caught errors that C at the time did not catch"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1566413355.183300",
        "client_msg_id": "52d6cd73-5c42-4d21-9234-c9d74666817d",
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48"
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566414676.183700",
        "client_msg_id": "5a3dd3a0-8fac-44be-941d-55f5ba3b1e11",
        "text": "Here is the screenshot of the runtime checks that Modula2 offered. this is from the ADW compiler for windows, which is now freeware. Notice how it is going to check for subscript range, so an array that goes from 0..9 will be checked if the subscript is outside the range. It also checks assignments to make sure your int32 being copied into an int16 doesn't overflow, it checks the switch cases, it also checks for null pointers, it looks at arithmetic overflow, and some other things. These runtime checks inflate the code by 30%; its very expensive to have all these IF statements, which are among the slowest statements in the CPU. But during development i gladly pay this toll, because its going to catch small errors quickly. C did not offer these at the time. The other advantage Modula-2 had was it used precompiled definition files, and if the definition file didn't change one could change the implementation and no other code would need to be recompiled. Built into the system was a dependency analyzer, that on large programs sped up compile times by 10:1 because you didn't waste time recompiling code that is not going to change. People really love interactive tools that compile as you type, but for 1980 this was a lightning fast system, and as interactive as you could get. I couldn't get people to even try Modula-2, because C was \"the standard\". The larger the program the more time you spend on cross-module concerns and bugs, and Module system designed by Prof. Wirth was brilliant and effective.  There is an old joke that programmers are too busy digging with dessert spoons to see the bulldozer demonstration.\n\nThe evolution of programming is fairly linear when you look at the last 50 years. People are slowly realizing that human error is the real obstacle to getting things built, and the reason there is so much interest in graphical interfaces in this group is that in a graphical product you can constrain the system so that fewer errors can be created in the first place. If something can't be put into a box you don't let it happen. This is in contrast with textual systems, where one can give crazy instructions. Any toolchain which helps prevent user frustration is beneficial and forward progress. Assembler was abandoned because it was too easy to overwrite a register, and create phantom bugs. C was phased out in favor of Java because in C it was too easy to double-free memory or reference deallocated memory, with phantom bugs resulting. Java should be abandoned because it is too easy to refer to an object before it is instantiated, causing innumerable nil pointer errors, and the OOP model is now discredited IMHO.\n\nHuman beings get up in the morning and make tons of mistakes. We have a sloppy biocomputer that is not that reliable, and our tools need to protect against omnipresent human errors. We can certainly make things prettier and easier to work with, but at the core we must build reliable systems.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1565111628.102100",
        "parent_user_id": "UC21F8Q48",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S2Kfx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here is the screenshot of the runtime checks that Modula2 offered. this is from the ADW compiler for windows, which is now freeware. Notice how it is going to check for subscript range, so an array that goes from 0..9 will be checked if the subscript is outside the range. It also checks assignments to make sure your int32 being copied into an int16 doesn't overflow, it checks the switch cases, it also checks for null pointers, it looks at arithmetic overflow, and some other things. These runtime checks inflate the code by 30%; its very expensive to have all these IF statements, which are among the slowest statements in the CPU. But during development i gladly pay this toll, because its going to catch small errors quickly. C did not offer these at the time. The other advantage Modula-2 had was it used precompiled definition files, and if the definition file didn't change one could change the implementation and no other code would need to be recompiled. Built into the system was a dependency analyzer, that on large programs sped up compile times by 10:1 because you didn't waste time recompiling code that is not going to change. People really love interactive tools that compile as you type, but for 1980 this was a lightning fast system, and as interactive as you could get. I couldn't get people to even try Modula-2, because C was \"the standard\". The larger the program the more time you spend on cross-module concerns and bugs, and Module system designed by Prof. Wirth was brilliant and effective.  There is an old joke that programmers are too busy digging with dessert spoons to see the bulldozer demonstration.\n\nThe evolution of programming is fairly linear when you look at the last 50 years. People are slowly realizing that human error is the real obstacle to getting things built, and the reason there is so much interest in graphical interfaces in this group is that in a graphical product you can constrain the system so that fewer errors can be created in the first place. If something can't be put into a box you don't let it happen. This is in contrast with textual systems, where one can give crazy instructions. Any toolchain which helps prevent user frustration is beneficial and forward progress. Assembler was abandoned because it was too easy to overwrite a register, and create phantom bugs. C was phased out in favor of Java because in C it was too easy to double-free memory or reference deallocated memory, with phantom bugs resulting. Java should be abandoned because it is too easy to refer to an object before it is instantiated, causing innumerable nil pointer errors, and the OOP model is now discredited IMHO.\n\nHuman beings get up in the morning and make tons of mistakes. We have a sloppy biocomputer that is not that reliable, and our tools need to protect against omnipresent human errors. We can certainly make things prettier and easier to work with, but at the core we must build reliable systems."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UHDQ62M4P",
                    "UC21F8Q48",
                    "ULTSNR8LF"
                ],
                "count": 3
            }
        ]
    }
]