<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #of-graphics</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-03-31 12:13</span><br/>
Spinning up a separate thread<br/><br/><span style="background-color:#ccf">@Kartik Agaram</span> said in <a href="../thinking-together/1585420887.013400.html#1585680051.053200">../thinking-together/1.585680.html&hellip;</a>:<br/><br/>&gt; Please build your prototypes atop Mu!<br/>&gt; I have no idea how to do graphics or sound. But a forcing function would be helpful.<br/>All that I need for a <em>basic</em> implementation of Hest's renderer is something like: the ability to draw stroked straight lines, filled rectangles and circles, and the most basic text (bitmap font) at arbitrary sizes and positions... with a few thousand drawing operations of various sorts happening in less than 3ms.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1585729946.002000"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1585729946.002000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-01 01:32</span><br/>
If you want to draw such shapes at good quality, I can recommend the nanovg library; you just need an opengl render target and can draw high quality images.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1585729966.002200"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1585729966.002200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-01 01:32</span><br/>
<a href="https://github.com/memononen/nanovg">https://github.com/memononen/nanovg</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1585729978.002600"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1585729978.002600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-01 01:32</span><br/>
It's the most simple approach I've seen.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1585730009.002800"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1585730009.002800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-01 01:33</span><br/>
ImGui will do this too, but it doesn't quite have the vector graphics sophistication of nanovg for things like gradient fills, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1585730055.003000"></a>
      <a href="../of-graphics/1585682016.001200.html#1585730055.003000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-01 01:34</span><br/>
In my intro thread, I showed a screenshot of a UI button I tried with nanovg: <a href="https://files.slack.com/files-pri/T5TCAFTA9-FUZDKAZ7S/image.png">https://files.slack.com/files-pri/T5TCAFTA9-FUZDKAZ7S/image.png</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1585730115.003400"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1585730115.003400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-01 01:35</span><br/>
The knob on the right is nanovg, the ones on the left are inside Bitwig (which I suspect might use something very similar, if not the same)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586245567.004200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586245567.004200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-04-07 00:46</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> can you elaborate on what you mean by "stroked straight line"?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586247058.004400"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586247058.004400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-07 01:10</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> See here <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes">https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586247082.004800"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586247082.004800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-07 01:11</span><br/>
At least, I assume that's what he means - the library I referenced draws SVG primitives like this.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586266807.009900"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586266807.009900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-04-07 06:40</span><br/>
Yeah, the "line" or "path" refers to the geometry, and the "stroke" is how it is rendered. When stroking a line, you generally want control over the stroke thickness and color at a minimum. Lots of features beyond that, but that's the basics.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586279479.010400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586279479.010400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-04-07 10:11</span><br/>
Nanovg requires OpenGL. Doesn't that conflict with the "no dependencies" requirement of the Mu project? If the goal is to be able to program all the way down to the bare metal, then I think you would want to standardize on a single GPU architecture, and program it directly. Just as you have standardized on x86. Or don't support a GPU, and instead interface directly to a frame buffer.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586279868.010600"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586279868.010600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-04-07 10:17</span><br/>
Yeah, my current plan is to focus on just a frame buffer. Mu currently can boot up a disk image with the hobbyist OS Soso (<a href="https://github.com/ozkl/soso">https://github.com/ozkl/soso</a>) in addition to Linux. Soso is much tinier so reduces my dependency on C. It's also graphical from the ground up, where I haven't really managed to compile a Linux kernel with graphics yet. On the other hand it doesn't have a network stack...<br/><br/>I interpreted the nanovg suggestion as something to crib from, and it's extremely useful in that respect. Even though I minimize dependencies I don't want to rethink everything from scratch. (For example, Mu's support for bootable disk images comes from digging into and cribbing from the Minimal Linux project at <a href="http://minimal.linux-bg.org">http://minimal.linux-bg.org</a>.) Regardless of dependencies, tiny projects that can teach how something works are <em>gold</em>.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586280000.010900"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586280000.010900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-04-07 10:20</span><br/>
Another way to put it: Mu burns everything to the ground <em>in production</em>. Mainstream software is good for prototypes (<a href="../thinking-together/1586108832.143700.html#1586116575.146400">../thinking-together/1.586116.html&hellip;</a>) and prototypes are very useful in staging environments.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586280316.011300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586280316.011300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-04-07 10:25</span><br/>
I actually like a lot of the OpenGL interface, from what I've seen of it. I'd be happy to implement some subset of it. Unless someone convinces me it sucks..
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586280654.011500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586280654.011500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-04-07 10:30</span><br/>
The <a href="https://libre-soc.org/">https://libre-soc.org/</a> project aims to produce an open source CPU + GPU. The GPU is integrated with the CPU: it's just an extension to the instruction set architecture, rather than being a coprocessor. This means that programming this GPU on the bare metal will be orders of magnitude simpler than a typical GPU. Hypothetically, when the project is finally finished and the hardware is available, it would be a good platform for a program-on-the-bare-metal type of software project.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586282702.011900"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586282702.011900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-04-07 11:05</span><br/>
The reason to implement OpenGL is for porting legacy software. I am not a fan: I think the API is overly complex and clumsy.<br/><br/>OpenGL is stuck forever at version 4.6 and everybody has moved on. The new cross-platform GPU API is WebGPU (which is still under development, although working prototypes exist). Vulkan also purports to be cross-platform, but Vulkan will never be available in a web browser. Vulkan is not nice to use (1000 lines of code to draw a triangle) while WebGPU has a pleasant to use and modern C, Rust and Javascript interface. WebGPU will be a native API on all desktop and mobile platforms, it will be available in web browsers via Javascript, and it will be the native GPU API for Web Assembly.<br/><br/>So WebGPU is the future and OpenGL is the past.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586282890.012100"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586282890.012100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-07 11:08</span><br/>
The advantage of GL is that it is pretty much available everywhere.  As you say, Vulkan is difficult for beginners (and advanced users :slightly_smiling_face: ).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586282914.012300"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586282914.012300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-07 11:08</span><br/>
If you just have a framebuffer, you could think of something like this; a software-based renderer: <a href="https://github.com/zauonlok/renderer">https://github.com/zauonlok/renderer</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586283190.012700"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586283190.012700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-07 11:13</span><br/>
<a href="https://github.com/ssloy/tinyrenderer">https://github.com/ssloy/tinyrenderer</a> - or this simpler one.  It even has an 'our_gl.h' header file....
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586283722.013100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586283722.013100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-04-07 11:22</span><br/>
I am using OpenGL right now for my project. My problem is that I want to be cross-platform, and Apple has officially deprecated OpenGL, and they also do not support OpenGL 4.3, which has features I need. The MacOS and WebAssembly platforms are the reasons why I will migrate to WebGPU.<br/><br/>OpenGL is still a great cross-platform solution if you don't need access to features introduced in the last 10 years, like compute shaders.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586299184.016900"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586299184.016900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-07 15:39</span><br/>
Yeah, for original poster’s question, he just needs basic GL.  I didn’t realise WebGPU would work native on desktop - if there’s a C API it’s more interesting... my live coding tool has GL/DX 12 and Vulkan backends in various levels of completion! 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586299400.017100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586299400.017100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-04-07 15:43</span><br/>
<span style="background-color:#ccf">@Chris Maughan</span> both those repos are excellent, thank you. However they're not actually writing to the framebuffer, are they? Maybe I'm missing something.<br/><br/>Just to give some context, the problem I wrestle with for graphics is how to make something that:<br/>a) can display on a real machine with minimal dependencies, and<br/>b) can also display on a stock *nix or Mac machine without needing root permissions and so on.<br/><br/>To help you triangulate, my non-graphics programs in Mu can currently run on Linux and also on a much simpler OS using either Qemu or native hardware. This is easy because we don't typically need root to access stdin/stdout/tty the way we need it for framebuffer access.<br/><br/>Once I can display a single pixel within these criteria, your repos become very relevant.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586300888.017300"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586300888.017300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-04-07 16:08</span><br/>
<span style="background-color:#ccf">@Chris Maughan</span> The WebGPU C implementations are wgpu (<a href="https://github.com/gfx-rs/wgpu">https://github.com/gfx-rs/wgpu</a>) and dawn (<a href="https://dawn.googlesource.com/dawn/">https://dawn.googlesource.com/dawn/</a>). Both implementations use the same C header file (<a href="https://github.com/webgpu-native/webgpu-headers/blob/master/webgpu.h">https://github.com/webgpu-native/webgpu-headers/blob/master/webgpu.h</a>). For now, these prototype implementations ingest SPIR-V as the shader language. Later they will change to ingest WebGPU Shader Language (WGSL), which is text based and isomorphic to SPIR-V, but that is still in an early stage of design.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586302035.017600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586302035.017600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-04-07 16:27</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> AFAIK you can't write directly to framebuffer hardware if you want to run under a modern OS. Under Linux, Windows or MacOS, Mu is effectively running in a virtual machine and is using OS APIs to do all of its input and output, including graphics. Probably Mu is running under a window manager, so that is another layer of abstraction between Mu and the hardware. Maybe you want to create a pixel array in Mu's address space, pretend that this pixel array is the frame buffer, and write OS-specific code to copy the frame buffer to the window once per frame. It's not difficult to code this using OpenGL. It will not be energy efficient on a laptop though, since the frame buffer copy happens 60 times per second even if the framebuffer hasn't changed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586302471.017800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586302471.017800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-04-07 16:34</span><br/>
It occurs to me that I just need a framebuffer emulator analogous to text-mode terminal emulators. And look, someone else had the same idea:<br/><br/><a href="https://sixpak.org/fbe">https://sixpak.org/fbe</a><br/><br/><span style="background-color:#ccf">@Doug Moen</span> it's totally an option to have different code paths for running on native hardware vs a host OS. For example, here are the syscalls I use for two different OSs: <a href="https://github.com/akkartik/mu/blob/master/init.linux">https://github.com/akkartik/mu/blob/master/init.linux</a> and <a href="https://github.com/akkartik/mu/blob/master/init.soso">https://github.com/akkartik/mu/blob/master/init.soso</a>. In combination with fbe, I could maybe have separate init.linux and init.qemu or something like that, where the ioctls expand to nothing and the address of <tt>mmap</tt>d memory changes.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586304245.018300"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586304245.018300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-04-07 17:04</span><br/>
Yes, I was describing my implementation of a framebuffer emulator.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586329794.018700"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586329794.018700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-04-08 00:09</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> sounds like you are on the right track.... I had thought you earlier mentioned you had some kind of framebuffer already - hence the software rasterizer.  To me, a framebuffer is a GPU memory surface that gets copied to the screen - I work for NVIDIA, so I have hardware bias :wink:.  The approach of using a memory buffer then copying it to the screen using an OS specific path, as <span style="background-color:#ccf">@Doug Moen</span> suggests sounds good to me :slightly_smiling_face:<br/>OpenGL remains the best supported way to do that on any platform.  Any version of it will be able to take a memory surface and copy it to the display, and it is still the first graphics API that most platforms support.   There are other ways to get a framebuffer that would work without creating an OpenGL context though.  My easy render repo has a really simple example of displaying memory pixels on the display in windows.  There are probably similar ways to do such things on other OS.  There may even be a cross platform header library that will accomplish the same thing:<br/><a href="https://github.com/cmaughan/easyrender/blob/master/src/devices/windows/device.cpp">https://github.com/cmaughan/easyrender/blob/master/src/devic&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586371594.019200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586371594.019200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-04-08 11:46</span><br/>
<a href="http://sixpak.org/fbe">sixpak.org/fbe</a> contains a loop that runs every millisecond and copies the framebuffer into a X pixmap using XSetPixel(). Although this code contains optimizations, I would still choose to write a framebuffer emulator in OpenGL, updating once per frame instead of once per millisecond. I think efficiency and power consumption could be an issue. (I still have work to do in Curv to prevent laptops from heating up and turning on their fan unnecessarily, which is why I'm sensitive to this issue.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1586371756.019400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1586371756.019400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-04-08 11:49</span><br/>
I want to correct a statement I made about WebGPU native. There was a checkin today to support both SPIR-V and WGSL as shader languages (even though web browsers will not support SPIR-V). People using existing game-programming toolchains will want to use SPIR-V.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1587411637.023300"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1587411637.023300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2020-04-20 12:40</span><br/>
Btw there is at least one software rasterizes version of nanovg
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1587411639.023500"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1587411639.023500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2020-04-20 12:40</span><br/>
<a href="https://github.com/syoyo/nanovg-nanort">https://github.com/syoyo/nanovg-nanort</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1587411692.023800"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1587411692.023800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2020-04-20 12:41</span><br/>
So no need to get rid of nanovg, there are also backends for all mainstream graphics apis
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1587411770.024000"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1587411770.024000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2020-04-20 12:42</span><br/>
If I were you I'd probably support some GPU style API, probably bgfx, so Mu can still take advantage of GPUs
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1587412020.024300"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1587412020.024300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2020-04-20 12:47</span><br/>
Even if it's against the core philosophy of Mu, unfortunately GPU capabilities vary wildly across vendors and generations, so abstractions are necessary
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1587412131.024500"></a>
      <img src="https://avatars.slack-edge.com/2019-09-26/774747080560_0edf98a60210d3ab07ea_72.jpg" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1587412131.024500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Anderson</b>
<span style="margin:2em; color:#606060">2020-04-20 12:48</span><br/>
And on many platforms OpenGL or OpenGL ES are the lowest level abstraction
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1587412269.024700"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../of-graphics/1585682016.001200.html#1587412269.024700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-04-20 12:51</span><br/>
The philosophy of Mu is to interrogate abstractions. Definitely willing to consider this!
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
