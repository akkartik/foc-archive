<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/96c2c97e5edea550b6935e656f64204c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0023-72.png" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brent</b>
<span style="margin:2em; color:#606060">2020-03-19 11:42</span><br/>
Hi all,<br/><br/>I would be interested to hear thoughts on the current state of educational environments for programming skills and paradigms. <br/><br/>I'm wondering if with a somewhat enhanced approach to sharing knowledge in our domain - certain things could be learnt (far?) more efficiently. Stretch goal would be to be learn the interesting parts of the go lang compiler in the morning, and compare their design decisions and trade offs to the internals of the dotty compiler in the afternoon. <br/><br/>To me; its another angle on "accidental complexity." There certainly are a number of hard bits in building and understanding software; but, whenever I start to get my head somewhat around a code set; I generally feel that the interesting / insightful / useful bits of the solution are far too buried in boilerplate and various other forms of noise.<br/><br/>I think the "learning" angle is a useful perspective to keep in mind. I do mainly mean it in the read a textbook / blog post, watch a youtube video, attend a (virtual) conference, go to coding bootcamp / university, onboard a new joiner to your team kinda way. But; I also feel that "learning" is pretty much all we are every trying to do. "Learn" how to implement this Rest API and make it slightly more testable than our last attempt. "Learn" what the root cause of this bug taking down our entire production platform is etc.<br/><br/>Of course; all thoughts and comments welcome - I would be interested to hear peoples views on points such as<br/>- what events stand out as important learning points in your path to technical enlightenment?<br/>- what approaches have been used to "get up to speed" in order to contribute to open source software? Perhaps from the "how did you learn enough stuff to be useful" perspective<br/>- how well (or not) have you seen the "living" knowledge of a code-set be managed in secular projects?<br/>- Is Udemy all we should hope for; or could we build better environments within which to have our discussions?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584647438.404100"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584647438.404100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2020-03-19 12:50</span><br/>
hey Brent, I’ve spent the last 5 years in online learning. I’ll speak specifically to “Is Udemy all we should hope for”?<br/><br/>Specifically, the company I worked for created an integrated environment for learning python, data science, etc (similar to Codecademy, hands-on, problem solving based approach). This was helpful for students that were motivated, b/c they no longer had to spend hours debugging command line / installation / other computer issues. They could just focus on debugging their Python code (we also showed variable state to help a tiny bit with debugging, but it was definitely no “Python tutor” like environment).<br/><br/>I think better environments can help highly motivated students, but not unmotivated students.. a word I’m using in the broadest sense and in a non-judgmental way. A biology student that doesn’t need to code or w/e I’d argue is unmotivated. So then the question is … are you interested in turning unmotivated students into computational thinkers? Or do you want to teach motivated students better Python?<br/><br/>Those are 2 very different problems :stuck_out_tongue:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584647986.416000"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584647986.416000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2020-03-19 12:59</span><br/>
So there's two different things going on here:<br/><li> Learning "programming" (e.g. education)<br/><li> Learning what's in a certain codebase, or how to use a specific tool or language or framework.<br/><br/>I'll comment on the first:<br/><br/>"Programming" is usually taught in terms of learning a specific language or tool, and getting it to compile and it's nuances, etc. In other words, in terms of the second category, above. I think that's a mistake, but that's NOT what programming IS. It's just what it HAPPENS to entail right now, as currently practiced / implemented. How the heck can we improve on or escape from any of that is it's taught that "programming" is getting a Java app to build, etc.<br/><br/>Instead, I think we need custom tools or environments or whatever, that expose the now concrete concepts of programming to be explored. This might not be an actual language, or might be very sandboxed; but the important thing is the CONCEPTS.<br/><br/>Learning using traditional programming bloat just gets in the way. People end up focusing more on the syntax to get a Java class to compile (sometimes not even knowing yet what that even means), and the understanding of what's being programmed and what that means, is lost / mixed up with a ton of boilerplate and tooling that is NOT PROGRAMMING. It's very confusing for new Learners.<br/><br/>It's true really of any language or tool. "Learning python" is not learning "programming" -- though some of that still happens as a side effect, that's not the same thing, and it's learned in a very specific context; the student will think that they are "learning programming" because they've learned some python commands; they will think that's what it means to program
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584648446.416400"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584648446.416400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2020-03-19 13:07</span><br/>
Strongly agree, and I think most people here would, that programming is definitely not just “Python” or “javascript” .. which are just temporary quirks. However, I wonder how you’d define “programming”? Is it general computing? Is it the art of creating programs to do something creative / accomplish a task? Excel is kinda programming but the learning curve for that is very different than it is for a “real” language like Python or JavaScript (again real in quotation marks).<br/><br/>Also, sadly, I don’t think there’s much of an appetite / audience for “general programming” knowledge. Everyone’s rushing to teach “practical” skills. Even in K-12 they teach Python often, or they’ll teach a more conceptual pre-cursor like block based programming / Scratch .. but then level up to “real” coding like Python. Part of the problem too is .. teaching kids (or even new adults) something that feels like the fake version of the “real” thing can be demoralizing. One day, the “real” programming thing will feel a lot more like Excel (which I guess why this community exists) and the ramp from conceptual program to “real” programming will be smoother
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584648479.416600"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584648479.416600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2020-03-19 13:07</span><br/>
but I think the question of “what programming” actually is, is quite interesting. I don’t know if we’ve quite figured it out b/c programming always lives in the assumptions and trappings of a pre-existing language of some kind!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584648804.416800"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584648804.416800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2020-03-19 13:13</span><br/>
I'd say that Bret Victor captures very well what programming is / is not, in "Learning Programming"<br/><br/><a href="http://worrydream.com/LearnableProgramming/">http://worrydream.com/LearnableProgramming/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584663848.419200"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584663848.419200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2020-03-19 17:24</span><br/>
I find most programming tools and libraries remarkably hard to learn (usually because of a lack of documentation or poor-quality documentation), but perhaps even more amazing is how everybody acts like these things aren't hard to learn, as if maybe I have a learning disability even though I got A's in school. At the same time I feel (strongly) like I produce better code than almost everyone else. It's as if I'm unusually competent at production and unusually incompetent at consumption. It is confusing. I have various ideas about teaching, but they might be very effective if everybody else has a different learning style.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584664097.419400"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584664097.419400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2020-03-19 17:28</span><br/>
Anyway, it seems like really good teaching is hard. I was really impressed with how <a href="http://vuemastery.com">vuemastery.com</a> teaches Vue - at least the non-paywalled videos I saw have lots of great animations nicely timed to the instructor, but the animations sure look labor-intensive. <a href="http://scrimba.com">scrimba.com</a> probably has much better "bang for the buck" in terms of "teaching effectiveness per unit of time it takes to put a course together", since the viewer can play with the code at any time and the instructor need not put lots of work into fancy animations.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584666274.420200"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584666274.420200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2020-03-19 18:04</span><br/>
Anyway, since watching Bret Victor's "Inventing on Principle" I was sure I wanted to "Invent on Principle" as he suggested, but the tricky part is figuring out what my Big Principle is.<br/><br/>One angle I've homed in on is the principle that "easy-sounding things should be easy". Programming is full of things that seem like they should be easy, but are <b>unnecessarily</b> hard in practice. Things like drawing graphics efficiently (you can start easily with Windows Forms but if you want efficient drawing you have to make this massive leap over to DirectX, in which case, good luck implementing your GUI widgets by hand) playing music and sounds (okay, playing a .wav file might be a simple static method call, but generating audio continuously or playing an mp3 or opus stream might be far more difficult), or keeping a user interface synchronized with the underlying data model (but see SwiftUI, Assisticant, MobX/KnockoutJS for reactive solutions in Swift, C# and JS respectively)<br/><br/>In this view, then, the problem isn't so much education, the problem is that our tools are too hard to use. If the tools were easier, education would be easier too.<br/><br/>Taking this a step further, I think there should be a toolset that allows a single universal education.<br/><br/>We haven't figured out what the "ideal" programming language looks like yet, as there are so many ideas still being explored (consider Unison, Idris, JAI, Nim, Ceylon, as well as the languages made by people right here in FoC). However, there are a lot of ideas that are highly useful and fairly universal: interfaces, unit testing, sequences (including singly-linked lists, growable arrays and hashtables, semi-persistent data structures (ask me about them), functional programming, ranges and slices of collections, <a href="http://loyc.net/loyc-trees/">universal syntax trees</a>, serialization, asynchronous functions, symbols like in Lisps/Ruby/JS, reactive state, geometry primitives like points, infinite lines, planes, affine matricies, garbage collection slash refcounting with weak refs, graphics, sound, sending UDP packets...<br/><br/>I would like to be part of a group that develops a really good <a href="http://loyc.net/2014/design-elements-of-mlsl.html">multi-language standard library</a> and implements it in several languages. If such a library were widely available and if people bothered to learn it, it would bestow the ability to write code in many languages more easily. It would also be useful as the basis of tools for converting code between languages (the hardest part of converting code from one mainstream language to another is dealing with differences between standard libraries, since the actual semantics of popular languages are, at least on some level, fairly similar.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584667089.420700"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584667089.420700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2020-03-19 18:18</span><br/>
I also think certain programming principles are much more important than others. Bad code typically results from violating one of the following principles that I follow:<br/><br/>1. Separate concerns!!! A program is like a house: just as walls give a house structure, separation of concerns gives a program structure. Most programming languages do not facilitate separation of concerns because they allow almost anything to touch almost anything else. Programmer discipline is required to create imaginary walls where no connections are allowed. For example, a language typically can't stop the GUI from directly running SQL update commands, so the wall between GUI and a specific data persistence library rests only in the minds of the developers. (I think some people "solve" this lack of compiler enforcement with "microservices architectures", but any solution that involves huge amounts of otherwise unnecessary plumbing code is not a good solution.)<br/>2. The Generalized Don't Repeat Yourself principle: avoid not just repeating information or business logic in multiple places, but minimize repetition of any patterns whatsoever. Elegant code minimizes the number of tokens in the program.<br/>3. Create functions and abstractions appropriately, but avoid excessive layering/wrapping (doing so is often motivated by prior failure to refactor, or failure to test, leading to brittle code you don't dare touch). There is an appropriate number of layers of abstraction; too many or too few is confusing (and many programs have <b>both</b> too many <b>and</b> too few, in different places).<br/>4. Minimize the number of code entities by merging things that turn out to be very similar. For example, I realized that "logging" and "reporting warnings and errors" are essentially the same thing, so in the <a href="http://core.loyc.net">Loyc.Essentials </a>way of doing things you would use the same interface <tt>IMessageSink</tt> for both (sometimes I wonder if no one else has noticed this). Similarly I often see interfaces like <tt>ISomethingRetriever</tt> whose job is to retrieve some kind of object given some kind of key. That's basically a dictionary! Just implement <tt>IReadOnlyDictionary</tt>, you fool, or whatever your language's equivalent is. Do not create a new and different interface every time you need to retrieve a new kind of object. More broadly, design both your interfaces and your components to be generic, reusable, and ignorant.<br/>5. Pick good names and write documentation that describes things in a <em>different way</em> than the names do. I often write documentation for a class <b>before</b> its code, which leads to clear thinking and good separation of concerns. (However I have to correct the documentation later because I usually tweak something or change plans midstream.) Documentation of large-scale entities (classes, modules) and mutable state (e.g. invariants) is often more important than documentation of small-scale entities (small functions and code blocks).<br/>6. Write good tests (or prove correctness)<br/>7. Think long and hard about your decisions. <em>Agonize over them.</em> You'll never come up with an optimal design by doing the first thing that comes to mind. Even after you implement it, be on the lookout for a better approach (either so you can use it in the future, or ideally, improve the original code).<br/>8. Be on the lookout for new and better general-purpose techniques, and then actually use those techniques. I am slightly irritated whenever I see professional developers using strings when they should be using <a href="https://www.codeproject.com/Articles/34753/Symbols-as-extensible-enums-2-2-2">Symbols</a>. Why? Do you use strings in C# because it doesn't have Symbols? But you've seen Symbols in Ruby and ES6 - take the lesson you learned in the other language and apply it to C#.<br/>(When I wrote this I was thinking of the question "what events stand out as important learning points in your path to technical enlightenment?" but now I see that, rather than answer the question, I've simply explained what I think an enlightened programmer <b>does</b>. I don't remember how I learned this stuff, but I am quite convinced of its importance.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584702338.430300"></a>
      <img src="https://secure.gravatar.com/avatar/96c2c97e5edea550b6935e656f64204c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0023-72.png" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584702338.430300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brent</b>
<span style="margin:2em; color:#606060">2020-03-20 04:05</span><br/>
<tt>So then the question is … are you interested in turning unmotivated students into computational thinkers? Or do you want to teach motivated students better Python?</tt><br/>It’s a very interesting angle to think about it from; thank you. I am interested in removing unnecessary blocker to knowledge acquisition; and hopefully - creating environments which are strong enablers of knowledge sharing. <a href="http://Dataquest.io">Dataquest.io</a> does seem to be built on some very similar ideas. Are you aware of any platforms that take a similar approach for non-data science fields in technology? My personal interest with this space is I want to be able to understand technical things faster. I feel quite a few things in programming are relatively straight forward; however - getting the key insights and understanding which are at the core of an approach / idea can be, for me, a somewhat difficult process. I’m just trying to take that angle and see if it can be turned into something that other people also find useful.<br/><br/><tt>"Programming" is usually taught in terms of learning a specific language or tool</tt><br/>I am far too ashamed to go into any level of detail of how badly messed up my “foundational” concepts of programming were; based on the introductory C++ courses I did at Uni. This extended many years into my professional career. And - how do I know when I “fixed” it? So terrifying.<br/><br/><tt>write documentation that describes things in a different way than the names do</tt><br/>Oh man; this is a hill I will die on! Billions of years of evolution culminates in<br/>// Finds project by Id<br/>getProjectById
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584702366.430500"></a>
      <img src="https://secure.gravatar.com/avatar/96c2c97e5edea550b6935e656f64204c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0023-72.png" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584702366.430500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brent</b>
<span style="margin:2em; color:#606060">2020-03-20 04:06</span><br/>
If I were to summarize my goals right now it would be: Build a competitor to Udemy. A platform optimized to teach programming concepts. Base courses on open source code sets to create rich; real world scenarios.<br/><br/>So; I’m trying to “learn” things I’m interested in; and at the same time, think about the process I use - to see if I can wrap it up into something that would be valuable to other people.<br/><br/>On the implementation level; having a url that links into an arbitrarily sophisticated environment is a great enabler. I came across these guys (and have had a few discussions with them) <a href="https://www.gitpod.io/education/">https://www.gitpod.io/education/</a> - they are building a more open source version of vs-code. And then there is; as far as I can tell; a slightly more open source version of the gitpod “auto-environment” idea from Redhat <a href="https://developers.redhat.com/blog/2019/09/17/eclipse-che-kubernetes-native-ide-version-7-now-available/">https://developers.redhat.com/blog/2019/09/17/eclipse-che-ku&hellip;</a>. So there are some quite powerful building blocks that could be leveraged.<br/><br/>This tweet poped into my feed a few days back - and is getting quite a warm response - <a href="https://twitter.com/LostInTangent/status/1236672803123814400">https://twitter.com/LostInTangent/status/1236672803123814400</a>. I see it as being in a similar space of putting knowledge into code sets.<br/><br/>A rough outline of the types of features I have in mind to explore:<br/><br/>1.) A focus on discoverability. StackOverflow has set the bar on being able to find extremely specific results; and the goal would be to bring a similar experience to course content. How to achieve this is the big open question. Currently I’m thinking along the lines of getting rid of Chapters and capturing the “structure” of the knowledge in the course - and perhaps from there; allowing users to explore in an autonomous way.<br/><br/>2.) A way to "layer on" complexity. I always find the early exercises overly simple; try to jump ahead; and then have to go back to try find where supporting info is addressed. This seems to come back to creating support for users to navigate the “structure” of the knowledge.<br/><br/>3.) A platform which allows linking through all related topics. Similar to following articles in wikipedia - being able to start in a course on <a href="https://github.com/zio/zio">https://github.com/zio/zio</a> and end up learning the relevant Category theory. (At least I think that's where users would end up.) And again; this seem to be back to the same core idea of knowledge having a structure - everything is a graph!!!<br/><br/>4.) Being able to immerse in real world ASAP. The jump between "exercise tasks" and "real world" often is large; but with environment support, and leveraging open source, the context of the lesson can be enriched. I’m hoping this can embrace the principle of <tt>Everything should be made as simple as possible, but no simpler.</tt> Whilst things often get buried in accidental complexity; it is also easy to forget actual complexity. I think <a href="https://github.com/promises-aplus/promises-spec/issues/94">https://github.com/promises-aplus/promises-spec/issues/94</a> is a really interesting real world scenario. If the community could have that discussion again; could we have better ways of framing “known” information so that people with different backgrounds could get up to speed efficiently - towards the goal of having more progressive debates and reaching what in retrospect are agreed to be “correct” decisions.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584702490.431300"></a>
      <img src="https://secure.gravatar.com/avatar/96c2c97e5edea550b6935e656f64204c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0023-72.png" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584702490.431300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brent</b>
<span style="margin:2em; color:#606060">2020-03-20 04:08</span><br/>
---<br/>There where lots of interesting points in this thread already - so hopefully once I start creating "content" I can loop back to them and dig into more detail.<br/><br/>If anyone is interested in collaborating - please let me know
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584714145.431500"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584714145.431500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2020-03-20 07:22</span><br/>
&gt; One angle I’ve homed in on is the principle that “easy-sounding things should be easy”. Programming is full of things that seem like they should be easy, but are <b>unnecessarily</b> hard in practice.<br/><span style="background-color:#ccf">@David Lee</span> 100% agree. A few points:<br/><br/>• In video game design, people often talk about “easy to start, hard to master”. I kinda like that approach and that’s essentially what MS Excel does. You can simulate complex stuff in Excel, but if you just want to add a bunch of numbers, create a plot, its REALLY easy to do so. Python on the other hand has like an hour of setup and a bunch of different tools and libraries to learn just to do that simple set of tasks that you can do more quickly on a piece of paper!<br/>• Another thing I’ll say, that Bret / Dynamicland people talk about a lot that I agree with … is that the fundamental REAL logic in most programs is very simple and short to express. However, bringing that to life adds the remaining 95% of code. Compatability with standards, browsers, optimizing performance, GUI, low level hardware stuff, etc. All of that is powered by brittle, complex, opaque software. I like what Bret said in an interview last year … “the real world simulates itself”, so the code for your unique logic / idea is very simple and minimal and can be understood and iterated on quickly. A lot of it can fit in your short-term memory (Alan Kay talks about getting things down to “a few pages of code”, which was the threshold under which even 6 year olds can program).<br/>&gt; Anyway, it seems like really good teaching is hard. I was really impressed with how <a href="http://vuemastery.com">vuemastery.com</a> teaches Vue<br/>After 5 years in this trying to teach aliens (what I call people you can’t see :stuck_out_tongue:) technical things, I’ve come to appreciate that “learning styles”, “teaching well”, “motivating students”, and all other phrases like this are MOSTLY BS (not completely, but mostly). This is a very strong statement, but in my opinion … it fundamentally comes down to teacher-learner fit (or content-learner fit). If you’re highly motivated and have a clear goal, and the learning content or teacher is teaching towards those goals, then everything is great! The student will say things like “I like how this teacher teaches” or “this meets my learning style” … but harmony in learning + teaching goals I think explains MOST of the stories people say. This is maybe a hot take, but just my perspective :stuck_out_tongue: There’s still room for innovation though on the edges (people who are semi motivated but need to have a few aha moments delivered via fun videos or interactive simulations before they make a bigger learning commitment, etc).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584714285.431700"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584714285.431700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2020-03-20 07:24</span><br/>
&gt; <a href="http://Dataquest.io">Dataquest.io</a> does seem to be built on some very similar ideas. Are you aware of any platforms that take a similar approach for non-data science fields in technology?<br/><span style="background-color:#ccf">@Brent</span> oh yeah there’s a few.<br/><br/>• <a href="http://Codecademy.com">Codecademy.com</a>: Python, JS, other stuff (including data science)<br/>• <a href="http://Katacoda.com">Katacoda.com</a>: for devops-y stuff, purchased by O’Reilley.<br/>• <a href="http://Codeschool.co">Codeschool</a> was bought by Pluralsight but mostly hasn’t gone anywhere (PS has struggled to switch away from video based learning)<br/>• <a href="http://Datacamp.com">Datacamp.com</a>: data science (Just throwing it in here)<br/>• There’s a few smaller niche sites that teach specific things, like <a href="https://www.sqlhabit.com/">https://www.sqlhabit.com/</a> and <a href="http://sqlbolt.com">sqlbolt.com</a> … both for SQL
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584714702.432000"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584714702.432000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2020-03-20 07:31</span><br/>
<span style="background-color:#ccf">@Brent</span> building a Udemy / Datacamp / Codecademy competitor is interesting but ultimately I’ve come to appreciate the following:<br/><br/>• Teaching consumers is effing hard. If you care about learning outcomes, the best thing is to add on a lot of things that students’ motivational investment. This is what coding bootcamps do .. they make you pay a lot of money (weeds out people who aren’t serious), they make you take a basic coding interview exam (weeds out people who aren’t serious), they’re often in person (shared struggle with other students), etc. They use the techniques universities use (old teaching methods with LOTS of carrots / sticks to “motivate” people). <br/>• If you instead care about being “innovative” in how you teach, the challenge here is that … customers don’t REALLY care about learning in some fancy new way, they just have a specific job to be done (<a href="https://hbr.org/2016/09/know-your-customers-jobs-to-be-done">https://hbr.org/2016/09/know-your-customers-jobs-to-be-done</a>) that’s either “I want a pay raise / move up in seniority in my existing job” or “I want to switch into a new career”. There’s a small sliver that wants to “learn for fun / curiosity”, but that’s competitive as F (competing for the job of fun has an endless sea of competition, including Twitch, Youtube, and video games / tv shows). Soooo if you want to build some cool whizbang learning environment … you still have to answer the question of “what job is being served / solved better? and for whom?“. You want to teach with only interactive explanations? Cool! Which learners meet their goals better b/c of it? And btw creating interactive simulations is time consuming and expensive, which means your ‘learning rate’ from your customers is a lot slower which means your competitors that just make lots of videos … may end up solving the job in a good enough way for most students at a lower price. <br/>• Hopefully that didn’t come off too much like a rant :stuck_out_tongue: I guess I spent 5 years here in this space and I felt like not enough rigor was applied to thinking about the customers’ actual desires, and instead more time was spent on feel-good things like “hands on learning” (which is still cool and interesting, but insufficient!)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584714781.432300"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584714781.432300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2020-03-20 07:33</span><br/>
<span style="background-color:#ccf">@Brent</span> anyway I can talk about this stuff for ages :stuck_out_tongue: I’m still a big fan of creating rich, learning environments for learning to code (even if we’re just teaching people current stuff like Python and JS). But I actually am thinking now that I’d rather work on the infrastructure side of this. Basically make it easy for universities and companies to create their OWN courses that are highly tailored for their needs, but without being devops experts and needing a 10 person software eng team to stand this up!<br/><br/>That <em>seems</em> like what Gitpod is doing a little? But Gitpod and <a href="http://Repl.it">Repl.it</a> both are focused on developers instead I think?<br/><br/>EDIT: looks like there’s at least one startup in this space: <a href="https://www.codesters.com/?lang=en">https://www.codesters.com/?lang=en</a><br/><br/>EDIT2: <a href="https://www.codio.com/">https://www.codio.com/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584714802.432500"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584714802.432500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2020-03-20 07:33</span><br/>
if y’all wanna hop on a Google hangout / zoom to chat more, I’m always down :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1584716328.433000"></a>
      <img src="https://avatars.slack-edge.com/2020-01-04/893378739792_34e7a55348e8c86c1901_72.jpg" style="float:left"/>
      <a href="../thinking-together/1584643351.400400.html#1584716328.433000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jared Windover</b>
<span style="margin:2em; color:#606060">2020-03-20 07:58</span><br/>
<span style="background-color:#ccf">@Brent</span> Re: the summary of your goals, the way I’ve thought about such a system in the past is a directed graph with two types of alternating nodes: concepts and explanations, where an explanation is for one concept and may rely on many existing concepts to explain the new concept. Similarly, there may be many explanations for the same concept (each relying on different precursor concepts). I think one hard part of this is that concepts may disagree with each other, and explanations may be more or less useful to different people (different sets of things they already understand/believe, and different styles of thinking). But it still seems (to me) like the “correct” way to organize educational information.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
