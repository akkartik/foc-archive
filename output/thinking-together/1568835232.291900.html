<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-18 12:33</span><br/>
In my project, the overall goal is to produce a notation that is so compact and precise, that it is shorter than the conventional product specification documents, and thus can be the specification and implementation in one.  Certainly in smaller projects it holds true, and we'll see how close it gets on larger projects. Classical UML, and formal system design processes are not practical because you can't execute UML, so you end up with an implementation phase than then needs to be checked against a changing specification document; chaos ensues. Having the spec and the program be one thing should be grasped as a big win.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568835929.292800"></a>
      <img src="https://secure.gravatar.com/avatar/649320ca20cacd083cf9225990f990b0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0016-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568835929.292800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Cedric Cogell</b>
<span style="margin:2em; color:#606060">2019-09-18 12:45</span><br/>
sounds similar to Language Driven Design approach of Racket
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568844065.319200"></a>
      <img src="https://avatars.slack-edge.com/2021-03-22/1871363334903_cbd558604a21b23211c3_72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568844065.319200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Breck Yunits</b>
<span style="margin:2em; color:#606060">2019-09-18 15:01</span><br/>
"Having the spec and the program be one thing should be grasped as a big win." agreed!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568847324.319500"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568847324.319500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-18 15:55</span><br/>
My understanding is that the spec should be less detailed than the implementation like a map to the territory. If the map is the same size as the territory, it’s not useful. Thus my opinion is that UML is useful only when it’s not the exact code ran as mentioned above with the map vs territory argument.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568847345.319700"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568847345.319700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-18 15:55</span><br/>
So I disagree.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568847527.319900"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568847527.319900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-18 15:58</span><br/>
To add. If the same map is the same size as the territory isn’t it logically and mathematically just as complicated?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568847681.320100"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568847681.320100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-18 16:01</span><br/>
Then again some designs implement three completely different systems and use a voting algorithm.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568852817.320800"></a>
      <img src="https://avatars.slack-edge.com/2019-04-10/604262911488_be27878783b4b23a5ed4_72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568852817.320800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Niko Autio</b>
<span style="margin:2em; color:#606060">2019-09-18 17:26</span><br/>
Function signatures in statically typed languages are much smaller than complete implementation and yet that's often all documentation you need.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568853570.321000"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568853570.321000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-18 17:39</span><br/>
In smaller projects all I get is a napkin sketch, so near zero time was spent on the spec in those situations. I was thinking of large company projects. In those environments big money is spent on a requirements document which is typically fed to a system architecture/design team which specializes in identifying in microscopic detail how the system is to operate, then passed to entirely separate team of implementors. The spec in that environment is supposed to completely specify WHAT  and WHEN the system accomplishes the task in excruciating detail, but not HOW, although nowadays screen mockups (some call them wireframes) are given and they have a fair amount of HOW in terms navigation and animation specified. The programmers are not tasked with any formulation of business logic or input or output formats. Those are supposed to be nailed down. My point is that if the cost of making the spec was 100 units of money, and the programming is 400 units, if you can use a notation for the spec that is executable maybe the total cost is 120 units. That would be a big savings in time and money. So many of the commercial practices use tools and methodologies that don't generate executable code. Certainly some of the prototyping tool companies are addressing this, but those things don't always work out so well.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568853839.321200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568853839.321200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-18 17:43</span><br/>
But Ernest's point is very subtly reinforcing my position. If they spend so much on the spec, and it isn't executable, then that work is thrown away in the end, and worse yet, the spec inevitably diverges from the actual product built, and you get into tug-of-wars between the spec authors and the implementors as the implementors find all the flaws, missing pieces, and contradictions in the plan. This is a very similar situation to building architects and the actual builders. The builders often have a dim view of some architects because they create impractical situations that have to be fixed in the field. It would be better if you have a single source of truth. Redundancy is the largest source of error in computers IMHO.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568873315.323500"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568873315.323500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-09-18 23:08</span><br/>
I like <span style="background-color:#ccf">@Ernest Lee</span>'s point.  It's nice having views that ignore some details.  I would love to ask my software, assuming A, B, and C and ignoring X, Y, and Z, does this complicated implementation reduce to this much simpler specification?  And I'd love an automated system that can say, "mostly, except I'm not sure about this 10% of it."
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568921980.390400"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568921980.390400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-19 12:39</span><br/>
This sounds a lot like the problem in game development. Designers may code badly and inefficiently, but having them being able to code for example visually in Unreal Engine 4 means they can create executable specs, that may be transformed into good code. There is no bottleneck between the spec design and translation into code.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568922238.390800"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568922238.390800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-19 12:43</span><br/>
A point to note is that the “bad” code is still executable code, so if no optimizations are required it can be shipped if correct.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568924175.391400"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568924175.391400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-19 13:16</span><br/>
If it takes 120 units to ship the spec, everyone should be using the 120 unit implementation rather than the 400 unit implementation. Since that 120 unit spec is cheaper and more expressive than the 400 unit implementation.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568924212.391600"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568924212.391600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-19 13:16</span><br/>
However that is large suspicious promise.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568930131.392500"></a>
      <a href="../thinking-together/1568835232.291900.html#1568930131.392500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-19 14:55</span><br/>
This rapid prototyping is even mentioned in “No Silver Bullet”.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568930133.392900"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568930133.392900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-19 14:55</span><br/>
<a href="http://faculty.salisbury.edu/~xswang/Research/Papers/SERelated/no-silver-bullet.pdf">faculty.salisbury.edu/~xswang/Research/Papers/SERelated/no-silver-bullet.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568930635.393700"></a>
      <a href="../thinking-together/1568835232.291900.html#1568930635.393700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-19 15:03</span><br/>
Instead the spec being another programming language, we create tools that allow non-programmers to sketch executable programs but at the level of the non-programmer’s understanding. It may not meet speed or clearness goals but it is a better communication tool than a spec. It may even be usable as is.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568955874.397500"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568955874.397500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-19 22:04</span><br/>
I have often built products from sketches, and paper mockups. For things that are obvious, or the details best left to the programmer, this can be very effective. It also cuts down on the conflict between spec and product because the spec is so loose. But i was thinking about larger systems, where the design is very deliberate and big money was spent on it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568956607.397700"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568956607.397700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-09-19 22:16</span><br/>
I am a big fan of Fred Brooks, and at a conference had the pleasure of meeting him, shaking his hand and thanking him for such a great book. His book has held up pretty well, and despite the title implying there is no big breakthrough coming, he does point out that all sorts of improvements are possible. He suggest that interchangeable/reusable parts would create cut costs dramatically, and that rapid prototyping might really speed up the design phase; i am merely extrapolating that rapid prototyping could become the final product. That is another way of calling it an executable spec. My point is that formal specification languages waste a lot of expensive consultants time, because the work has to be repeated in an entirely different environment.<br/><br/>As for interchangeable parts, I believe that the weak data structures that are in common use today preclude this revolution.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1568980260.400200"></a>
      <img src="https://secure.gravatar.com/avatar/66349e4630b8f49508e271b01fba4e18.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1568980260.400200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ernest Lee</b>
<span style="margin:2em; color:#606060">2019-09-20 04:51</span><br/>
In the industry of game development, interchangable art assets and per engine specific code is common in the asset stores. The use of visual programming languages in both Unreal Engine, Unity and in progress in Godot provide the promise and results of rapid prototyping. The visual languages are good enough to be shipped to release as is without conversion to c++ / c#. I’m agreeing with you, but the future is unevenly distributed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1569096221.413600"></a>
      <img src="https://secure.gravatar.com/avatar/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png" style="float:left"/>
      <a href="../thinking-together/1568835232.291900.html#1569096221.413600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tudor Girba</b>
<span style="margin:2em; color:#606060">2019-09-21 13:03</span><br/>
I find the topic of executable specifications quite exciting.<br/><br/>The main reason why people aim for a specification is explainability. Explainability brings with it feedback and this leads to better decisions.<br/><br/>A specification is used as a model in that it leaves some details away. Of course, no details are irrelevant in general, but some details can be irrelevant for a specific perspective. For example, security details are not irrelevant in general, but it is irrelevant when I want to evaluate how to model some accounting logic. And when we are interested in penetration tests, the specific accounting model might be irrelevant. Considering this, aiming for a single notation that focuses only on some parts but not on others can be interesting, but it is fundamentally limiting.<br/><br/>Solutions like the visual coding in Unity/Unreal Engine, coding in Scratch, or coding in Excel are certainly interesting, but at the end, these specifications sit on top of a huge black box (the actual engine) that everyone takes for granted that it must remain a black box.<br/><br/>That black box should not remain a black box. A program is a specification, too. Yet, the explainability power is rather low. So, why don’t we bring explainability into our systems?<br/><br/>From my perspective, there is a distinction between the act of creating a specification and the act of understanding an explanation. Most solutions I see focus on the language with which to create. This is important, but it leaves open the other half of the problem.<br/><br/>Interestingly, understanding an existing system implies creating a mental model about that system. That model is a projection. The projection is separate from the system, but it allows us to relate to its internals. And this projection is not a language issue. It’s a tool issue. It’s an issue of the environment through which we experience the internals of our system.<br/><br/>Nowadays, we typically call it the IDE. The I in IDE stands for integrated, and I believe the ultimate integration involves all stakeholders of our system. It’s not only developers (the typical IDE fails today even on that front - for example, it fails every time the developer has to go on Stackoverflow to ask a question about her/his own system).<br/><br/>To reach this integration, the IDE has to offer these projections. As different aspects of our system are interesting from different perspectives, the IDE cannot rely on one single form. It must be moldable. I believe this is fundamental. By molding the way we perceive the internals of our systems, we can bring explainability into our specification and make it accessible to a wider audience.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
