<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #of-functional-programming</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/bc3e6041047849518d1b042f0a29d5af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>S.M Mukarram Nainar</b>
<span style="margin:2em; color:#606060">2020-05-19 19:11</span><br/>
Anyone know of any "toy" optimizing compilers for a functional programming language that are small enough to study and fit in head? Looking for learning resources.<br/><br/>Tangentially, are there any nanopass compilers that are used outaide of education?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1589946647.024900"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1589946647.024900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2020-05-19 20:50</span><br/>
Mentioning "nanopass" suggests that I wouldn't have much to add.  :wink:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1589966170.025100"></a>
      <img src="https://secure.gravatar.com/avatar/da3a20a76a69532fa83e790e89cb4c6c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1589966170.025100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Eyal Lotem</b>
<span style="margin:2em; color:#606060">2020-05-20 02:16</span><br/>
For a small Hindley Milner (Algorithm W) type checker check out this introductory paper: <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.7733&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.&hellip;</a><br/><br/>and Lennart Augustusson has a few toy compilers for various small languages in his blog, e.g:<br/><a href="http://augustss.blogspot.com/2007/06/simple-compiler-in-my-last-post-i.html">http://augustss.blogspot.com/2007/06/simple-compiler-in-my-last-post-i.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1589977533.025300"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1589977533.025300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-20 05:25</span><br/>
"A nanopass framework for commercial compiler development" (for Chez Scheme) by Andy Keep. <a href="http://andykeep.com/pubs/dissertation.pdf">http://andykeep.com/pubs/dissertation.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1589977699.025500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1589977699.025500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-20 05:28</span><br/>
This project is open source and active. <a href="http://nanopass.org/">http://nanopass.org/</a> and <a href="https://github.com/nanopass">https://github.com/nanopass</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1589977899.025800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1589977899.025800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-20 05:31</span><br/>
This is something I want to learn more about myself. I'm not happy with the compiler I wrote for my own functional language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1589978095.026000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1589978095.026000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-20 05:34</span><br/>
This blog post compares the nanopass approach to building a parser using parser combinators. &lt;<a href="https://blog.sigplan.org/2019/07/09/my-first-fifteen-compilers/">https://blog.sigplan.org/2019/07/09/my-first-fifteen-compilers/</a>&gt; I hope the analogy is correct, because building a compiler by composing simple generic functional building blocks sounds like just the approach I need.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1589978796.026300"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1589978796.026300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-20 05:46</span><br/>
Digging more into the idea of constructing a compiler by composing combinators. Here's a one page compiler written this way in Haskell that "accepts a Turing-complete language and produces WebAssembly". It's not an optimizing compiler, though. <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">https://crypto.stanford.edu/~blynn/lambda/sk.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1589979597.026600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1589979597.026600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-20 05:59</span><br/>
According to somebody on Hacker News &lt;<a href="https://news.ycombinator.com/item?id=15153956">https://news.ycombinator.com/item?id=15153956</a>&gt;,<br/>&gt; Chez Scheme [0] is written using the nanopass framework, and it's regarded as one of the fastest Scheme compilers in existence [1]. Before it was rewritten to use the nanopass system, Chez's compiler was known for its performance in terms of lines of code compiled per second; the rewrite slowed it down a bit, but the quality and performance of generated machine code improved. Andy Keep and Kent Dybvig wrote a paper about the project [2]. I haven't browsed the Chez source, but it's a good way to answer your question.<br/>&gt; [0] <a href="https://github.com/cisco/ChezScheme">https://github.com/cisco/ChezScheme</a><br/>&gt; [1] <a href="http://ecraven.github.io/r7rs-benchmarks/benchmark.html">http://ecraven.github.io/r7rs-benchmarks/benchmark.html</a><br/>&gt; [2] <a href="https://www.cs.indiana.edu/~dyb/pubs/commercial-nanopass.pdf">https://www.cs.indiana.edu/~dyb/pubs/commercial-nanopass.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1589979839.026900"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1589979839.026900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-05-20 06:03</span><br/>
Looking at the ChezScheme repository on github, it uses the nanopass framework on github (that I linked to earlier) as a dependency.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590000821.027100"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1590000821.027100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2020-05-20 11:53</span><br/>
I really liked this programming language walkthrough for compiling a "regular looking" (looks imperative) language to continuation passing style (behaves like scheme + CPS):<br/><br/><a href="http://lisperator.net/pltut/">http://lisperator.net/pltut/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590084064.027300"></a>
      <img src="https://secure.gravatar.com/avatar/bc3e6041047849518d1b042f0a29d5af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1590084064.027300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>S.M Mukarram Nainar</b>
<span style="margin:2em; color:#606060">2020-05-21 11:01</span><br/>
Thanks everyone!<br/>I didn't know chez was rewritten in nanopass, that's neat.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1592502105.031300"></a>
      <img src="https://secure.gravatar.com/avatar/0d11c25a0fa037a73c22c65361fb142a.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0014-72.png" style="float:left"/>
      <a href="../of-functional-programming/1589940714.024800.html#1592502105.031300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Boarders</b>
<span style="margin:2em; color:#606060">2020-06-18 10:41</span><br/>
I think Lisp in Small Pieces or Appel's Compiling with Continuations might have some good basic optimisation techniques but I would also love to know a good resource for this!
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
