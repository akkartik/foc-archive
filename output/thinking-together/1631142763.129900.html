<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1631142763.129900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2021-09-08 16:12</span><br/>
<b>Calling all software engineers who know basic category theory:</b> some applied category theorists in the US are organizing a hackathon to explore how <a href="https://topos.site/poly-course/">the theory of polynomial functors</a> can be applied to software development (new programming libraries and/or languages). The attendees would be a mix of software engineers (who know category theory) and category theorists. If you'd be interested in attending or brainstorming about such a hackathon let me know. I've offered to help organize it, but we need more input from software engineers. :slightly_smiling_face: This would be an in-person event in the US, taking place ~March next year.<br/><br/>There is <a href="https://topos.site/poly-course/">a short course and book draft</a> on the category of polynomial functors, outlining its applicability to <b>interactive systems</b> and <b>databases</b>. I expect these applications will be the focus of the hackathon.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1631365343.173900"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../thinking-together/1631142763.129900.html#1631365343.173900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2021-09-11 06:02</span><br/>
I’m interested in this, but I am only familiar with the basics of CT.<br/><br/>FYI: I’ve been learning what I can about generating code from laymen-defined models+properties where the generated code “smartly” chooses between both runtime (based on collected metrics) and static (based on machine model) strategies (such as sort algorithm, data layouts, GPU vs. CPU targeting, batch/row sizes, etc). There’s also a very difficult problem on providing feedback or even choices when “things” are over-constrained/non-feasible.<br/><br/>Any thoughts on if Poly could be a helpful way to model this problem? In the Poly book, they restrict the lens structure in a way I don’t understand, so I don’t know if it can model more complex optics like monadic lenses (which is one way to model+execute RT strategy decisions). I also really don’t understand the implications of things like “preserving op-cartesian arrows.”
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1631404772.174300"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1631142763.129900.html#1631404772.174300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2021-09-11 16:59</span><br/>
&gt; I’ve been learning what I can about generating code from laymen-defined models+properties<br/>It sounds like you're interested in <b>compilers</b> for high-level languages? Your description reminds me of MLIR, which aims to be a good framework for compiling programs from (vastly different) high-level domains, such as neural networks and hardware circuits. It definitely does all those static optimizations you describe.<br/><br/>As for whether Poly can help with this: my hunch is <b>no</b>, not right now. (Disclaimer though: I'm not a category theorist, I'm just a software engineer who's been in contact with the book authors.) Poly is being investigated as a <b>modelling language</b>, but not as a compiler. The main challenge right now is connecting Poly back to everyday programming constructs. We've got an understanding of how it connects to type systems, I/O, and databases, but other important stuff like recursion is missing. It's unclear how deep the Poly rabbit hole goes; it's still very early days. That's why there's a hackathon being planned: to support further exploration!<br/><br/>&gt; I don’t know if it can model more complex optics like monadic lenses<br/>Nor do I. I don't even know what a monadic lens is :slightly_smiling_face:<br/><br/>&gt; I also really don’t understand the implications of things like “preserving op-cartesian arrows.”<br/>The book is mainly targeted at category theorists right now, and so its style is to list out a bunch of theorems on every aspect of Poly. Some of them have clear implications, some of them don't. My personal strategy has been to focus on the theorems that seem interesting to me as a software engineer :innocent:.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1631443658.000200"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../thinking-together/1631142763.129900.html#1631443658.000200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2021-09-12 03:47</span><br/>
Hah, well my current hope is that the compiler input isn’t a high level language, but a model (think more like minecraft or sketch)<br/>I’m looking for the right model(s) to slowly increase power/complexity, basically adding a dimension at a time (and trying to keep people thinking about the “what” rather than the “how” when manipulating the model)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1631490675.001200"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1631142763.129900.html#1631490675.001200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2021-09-12 16:51</span><br/>
What do you mean by "model" here? That word has a lot of meanings!<br/><br/>For example, how do you wish me to perceive Minecraft as a model? I see it as a fully-fledged interactive application! But if I were to think of Minecraft as a <em>tool</em> for making models, I can recall how people use Minecraft blocks to build <em>physical models</em> of locations and buildings. But those aren't models of interactive systems. You can also use Minecraft's redstone system to build circuits, but that's equivalent to a low-level programming language, so I don't see it as something special. And of course you can write mods for Minecraft, but that's just conventional programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1631520851.004400"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../thinking-together/1631142763.129900.html#1631520851.004400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2021-09-13 01:14</span><br/>
Minecraft is a game where you have a model of a world, you can move around to look at different pieces of it, and manipulate it by doing certain actions (whose number and complexity grow over time)<br/><br/>If you replaced the “model of the world” with a “directory”, “moving around to look at different pieces of it” with “clicking and scrolling in an IDE” and “doing certain action” with “adding/editing code”, then you get an open-ended game we call programming :slightly_smiling_face:. I used Minecraft here as a reference for two reasons:<br/>1. “Adding/editing code” is all or nothing-- I’d prefer a growing set of manipulation operations (like several minecraft mods add) to avoid boilerplate without the user needing to know in advance about every operation to understand the model<br/>2. Minecraft operations/views are built around certain guarantees of the “model” (usually how different cubes will interact). In programming, the directory is so unconstrained we barely think about it; the only constraint (assumed) is that the files in the directories respect their extensions, so becomes a facsimile for some distributed AST.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1631522890.004600"></a>
      <img src="https://avatars.slack-edge.com/2023-04-13/5095853045814_6402e9775ed73b75334f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1631142763.129900.html#1631522890.004600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Nick Smith</b>
<span style="margin:2em; color:#606060">2021-09-13 01:48</span><br/>
I'd say a Minecraft world is a "world" or an "open system" (in the sense that it has state and I/O), not a "model of a world". The latter phrase suggests it's trying to accurately emulate (model) something external.<br/><br/>&gt; Minecraft operations/views are built around certain guarantees of the “model”<br/>Right, I'd describe that as "the state obeys a schema" and "the interactions obey a protocol". The aforementioned <b>Poly</b> aspires to be a language for schemas and protocols :slightly_smiling_face: (but it's not well-developed yet)
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
