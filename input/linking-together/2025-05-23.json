[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1748002955.718379",
        "client_msg_id": "0d0496c5-8255-4cf6-9fdf-49bc9848875a",
        "text": "FWIW, aside:\n&gt; Therefore each must roll their own text-&gt;ast convertor.\nReality: existing tools want to deal with bracketed text.\nAST == Lisp\n&gt; roll their own text-&gt;ast convertor.\nOverwhelming problem in 1960. Nothing-burger in 2025 (OhmJS, PEG, I'm fooling with text-to-text (t2t)).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747153874.428279",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YxtRM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FWIW, aside:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Therefore each must roll their own text->ast convertor."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Reality: existing tools want to deal with bracketed text.\nAST == Lisp\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "roll their own text->ast convertor."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Overwhelming problem in 1960. Nothing-burger in 2025 (OhmJS, PEG, I'm fooling with text-to-text (t2t))."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U07BD7U4S4R",
        "type": "message",
        "ts": "1748029948.975809",
        "client_msg_id": "94e719cc-d1e0-43a5-abf8-cec2ba680ad6",
        "text": "I mentioned `semantic` in \"AST (abstract syntax\/semantic\/etc tree)\" for a reason.\n\"(foo bar baz)\" tells you nothing about semantics.\n `foo` here might behave like `or` – then both foo and bar must exist, but only one will be evaled,\n or like `def` – then foo is new sym, which might or might not shadow existing one, and baz must exist.\nor like `list`  – then this is just list of whatever bar and baz eval to.\n\njust having tokens conveniently grouped with parens is almost never enough.\n\nre keeping, and building on top of: if you leave access to \"lower level\" format – there inevitably will be \"out of band\" changes and consequences.\n\nAnd I'd argue that tabs-vs-spaces, formatter-wars, linters, package management, junky diffs, etc – are very much \"today's problems\" too",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0343f70ca57",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-07-04\/7377091009748_d0343f70ca57c18eeb41_72.png",
            "first_name": "misha",
            "real_name": "misha",
            "display_name": "misha",
            "team": "T5TCAFTA9",
            "name": "misha.akovantsev",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747153874.428279",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UZu7q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I mentioned "
                            },
                            {
                                "type": "text",
                                "text": "semantic",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in \"AST (abstract syntax\/semantic\/etc tree)\" for a reason.\n\"(foo bar baz)\" tells you nothing about semantics.\n "
                            },
                            {
                                "type": "text",
                                "text": "foo",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " here might behave like "
                            },
                            {
                                "type": "text",
                                "text": "or",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " – then both foo and bar must exist, but only one will be evaled,\n or like "
                            },
                            {
                                "type": "text",
                                "text": "def",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " – then foo is new sym, which might or might not shadow existing one, and baz must exist.\nor like "
                            },
                            {
                                "type": "text",
                                "text": "list",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  – then this is just list of whatever bar and baz eval to.\n\njust having tokens conveniently grouped with parens is almost never enough.\n\nre keeping, and building on top of: if you leave access to \"lower level\" format – there inevitably will be \"out of band\" changes and consequences.\n\nAnd I'd argue that tabs-vs-spaces, formatter-wars, linters, package management, junky diffs, etc – are very much \"today's problems\" too"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1748066008.881309",
        "client_msg_id": "7a31b9a4-ce41-4ef0-b656-8ac0306e8593",
        "text": "Semantics matter, obviously. But I am not convinced that they can be usefully integrated with syntax or more generally representation issues. I'd love to be proven wrong, because I see the separation of syntax and semantics as an important source of bugs in my field: programs that do something superficially reasonable, but not what a domain expert would expect them to do from a superficial look at the source code.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1747153874.428279",
        "parent_user_id": "ULM3U6275",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5vlB6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Semantics matter, obviously. But I am not convinced that they can be usefully integrated with syntax or more generally representation issues. I'd love to be proven wrong, because I see the separation of syntax and semantics as an important source of bugs in my field: programs that do something superficially reasonable, but not what a domain expert would expect them to do from a superficial look at the source code."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]