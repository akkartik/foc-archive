[
    {
        "user": "UEGFXUK3M",
        "type": "message",
        "ts": "1545989886.109100",
        "edited": {
            "user": "UEGFXUK3M",
            "ts": "1545989903.000000"
        },
        "client_msg_id": "8f860bee-41bf-41c5-9a08-54a26deb0a00",
        "text": "Great thread! I’ll add a few points about feedback.\n\nFirst, in other domains such as motor learning, it is well known that ‘continuous concurrent feedback’ can be counter productive, e.g.:\n<http:\/\/hp-research.com\/sites\/default\/files\/publications\/Schmidt%20%26%20Wulf%20(1997,%20HF).pdf>\n\nThe reason often given is that when the feedback in question is not ‘naturally in the information environment’, it becomes a crutch that when taken away causes failure. Imagine for example a child learning to ride a tricycle with stabilised wheels, versus a bike with no pedals that they learn to balance with by lifting their feet up. Other reasons given include that feedback can interfere with the development of what are ultimately “feedforward” skills.\n\nAnother thing to consider in this case, is what people in design refer to as “talkback”, which is the generative nature of say a sketch on paper that means it gives back to you more information than you put into it, and that information may be self-contradictory. For example if you sketch a chair and draw over the lines again and again, your brain can then play around with which is the “correct” set of lines, or even imagine ones that aren’t drawn. Feedback in live programming does not entertain these imaginary\/self-contradictory paths because they cannot be run as programs, and so the overall “talkback” is limited. Ironically, when there is no feedback, i.e. the program is not running, it may be that the talkback is much greater because the programmer can run bits of code in their head, consider different routes, sketch code they know does not work, receive ideas back from it, and so on. I think this is a good way of explaining what <@UC2A2ARPT> is arguing for.\n\nMore on sketching:\n<https:\/\/www.youtube.com\/watch?v=Ihx4zrEQR9s>\n<https:\/\/www.youtube.com\/watch?v=k5TUSkigclA>\nMasaki Suwa and Barbara Tversky, “What Do Architects and Students Perceive in Their Design Sketches? A Protocol Analysis,” Design Studies 18, no. 4 (1997): 385–403\nAlistair McGown, Graham Green, and Paul A. Rodgers, “Visible Ideas: Information Patterns of Conceptual Sketch Activity,” Design Studies 19, no. 4 (1998): 431–453\nMasaki Suwa et al., “Seeing into Sketches: Regrouping Parts Encourages New Interpretations,” in Visual and Spatial Reasoning in Design, 2001, 207–219.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "bbd74d10a2d2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-04-24\/1108683470016_bbd74d10a2d2a0dbb156_72.jpg",
            "first_name": "Jack",
            "real_name": "Jack",
            "display_name": "jarm",
            "team": "T5TCAFTA9",
            "name": "jack",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1545891251.087800",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2k6S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great thread! I’ll add a few points about feedback.\n\nFirst, in other domains such as motor learning, it is well known that ‘continuous concurrent feedback’ can be counter productive, e.g.:\n"
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/hp-research.com\/sites\/default\/files\/publications\/Schmidt%20%26%20Wulf%20(1997,%20HF).pdf"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThe reason often given is that when the feedback in question is not ‘naturally in the information environment’, it becomes a crutch that when taken away causes failure. Imagine for example a child learning to ride a tricycle with stabilised wheels, versus a bike with no pedals that they learn to balance with by lifting their feet up. Other reasons given include that feedback can interfere with the development of what are ultimately “feedforward” skills.\n\nAnother thing to consider in this case, is what people in design refer to as “talkback”, which is the generative nature of say a sketch on paper that means it gives back to you more information than you put into it, and that information may be self-contradictory. For example if you sketch a chair and draw over the lines again and again, your brain can then play around with which is the “correct” set of lines, or even imagine ones that aren’t drawn. Feedback in live programming does not entertain these imaginary\/self-contradictory paths because they cannot be run as programs, and so the overall “talkback” is limited. Ironically, when there is no feedback, i.e. the program is not running, it may be that the talkback is much greater because the programmer can run bits of code in their head, consider different routes, sketch code they know does not work, receive ideas back from it, and so on. I think this is a good way of explaining what "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " is arguing for.\n\nMore on sketching:\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=Ihx4zrEQR9s"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=k5TUSkigclA"
                            },
                            {
                                "type": "text",
                                "text": "\nMasaki Suwa and Barbara Tversky, “What Do Architects and Students Perceive in Their Design Sketches? A Protocol Analysis,” Design Studies 18, no. 4 (1997): 385–403\nAlistair McGown, Graham Green, and Paul A. Rodgers, “Visible Ideas: Information Patterns of Conceptual Sketch Activity,” Design Studies 19, no. 4 (1998): 431–453\nMasaki Suwa et al., “Seeing into Sketches: Regrouping Parts Encourages New Interpretations,” in Visual and Spatial Reasoning in Design, 2001, 207–219."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UDJ2TKB99",
        "type": "message",
        "ts": "1545997596.109900",
        "edited": {
            "user": "UDJ2TKB99",
            "ts": "1545999574.000000"
        },
        "client_msg_id": "3d2d6a2f-d94d-47d9-9194-b7113e3dae31",
        "text": "I hadn't considered this persistence-centric argument against graphical representations, but given my interest in long-term data preservation, it's appealing. Specifically: *working in plain-text systems makes your work more likely to be reusable a decade from now*\n\nFor decades, the plain text file has remained a pretty good common denominator for a diverse set of tools, which creates friction against graphically-oriented authoring environments.\n\nI've seen this play out most vividly in iOS development, where there are very well supported graphical tools for UI layout authoring, but many people avoid using them (in favor of generating UI elements in code and layout constraints in a textual DSL) because git version control and code review diffing operates on the harder-to-read plain-text serialization of the visual format, and it can be difficult to do a merge correctly.\n\nDoes that mean we're stuck here forever? I'd like to think not, but I believe it depends on us finding the next set of long-term primitives beyond text files in folder hierarchies",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7acd71947ea2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-10-04\/2564854327154_7acd71947ea203e9a69b_72.jpg",
            "first_name": "Joe",
            "real_name": "Joe Trellick",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "joe",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1545983608.108800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a05",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I hadn't considered this persistence-centric argument against graphical representations, but given my interest in long-term data preservation, it's appealing. Specifically: "
                            },
                            {
                                "type": "text",
                                "text": "working in plain-text systems makes your work more likely to be reusable a decade from now",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nFor decades, the plain text file has remained a pretty good common denominator for a diverse set of tools, which creates friction against graphically-oriented authoring environments.\n\nI've seen this play out most vividly in iOS development, where there are very well supported graphical tools for UI layout authoring, but many people avoid using them (in favor of generating UI elements in code and layout constraints in a textual DSL) because git version control and code review diffing operates on the harder-to-read plain-text serialization of the visual format, and it can be difficult to do a merge correctly.\n\nDoes that mean we're stuck here forever? I'd like to think not, but I believe it depends on us finding the next set of long-term primitives beyond text files in folder hierarchies"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBSMEUXAA",
        "type": "message",
        "ts": "1546057017.110600",
        "client_msg_id": "43c3d5aa-0045-427e-9885-020d92f3b5b3",
        "text": "Wouldn't a serialization format that supports diffs and merges and tools that help visualize UI layout diffs fix that?  Unreal Blueprints have diff and merge tools that show visual graph differences.  The merge tool doesn't really work but the diff tool is actually pretty useful. It's especially necessary because Blueprints serialize as binary",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1545983608.108800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x4eB5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wouldn't a serialization format that supports diffs and merges and tools that help visualize UI layout diffs fix that?  Unreal Blueprints have diff and merge tools that show visual graph differences.  The merge tool doesn't really work but the diff tool is actually pretty useful. It's especially necessary because Blueprints serialize as binary"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBSMEUXAA",
        "type": "message",
        "ts": "1546057230.110800",
        "client_msg_id": "728475e3-8a27-4eab-b5d1-0a775de09668",
        "text": "It's harder to support this with a graphical representation but maybe it means any \"serious\" graphical programming environment should think about collaboration and support version control, diffs, and merging, maybe in a generic way. A standalone tool that can output a standard image format on any platform, for example, or maybe even render ASCII for people that want to always stay in a terminal",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1545983608.108800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "csi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's harder to support this with a graphical representation but maybe it means any \"serious\" graphical programming environment should think about collaboration and support version control, diffs, and merging, maybe in a generic way. A standalone tool that can output a standard image format on any platform, for example, or maybe even render ASCII for people that want to always stay in a terminal"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UDJ2TKB99",
                    "UA14TGLTC",
                    "U79HM6726",
                    "UE0ETTCG7"
                ],
                "count": 4
            }
        ]
    }
]