<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-18 01:23</span><br/>
<a href="https://florentcrivello.com/index.php/2019/09/04/the-efficiency-destroying-magic-of-tidying-up/">https://florentcrivello.com/index.php/2019/09/04/the-efficie&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574082328.214100"></a>
      <img src="https://avatars.slack-edge.com/2018-12-12/502004543669_540fc50d2192cc8aba20_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574082328.214100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Marcel Goethals</b>
<span style="margin:2em; color:#606060">2019-11-18 05:05</span><br/>
a city is not a tree
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574095174.214400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574095174.214400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-11-18 08:39</span><br/>
<a href="https://www.patternlanguage.com/archive/cityisnotatree.html">https://www.patternlanguage.com/archive/cityisnotatree.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574160109.214800"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574160109.214800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2019-11-19 02:41</span><br/>
I love this quote:<br/><br/>&gt; Whenever we have a tree structure, it means that within this structure no piece of any unit is ever connected to other units, except through the medium of that unit as a whole.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574165711.219900"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574165711.219900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-19 04:15</span><br/>
Ok, so, can we talk about this for a bit? If you subscribe to the theory laid out in those two articles (unsurprisingly, much better in the one by Christopher Alexander), and if you believe that it can be applied to software, how does this change the way you design (as in architect — but that’s not a verb, as Alexander would say) systems?<br/><br/>In essence one possible conclusion is that we’ve been doing software architecture all wrong for decades, trying to cleanly separate everything into distinct layers or subsystems with as little overlap as possible, modeling everything as a tree, when it should be a semi-lattice.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574184067.220100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574184067.220100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-11-19 09:21</span><br/>
That's basically what I've been saying! Come on in, the water's fine.<br/><br/><a href="http://akkartik.name/post/modularity">http://akkartik.name/post/modularity</a><br/><a href="https://lobste.rs/s/rqgeej/what_four_color_theorem_can_teach_us_about#c_zgjio7">https://lobste.rs/s/rqgeej/what_four_color_theorem_can_teach_us_about#c_zgjio7</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574189703.220400"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574189703.220400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2019-11-19 10:55</span><br/>
I think microservices architecture (optimized for decoupled deployments) directly counters the tree (SOA optimized for minimal overlap) trend
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574189750.220800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574189750.220800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-11-19 10:55</span><br/>
<span style="background-color:#ccf">@Don Abrams</span> can you elaborate?!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574190301.221000"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574190301.221000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2019-11-19 11:05</span><br/>
Sure:<br/><br/>In SOA everything had it’s neat little box where there were hierarchies of responsibilities and each service handled some (sub)responsibility that would never overlap with another.<br/><br/>In a microservices architecture--where any service can talk to any other service-- the tree model doesn’t exist anymore. Instead you have the possibility that anyone can depend on you (and vica versa). It’s way way harder to operationalize <b>because</b> you can’t visualize the entire system.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574190491.221200"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574190491.221200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2019-11-19 11:08</span><br/>
(FYI: I purposely am not referring to the hybrid/tiered microservices architectures aka distributed SOA because they are mostly frankenstein monsters borne out of lack of tooling/understanding of the tradeoffs before starting-- my perspective matches the one described here: <a href="http://nealford.com/downloads/Evolutionary_Architecture_Keynote_by_Neal_Ford.pdf">http://nealford.com/downloads/Evolutionary_Architecture_Keynote_by_Neal_Ford.pdf</a>)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574191377.221600"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574191377.221600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-11-19 11:22</span><br/>
I'm still a little confused because I always thought microservices <em>were</em> SOAs.<br/><br/>Ignoring labels, I think you're comparing the ideal of one side with the reality of the other. We've been creating overly complex spaghetti architecture diagrams long before either of these terms were coined.<br/><br/>But I think I'm still not understanding you, so would appreciate further elaboration.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574212062.223500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574212062.223500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-19 17:07</span><br/>
The Christopher Alexander essay is amazing. But no, we are not designing software wrong. This is explained by a section of Alexander's essay, starting with "The tree is accessible mentally and easy to deal with. The semilattice is hard to keep before the mind's eye and therefore hard to deal with."<br/><br/>My point is that source code needs to be organized in a way that the human mind can comprehend, otherwise, it is not maintainable. On the other hand, it is fine if the output of an optimizing compiler is a big mess that you could not reasonably maintain by hand.<br/><br/>In the first article, consider that photo of the topologically optimized machine part. Do you want your source code to look like that? If the requirements change, can you modify that structure to meet the new requirement? Of course not, but that structure is the output of an optimizing "topology" compiler. The source code used to generate it is quite a bit simpler and more orderly.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574218803.223700"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574218803.223700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-11-19 19:00</span><br/>
I mostly agree; you don't have to see reality "as it is" to reason about it. It's just worth remembering that hierarchical decomposition is an approximation, and that other approximations are possible (see my links above).<br/><br/>All too often the response to a failure of hierarchy is to add more hierarchy. It's easy to confuse the map for the territory.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574256350.224800"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574256350.224800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 05:25</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> Having read both of your articles you linked earlier, I think you're onto something… I'm just not sure if I understand it fully yet. Can you try to explain what you mean by tests being "like a Fourier transform" — is that your way of highlighting the property that reduces the granularity from individual atoms (all possible program states) to slightly higher-level and neatly organized composites?<br/><br/>I'm also not quite sure how to close the loop from there to the trees vs. semi-lattices argument, and would love to hear more about where you see the connection.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574256968.225000"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574256968.225000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 05:36</span><br/>
There is something to micro services (although I have no experience there and would've never made the connection) or the actor model, or Alan Kay's original idea of object orientation that seem to at least point into an interesting direction. While it could easily be interpreted as just another form of modularization it has a different quality to it, although I'm having a hard time to describe it more precisely. I believe it has something to do with what we see in biological systems, a strong inspiration for Alan Kay when designing object oriented systems, and looking at nature it is a de-facto proven way of organizing much more complex systems reliably. They also clearly exhibit strong hierarchical tree structures, although part of why they're so clearly visible to us is likely that we're hardwired to see them (see paper <em>The Architecture of Complexity</em>). They also have many properties of much higher connectivity, which yields their emergent properties. And that I believe is the part that's missing in software. So far we have mostly designed pure trees, and not just used trees as a way to understand a much more connected semi-lattice; perhaps using several different trees to model different aspects of the same system.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574257634.225200"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574257634.225200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 05:47</span><br/>
We also usually build software from the bottom up assembling smaller components. Christopher Alexander describes his design process as the opposite, always starting from the whole and unfolding structure within it. I have thought long and hard about what such a process could look like for software, but haven't had an epiphany yet…<br/><br/>I'm convinced more iterative design and development processes that try to loop around a working product and improve it in small increments are usually more successful because they are at least somewhat leaving the space of purely bottom-up assembly of components behind and come a bit closer to an unfolding process. But I doubt it's anywhere close to what Alexander has in mind.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574263790.225800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574263790.225800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-20 07:29</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span> "Christopher Alexander describes his design process as the opposite, always starting from the whole and unfolding structure within it. I have thought long and hard about what such a process could look like for software, but haven't had an epiphany yet…" -- Isn't this just Top Down Design? Also known as Stepwise Refinement. <a href="https://inf.ethz.ch/personal/wirth/Articles/StepwiseRefinement.pdf">https://inf.ethz.ch/personal/wirth/Articles/StepwiseRefinement.pdf</a> To use this approach practically while coding and writing tests, the lower level modules start out as stubs, which can be refined into partial solutions that can pass some unit tests but don't fully solve the problem (because you haven't figured out how to solve the complete problem yet). This means your dependencies may change as you replace a stub or trial solution of a submodule with a more final implementation that meets all the requirements. It is tempting to let your dependencies determine your design, or to let whatever code is easiest to write determine your design. That's bottom up thinking. To break out of this, I have to alternate between sessions of coding, and sessions of top down thinking where I don't write code, and instead think about how my present code fails to implement my vision and goals.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574264926.226200"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574264926.226200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 07:48</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> Ah, that's interesting. My initial reaction is "of course it's not", but I haven't read this particular paper of Wirth yet. :wink:<br/><br/>I don't think the top-down nature of Alexander's approach is the important piece, but what he calls <em>unfolding</em> in <em>The Nature of Order</em> — uncovering the structure of the whole while looking at all dimensions at once.<br/><br/>We certainly know how to develop software in small increments, but that usually means we're still trying to reach a more or less well defined goal and just cut the path towards it into manageable pieces, maybe even allowing slight diversions along the way. The process, however, is still primarily goal-driven.<br/><br/>What Alexander describes sounds a lot more like the process of a sculptor carving pieces of material from a block until an image manifests itself, "discovering the sculpture that's been hiding in the block", but the sculptor wouldn't be able to tell you in the beginning what they're going to end up with.<br/><br/>I'll give Wirth's paper a read, he usually is worth the time. Thanks for making the connection to it and sharing a link!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574266211.226500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574266211.226500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-20 08:10</span><br/>
I haven't read the Nature of Order, so I'll look that up. "Uncovering the structure of the whole while looking at all dimensions at once" is something I am trying to do in my project. Since I've taken on a project at the limits of my abilities, I can only use an iterative approach, where I build a trial solution, and then iterate as new problems and challenges come to the forefront. Pure top down design (using a single iteration) doesn't work for me until the problem is trivial or well understood (by me). I have to write code to make progress and get a fuller understanding of the problem, but with new knowledge and insight comes the need to refactor the design and even change module boundaries (aka uncovering the structure of the whole). My brain isn't big enough to look at all dimensions at once, so I keep copious design notes to record my past insights and decisions, and work on a few dimensions at a time during each major iteration. Quoting Wirth, programmers "must learn to weigh the various aspects of design alternatives in the light of these criteria. They must be taught to revoke earlier decisions, and to back up if necessary, even to the top."
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574266658.226700"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574266658.226700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 08:17</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> Well, if you end up reading <em>The Nature of Order</em>, please enlighten us. It's four books with over 2000 pages total. You might want to read posts about it instead. I haven't read it either, but read several summaries and posts that focus on the unfolding process (which I believe is in book 2 or 3). I don't have the time right now to find the links, but I'm pretty sure you'll find some of them here somewhere…
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574267368.226900"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574267368.226900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 08:29</span><br/>
Well, I guess I've got better at this note taking thing: Here's something to start with:<br/><br/>• <a href="http://iamronen.com/quality/christopher-alexander-the-nature-of-order/">http://iamronen.com/quality/christopher-alexander-the-nature-of-order/</a><br/>• <a href="http://www.livingneighborhoods.org/library/empirical-findings.pdf">http://www.livingneighborhoods.org/library/empirical-findings.pdf</a><br/>• <a href="http://www.permacultureproject.com/wp-content/uploads/2015/02/Alexander-as-phenomenology-of-wholeness-dec-081.pdf">http://www.permacultureproject.com/wp-content/uploads/2015/0&hellip;</a><br/>• <a href="http://jomardpublishing.com/UploadFiles/Files/journals/NDI/V2N2/SalingarosN.pdf">http://jomardpublishing.com/UploadFiles/Files/journals/NDI/V2N2/SalingarosN.pdf</a><br/>• <a href="https://arxiv.org/pdf/1303.7303.pdf">https://arxiv.org/pdf/1303.7303.pdf</a><br/>• <a href="http://zeta.math.utsa.edu/~yxk833/life.carpet.html">http://zeta.math.utsa.edu/~yxk833/life.carpet.html</a><br/>• <a href="https://youtu.be/98LdFA-_zfA">https://youtu.be/98LdFA-_zfA</a><br/><br/>I wouldn't expect going down this rabbit hole to yield any immediate and practical conclusions for what you're trying to do. You will also see that this is a strong diversion from the analytical world of ours talking a lot about abstract emotional concepts like beauty and our capabilities to "see" or feel these properties indirectly.<br/><br/>I'm not surprised that Alexander ultimately jumps off a cliff of spirituality and religion, which isn't even closely what I am looking for by studying his work. But who knows, maybe he just reached enlightenment and has finally figured it out…
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574267898.227100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574267898.227100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-20 08:38</span><br/>
Volume 2, The Nature Of Order (Wikipedia synopsis) "Complex systems do not spring into existence fully formed, but rather through a series of small, incremental changes. The process begins with a simple system and incrementally changes that system such that each change preserves the structure of the previous step. Alexander calls these increments "structure-preserving transformations," and they are essential to his process." That's what I was trying to explain earlier.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574267909.227300"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574267909.227300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 08:38</span><br/>
&gt;  Quoting Wirth, programmers "must learn to weigh the various aspects of design alternatives in the light of these criteria. They must be taught to revoke earlier decisions, and to back up if necessary, even to the top."<br/><br/>I think the underdeveloped skill in our industry that could also potentially be augmented with better tools is our capacity to work with several dimensions (different tree approximations of the same semi-lattice) at once as well as how easy we can jump back and forth between different levels of complexity (the depth within those trees), <em>up and down the ladder of abstraction</em>.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574268152.227500"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574268152.227500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 08:42</span><br/>
&gt; <em>Wikipedia synopsis</em><br/><br/>Well, the rabbit hole just looks like any other from up there… :wink:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574268471.227700"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574268471.227700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-20 08:47</span><br/>
"I'm not surprised that Alexander ultimately jumps off a cliff of spirituality and religion" -- I think that Alexander's notion of "life" is a very desireable property for an FoC system to have, even if the concept is slippery. Donald Norman jumped off the same cliff, I think. He wrote "The Design of Everyday Things" -- which has lessons for programming language design -- and later followed up with "Emotional Design: Why we Love or Hate Everyday Things" (which I haven't read yet). Norman recanted his previous belief that emotion has no place in design (and revised The Design of Everyday Things to remove this assertion).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574268773.227900"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574268773.227900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-20 08:52</span><br/>
from my notes, derived from Christopher Alexander:<br/>Quality Without a Name:<br/><li> Usability - Will the feature make Curv more usable for novices?<br/>  Is the feature something that developers will enjoy using?<br/>  Would either group miss it if it was no longer available?<br/><li> Readability - Is the intent of the feature clear and well presented?<br/><li> Configurability - Can the user adapt the feature to his or her needs?<br/><li> Profoundness - Does the feature strike the user as special or unique,<br/>  but at the same time, insightful and correct?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574269637.228100"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574269637.228100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 09:07</span><br/>
I fully agree that what Alexander calls "life" in one period and "wholeness" or "quality without a name" in others is a very valuable concept and we could certainly use more of it  — I'm just less interested in the spiritual conclusion from his late period which leaves me somewhat unsatisfied.<br/><br/>On the other hand, understanding the extraordinary amount of several decades of work after his <em>Pattern Language</em>, which is what most programmers know him for, shows what a huge amount of ideas is still ripe to be adapted to our industry (and others that involve a lot of design).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574269935.228300"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574269935.228300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 09:12</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> I like your list of how you adapted his principles directly to software design. Would love to read more about it. In particular I would find your take on the 15 fundamental properties of wholeness adapted to software design very interesting — not sure if that is already what you based those four on, or if he published that later. It's definitely in Nature of Order and I think that's in book 1.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574270053.228500"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574270053.228500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 09:14</span><br/>
It sounds like you break it down into features and then apply the principles to those features individually — do I understand that correctly?<br/>Do you also look at the system as a whole and how those properties are preserved across individual features?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574270610.228700"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574270610.228700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 09:23</span><br/>
15 properties of wholeness:<br/><br/>• <a href="http://www.tkwa.com/fifteen-properties/">http://www.tkwa.com/fifteen-properties/</a><br/>• <a href="https://blog.p2pfoundation.net/the-fifteen-geometric-properties-of-wholeness/2014/03/01">https://blog.p2pfoundation.net/the-fifteen-geometric-propert&hellip;</a><br/>• <a href="https://www.archdaily.com/626429/unified-architectural-theory-chapter-11/">https://www.archdaily.com/626429/unified-architectural-theory-chapter-11/</a><br/><br/>Forget all the links above and look at these first — I think this is potentially the most useful for us to adapt in software design. Alexander's unfolding process is what he came up with after identifying the 15 properties and doing a ton of empirical research to show that people can generally sense the presence or absence of these properties (in architecture of course). His process then makes sure that you create and preserve the properties.<br/><br/>I'm particularly after <em>Levels of Scale</em> as one of the properties we don't really follow in software where the "size" or scale of our abstractions can be completely arbitrary — everything is just a function call (or a method on an object, if you're into that kind of thing), but we have no sense for which level of scale we're operating on, mixing and matching low-level algorithms in high-level structures and vice versa.<br/><br/>Ah, that just makes me realize that I really need to stop posting here and get my act together and write some proper blog posts about this.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574271050.229100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574271050.229100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-11-20 09:30</span><br/>
I spend most of my time thinking about individual features, so the QWAN is easiest to apply in that context. I try to periodically look at the system as a whole and I try to see how the QWAN applies to the gestalt, but it's more difficult. I can occasionally see design alternatives where if I modify multiple features at once, then I jump to a different part of the design landscape where the fitness of the design is improved along certain axes.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574271329.229300"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574271329.229300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-11-20 09:35</span><br/>
<span style="background-color:#ccf">@Dan Cook</span> had a great thread back about Christopher Alexander back in March, that I got a lot out of, but.. it turns out Slack at some point added a restriction on free plans. It doesn't just keep us from searching for old threads if we don't pay, it also refuses to <em>show</em> them. Which means that what I thought of as a permalink for a thread isn't really all that permanent. That is some <b>bullshit</b>. Sign me up to move elsewhere.<br/><br/>Anyway, where was I? Unfolding wholeness. It's a dashed subtle idea, and I never grokked it until March, and now I fear I've forgotten a lot of the nuance yet again. But it's <em>not</em> the same as iterative refinement. One very concrete sentence that particularly stood out for me because it fits my prejudices:<br/><br/><br/>> In order for code to be living structure, even the tools used to make the code need to be living structure.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574286443.229900"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574286443.229900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-11-20 13:47</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span><br/><br/><br/>&gt; Can you try to explain what you mean by tests being "like a Fourier transform..?<br/><br/>It's very easy to think of a program as the sum of its source code. Subsystems, functions, lines of code. This decomposition is often useful. I think of it as the time domain in my analogy.<br/><br/>An alternative worldview is to think of a program as a space of inputs that it handles, decomposing into different <em>regimes</em>. Within a regime behavior changes smoothly/continuously. Across a regime boundary behavior changes abruptly/discontinuously. I find this decomposition more useful, partly because it's not reified anywhere in the source code and so easy to forget. I consider this the frequency domain in my analogy.<br/><br/>One place where you can see the frequency domain if you squint, and if a program is written in a certain way, is by staring at its tests. Usually you'll have one test per regime, and areas around the test will tend to behave similarly. One could imagine trying to add multiple tests per regime to help nail down the boundary more carefully and so reify the frequency domain in the limit. If we did that, a whole new universe of tools would open up. But it's definitely still an open problem.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574288090.245500"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574288090.245500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-20 14:14</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> let's see if I grokked this: I think I understand why you picked tests, and it certainly makes this easier to understand than what I’m about to try, but what still puzzles me a little is this: how the program is written is highly subjective, so one domain is based on an arbitrary factor — which makes sense, it's about how we design things after all. But then I would rather try to base the second domain on a different property dependent on the same arbitrary design, but tests are a completely different beast and also completely arbitrarily designed. I know we’re talking about a metaphor here and that's probably not the point, but I would’ve rather picked a property of the program design to stay within the same level of arbitrariness… I don’t know, encoded invariants maybe? Assuming a tester would try to hit all encoded invariants through something like designing the unit tests based on cyclomatic complexity, trying to exercise all possible code paths.<br/><br/>Anyway, the metaphor works and I think I understand that part. Would you agree that the connection to trees and lattices then is this: time domain or decomposition in subsystems (program structure) is one tree approximation, frequency domain or decomposition in regimes (invariants?) is a different tree approximation, but both trees stem from the same program, therefore likely a more complex lattice structure?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574290209.245700"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574290209.245700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-11-20 14:50</span><br/>
> Would you agree that the connection to trees and lattices then is this:<br/><br/>I hadn't thought about it quite that far :smile: Originally I linked my posts as examples where I point out flaws in one (dominant) approach to tree-based decomposition in software. So I was agreeing with you that we've been doing things wrong for decades. But perhaps my approach is also tree-based, so it isn't completely relevant to this particular thread. As Doug Moen pointed out above (at least in my interpretation of <a href="1574069038.213900.html#1574212062.223500">1.574212.html&hellip;</a>), trees are valuable approximations or abstractions even if they don't capture every last nuance about cities or software.<br/><br/><br/>> how the program is written is highly subjective, so [the time] domain is based on an arbitrary factor.. I would rather try to base the second domain on a different [independent] property..<br/><br/>You're absolutely right! Congratulations, you found a soft spot in my argument I've waited years for someone to point out :heart:<br/><br/>I'd like the way we visualize the domain of a problem to be independent of how our code happens to be written. Unfortunately tests don't do that. They co-evolve with the code. So two programs written by different people for the exact same domain could end up having incompatible tests, if they choose a fundamentally different approach to solving it, and their internal data structures are different, and there are cascading effects throughout tests of different granularities everywhere. In defense of tests:<br/><br/><br/>• A lot of times there's one obvious architecture. Compilers have a certain flow of parsing, optimization and code-generation that is fairly timeless.<br/>• Having a frequency domain to visualize is super helpful even if it's only for your program's architecture. It's better than nothing, until we come up with something better.<br/>• I've been writing tests for years in a way that tries to mitigate this problem as much as possible. Rather than have tests run sub-components and make assertions on their behavior, I always run the whole program, emitting a <em>trace</em> of domain-specific events (facts deduced by the program), namespaced by different conceptual sub-components. Then different tests make assertions on the state of the trace. Fine-grained unit tests may focus on just traces pertaining to a specific namespace, while coarse-grained integration tests may look at a different namespace. I call this approach white-box testing (<a href="http://akkartik.name/post/tracing-tests">http://akkartik.name/post/tracing-tests</a>) and it isn't a complete solution to the problem, because it is possible to imagine a program so radically different that it doesn't even share the same coarse sub-components. But for the most part, in practice, white-box tests help because they simplify the problem of compatibility to just having the same namespace names and trace format.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574323870.283300"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574323870.283300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-21 00:11</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> I read your <em>A new way of testing</em> and I think you’re onto something that I can make a connection to in a totally different context but it feels like the same pattern to me.<br/><br/>What you see in “white-box testing” is what I see in declarative frameworks like SwiftUI or React, or in the application of monads (as in Haskell’s IO), or in effect systems: I think it’s also what you call “obvious architecture” above. It’s not obvious at all, but I think I know what you mean. :-)<br/><br/>I see a subtle trend in programming uncovering distinct layers, I would call them <em>layers of scale</em> in the Alexander sense, and designing more and more systems around those, by increasing the expressiveness within each of these layers with algebraic composition.<br/><br/>When you declaratively specify a UI with SwiftUI, you don’t tell the system what to do directly (that’s the declarative part, but that’s not quite my point here), but you create a data structure that will be “parsed” and transformed into the view hierarchy at runtime. You’re kind of programming within programming, but not just in an eDSL sense, but more in an Inception sense. There are two distinct scales here, although you don’t really see them if you don’t look for them.<br/><br/>When you use the IO monad in Haskell, you don’t cause the side effects to happen directly, but you assemble a data structure that will eventually become the “real program” and then reduce down to calculating all the side effects. Again, two separate scales.<br/><br/>Both concepts look very similar to me. As does what you do with your “trace-based tests”. You’re separating levels of scale, slicing the system into different domains, but not in an elaborate manual way, designing each layer individually, but by exploiting a structure that already exists.<br/><br/>I find it hard to describe, even though the pattern makes total sense in my head… we look for something like a pivot point to rotate the whole system around and at certain angles everything aligns neatly and we can see different aspects of the same thing clearly. It’s like splitting your system into distinct layers, but simpler — a lot less effort than designing the layers explicitly — and yet more powerful. These are the tree approximations derived from a lattice structure. They are not designed, but derived. They are already there and therefore don’t have to be designed, just discovered. And if we could understand better how to discover them, we could cope with much more complex systems.<br/><br/>I find as we tumble down our rabbit holes and get quite deep into them, it becomes harder and harder to convey what we learn as what makes sense to us is just totally incomprehensible to others who have not been down the same rabbit hole as far as we have. Words with meanings obvious to us lead others down a completely wrong path. I felt like this when trying to decipher your Fourier transform analogy, and I wouldn’t be surprised if you will feel like this with what I just wrote.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574323999.285500"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574323999.285500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-11-21 00:13</span><br/>
<a href="https://www.lesswrong.com/posts/tMhEv28KJYWsu6Wdo/kensh">https://www.lesswrong.com/posts/tMhEv28KJYWsu6Wdo/kensh</a><br/><br/>This is pretty much how I feel about Christopher Alexander — he’s telling me to “look up”, and I do but I still can’t quite see what he means because there’s nothing above the menu bar on my screen… :-)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574324589.285800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574324589.285800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-11-21 00:23</span><br/>
Yeah, that's indeed my reaction. I'll try to reflect more on your comment.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574580407.319200"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574580407.319200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-11-23 23:26</span><br/>
You still want trees and categories, but you also need then to overlap sometimes. This can be as simple as using interfaces instead of abstract classes
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1574674319.319600"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1574674319.319600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-11-25 01:31</span><br/>
[OT] what a great thread, sadly most of people on FoC will miss it and we collectively will miss it in a few months, this looks really valuable and reminds me of reading back and forths in the c2 wiki :slightly_smiling_face:<br/><br/>What I would love for a tool (of thought :stuck_out_tongue:) is the ability of the people in this conversation to go back, summarize and highlight parts of the conversation for people comming to it later to get a gist or a refinement of the conversation after it happened since I think most of the participants have a clearer idea at the end than at the beginning and the clearest idea just after finishing the conversation, after that the subtelties will fade out (like tears in the rain :stuck_out_tongue:). I've been thinking about a slack/wiki hybrid where you start from threads and start refining them into articles, you can still jump back to previous iterations of the article and the raw conversation, but the entry point is an organized summary.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575498401.340400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1575498401.340400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-12-04 14:26</span><br/>
Make it happen, <span style="background-color:#ccf">@Mariano Guerra</span>!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1575532208.340700"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../linking-together/1574069038.213900.html#1575532208.340700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2019-12-04 23:50</span><br/>
it may be my next (or next next) project if no one solves it by then :slightly_smiling_face:
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
