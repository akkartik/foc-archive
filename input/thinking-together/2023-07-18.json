[
    {
        "user": "U0378MDUG1Y",
        "type": "message",
        "ts": "1689664080.946329",
        "client_msg_id": "78D9AE73-99BF-4B02-A23B-2BF840095BA6",
        "text": "A related paper on the topic; “On the Expressive Power of Programming Languages” by Matthias Felleisen (1990)\n\n<https:\/\/citeseerx.ist.psu.edu\/doc\/10.1.1.51.4656|https:\/\/citeseerx.ist.psu.edu\/doc\/10.1.1.51.4656>\n\nSummary of the paper:\n<https:\/\/m.youtube.com\/watch?v=43XaZEn2aLc|https:\/\/m.youtube.com\/watch?v=43XaZEn2aLc>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1092a4f97098",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-03-23\/3286745266387_1092a4f970985ebc8d2b_72.png",
            "first_name": "Christopher",
            "real_name": "Christopher Shank",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chris.shank.23",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "attachments": [
            {
                "from_url": "https:\/\/m.youtube.com\/watch?v=43XaZEn2aLc",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/43XaZEn2aLc\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https:\/\/www.youtube.com\/embed\/43XaZEn2aLc?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen title=\"On the Expressive Power of Programming Languages by Shriram Krishnamurthi [PWLConf 2019]\"><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "id": 1,
                "original_url": "https:\/\/m.youtube.com\/watch?v=43XaZEn2aLc",
                "fallback": "YouTube Video: On the Expressive Power of Programming Languages by Shriram Krishnamurthi [PWLConf 2019]",
                "title": "On the Expressive Power of Programming Languages by Shriram Krishnamurthi [PWLConf 2019]",
                "title_link": "https:\/\/m.youtube.com\/watch?v=43XaZEn2aLc",
                "author_name": "PapersWeLove",
                "author_link": "https:\/\/www.youtube.com\/@PapersWeLove",
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FRY1o",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A related paper on the topic; “On the Expressive Power of Programming Languages” by Matthias Felleisen (1990)\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/citeseerx.ist.psu.edu\/doc\/10.1.1.51.4656",
                                "text": "https:\/\/citeseerx.ist.psu.edu\/doc\/10.1.1.51.4656"
                            },
                            {
                                "type": "text",
                                "text": "\n\nSummary of the paper:\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/m.youtube.com\/watch?v=43XaZEn2aLc",
                                "text": "https:\/\/m.youtube.com\/watch?v=43XaZEn2aLc"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UK3LH8CF5",
        "type": "message",
        "ts": "1689686006.386839",
        "client_msg_id": "50158e84-9e02-4b28-8f45-a793223bc7c0",
        "text": "Yep, that's the paper I brought up in the episode. I find that definition very unsatisfying because it isn't about the end-user, it is about the computer. I mean, the definition is incredibly clever. But it is a formal definition to something I don't think will be captured by a formal definition. As is evidence by this thread, we can often mean many different things by expressivity. I think there are ways to capture those uses, but it won't be by a formal property that holds in the programming language. It will be in the same way we can explore things like free will, gender, knowledge, etc.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "z4u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yep, that's the paper I brought up in the episode. I find that definition very unsatisfying because it isn't about the end-user, it is about the computer. I mean, the definition is incredibly clever. But it is a formal definition to something I don't think will be captured by a formal definition. As is evidence by this thread, we can often mean many different things by expressivity. I think there are ways to capture those uses, but it won't be by a formal property that holds in the programming language. It will be in the same way we can explore things like free will, gender, knowledge, etc."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1689690710.666009",
        "client_msg_id": "7293dadf-cabf-4eb5-8a84-5c9ed215a8f1",
        "text": "I think it's a useful aspect of expressiveness. And I disagree that it's \"not about the end-user\". TBH I'm only going by the video, but he gives some examples in the Q&amp;A where it's really clear how end users are affected. Any rigorous theoretical definition of a vague intuitive idea is going to look distant from that intuition until you follow the consequences and see how they line up. You probably aren't explicitly thinking about the set of all possible contexts for a piece of code when you try to understand it, but you're still feeling their effects.\n\nI agree we're unlikely to get a complete rigorous definition, but I don't think we should surrender to the extent of comparing expressivity to free will, et al. The formal rigor of the computer is intrinsic to the subjective experience of programming, so it should definitely be possible for formal results about computers to help understand that experience.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wqIZO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think it's a useful aspect of expressiveness. And I disagree that it's \"not about the end-user\". TBH I'm only going by the video, but he gives some examples in the Q&A where it's really clear how end users are affected. Any rigorous theoretical definition of a vague intuitive idea is going to look distant from that intuition until you follow the consequences and see how they line up. You probably aren't explicitly thinking about the set of all possible contexts for a piece of code when you try to understand it, but you're still feeling their effects.\n\nI agree we're unlikely to get a complete rigorous definition, but I don't think we should surrender to the extent of comparing expressivity to free will, et al. The formal rigor of the computer is intrinsic to the subjective experience of programming, so it should definitely be possible for formal results about computers to help understand that experience."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UK3LH8CF5",
        "type": "message",
        "ts": "1689692447.496359",
        "client_msg_id": "A89C2803-40E3-40BA-A9A5-F2B141B9B1E1",
        "text": "Yeah it definitely has effects on the end user. But it isn’t about the end user. An programmer can find something to be more expressive and yet it fail to meet this definition. I don’t think the definition gives us any reason to think we are wrong that something is more expressive just because it doesn’t change halting behavior. \n\nBeing able to draw the transformations of a red black tree graphically rather than textually for example is a more expressive way of specifying that computation. But it clearly isn’t by this definition. \n\nThe definition fails to capture at least my intuition about expressiveness. Because expressiveness isn’t about the computer, it’s about people. ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LPcYi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah it definitely has effects on the end user. But it isn’t about the end user. An programmer can find something to be more expressive and yet it fail to meet this definition. I don’t think the definition gives us any reason to think we are wrong that something is more expressive just because it doesn’t change halting behavior. \n\nBeing able to draw the transformations of a red black tree graphically rather than textually for example is a more expressive way of specifying that computation"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " But it clearly "
                            },
                            {
                                "type": "text",
                                "text": "isn’t"
                            },
                            {
                                "type": "text",
                                "text": " by this definition"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " \n\nThe definition fails to capture at least my intuition about expressiveness"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " Because expressiveness "
                            },
                            {
                                "type": "text",
                                "text": "isn’t"
                            },
                            {
                                "type": "text",
                                "text": " about the computer, "
                            },
                            {
                                "type": "text",
                                "text": "it’s"
                            },
                            {
                                "type": "text",
                                "text": " about people"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03LJBR6THT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1689694485.198489",
        "client_msg_id": "657fffe2-411a-42bf-b264-8ce66e74a324",
        "text": "I have been playing with the -0613 OpenAI models, which have festures to be forced to return JSON that adheres to a provided schema, and it has been working well, so far. Even when dealing with relatively complicated schema and relatively complicated requests. So limiting it to function-like inputs and outputs feels like asking too little of the model per call. But then again, other models may not be as good at it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689369045.712599",
        "parent_user_id": "U05GSC0B4A0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t\/j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have been playing with the -0613 OpenAI models, which have festures to be forced to return JSON that adheres to a provided schema, and it has been working well, so far. Even when dealing with relatively complicated schema and relatively complicated requests. So limiting it to function-like inputs and outputs feels like asking too little of the model per call. But then again, other models may not be as good at it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1689697348.623959",
        "client_msg_id": "8246e439-a3d0-4e99-a2c2-7d454f1e5aae",
        "text": "I certainly agree it's a mistake to treat it as the full story. I think I was fairly clear about that. (But don't forget that \"halting\" in PL theory is mainly a tractable proxy for lots of directly user-relevant complications.)\n\nI strongly disagree that a visual representation of a red-black tree transformation is more expressive than a textual one _in the same sense_ that a language with higher order functions is more expressive than one without. Even in end-user terms those are very different questions, and acting on the belief that they're the same will eventually lead to confusion. As with regex, the two representations of the tree transform are isomorphic; with the right tooling you could switch them with a toggle, \"expressing\" them with no human involvement at all. You and I could keep our editors on different settings and still work together on the underlying structure.\n\nI look at it this way: the notion of the ability of a language to express different programs as a function of basically its abstract syntax and semantics exists and needs a name. \"Expressivity\" already means pretty much that in academia, as far as I can tell anyway. Different serializations of the same abstract syntax (visual, textual, morse code) definitely do have effects on our squishy brains, making coding easier or harder, but they're easily localizable to a different part of the computing system. Different thing, different name.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l3848",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I certainly agree it's a mistake to treat it as the full story. I think I was fairly clear about that. (But don't forget that \"halting\" in PL theory is mainly a tractable proxy for lots of directly user-relevant complications.)\n\nI strongly disagree that a visual representation of a red-black tree transformation is more expressive than a textual one "
                            },
                            {
                                "type": "text",
                                "text": "in the same sense",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that a language with higher order functions is more expressive than one without. Even in end-user terms those are very different questions, and acting on the belief that they're the same will eventually lead to confusion. As with regex, the two representations of the tree transform are isomorphic; with the right tooling you could switch them with a toggle, \"expressing\" them with no human involvement at all. You and I could keep our editors on different settings and still work together on the underlying structure.\n\nI look at it this way: the notion of the ability of a language to express different programs as a function of basically its abstract syntax and semantics exists and needs a name. \"Expressivity\" already means pretty much that in academia, as far as I can tell anyway. Different serializations of the same abstract syntax (visual, textual, morse code) definitely do have effects on our squishy brains, making coding easier or harder, but they're easily localizable to a different part of the computing system. Different thing, different name."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U03LJBR6THT",
        "type": "message",
        "ts": "1689706884.779879",
        "client_msg_id": "2f3cc681-31bf-4515-b807-f167a3bbd328",
        "text": "The two interpretations of \"expressive\" are not completely separate in that, multiple representation of a program may allow for new kinds of program that would otherwise be unmaintainable &amp; such few programmers would choose to express such ideas in its textual representation.\n\nGiven that even complex semantics like generator functions in javascript used to be implemented in typescript for older browsers using arcane set of pre-es5 trickery.. the pattern would not be used by most pre syntax, but the new representation allows now a whole set of new very well maintainable programs in new ways.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0afa5db0b2d5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-07-06\/5524013698279_0afa5db0b2d593650747_72.jpg",
            "first_name": "Marcelle",
            "real_name": "Marcelle Rusu",
            "display_name": "Marcelle Rusu",
            "team": "T5TCAFTA9",
            "name": "marcelrusu0",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/wl3f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The two interpretations of \"expressive\" are not completely separate in that, multiple representation of a program may allow for new kinds of program that would otherwise be unmaintainable & such few programmers would choose to express such ideas in its textual representation.\n\nGiven that even complex semantics like generator functions in javascript used to be implemented in typescript for older browsers using arcane set of pre-es5 trickery.. the pattern would not be used by most pre syntax, but the new representation allows now a whole set of new very well maintainable programs in new ways."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U03LJBR6THT",
        "type": "message",
        "ts": "1689706998.246149",
        "edited": {
            "user": "U03LJBR6THT",
            "ts": "1689707022.000000"
        },
        "client_msg_id": "353f8273-2ead-415e-bdbe-701ef58ee501",
        "text": "Not as an extreme example, but I often found when programming state machines in the javascript library \"xstate\" I reached for their visual editor for debugging &amp; thinking bigger.\n\nI would not have created all the state machines I did without it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0afa5db0b2d5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-07-06\/5524013698279_0afa5db0b2d593650747_72.jpg",
            "first_name": "Marcelle",
            "real_name": "Marcelle Rusu",
            "display_name": "Marcelle Rusu",
            "team": "T5TCAFTA9",
            "name": "marcelrusu0",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n9t",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not as an extreme example, but I often found when programming state machines in the javascript library \"xstate\" I reached for their visual editor for debugging & thinking bigger.\n\nI would not have created all the state machines I did without it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1689708564.446159",
        "client_msg_id": "680375b6-fb72-44ad-95b6-1305c1fa92ef",
        "text": "Generators are an excellent example of structural expressivity. The code you write with them is quite differently shaped, and compiling to generator-free code requires global transformations.\n\nI don't have a ton of experience with xstate, but I do recall the code interface being fairly clunky. It's easy for me to believe that a visual interface could be genuinely simpler for the same functionality. That would fit in with the desugaring style of expressivity improvements, less drastic than e.g. generators or HOFs, but significant in their own way. Anyway, not isomorphic, I'm guessing? The abstract syntax tree (graph?) probably has fewer nodes.\n\nIn a similar vein, I'd suggest that NFAs and regex are more expressive due to their concision than full DFAs, despite being at the same level of the Chomsky hierarchy.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lgpv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Generators are an excellent example of structural expressivity. The code you write with them is quite differently shaped, and compiling to generator-free code requires global transformations.\n\nI don't have a ton of experience with xstate, but I do recall the code interface being fairly clunky. It's easy for me to believe that a visual interface could be genuinely simpler for the same functionality. That would fit in with the desugaring style of expressivity improvements, less drastic than e.g. generators or HOFs, but significant in their own way. Anyway, not isomorphic, I'm guessing? The abstract syntax tree (graph?) probably has fewer nodes.\n\nIn a similar vein, I'd suggest that NFAs and regex are more expressive due to their concision than full DFAs, despite being at the same level of the Chomsky hierarchy."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UK3LH8CF5",
        "type": "message",
        "ts": "1689711216.445119",
        "client_msg_id": "76daa05c-34b4-4f15-a045-ad56f0051f48",
        "text": "&gt; I strongly disagree that a visual representation of a red-black tree transformation is more expressive than a textual one in the same sense that a language with higher order functions is more expressive than one without.\n&gt; I look at it this way: the notion of the ability of a language to express different programs as a function of basically its abstract syntax and semantics exists and needs a name. \"Expressivity\" already means pretty much that in academia, as far as I can tell anyway. Different serializations of the same abstract syntax (visual, textual, morse code) definitely do have effects on our squishy brains, making coding easier or harder, but they're easily localizable to a different part of the computing system. \n&gt; Different thing, different name.\nI don't see any reason to privilege one of these as expressivity vs the other. Nor do I think they are clearly distinct concepts. They definitely do not form a natural kind and how we decide to divide them up is going to be based on our concerns and desires. Personally, I think it is good to call both of these things (and some others) expressivity because it causes us to look holistically at the way in which we express ourselves in programs. That to me is what expressivity about, how does this language help and hinder me from expressing things the way I want to express them.\n\nYou might not want to call that expressivity for your purposes. I think that's totally fine.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DSDO",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I strongly disagree that a visual representation of a red-black tree transformation is more expressive than a textual one in the same sense that a language with higher order functions is more expressive than one without."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I look at it this way: the notion of the ability of a language to express different programs as a function of basically its abstract syntax and semantics exists and needs a name. \"Expressivity\" already means pretty much that in academia, as far as I can tell anyway. Different serializations of the same abstract syntax (visual, textual, morse code) definitely do have effects on our squishy brains, making coding easier or harder, but they're easily localizable to a different part of the computing system. "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Different thing, different name."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI don't see any reason to privilege one of these as expressivity vs the other. Nor do I think they are clearly distinct concepts. They definitely do not form a natural kind and how we decide to divide them up is going to be based on our concerns and desires. Personally, I think it is good to call both of these things (and some others) expressivity because it causes us to look holistically at the way in which we express ourselves in programs. That to me is what expressivity about, how does this language help and hinder me from expressing things the way I want to express them.\n\nYou might not want to call that expressivity for your purposes. I think that's totally fine."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1689716161.587319",
        "client_msg_id": "205d4ce9-dd78-4679-964b-a09794d2f8ae",
        "text": "If possibilities for easily reversible transformations of structures don't seem like a different natural kind than possibilities for whole new kinds of structures, then I guess we have irreconcilable differences in what we consider a natural kind. Granted, there are also other ways you could reasonably slice the space, but I'm very certain that's one of them.\n\nAs for privileging one over the other: Certainly to each their own, but I believe, and this seems to be a well-accepted principle ranging from physical engineering to social organization, that you should pay more attention to (and solve earlier) decisions that are harder to change later. This does not apply _super_ rigorously to PL design, but it suggests to me that the choice of structures that affect the architecture of programs, the stdlib conventions, etc, are higher priority for thinking about than, e.g. sexprs vs ML-ish syntax vs something visual. (Especially if part of your goal is to efficiently support arbitrary representations anyway.)\n\nWhich is not to say that no one should work on the representation side; by that logic no one would ever work on anything but disease research and agriculture or some nonsense. And as I've agreed repeatedly (since my first post in this thread), nothing has the whole story on the intuition of expressivity. But I think the structural aspect of expressivity, if you insist on specifying it so, has higher practical leverage than the representational.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689118227.745139",
        "parent_user_id": "U05597GCDDK",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YoJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If possibilities for easily reversible transformations of structures don't seem like a different natural kind than possibilities for whole new kinds of structures, then I guess we have irreconcilable differences in what we consider a natural kind. Granted, there are also other ways you could reasonably slice the space, but I'm very certain that's one of them.\n\nAs for privileging one over the other: Certainly to each their own, but I believe, and this seems to be a well-accepted principle ranging from physical engineering to social organization, that you should pay more attention to (and solve earlier) decisions that are harder to change later. This does not apply "
                            },
                            {
                                "type": "text",
                                "text": "super",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " rigorously to PL design, but it suggests to me that the choice of structures that affect the architecture of programs, the stdlib conventions, etc, are higher priority for thinking about than, e.g. sexprs vs ML-ish syntax vs something visual. (Especially if part of your goal is to efficiently support arbitrary representations anyway.)\n\nWhich is not to say that no one should work on the representation side; by that logic no one would ever work on anything but disease research and agriculture or some nonsense. And as I've agreed repeatedly (since my first post in this thread), nothing has the whole story on the intuition of expressivity. But I think the structural aspect of expressivity, if you insist on specifying it so, has higher practical leverage than the representational."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UK3LH8CF5"
                ],
                "count": 1
            }
        ]
    },
    {
        "text": "The default behaviour for a validated text field in Blockly is to turn the background red while the value is invalid, and if the user hits enter (or nvaigates away from the field) while the field is red, abandon the change and return the field to the previous value. This feels broken to me. In the visual interface, if you try to put something somewhere and it doesn't \"fit\", the piece doesn't go back where it started. It stays close to where you tried to put it, but far enough away to visually indicate that it isn't connected. So you get immediate feedback that it didn't work, and what was done instead. But in the text field, if I have \"value\" and I change it to \"value$\", and the dollar sign is invalid, the field will only turn red between when I hit dollarsign and when I hit enter, and then it will go back to the previous value, and just hope I notice that it didn't do what I wanted it to do. For people who look at the keys while typing, that's not going to work. Blockly steadfastly tries to avoid invalid state, presumably because syntax errors aren't any fun. But in the visual interface it accomplishes that by making invalid syntax impossible to generate, and when it modifies the syntax for you to keep it valid, that's easy to see. Here, it lets you type an invalid value, let's you hit enter, and the fact it didn't work is potentially invisible. It feels like it should be possible to do better. Has anyone seen an interface for entering values into a text field that solves this problem? Where the field maintains a valid value, starting with a default, but it also allows you to maintain a view on failed attempts to modify it, so that you can correct them? Should the screen just go modal, not responding to \"enter\" or clicks outside the editor while the value is invalid? Should the failed attempt to change it be noted somewhere? Or is maintaining valid state in text fields a silly goal, and instead you should just throw errors at a later step, or something?",
        "files": [
            {
                "id": "F05J1G26QPK",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "U02U0AS3J49",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pDO5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The default behaviour for a validated text field in Blockly is to turn the background red while the value is invalid, and if the user hits enter (or nvaigates away from the field) while the field is red, abandon the change and return the field to the previous value. This feels broken to me. In the visual interface, if you try to put something somewhere and it doesn't \"fit\", the piece doesn't go back where it started. It stays close to where you tried to put it, but far enough away to visually indicate that it isn't connected. So you get immediate feedback that it didn't work, and what was done instead. But in the text field, if I have \"value\" and I change it to \"value$\", and the dollar sign is invalid, the field will only turn red between when I hit dollarsign and when I hit enter, and then it will go back to the previous value, and just hope I notice that it didn't do what I wanted it to do. For people who look at the keys while typing, that's not going to work. Blockly steadfastly tries to avoid invalid state, presumably because syntax errors aren't any fun. But in the visual interface it accomplishes that by making invalid syntax impossible to generate, and when it modifies the syntax for you to keep it valid, that's easy to see. Here, it lets you type an invalid value, let's you hit enter, and the fact it didn't work is potentially invisible. It feels like it should be possible to do better. Has anyone seen an interface for entering values into a text field that solves this problem? Where the field maintains a valid value, starting with a default, but it also allows you to maintain a view on failed attempts to modify it, so that you can correct them? Should the screen just go modal, not responding to \"enter\" or clicks outside the editor while the value is invalid? Should the failed attempt to change it be noted somewhere? Or is maintaining valid state in text fields a silly goal, and instead you should just throw errors at a later step, or something?"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1689725958.912849",
        "client_msg_id": "5c18c7c0-5047-4d30-87a4-9a32a54d7bd4",
        "thread_ts": "1689725958.912849",
        "reply_count": 6,
        "reply_users_count": 5,
        "latest_reply": "1689791675.832219",
        "reply_users": [
            "U016VUZGUUQ",
            "U02U0AS3J49",
            "U02028JHX37",
            "UDQBTJ211",
            "UA14TGLTC"
        ],
        "replies": [
            {
                "user": "U016VUZGUUQ",
                "ts": "1689733281.716799"
            },
            {
                "user": "U02U0AS3J49",
                "ts": "1689738491.241629"
            },
            {
                "user": "U02028JHX37",
                "ts": "1689748756.223389"
            },
            {
                "user": "UDQBTJ211",
                "ts": "1689786109.088269"
            },
            {
                "user": "U02U0AS3J49",
                "ts": "1689786833.098369"
            },
            {
                "user": "UA14TGLTC",
                "ts": "1689791675.832219"
            }
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1689733281.716799",
        "client_msg_id": "9ee72b4f-6944-46ba-a373-ad71b561f9e5",
        "text": "A couple ideas, possibly combinable: text field stays red indefinitely, blocking any attempts at running or inferring from the program (I forget what the right term is in your project); I guess this is basically \"throw errors later\", but with a more deliberate focus on showing the reason for the error. Other idea: each text field stores both the last user input, possibly invalid, (\"draft\"?) and the last valid, active value, with really clear UI about what text is currently active: probably invalid draft text off to the side in red. Or possibly a \"restore 'my previous valid text'\" operation if you go the throw-errors path.\n\nI think it's really important not to casually throw away user input even if it's invalid. It might contain a pretty significant bit of work (e.g. digging through an obtuse document for the exact right term) that's only slightly invalid, e.g. only typo'd. And if the user trusts the computer to remember it, they're liable to completely flush it from their mind until they come back later to an error message or mysterious reversion to the old value, whereupon they feel both frustrated and betrayed. :melting_face: (I think I'm preaching to the choir here, just had to vent dredged-up memories of frustrating software)\n\nI think a modal _dialog_, front and center on the screen, might be ok, albeit clunky. But just stopping responding to clicks elsewhere is exactly the kind of interaction that gives modal interfaces a bad name. The scenario when this whole thing is a problem is when the user's locus of attention moves away \"prematurely\", which is the exact reason they'll be confused and frustrated when the rest of the UI \"freezes\".",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689725958.912849",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EOSS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A couple ideas, possibly combinable: text field stays red indefinitely, blocking any attempts at running or inferring from the program (I forget what the right term is in your project); I guess this is basically \"throw errors later\", but with a more deliberate focus on showing the reason for the error. Other idea: each text field stores both the last user input, possibly invalid, (\"draft\"?) and the last valid, active value, with really clear UI about what text is currently active: probably invalid draft text off to the side in red. Or possibly a \"restore 'my previous valid text'\" operation if you go the throw-errors path.\n\nI think it's really important not to casually throw away user input even if it's invalid. It might contain a pretty significant bit of work (e.g. digging through an obtuse document for the exact right term) that's only slightly invalid, e.g. only typo'd. And if the user trusts the computer to remember it, they're liable to completely flush it from their mind until they come back later to an error message or mysterious reversion to the old value, whereupon they feel both frustrated and betrayed. "
                            },
                            {
                                "type": "emoji",
                                "name": "melting_face",
                                "unicode": "1fae0"
                            },
                            {
                                "type": "text",
                                "text": " (I think I'm preaching to the choir here, just had to vent dredged-up memories of frustrating software)\n\nI think a modal "
                            },
                            {
                                "type": "text",
                                "text": "dialog",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", front and center on the screen, might be ok, albeit clunky. But just stopping responding to clicks elsewhere is exactly the kind of interaction that gives modal interfaces a bad name. The scenario when this whole thing is a problem is when the user's locus of attention moves away \"prematurely\", which is the exact reason they'll be confused and frustrated when the rest of the UI \"freezes\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "dart",
                "users": [
                    "U02QC0PPER3"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1689738491.241629",
        "client_msg_id": "f97c7717-4896-424d-9ece-a1731a6da251",
        "text": "So user hits enter or navigates away while invalid, a modal dialogue pops up with value, OK, Cancel, but OK is greyed out while the value is invalid, the invalid new text is in the dialog, the validity requirements are displayed, the prior valid value is displayed next to the cancel button. Something like that? I'm also imagining a \"current value\" non-editable element, and a usually hidden \"set to\" element that hides when it succeeds or is cancelled, stays visible otherwise. Not sure what that would look like, but it wouldn't require you to solve the validity problem first, which seems like an improvement.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689725958.912849",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tt9=0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So user hits enter or navigates away while invalid, a modal dialogue pops up with value, OK, Cancel, but OK is greyed out while the value is invalid, the invalid new text is in the dialog, the validity requirements are displayed, the prior valid value is displayed next to the cancel button. Something like that? I'm also imagining a \"current value\" non-editable element, and a usually hidden \"set to\" element that hides when it succeeds or is cancelled, stays visible otherwise. Not sure what that would look like, but it wouldn't require you to solve the validity problem first, which seems like an improvement."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02028JHX37",
        "type": "message",
        "ts": "1689748756.223389",
        "client_msg_id": "2ee095ff-8a09-4547-9163-a8060f98c660",
        "text": "I think it would be interesting if the invalid string split into a separate red-highlighted \"string block\", lying near the text field (which retains the old valid value).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gdf13e3ce9df",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/df13e3ce9dfc39e2f387bd3d6e87b952.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0016-72.png",
            "first_name": "",
            "real_name": "Jan Ruzicka",
            "display_name": "Jan Ruzicka",
            "team": "T5TCAFTA9",
            "name": "jan.ruzicka01",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1689725958.912849",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/N8AV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think it would be interesting if the invalid string split into a separate red-highlighted \"string block\", lying near the text field (which retains the old valid value)."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]