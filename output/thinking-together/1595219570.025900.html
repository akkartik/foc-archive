<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/a47904aa9b4359ffea837d58cd82cfb0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ricardo Medina</b>
<span style="margin:2em; color:#606060">2020-07-19 21:32</span><br/>
Probably asked before but, what is your go-to tool for the implementation of a language prototype in terms of parsing, compiling, etc? Language, library, generator...?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595219950.027400"></a>
      <img src="https://avatars.slack-edge.com/2020-02-05/941640103046_9cb6f99c1d4661569649_72.jpg" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595219950.027400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chet Corcos</b>
<span style="margin:2em; color:#606060">2020-07-19 21:39</span><br/>
For me, prototype = typescript. Parsimmon is a great parsing library to start with. Or if you feel fancy you can check out ohm which is a compiler-compiler. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595219972.027700"></a>
      <img src="https://avatars.slack-edge.com/2020-02-05/941640103046_9cb6f99c1d4661569649_72.jpg" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595219972.027700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chet Corcos</b>
<span style="margin:2em; color:#606060">2020-07-19 21:39</span><br/>
<a href="https://github.com/harc/ohm">https://github.com/harc/ohm</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595220048.028900"></a>
      <img src="https://avatars.slack-edge.com/2020-02-05/941640103046_9cb6f99c1d4661569649_72.jpg" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595220048.028900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chet Corcos</b>
<span style="margin:2em; color:#606060">2020-07-19 21:40</span><br/>
Meta 2 is a really cool paper about compiler-compilers btw. Here’s a nice overview: <a href="https://youtu.be/L1rwVBLHGiU">https://youtu.be/L1rwVBLHGiU</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595222597.029500"></a>
      <img src="https://secure.gravatar.com/avatar/aa31b79adedc3f60547769f1a8971ba6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595222597.029500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Emmanuel Oga</b>
<span style="margin:2em; color:#606060">2020-07-19 22:23</span><br/>
I think I'll try instaparse for my next experiment <a href="https://github.com/Engelberg/instaparse">https://github.com/Engelberg/instaparse</a> and <a href="https://github.com/noprompt/meander">https://github.com/noprompt/meander</a> to manipulate the parse tree
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595222683.029900"></a>
      <img src="https://secure.gravatar.com/avatar/aa31b79adedc3f60547769f1a8971ba6.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595222683.029900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Emmanuel Oga</b>
<span style="margin:2em; color:#606060">2020-07-19 22:24</span><br/>
If you are not sure about clojure for language implementation this talk might be interesting for you: <a href="https://www.youtube.com/watch?v=t8usj1fN9rs">https://www.youtube.com/watch?v=t8usj1fN9rs</a> (since strictly typed languages are often considered "the best" for compiler work)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595228708.034300"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595228708.034300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-07-20 00:05</span><br/>
I’ve found this library useful in the past, especially for quick parsing tasks. <a href="https://github.com/orangeduck/mpc">https://github.com/orangeduck/mpc</a><br/>Last time I did a language, I rolled my own tokenizer and lexer.  I find things easier to understand that way.  I know that Jonathan Blow’s Jai language uses the same hand rolled approach.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595229509.034600"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595229509.034600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2020-07-20 00:18</span><br/>
It has the nice feature of being able to just pass a grammar to the library, and it builds the parser combinators.  Very quick and easy.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595230411.034800"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595230411.034800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2020-07-20 00:33</span><br/>
I find the question a bit underspecified, as which tools one might choose will hinge on both the specifics of what one is building and a variety of personal preferences. In my case, I like languages/environments that allow me to develop new semantics from within them, only worrying about adding syntactic affordances later. If one prefers that approach, it's hard to beat <a href="https://racket-lang.org">https://racket-lang.org</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595234281.036100"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595234281.036100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2020-07-20 01:38</span><br/>
I use the compiler tools from erlang, leex, yecc, absform and the compiler module
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595236571.036800"></a>
      <img src="https://secure.gravatar.com/avatar/cf29e340a09ac08ae262632ef9101046.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595236571.036800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ian Rumac</b>
<span style="margin:2em; color:#606060">2020-07-20 02:16</span><br/>
I just use kotlin and wrote my own parser, the language feels so nice and expressive that I just keep coming back to it for everything.<br/>Basically just find special tokens, create a index of [position, token], then recursively parse it breadth first. tho it isn’t a complete “language”, but a DSL language so it’s easier than full on lang :)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595236697.037100"></a>
      <img src="https://secure.gravatar.com/avatar/cf29e340a09ac08ae262632ef9101046.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595236697.037100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ian Rumac</b>
<span style="margin:2em; color:#606060">2020-07-20 02:18</span><br/>
and weird, nobody mentioned ANTLR yet
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1595265341.054500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1595219570.025900.html#1595265341.054500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-07-20 10:15</span><br/>
I hand rolled the lexer and parser for Curv in C++, because I didn't want to fight tool limitations in defining the syntax or implementing error recovery. In retrospect,<br/>• A regex-based scanner generator like re2c would have made the scanner easier to write.<br/>• My hand-written recursive descent parser was easy to write and continues to be easy to modify. No regrets.<br/>• After hanging out in FoC for a year, I have IDE envy. To properly implement completions and hints, I need an incremental parser. So maybe I should switch to the tree-sitter parser generator?  <a href="https://github.com/tree-sitter/tree-sitter">https://github.com/tree-sitter/tree-sitter</a><br/>• For me, the hard part is the back end, not the parser/lexical analyser. What are the libraries/DSLs for semantic analysis, optimization and code generation?
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
