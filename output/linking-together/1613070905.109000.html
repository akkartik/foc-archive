<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 11:15</span><br/>
this was so refreshing to read: <a href="https://litestream.io/blog/why-i-built-litestream/">https://litestream.io/blog/why-i-built-litestream/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613072679.109800"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613072679.109800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 11:44</span><br/>
This echos my philosophy as well - almost no one is building a system that really requires more than one machine. The belief that we are has caused us to add so much incidental cruft that if you use industry best practices, you actually <em>do</em> need multiple machines. Taking an extreme example, the entire write load of twitter is only ~6k tweets/s, which can easily fit on a single machine. As another, there’s a great paper from the hyper folks that showed you could serve <a href="http://www.vldb.org/pvldb/vol10/p1921-schuele.pdf">all of the queries to wikipedia from a single instance</a>. If you use them well, computers are insanely fast. The problem is just that we use them really poorly and because of the incentives around software, we’re more likely to go with our first poor solution to a problem than taking the time to come to a good one. This is how we ended up with things like Hadoop which are millions of lines of code to run 100+ node clusters that <a href="https://blog.acolyer.org/2015/06/05/scalability-but-at-what-cost/">can’t beat a laptop</a>.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074498.110100"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074498.110100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:14</span><br/>
<b>oh boy, this hits ^</b> 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074538.110300"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074538.110300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:15</span><br/>
yeah theres a lot to be said here… I think the move fast / startup mindset of building “just enough” software quickly / inefficiently until the next set of scale hits (and new set of engineers can wrangle the PGbouncer ) has been the modus operandi
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074561.110500"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074561.110500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:16</span><br/>
the counter to this thinking is Jonathan Blow (and others like ALan Kay ofc).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074580.110700"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074580.110700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:16</span><br/>
Crave Cookie runs on Crystal + sqlite, &lt;$300 a month: <a href="https://www.indiehackers.com/podcast/166-sam-eaton-of-crave-cookie">https://www.indiehackers.com/podcast/166-sam-eaton-of-crave-cookie</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074596.110900"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074596.110900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:16</span><br/>
but this requires a slower, artisan attitude. Which is unfortunate…
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074615.111200"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074615.111200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:16</span><br/>
I’m more on the data science side of things, and the layers of abstraction I keep encountering there is absolutely bonkers.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074681.111500"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074681.111500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 12:18</span><br/>
Yeah, the problem is that “fixing” this would require a whole lot of unlearning and re-education, which just isn’t likely to happen
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074684.111700"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074684.111700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:18</span><br/>
TL;DR my take is that systems software engineering is just software engineering turned into risk management
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074699.111900"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074699.111900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:18</span><br/>
yup
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074748.112100"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074748.112100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:19</span><br/>
ultimately, new inventions tailored to new use cases are probably the only way these types of things go away. E.g. you can’t build “the next Google” by replicating what Google does, but worse. You have to build the thing that replaces the need for <a href="http://Google.com">Google.com</a> with a different solution
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613074766.112300"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613074766.112300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:19</span><br/>
in many ways, true personal computing inventions could reduce the need for all this systems complexity (over time)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613075020.112700"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613075020.112700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 12:23</span><br/>
My hope is to flip the problem on its head and show that part of the problem is we didn’t actually go high level enough. Languages like python still let you specify too many details and those details are what prevent us from creating compilers that output extremely high performance programs by default. We can’t expect everyone to magically become great systems programmers, but giving them tools where a single integer add takes ~30 instructions is hell of a handicap to start with.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613075104.112900"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613075104.112900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 12:25</span><br/>
Chris Lattner’s (LLVM, Swift) thesis actually talks a bit about this and his attempt to try and create a layout aware compiler
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613075137.113100"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613075137.113100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 12:25</span><br/>
rather than trying to convince anyone to unlearn stuff though, something like better compilers seems like a much more likely path to success
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613075152.113300"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613075152.113300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 12:25</span><br/>
it has to just be the default somehow
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613075841.118500"></a>
      <img src="https://avatars.slack-edge.com/2022-01-31/3025191075606_a863c7a92962a53b14dd_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613075841.118500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Yousef El-Dardiry</b>
<span style="margin:2em; color:#606060">2021-02-11 12:37</span><br/>
Well put <span style="background-color:#ccf">@Chris Granger</span>  <span style="background-color:#ccf">@Srini K</span>. I think this is a general problem of software development, not just “systems engineering”. Too much focus on trends / hypes / frameworks, which causes overcomplicated solutions for even the simplest cases
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613076006.121400"></a>
      <img src="https://avatars.slack-edge.com/2022-01-31/3025191075606_a863c7a92962a53b14dd_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613076006.121400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Yousef El-Dardiry</b>
<span style="margin:2em; color:#606060">2021-02-11 12:40</span><br/>
Thinking out loud: A higher level language would be a solution, but should probably work across the stack in order to really reduce complexity of entire applications
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613076711.121700"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613076711.121700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-02-11 12:51</span><br/>
Fun related anecdote, the, original NASDAQ system ran on a single machine (using Java no less)! <a href="https://signalsandthreads.com/multicast-and-the-markets/#2923">https://signalsandthreads.com/multicast-and-the-markets/#2923</a><br/>It actually made things a lot easier for making sure transactions were correctly synchronized. Then you just had to make sure the network routed things well.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613076998.122100"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613076998.122100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 12:56</span><br/>
<span style="background-color:#ccf">@Yousef El-Dardiry</span> yeah, I think the key really is having system level understand-ability. Even if a language was higher level but the abstractions it was built on are leaky / shaky, you’re in for trouble. Arguably Ruby / Python are higher level in some specific ways but systems understanding is poorer (hence the need for systems engineering / risk management / server-wrangling)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613082733.122700"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613082733.122700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-02-11 14:32</span><br/>
<span style="background-color:#ccf">@Chris Granger</span><br/>&gt; My hope is to flip the problem on its head and show that part of the problem is we didn’t actually go high level enough. Languages like python still let you specify too many details and those details are what prevent us from creating compilers that output extremely high performance programs by default.<br/>This reminds me of the Haskell ethos a bit?<br/>A language designed to describe pure computation at an extremely high level, then let the compiler figure out efficient ways to run those computations. The language is so high level that it didn't support the very concept of side effects (causing them to invent/discover the monad...)<br/><br/>The result is that the GHC compiler truly is a marvel of modern engineering. But (devils advocate time), It took 30 years of the most advanced CS research to get here, and it still has extremely unpredictable performance gotchas in some places.<br/><br/>Maybe it's because I've been jaded by our current world, but I can't see "higher level" as a solution.<br/><br/>Mainly because "creating compilers that output extremely high performance programs by default" is actually a <b>really</b> hard problem for the general case. Part of the problem being: there is no single <em>general case.</em> <br/><br/><span style="background-color:#ccf">@Srini K</span> makes the point, a higher level language often results in poorer systems understanding, not greater. Or to put it another way, all abstractions are leaky eventually... How do you handle it when the leaks happen?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613082811.122900"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613082811.122900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:33</span><br/>
Haskell focused much more on things that are counter to what would make something understandable and fast, e.g. laziness.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083084.123100"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083084.123100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:38</span><br/>
There are a handful of patterns we know to have very good performance by default, the question is can we you create a language that can be compiled to those patterns and whose idioms feel natural to the user, such that you’re not constantly trying to go around them (side effects in haskell being a good example).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083115.123300"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083115.123300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:38</span><br/>
Another approach is to separate the specification from the layout ala relational DB world.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083254.123500"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083254.123500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:40</span><br/>
the logic of a program doesn’t <em>have</em> to bake in access paths, that’s just an artifact of the way our languages evolved. If we didn’t have pointers, arrays, etc, we could have the same kind of logical/physical independence.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083381.123900"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083381.123900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:43</span><br/>
A slightly less ambitious version of something like this is the DOTS effort in Unity, where following a relatively small set of conventions allows them to employ a specialized compiler to make your games <em>much</em> faster than what they were on the traditional stack.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083710.124100"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083710.124100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-02-11 14:48</span><br/>
First, I have to <b>fan boy</b> out a little. I followed Eve for a long time, and I'm a fan of your work. :smile: Thank you. It's an honor to argue on the internet with you :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083731.124300"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083731.124300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-02-11 14:48</span><br/>
ok back on topic:<br/>SIMD intrinsics / vectorization is another low level example of this sort of thing.<br/>I think it works great when the scope is limited.<br/>That's why I'm a fan of the "DSL" approach. Many tiny languages that are all good at different things but have a way to communicate.<br/>I don't want a swiss army knife, I want a tool box.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083811.124700"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083811.124700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:50</span><br/>
SIMD is actually a great example - it is <em>exceptionally</em> difficult to automatically vectorize because the semantics of most languages force your layout to be exactly as you described it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083910.124900"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083910.124900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:51</span><br/>
Imagine for a moment you had a compiler that could make layout choices based on the way data is actually used. E.g. in the case of something like a physics simulation where you’re constantly doing math over a series of objects with x, y, vx, vy, we could choose to store those as x[], y[], vx[], vy[]
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083915.125100"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083915.125100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:51</span><br/>
now vectorization is trivial
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613083991.125300"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613083991.125300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:53</span><br/>
(the reality of something like that is actually even more interesting, to go as fast you possibly could, you’d actually want to tile them as something like xxxx,yyyy,vxvxvxvx,vyvyvy for better cache utilization)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613084114.125500"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613084114.125500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:55</span><br/>
doing that everywhere would be nuts, it’s so much incidental bookkeeping that no one in their right mind would do that transformation across their whole system and our compilers have their hands tied because layout is explicitly part of the semantics of systems languages.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613084168.125700"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613084168.125700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:56</span><br/>
ideally you’d want something where you can mostly leave layout to the compiler, but provide a separate explicit specification of it if you really need to. (e.g. where layout has semantic meaning, like a tcp packet)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613084279.125900"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613084279.125900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-02-11 14:57</span><br/>
I see where you are heading. Something similar already happened for register allocation when we moved up from assembly language. You don't layout your own registers anymore. The compiler has fancy graph coloring algorithms that do it for you.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613084363.126100"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613084363.126100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 14:59</span><br/>
fwiw, I think the DSL approach is totally legit too and I would argue that there’s a pretty thin line between DSL and well architected library. The main issue you face going down the stable of languages route is that eventually you want to take something from your nice sound DSL and use it in your robot movement DSL - then what? How do you translate semantics across different languages? And can people internalize all the little differences between the two? Something like LISP is pretty close to that and the conventional wisdom quickly became “don’t use macros (the DSL creation feature) unless you absolutely have to.”
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613085090.126600"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613085090.126600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 15:11</span><br/>
Computational performance is such a fascinating topic to me and it took me a long time to realize that it’s actually much simpler in concept than I thought. To go fast, you just can’t do much stuff. All of those super fancy structures we’d read about in research papers? They were almost always slower because in the end the only cleverness that matters is the bit where the total amount of work you do is less. You were often saving 10% here and hiding an extra 20% over there without realizing it.<br/><br/>What makes the problem so difficult is that we hide a bunch of the work under abstractions that go all the way down to the computer arch. Realistically you can never account for all of that, but you’d do better than 99% of the code that’s out there if you had something that could give you better layouts.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613085146.126800"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613085146.126800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 15:12</span><br/>
so much of modern performance is bound to data movement
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613085548.127100"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613085548.127100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2021-02-11 15:19</span><br/>
That's a totally fair criticism against the DSL / zoo of languages approach. I don't have a good answer there either, just a personal preference :slightly_smiling_face:<br/><br/>I will point out that the "smart compiler" approach has limits as well.<br/><br/><a href="https://www.swansontec.com/sregisters.html">This article</a> is a bit specialized, but shows a practical example of automated where register allocation breaks down. Hardware engineers give preference to different registers for certain operations. It's hard to encode that into a modern compiler in an automatic way, t<a href="https://signalsandthreads.com/compiler-optimization/#004327">hough both Intel and ARM spend a lot of time and money attempting to do so</a>. They often get "good enough" but it's never "optimal". Which is fine, but the problem is, because they are heuristic based, there is usually some input program that produces a terrible layout that completely destroys the performance, and then it's hard to fix without breaking other things.<br/><br/>Computational performance is definitely a fascinating problem, with multiple approaches. :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613085768.127600"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613085768.127600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 15:22</span><br/>
Yeah, I think with something like layout it’s important that you can still manually specify it if you want. The problem with most automated approaches is that you can’t see into it or adjust it slightly without resorting to weird tricks like reordering completely unrelated things.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613085802.127800"></a>
      <img src="https://avatars.slack-edge.com/2018-11-25/487455880658_9e85c7bdd45b1d2d4721_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613085802.127800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Granger</b>
<span style="margin:2em; color:#606060">2021-02-11 15:23</span><br/>
This gets back to one of the biggest mental shifts we had after Eve which was that rather than focusing on simple, we should focus on “simple to understand”
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613088458.128200"></a>
      <img src="https://avatars.slack-edge.com/2021-10-09/2610495978720_72578ab3b4f8ab9ef250_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613088458.128200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Srini K</b>
<span style="margin:2em; color:#606060">2021-02-11 16:07</span><br/>
&gt;  Computational performance is such a fascinating topic to me and it took me a long time to realize that it’s actually much simpler in concept than I thought. To go fast, you just can’t do much stuff. All of those super fancy structures we’d read about in research papers? They were almost always slower because in the end the only cleverness that matters is the bit where the total amount of work you do is less. You were often saving 10% here and hiding an extra 20% over there without realizing it.<br/>This is a profound insight. I remember Jonthan Blow talking about just this in an older talk he gave: <a href="https://youtu.be/JjDsP5n2kSM?t=556">https://youtu.be/JjDsP5n2kSM?t=556</a> TL;DR lists are often fine! Start there, optimize only later / avoid premature optimization. <b>All data structures are fundamentally about optimization.</b><br/><br/>Fun story of him looking at DOOM source code when it came out how he was chewed out by John Romero when Blow said asset loading was done sub-optimally (back when he wasn’t enlightened!)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613212519.135900"></a>
      <img src="https://avatars.slack-edge.com/2021-01-30/1694828418931_9ff8c2de03dba11dab1d_72.jpg" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613212519.135900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Florian Cäsar</b>
<span style="margin:2em; color:#606060">2021-02-13 02:35</span><br/>
This is a really interesting topic. How does say Python fair here? It's the staple ingredient in most popular data science / machine learning oriented stacks. Most heavy computation is done indirectly via libraries who in turn call out to tightly optimized C++ or GPU code. On the plus side, that gives you the flexibility of a high level language to declaring your computational flow in with the heavy work done in optimized land. Of course, this also makes it a lot of "fun" if you want to customize / inject yourself into some part of the computation, since you need to drop down to Cython or so.<br/><br/>On a secondary note, what do you think of Blow's Jai language? <a href="https://inductive.no/jai/">Here</a>'s a some information on Jai for the unfimilar - basically, C++ "but better", intended for games but quite general.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1613216003.136800"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../linking-together/1613070905.109000.html#1613216003.136800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2021-02-13 03:33</span><br/>
"almost no one is building a system that really requires more than one machine" — have hundreds of billions of dollars of transactions to prove it.  Guess I'll retire after overseeing $1T.  We've always used one server — running Rails!  :wolf:  Except for that one time when had a calculation that needed parallelizing over a few hundred EC2 instances.  We used Redis.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
