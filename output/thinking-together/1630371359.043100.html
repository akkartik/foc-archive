<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2021-03-22/1871363334903_cbd558604a21b23211c3_72.png" style="float:left"/>
      <a href="../thinking-together/1630371359.043100.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Breck Yunits</b>
<span style="margin:2em; color:#606060">2021-08-30 17:55</span><br/>
Has anyone seen a study on "how a DSL becomes a GPL"? Or, alternatively, "what is the most common path travelers take before arriving at Greenspun's 10th rule?"<br/><br/>Is there something like "DSLS either die or eventually add identifiers, then functions, then branching, then macros, etc"? I'm curious if you can look ahead and say "well if this is successful, it will eventual require so many things, so might as well not do a DSL in the beginning and instead start with a GPL and build a library"
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1630396931.043400"></a>
      <img src="https://avatars.slack-edge.com/2021-07-07/2254853369060_d6900487d9109f495c79_72.jpg" style="float:left"/>
      <a href="../thinking-together/1630371359.043100.html#1630396931.043400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alexander Chichigin</b>
<span style="margin:2em; color:#606060">2021-08-31 01:02</span><br/>
I know only <a href="https://mikehadlow.blogspot.com/2012/05/configuration-complexity-clock.html">https://mikehadlow.blogspot.com/2012/05/configuration-complexity-clock.html</a> but that's not an actual study... :sweat_smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1630399048.043700"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1630371359.043100.html#1630399048.043700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2021-08-31 01:37</span><br/>
I've never seen it studied, but I've seen it happen over and over. This is why DSLs should be embedded in real programming languages.<br/><a href="https://twitter.com/jackrusher/status/1348645505811828737">https://twitter.com/jackrusher/status/1348645505811828737</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1630480313.044400"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1630371359.043100.html#1630480313.044400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-09-01 00:11</span><br/>
It's unfair that there is a :100: emoji but not one for 50% agreement!<br/><br/>My first question when choosing embedded vs. standalone for a DSL is: is the stuff that you encode using the DSL more like "code" or more like "data"? In the former case, go for embedded (for the reason <span style="background-color:#ccf">@Jack Rusher</span> gave). In the latter case, go for standalone in order to keep your data independent of a single language ecosystem, and thus more widely usable.<br/><br/>There is of course no clear borderline between code and data, all code being data from another point of view. But in the context of a specific domain, the choice is often obvious.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1630568392.044900"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1630371359.043100.html#1630568392.044900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2021-09-02 00:39</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> The line between code-like and data-like for me is whether or not the data will be interpreted (in the abstract interpreter sense) and thus encodes computation. If one is — for example — just writing a bunch of sensor readings from an experiment, one might as well do it as packed binary data frames. Whereas, if one is creating a specification/configuration language that includes constructs for things like conditionals and loops/recursion, it's already too late — just use scheme/Smalltalk/FORTH and be done with it. :blush:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1630573653.045200"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1630371359.043100.html#1630573653.045200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-09-02 02:07</span><br/>
Exactly. I thought a lot about this because my current project in DSL space is very much on the borderline. Leibniz (<a href="https://github.com/khinsen/leibniz-pharo">https://github.com/khinsen/leibniz-pharo</a>) is a domain-specific specification language, which does include conditionals etc. (it's a term rewriting system). But its reaon for existence is the documentation of computational models for humans, independently of any concrete implementation in code, so I ended up choosing the standalone approach explicitly to remove the temptation of the quick hack in whoever's favorite programming language of the day.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1630573743.045500"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1630371359.043100.html#1630573743.045500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-09-02 02:09</span><br/>
BTW, I do consider a schema for packed binary data frames a DSL, although I am not sure everybody would agree with that.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1631030080.120900"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1630371359.043100.html#1631030080.120900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2021-09-07 08:54</span><br/>
It all depends on intention, and it's worth being very conscious of one's intentions and drawing a hard line in one's mind between a configuration format and a DSL. The world is awash in configuration formats that slowly accumulated features and backed into Turing-completeness. A classic example is Apache configuration. Google Analytics is another one. YAML might also qualify, though I don't recall if they intended to make it Turing-complete from the start.<br/><br/>That's one advantage of embedding in a real language: no illusions. You can't slide down a slippery slope if you start at the bottom.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
