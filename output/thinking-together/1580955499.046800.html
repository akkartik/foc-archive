<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-08-03/5678948713014_729eecb0df1d998c9bcc_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Josh Cho</b>
<span style="margin:2em; color:#606060">2020-02-05 18:18</span><br/>
What are people’s opinions on Behavioral Programming?<br/><a href="https://youtu.be/cXuvCMG21Ss">https://youtu.be/cXuvCMG21Ss</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580966537.047400"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1580966537.047400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-02-05 21:22</span><br/>
There are several competing theories of how to look at programming. One theory is the actor model, which is a pure object oriented conception, from Hewitt i believe, and was embodied in various languages like smalltalk, where messages are passed. Other systems make explicit a finite state machine, and you have state transitions caused by various events. There are other approaches. But as Joe Armstrong pointed out in his talk with Hoare and Hewitt, at the reunion of the "3 old men", only his Erlang/Elixir system actually worked. The concept of having the agents track the state themselves leads to chaos; an almost impossible to debug system.  I think Luca's example of TicTacToe shows how it makes the game far harder to understand and prove correct than something much more conventional.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580967686.047600"></a>
      <img src="https://avatars.slack-edge.com/2019-12-12/870368572213_57dceb337de9d471d315_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1580967686.047600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Eddy Parkinson</b>
<span style="margin:2em; color:#606060">2020-02-05 21:41</span><br/>
"Who needs it today?" Paul Graham asks this question a lot. It helps you workout who the early adopters are.<br/><br/>This rather looks like an idea looking for a problem. Which sometimes works. But it can be hard to find early adopters if you start with an idea and then search for early adopters. Have a read of <a href="http://www.paulgraham.com/bronze.html">http://www.paulgraham.com/bronze.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581020217.049100"></a>
      <img src="https://avatars.slack-edge.com/2019-11-14/834114331988_5612322b81b6d142511b_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581020217.049100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Pezo - Zoltan Peto</b>
<span style="margin:2em; color:#606060">2020-02-06 12:16</span><br/>
I’ve checked some Conal Elliott videos on youtube and I’m a fan (but that’s for now). :smile: I try to use technologies which are conceptually closer: I’m learning cycle.js for “FRP” (it can be married with react.js). This (Stream based programming / “FRP” / real FRP) and Dependent Types are my 2 things I’d like to focus in the next years. I really believe they will help a lot and mainstream is just matter of time. (But sure, knowing a bit about this industry it can take a lot of time to be mainstream.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581023233.050100"></a>
      <img src="https://avatars.slack-edge.com/2023-08-03/5678948713014_729eecb0df1d998c9bcc_72.jpg" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581023233.050100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Josh Cho</b>
<span style="margin:2em; color:#606060">2020-02-06 13:07</span><br/>
<span style="background-color:#ccf">@Eddy Parkinson</span> Thanks, that was a very good read.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581065852.052000"></a>
      <img src="https://secure.gravatar.com/avatar/7cefc64f7b1b53513625bf3487ecd16d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581065852.052000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ionuț G. Stan</b>
<span style="margin:2em; color:#606060">2020-02-07 00:57</span><br/>
I've heard about behavioral programming while researching Harel's statecharts (which are themselves a nice idea). I'd like to try it out in a toy project, for the time being, since the idea of moving the immutability to the code base itself is tempting. That's how I see those bthreads as of now, as a means of implementing an immutable code base. Although, append-only better describes the situation.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581118402.053700"></a>
      <img src="https://secure.gravatar.com/avatar/80bf3c31da6a1f3f44e68bfe227fd35d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581118402.053700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>George Campbell</b>
<span style="margin:2em; color:#606060">2020-02-07 15:33</span><br/>
this reminds me of a project that I made where the program was parsing many different versions of an xml (it was a long time ago) file. I wrote the version 1 was a recursive decent parser class. Version N+1 extends N and override the parts of the AST that had changed. it ment that I didn’t break parsing of older messages. it did mean that i couldn’t deprecate the code old versions that weren’t used anymore. it made easy to see what changed from between versions.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581238268.054500"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2508698086192_565c54a4fa91a0c8c75a_72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581238268.054500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Lieber</b>
<span style="margin:2em; color:#606060">2020-02-09 00:51</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span><br/>&gt; … it makes the game far harder to understand and prove correct than something much more conventional.<br/><br/>This seems right at first glance, but I would want to learn more about the tooling before I agree. I still have only skimmed the linked papers, but the original authors rely on model-checking for various aspects of BP already, so I suspect proving correctness of tic-tac-toe is within reach.<br/><br/>As for understanding, well, if the idea that the event log is all that matters to understanding legacy code is true, then a tool that lets you manually or programmatically explore potential event logs might be even better than trying to find all the move validation code in a traditional code base. Certainly, if the way you understand a program is with event logs, that would make answering reachability questions like "what happens when 'X' tries to move" or "what can prevent an 'X' move" straight-forward. The answer to the first is a printout, and the answer to the second is some representation of "if it's preceded by an 'X' move."<br/><br/>I'm definitely imagining the best possible scenario, though. BP is on my reading list now, so perhaps I'll be brought back to earth soon. :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581288917.060400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581288917.060400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-09 14:55</span><br/>
<span style="background-color:#ccf">@Tom Lieber</span> It would be a great breakthrough if we discovered that decomposing problems into behaviors aided in creating verified models for them. I haven't seen this yet, but it seems worth exploring.<br/><br/>Also, you're right that BP can seem quite useful if you imagine the best possible scenario. But that doesn't seem how it's being sold. It seems to be sold as a methodogical silver bullet. Just use it and all problems become easy. If they instead said, "if used well it will help" I'd be much more amenable.<br/><br/><b>Exhibit A</b> <em>"What if we could make changes or understand how complex systems work without having to read and maintain an artifact."</em> (OP, 3:34) This seems wildly overblown. You still have to maintain the artifact. Especially if you want the desired model to be a linear/affine combination of the input behaviors. Because there are certainly many more combinations of behaviors that lead to spaghetti than not.<br/><br/>I had a conversation with Luca Matteis a month ago (<a href="https://twitter.com/lmatteis/status/1204862635537252352">https://twitter.com/lmatteis/status/1204862635537252352</a>) where we chatted a bit about my layers as compared to BP. I'm careful not to claim my layers always help. It takes taste to decompose programs into layers the right way. Even so, BP seems to lack one thing layers provide: intermediate combinations are useful, and functionality grows in a monotonic way. What happens to a BP program if you take out one behavior? Is it still legal? Easy to reason about? Useful? I haven't seen anybody answer these questions.<br/><br/><b>Exhibit B</b> Here's a less technical description of BP by the creator: <a href="http://www.wisdom.weizmann.ac.il/~harel/papers/LiberatingProgramming.pdf">http://www.wisdom.weizmann.ac.il/~harel/papers/LiberatingProgramming.pdf</a>. It seems <em>incredibly</em> overblown. We discussed it back in Dec 2018, but that's way beyond the visible window of this forum. Here's a comment I wrote there about it.<br/><br/>---<br/><br/>&gt; ...current methods for dealing with programming the dynamics of reactivity, however powerful and convenient, suffer from the same woes: We sit in front of a screen and write (or draw) programs that prescribe the behavior for each of the relevant parts of the system over time. Then we must check/test/verify that the combined behavior of all the parts satisfies a separately specified set of requirements or constraints. ... There is no need for separate specifications for the operational tasks and the requirements thereof. Anything that falls inside the total sum of what has been played-in will be a legal behavior of the system. <br/>I'm still wrapping my head around this vision, but I think it's ignoring the essential complexity of programming. On a fundamental level programmers deal with non-linear building blocks; interactions between constraints can be hard to imagine ahead of time. How would you gain confidence that you've "played-in" a project sufficiently to work out possible constraints?<br/><br/>Admittedly we have trouble doing this with existing systems. But surely we need to pay <em>more</em> attention to constraints, not less. Representing actions physically makes it more difficult to survey all actions entered so far, the scenarios they apply in, etc.<br/><br/>Check/test/verify is the <em>fundamental</em>, irreducible core of programming. Trying to eliminate it is a fool's errand.<br/><br/>LSC (the original Behavioral Programming system) introduces the notion of "play-in" to describe scenarios and how the system should react to them. So there'll be a natural tendency for the number of scenarios and handlers to grow. It's unclear to me how the opposite dynamic of <em>generalizing scenarios</em> happens. How does the system encourage noticing that two scenarios are special cases of a single one and may be coalesced? How does the programmer/user replace two played-in scenarios with a single new one? Without supporting this countervailing operation, the whole system will descend into monotonically complexifying spaghetti.<br/><br/>---<br/><br/>Based on this quote, I don't think BP started out envisioning model-checking. If they've since started to do so, I'd appreciate recent papers.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581289273.060800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581289273.060800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-09 15:01</span><br/>
There's an interesting connection betwen BP and <a href="http://people.csail.mit.edu/brooks/papers/AIM-864.pdf">http://people.csail.mit.edu/brooks/papers/AIM-864.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581289598.061000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581289598.061000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-09 15:06</span><br/>
Imperative programming is concerned with the order in which things happen.<br/><br/>Functional programming tries to make things as atemporal as possible, robust to multiple orderings of operations.<br/><br/>OP shows how to write unordered behaviors -- but rely on the operations happening in just the right order. (at time 9:30) I don't understand why this is a good thing! It seems to be the worst of both worlds. I still have to think about the order in which I want things to happen, but now I can't just describe the order directly. I have to arrange behaviors to make that order emergently occur. And now readers can't just read behaviors and understand their purpose. They have to <em>simulate</em> them to understand implications. Why is this an improvement on just regular much-maligned imperative programming?<br/><br/>In fairness, OP is not by the creator of BP. But it doesn't seem like a strong case.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581290295.061600"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581290295.061600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-09 15:18</span><br/>
I'm at 12 minutes now, and OP is talking about modifying a program based on just reading an event trace. I <em>love</em> traces, and I <em>want</em> to nod along. But wait a minute, what if a program needed events to happen in different orders in two different scenarios? Most real-world programs have many many scenarios they need to work in. Never allowing ourselves to touch existing parts of the program seems like a bad way to reliably get the desired effect.<br/><br/>It's not clear to me how this block means "block loadingAccount until adShown":<br/><pre style="white-space:pre-wrap">yield {<br/>  wait: 'adShown'<br/>  block: 'loadingAccount'<br/>}</pre><br/>Can somebody explain this? Is it assuming there's another b-thread somewhere pumping out 'loadingAccount' events <em>ad infinitum</em>?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581290720.061800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581290720.061800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-09 15:25</span><br/>
The animations suggest that b-threads run in lock step, each <tt>yield</tt> in them taking equal time. Is this true? Certainly the examples here would have wildly different behavior for different relative timings. Being this sensitive to timing seems really bad. It gives me flashbacks to writing Verilog code and running into bugs from signals not getting to a latch in time for the next clock cycle.<br/><br/>Ok, I'll stop spamming this thread. Summary: I have been slowly thinking about BP over 1.5 years now, and my opinion is slowly crystallizing to opposition. OP seems like a poor advertisement for BP. Either it's misunderstanding BP or it's making certain drawbacks very obvious but not self-aware of doing so.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581292548.062100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581292548.062100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-09 15:55</span><br/>
Ah, I see that <a href="http://www.wisdom.weizmann.ac.il/~amarron/BP%20-%20CACM%20-%20Author%20version.pdf">http://www.wisdom.weizmann.ac.il/~amarron/BP%20-%20CACM%20-%&hellip;</a> (the original BP paper?) admits the possibility of conflicting b-threads in Section 5.1. They point out that:<br/><br/><li> Conflicts can be resolved using priorities. Which absolutely requires new b-threads to be aware of what older b-threads exist.<br/><li> A model-checker is required to warn programmers when conflict may arise.<br/><br/>Using BP in React seems like a recipe for spaghetti until React gains a model-checker. Is there one in development somewhere?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1581381032.079000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1580955499.046800.html#1581381032.079000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-02-10 16:30</span><br/>
I poked the author on Twitter with these concerns: <a href="https://twitter.com/akkartik/status/1227025035329703936">https://twitter.com/akkartik/status/1227025035329703936</a>
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
