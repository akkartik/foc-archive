<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2023-12-19 12:04</span><br/>
A large codebase is a realm ruled by the iron fist of legalism. In addition, it is a patchwork of many different jurisdictions, each with their own overlapping but subtly different laws. And it's incredibly easy to spawn a new jurisdiction!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1703092698.645919"></a>
      <img src="https://avatars.slack-edge.com/2020-09-09/1376906509376_a07cdcb6d037bf7b6a5e_72.jpg" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html#1703092698.645919" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Denny Vrandečić</b>
<span style="margin:2em; color:#606060">2023-12-20 09:18</span><br/>
It is easy because the terrain is often only vast and multidimensional. And instead of tending to existing areas, people love to conquer new terrain.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1703416084.404329"></a>
      <img src="https://avatars.slack-edge.com/2021-12-12/2854686602576_90c9108c61f5d809eb8a_72.jpg" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html#1703416084.404329" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Beni Cherniavsky-Paskin</b>
<span style="margin:2em; color:#606060">2023-12-24 03:08</span><br/>
To a programmer, sure, a small intimately familiar codebase offers much escape from legalism, by making it realistically achievable to change the rules.<br/><br/>But it's also an interesting question what can we do for "end users", or even other programmers who are reluctant to invest in learning our piece of the terrain.<br/>Do you think for a <em>given user task,</em> building it with less legalism for users correlates with smaller codebases? :thinking_face:<br/><br/>[The question is unfair, because achieving same "functionality" with less legalism is actually very valuable and should count as "more functionality"...  Very hard to quantify.]
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1703416464.236579"></a>
      <img src="https://avatars.slack-edge.com/2021-12-12/2854686602576_90c9108c61f5d809eb8a_72.jpg" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html#1703416464.236579" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Beni Cherniavsky-Paskin</b>
<span style="margin:2em; color:#606060">2023-12-24 03:14</span><br/>
The "conquer new terrain" metaphor is apt.  People don't go off merely because we're too selfish to "tend to existing areas"; to some degree we enjoy it <em>because</em> it lets us make our own jurisdiction!  Whereas putting up with other people's rules (and being careful not to break their use cases) is genuinely hard.<br/><br/>=> Conjecture: any techniques for building less legalistic software might benefit programming itself by reducing NIH tendencies and encouraging positive-sum code reuse??
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1703441961.690709"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html#1703441961.690709" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2023-12-24 10:19</span><br/>
> Do you think for a given user task, building it with less legalism for users correlates with smaller codebases? :thinking_face:<br/>> <br/>Proprietary programs and websites tend towards power for the authors, laws for users. Open source programs tend towards power for insiders (who can modify them), laws for outsiders. I want my small, open source Freewheeling programs to provide power for people, laws for the computer.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1703449853.202439"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html#1703449853.202439" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2023-12-24 12:30</span><br/>
... (yet again, sorry) my deep belief is: insiders and authors (and researchers and assembler programmers) think that "programming" MUST consist of step-wise sequencing of electronic machines, whereas people don't want to know about programming and think in terms of free will (aka true asynchronousity, not step-wise simultaneity) .  Any UX that presents tools that need to be sequenced in a step-wise (synchronous) manner will not be understood by people, and will remain in the domain of the ivory towerists. The trains will run on time, but, the tools will not be appreciated by the majority ...
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1703452575.783849"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html#1703452575.783849" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2023-12-24 13:16</span><br/>
Isn't lots of asynchronous orchestration also too complex for people? Orchestration is just inherently difficult to model in one's head.<br/><br/>Conversely, it's the most natural thing in the world for my kids to say first do this, then do that. Lots of people imagine moments in time advancing synchronously everywhere at once.<br/><br/>So there's a kernel of something here, but I don't think it's quite fully baked yet. Sync vs async is too blunt to be all of the answer.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1703477203.470019"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html#1703477203.470019" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2023-12-24 20:06</span><br/>
> Isn't lots of asynchronous orchestration also too complex for people? <br/>Lots yes.  Some no.<br/><br/>Let's take away the big words and observe what remains.<br/><br/>People - Western, English speaking people - draw diagrams on whiteboards and flip charts.  The diagrams read from left to right, top to bottom.  Usually the diagrams consist of boxes with some words on them, and arrows with some words on them.<br/><br/>> Orchestration is just inherently difficult to model in one's head.<br/>For programmers, yes, for people, not so much.  As long as the result is not "too busy".  I.E. diagrams cannot contain too much detail. If they want to express more detail, they flip to the next blank page and draw another not-so-busy diagram. And so on.  Drawing <b>everything</b> on a single diagram is anathema.  Good powerpoint slide decks are like that.  One point per slide, advance to next slide if more detail is required.<br/><br/>> <br/>> Conversely, it's the most natural thing in the world for my kids to say first do this, then do that. Lots of people imagine moments in time advancing synchronously everywhere at once.<br/>Yes.  And your kids have no problem saying "while the potatoes cook, cut up the carrots". They don't invoke monads or futures or awaits to say this, they just say it.  When they draw it on a whiteboard, it's pretty clear - one box branches out to two boxes.  Left to right.  Then, the two branches join back together into a single box.  No rules. The person drawing the branches gets to say when the branches join. The toolmaker doesn't get to dictate. The toolmaker provides a recursive canvas (a flip-chart, or an erasable whiteboard) and provides the dry-erase markers. The person doing the drawing uses the tools to say what they mean.<br/><br/>Not everyone expresses what they mean in a good way. The people who do this well are promoted to "Architect" status, the rest don't get promoted.<br/><br/>> So there's a kernel of something here, but I don't think it's quite fully baked yet. Sync vs async is too blunt to be all of the answer.<br/>In a way, yes, in a way, no. My feeling is that this is quite simple and doesn't need to be complicated further.  Encapsulate units, make the units be totally independent. Function-based programming  languages do only half of the job.  It is trivial to do the rest of the job.  Preserve time-ordering and left-to-rightness and top-to-downness. Allow composition of such units (aka LEGO-ification).  Current programming languages lean solely on the LIFO meme (stack).  Simply adding a LIFO meme (queue) can break out of the step-wise (synchronous) paradigm. This is nothing new - networking protocols already do this kind of thing.  I think that we can push network protocol-ization down to the programming level.  Easily.<br/><br/>Don't use one at the exclusion of the other. Use both. LIFO and FIFO. CALL/RETURN and SEND.<br/><br/>LIFO is good for expressing the innards of components, FIFO is good for expressing inter-component communication.<br/><br/>Input and output queues are good for preserving time-ordering of data arrival and data generation.<br/><br/>"Programming" is the whole enchilada. Innards and inter-component communication.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1703488872.508029"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html#1703488872.508029" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2023-12-24 23:21</span><br/>
The question of "why not use both?" makes sense to me. But I don't think things will be any better if we start using both. I think architects will still continue to make the same sorts of messes they do today. I think you're comparing apples and oranges, the current messy state of the status quo vs the idealized pristine state of your idea. But people will start making a mess with it one microsecond after they adopt it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1703847907.361929"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1703016259.139779.html#1703847907.361929" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2023-12-29 03:05</span><br/>
I see this as 2 separable issues (1) access-ability and (2) scalability.  Spreadsheets would be an example of (1) without (2).  People can use spreadsheets easily, but, after a point, a project becomes unscalable - a complicated mess.<br/><br/>I think that 0D and The Rule of 7 address both of these issues, but, I have yet to say it in a way that is convincing enough. Where "address" means taking a step in that direction without necessarily producing an ultimate solution.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
