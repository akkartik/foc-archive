[
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1675764936.721009",
        "client_msg_id": "e6dd7f75-4516-41c5-909a-4f356924b4b0",
        "text": "Re: ALGOL.    My quip (which I get a lot of flak for, so good…) is that today’s “general purpose” languages are nothing of the sort.  They are domain specific languages for the domain of algorithms.\n\nSee ALGOL, the ALGOrithimic Language, which all of today’s mainstream languages are descendants of and largely indistinguishable from.\n\nThat said, “algorithms” is a pretty good domain, and if I had to choose one and only on architectural style, call\/return is the one I’d choose.  And I think the idea that we have to get _rid_ of the dominant style in order to overcome its limitations is one of they key obstacles to actually doing so.\n\nWe need to generalize from it, not ditch it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4\/QGA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Re: ALGOL.    My quip (which I get a lot of flak for, so good…) is that today’s “general purpose” languages are nothing of the sort.  They are domain specific languages for the domain of algorithms.\n\nSee ALGOL, the ALGOrithimic Language, which all of today’s mainstream languages are descendants of and largely indistinguishable from.\n\nThat said, “algorithms” is a pretty good domain, and if I had to choose one and only on architectural style, call\/return is the one I’d choose.  And I think the idea that we have to get "
                            },
                            {
                                "type": "text",
                                "text": "rid",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of the dominant style in order to overcome its limitations is one of they key obstacles to actually doing so.\n\nWe need to generalize from it, not ditch it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1675766777.386399",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1675827436.000000"
        },
        "client_msg_id": "974f8f37-6965-4489-a9a3-bc8f37ed4370",
        "text": "a) I consider IF-THEN-ELSE to be the root of many evils.  It is “too general” and allows one to construct ad-hoc control flows.  (McCarthy specified COND, which maps functions to values, but, was not meant to be a control flow concept).\n\nb) There used to be a time when CPUs gave equal weight to function calling and to co-routining.  Function calling is an attempt to graft mathematics notations onto CPUs.  One difference is that mathematics notation requires instantaneous textual replacement of functions (“referential transparency”).  CPUs have propagation delays which make it “impossible” to graft 0-time concepts onto electronics.  A lot of epicycles have been invented to get around this issue by completely ignoring it (e.g “operating systems”).  [aside: “instantaneous textual replacement” without side-effects?  Isn’t that what Microsoft Word “find-and-replace” does?]\n\nc) I am enjoying your comments \/ this perspective.  Mathematical “algorithms” are not the same as “electronic machine algorithms”.  Electronic machines have “mutation”.  Period. “Mutation” is also known as “RAM” (and heaps, and caches, and registers, and ...).  Models of mathematical-only algorithms using electronic machines are not the same thing as models of electronic machines in general.  Using only functional notation to express electronic-machine-algorithms snips off a bunch of possible avenues of thought.\n\nd) Abstraction.  “Lambda” is a way to lasso and abstract code.  But, a rectangle drawn on a whiteboard is also a way to lasso and abstract code.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5+k",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "a) I consider IF-THEN-ELSE to be the root of many evils.  It is “too general” and allows one to construct ad-hoc control flows.  (McCarthy specified COND, which maps functions to values, but, was not meant to be a control flow concept).\n\nb) There used to be a time when CPUs gave equal weight to function calling and to co-routining.  Function calling is an attempt to graft mathematics notations onto CPUs.  One difference is that mathematics notation requires instantaneous textual replacement of functions (“referential transparency”).  CPUs have propagation delays which make it “impossible” to graft 0-time concepts onto electronics.  A lot of epicycles have been invented to get around this issue by completely ignoring it (e.g “operating systems”).  [aside: “instantaneous textual replacement” without side-effects?  Isn’t that what Microsoft Word “find-and-replace” does?]\n\nc) I am enjoying your comments \/ this perspective.  Mathematical “algorithms” are not the same as “electronic machine algorithms”.  Electronic machines have “mutation”.  Period. “Mutation” is also known as “RAM” (and heaps, and caches, and registers, and ...).  Models of mathematical-only algorithms using electronic machines are not the same thing as models of electronic machines in general.  Using only functional notation to express electronic-machine-algorithms snips off a bunch of possible avenues of thought.\n\nd) Abstraction.  “Lambda” is a way to lasso and abstract code.  But, a rectangle drawn on a whiteboard is also a way to lasso and abstract code."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U017TE5R09M"
                ],
                "count": 1
            }
        ]
    }
]