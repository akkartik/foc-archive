[
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1565944411.090600",
        "client_msg_id": "2281af66-b965-4d63-8ceb-e889be3235b6",
        "text": "You are 100% correct that the introduction of API's instead of memory mapped state info is a drawback. This by the way was Wozniak's greatest contribution to the Apple OS, and what made it so brilliant. Every device was memory mapped in low RAM so you could POKE a value into a memory location and get a character drawn on the screen, etc. some could be read (PEEK) and some could be both read and written like the screen. Fast forward to now, you have 1000 api calls in OSX to do the same things that took zero calls in Apple OS. This is retrograde progress, and i have put as many state variables as i could scrounge in Beads, however as i just pointed out modern OS'es are perverse in their love of API's and you can't actually interrogate so easily. One of the problems is that modern computers want to allow multiple connected mice at the same time, and support all sorts of weird stuff that complexifies the whole thing.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5qx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You are 100% correct that the introduction of API's instead of memory mapped state info is a drawback. This by the way was Wozniak's greatest contribution to the Apple OS, and what made it so brilliant. Every device was memory mapped in low RAM so you could POKE a value into a memory location and get a character drawn on the screen, etc. some could be read (PEEK) and some could be both read and written like the screen. Fast forward to now, you have 1000 api calls in OSX to do the same things that took zero calls in Apple OS. This is retrograde progress, and i have put as many state variables as i could scrounge in Beads, however as i just pointed out modern OS'es are perverse in their love of API's and you can't actually interrogate so easily. One of the problems is that modern computers want to allow multiple connected mice at the same time, and support all sorts of weird stuff that complexifies the whole thing."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UHWC9PXBL",
                    "UA14TGLTC",
                    "U8A5MS6R1",
                    "UFLN9JFRT"
                ],
                "count": 5
            }
        ]
    },
    {
        "user": "U6FKVSVCK",
        "type": "message",
        "ts": "1565965539.099500",
        "client_msg_id": "8c0341c8-309f-43a0-b719-bc9e3a2f8cf1",
        "text": "I'm not sure I follow why APIs themselves are bad? An API separates implementation from interface, which is a way to allow the user to mentally manage less complexity. Peeking and poking memory directly maybe works when you know it is only text you are moving around, but I think that's a great example of something that doesn't scale- I don't want to have to know the internal implementation of every OS functionality in order to be able to use it. \n\nArguably a good API makes state querying and modification as easy or easier than your peek\/poke example, and does so by organizing the shared data in a nicer way than flat memory, and organizing the procedures into related functionality that makes them easy to find, with minimal mutual interference in meaning and effect.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cad501b70b26",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-07\/786673147216_cad501b70b26e7666ed0_72.png",
            "first_name": "Tim",
            "real_name": "Tim Babb",
            "display_name": "tbabb",
            "team": "T5TCAFTA9",
            "name": "tbabb",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "y3yc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not sure I follow why APIs themselves are bad? An API separates implementation from interface, which is a way to allow the user to mentally manage less complexity. Peeking and poking memory directly maybe works when you know it is only text you are moving around, but I think that's a great example of something that doesn't scale- I don't want to have to know the internal implementation of every OS functionality in order to be able to use it. \n\nArguably a good API makes state querying and modification as easy or easier than your peek\/poke example, and does so by organizing the shared data in a nicer way than flat memory, and organizing the procedures into related functionality that makes them easy to find, with minimal mutual interference in meaning and effect."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U6FKVSVCK",
        "type": "message",
        "ts": "1565965636.101100",
        "client_msg_id": "9590a388-8ea7-48ed-99dd-d8ab7968b5de",
        "text": "I would argue that encapsulation (the ability to hide internal complexity) is absolutely essential for a good end user programming experience",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cad501b70b26",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-07\/786673147216_cad501b70b26e7666ed0_72.png",
            "first_name": "Tim",
            "real_name": "Tim Babb",
            "display_name": "tbabb",
            "team": "T5TCAFTA9",
            "name": "tbabb",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ub5PR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would argue that encapsulation (the ability to hide internal complexity) is absolutely essential for a good end user programming experience"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UAVCC2X70",
                    "UA14TGLTC",
                    "UAL7940NM",
                    "UFLN9JFRT"
                ],
                "count": 4
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1566008223.112400",
        "client_msg_id": "ef11d824-7d00-455a-85a2-dc1c5cc35d35",
        "text": "I agree separating interface from implementation is important, but exposing state does not imply exposing implementation. The state could actually be _derived state_, automatically maintained based on some hidden original source. In such a scenario, the state acts as an API. Then the only departure from a function-based API is the syntactic means of accessing it. Do you call functions to discover the state, or just query it directly? The difference is probably only important in terms of how it shapes the user's mental model of a system. This was my original point: if a user is inclined to think of something as state, then it should be presented as state. Functions can mean\/do a lot more (in particular, take input and mutate things!) so they likely induce additional cognitive burden.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q\/yPp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree separating interface from implementation is important, but exposing state does not imply exposing implementation. The state could actually be "
                            },
                            {
                                "type": "text",
                                "text": "derived state",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", automatically maintained based on some hidden original source. In such a scenario, the state acts as an API. Then the only departure from a function-based API is the syntactic means of accessing it. Do you call functions to discover the state, or just query it directly? The difference is probably only important in terms of how it shapes the user's mental model of a system. This was my original point: if a user is inclined to think of something as state, then it should be presented as state. Functions can mean\/do a lot more (in particular, take input and mutate things!) so they likely induce additional cognitive burden."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1566008466.114000",
        "client_msg_id": "4779f176-a87e-4624-a9a8-56e30fc3f08c",
        "text": "(I'll also re-iterate that I'm not addressing approaches to _modifying_ state here; that's a separate discussion topic)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mQ3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(I'll also re-iterate that I'm not addressing approaches to "
                            },
                            {
                                "type": "text",
                                "text": "modifying",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " state here; that's a separate discussion topic)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1566015154.124400",
        "client_msg_id": "99be3290-7613-49b8-9054-fea9e8fc4a0c",
        "text": "I agree with Nick that simply referencing the value of a state variable represents less cognitive burden for the programmer, than remembering the name of yet another function call. OSX has gotten to an absurd API count, and when you take the API's for all the Java classes it exceeds 10,000, which is a huge cognitive burden for the programmer. Java exacerbates the API problem by having multiple ways to do similar things, so you then have to wonder which API set would be best, and when you merge other modules of code from other authors, you then start mixing which API sets are in use, and it gets ugly in a hurry. This is one of the reasons why the era of interchangeable parts did not occur with the Java language, and one of my reasons why Java has to be scrapped ASAP.\n\nI think of a function as doing some isolated calculation like Trig functions which have a very complex internal implementation but are trivial to use, taking only a single input.\n\nThe problem i have with API's is the quantity one has to learn to accomplish anything. In the Apple 2 days, you might learn a few dozen. In Apple Macintosh it was a few hundred. Win32 GDI was also a few hundred albeit a much more modal\/complex set than Apple's clever and clean Quickdraw. Fast forward to today, and nobody even prints books with the full set of API's because the books would be too fat. Because we aren't printing the documentation on paper, people aren't noticing the load, but I prefer printed documentation, and after emptying my 500 sheet input tray of my fancy canon laser printer, i give up and want to scrap the whole thing. My Beads language project is the result of my extreme distaste for how complex the current toolchain is, mostly caused by an API explosion. You can build a graphical interactive chess game with audio, autosizing graphics, etc., with under 20 API's and i consider that a big win for the programmer as I don't need a fancy context sensitive IDE to help prop up an overcomplex mess, and can learn the 20 API calls after repetitive usage.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566015154.124400",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1566026943.125200",
        "reply_users": [
            "U85HCL7JP",
            "UAVCC2X70",
            "UEQ6M68H0"
        ],
        "replies": [
            {
                "user": "U85HCL7JP",
                "ts": "1566018752.124700"
            },
            {
                "user": "UAVCC2X70",
                "ts": "1566020714.125000"
            },
            {
                "user": "UEQ6M68H0",
                "ts": "1566026943.125200"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "muvc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree with Nick that simply referencing the value of a state variable represents less cognitive burden for the programmer, than remembering the name of yet another function call. OSX has gotten to an absurd API count, and when you take the API's for all the Java classes it exceeds 10,000, which is a huge cognitive burden for the programmer. Java exacerbates the API problem by having multiple ways to do similar things, so you then have to wonder which API set would be best, and when you merge other modules of code from other authors, you then start mixing which API sets are in use, and it gets ugly in a hurry. This is one of the reasons why the era of interchangeable parts did not occur with the Java language, and one of my reasons why Java has to be scrapped ASAP.\n\nI think of a function as doing some isolated calculation like Trig functions which have a very complex internal implementation but are trivial to use, taking only a single input.\n\nThe problem i have with API's is the quantity one has to learn to accomplish anything. In the Apple 2 days, you might learn a few dozen. In Apple Macintosh it was a few hundred. Win32 GDI was also a few hundred albeit a much more modal\/complex set than Apple's clever and clean Quickdraw. Fast forward to today, and nobody even prints books with the full set of API's because the books would be too fat. Because we aren't printing the documentation on paper, people aren't noticing the load, but I prefer printed documentation, and after emptying my 500 sheet input tray of my fancy canon laser printer, i give up and want to scrap the whole thing. My Beads language project is the result of my extreme distaste for how complex the current toolchain is, mostly caused by an API explosion. You can build a graphical interactive chess game with audio, autosizing graphics, etc., with under 20 API's and i consider that a big win for the programmer as I don't need a fancy context sensitive IDE to help prop up an overcomplex mess, and can learn the 20 API calls after repetitive usage."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U85HCL7JP",
        "type": "message",
        "ts": "1566018752.124700",
        "edited": {
            "user": "U85HCL7JP",
            "ts": "1566018770.000000"
        },
        "client_msg_id": "3e23d9bf-cf6b-4b67-9bb8-22996c8ab0ff",
        "text": "I agree so much with you <@UEQ6M68H0>, it’s impossible to make sense of the quantity of API’s. I was thinking recently on how some people want to make learn to program as easy as learn to drive, but the number of API’s in a car are way less.\nI’d love to hear more about your approach to reduce API’s to under 20, any blog post or source code that I can read?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0c5d8f6a2266",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-07-25\/1286770110448_0c5d8f6a2266551a36f2_72.jpg",
            "first_name": "",
            "real_name": "Daniel Garcia",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "daniel.garcia.carmona",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566015154.124400",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+9E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree so much with you "
                            },
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": ", it’s impossible to make sense of the quantity of API’s. I was thinking recently on how some people want to make learn to program as easy as learn to drive, but the number of API’s in a car are way less.\nI’d love to hear more about your approach to reduce API’s to under 20, any blog post or source code that I can read?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1566020714.125000",
        "client_msg_id": "68f7da68-c3aa-468b-83ec-3789b2f4f046",
        "text": "If you're talking just about the basics of programming, you really don't need much. But if you're talking about all the things you might do with an application (e.g. http requests, graphics, etc.) ... I believe that could be cut down significantly, and I'd also be curious to see what Beads does about that",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1566015154.124400",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/Bl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you're talking just about the basics of programming, you really don't need much. But if you're talking about all the things you might do with an application (e.g. http requests, graphics, etc.) ... I believe that could be cut down significantly, and I'd also be curious to see what Beads does about that"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]