[
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1558515628.081500",
        "client_msg_id": "725a2c19-36e9-40cd-9209-5fbbe077aff7",
        "text": "I have watched a bunch of the Jai videos, and I can assure you he is doing a superb job on the performance bottlenecks that actually matter. The fancy instructions that Intel has added to their hardware in the last dozen years are garbage, and have nearly zero impact on performance of actual software. The real killer problem is whether you are generating cache misses; every cache miss in the CPU can cost over 100 clocks, and he has spent a lot of thought working on that crucial issue. Do not underestimate someone who has shipped on so many platforms with such a wide hardware power range. That gives you a real education. I have never met Mr. Blow, but i know from experience that staying in the cache really matters, way more than using one of the silly instructions that Intel added primarily for the purpose of slowing down the cloners. One of the technical reasons Java programs are so slow is that they spray objects all over the heap, and it causes a lot of cache misses. This is one of the intrinsic flaws of the OOP paradigm, that it doesn't concentrate memory accesses into a small region. Yes, Jai is focused on giving you very low level control over things, but 3D games do throw around a lot of data, and being able to optionally specify various low level aspects will be appreciated by people on slower platforms (like mobile devices, which have very tight RAM constraints compared to desktop platforms). Of the new language projects on the next gen language spreadsheet, i would say he is ahead of the other teams; he has already got something like 50k lines of code of a game working, so only the Red team is ahead in terms of number of lines of code in their language being used. Red has split their language into two main dialects, one for system programming and one for general use. That is an interesting strategy, because the system one can be simpler and not try to cover such a wide range of applications. It is more work to create two code bases and language specs, but it does reflect that fact that some people are doing system programming and don't need any user interface stuff. Certainly the libraries can way smaller and perhaps more focused on a lower level implementation of network protocols, which would be a hindrance for someone writing a simple app that needs to post some fields to a web API form.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1558420574.077800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mzi=7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have watched a bunch of the Jai videos, and I can assure you he is doing a superb job on the performance bottlenecks that actually matter. The fancy instructions that Intel has added to their hardware in the last dozen years are garbage, and have nearly zero impact on performance of actual software. The real killer problem is whether you are generating cache misses; every cache miss in the CPU can cost over 100 clocks, and he has spent a lot of thought working on that crucial issue. Do not underestimate someone who has shipped on so many platforms with such a wide hardware power range. That gives you a real education. I have never met Mr. Blow, but i know from experience that staying in the cache really matters, way more than using one of the silly instructions that Intel added primarily for the purpose of slowing down the cloners. One of the technical reasons Java programs are so slow is that they spray objects all over the heap, and it causes a lot of cache misses. This is one of the intrinsic flaws of the OOP paradigm, that it doesn't concentrate memory accesses into a small region. Yes, Jai is focused on giving you very low level control over things, but 3D games do throw around a lot of data, and being able to optionally specify various low level aspects will be appreciated by people on slower platforms (like mobile devices, which have very tight RAM constraints compared to desktop platforms). Of the new language projects on the next gen language spreadsheet, i would say he is ahead of the other teams; he has already got something like 50k lines of code of a game working, so only the Red team is ahead in terms of number of lines of code in their language being used. Red has split their language into two main dialects, one for system programming and one for general use. That is an interesting strategy, because the system one can be simpler and not try to cover such a wide range of applications. It is more work to create two code bases and language specs, but it does reflect that fact that some people are doing system programming and don't need any user interface stuff. Certainly the libraries can way smaller and perhaps more focused on a lower level implementation of network protocols, which would be a hindrance for someone writing a simple app that needs to post some fields to a web API form."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1558559062.082100",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1558559072.000000"
        },
        "client_msg_id": "02b91519-7303-4d0f-9dc0-fb8844705b64",
        "text": "<https:\/\/begriffs.com\/posts\/2019-05-23-unicode-icu.html>\n\n_“Puh-leaze, if your program can’t handle Medieval Irish carvings then I want nothing to do with it.“_ :joy:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "title": "Unicode programming, with examples",
                "title_link": "https:\/\/begriffs.com\/posts\/2019-05-23-unicode-icu.html",
                "text": "The design of Unicode illustrated with the ICU4C API",
                "fallback": "Unicode programming, with examples",
                "image_url": "https:\/\/begriffs.com\/images\/unicode-logo.png",
                "from_url": "https:\/\/begriffs.com\/posts\/2019-05-23-unicode-icu.html",
                "image_width": 249,
                "image_height": 250,
                "image_bytes": 17908,
                "service_icon": "https:\/\/begriffs.com\/images\/icon\/apple-touch-icon.png",
                "service_name": "begriffs.com",
                "id": 1,
                "original_url": "https:\/\/begriffs.com\/posts\/2019-05-23-unicode-icu.html"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Nqe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/begriffs.com\/posts\/2019-05-23-unicode-icu.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "“Puh-leaze, if your program can’t handle Medieval Irish carvings then I want nothing to do with it.“",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "emoji",
                                "name": "joy",
                                "unicode": "1f602"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBSMEUXAA",
        "type": "message",
        "ts": "1558567021.082400",
        "edited": {
            "user": "UBSMEUXAA",
            "ts": "1558569771.000000"
        },
        "client_msg_id": "253dd38f-2636-4841-96a9-94e5d318af3d",
        "text": "I know the importance of cache friendly data layouts. I've shipped multiple AAA games on console, worked on my own personal game (which was funded by Blow at one point) that targeted Xbox 360, and I just mentioned Unity DOTS (data oriented tech stack), whose major reason for existence is reducing cache misses in Unity game code.  I even said that Jai is doing a good job with memory related performance issues, although I should have explicitly mentioned cache management. The feature that allows for treating data as SOA or AOS with a single keyword is slick.   To say that SIMD doesn't matter at all because \"fancy instructions that Intel has added to their hardware in the last dozen years are garbage\" (AVX?) is naive.  Utilizing SSE4 instructions efficiently is standard in modern game engines, so is scaling to ~4-8 cores.  You can argue that the language shouldn't do this, game developers are already doing it, but that brings Jai back to \"better C++\" land imo, not Future of Coding for game engines.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "0edf98a60210",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-09-26\/774747080560_0edf98a60210d3ab07ea_72.jpg",
            "first_name": "",
            "real_name": "Scott Anderson",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "scottan",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1558420574.077800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1g6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I know the importance of cache friendly data layouts. I've shipped multiple AAA games on console, worked on my own personal game (which was funded by Blow at one point) that targeted Xbox 360, and I just mentioned Unity DOTS (data oriented tech stack), whose major reason for existence is reducing cache misses in Unity game code.  I even said that Jai is doing a good job with memory related performance issues, although I should have explicitly mentioned cache management. The feature that allows for treating data as SOA or AOS with a single keyword is slick.   To say that SIMD doesn't matter at all because \"fancy instructions that Intel has added to their hardware in the last dozen years are garbage\" (AVX?) is naive.  Utilizing SSE4 instructions efficiently is standard in modern game engines, so is scaling to ~4-8 cores.  You can argue that the language shouldn't do this, game developers are already doing it, but that brings Jai back to \"better C++\" land imo, not Future of Coding for game engines."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]