[
    {
        "user": "U06MCTWJKSR",
        "type": "message",
        "ts": "1745935603.297889",
        "edited": {
            "user": "U06MCTWJKSR",
            "ts": "1745936510.000000"
        },
        "client_msg_id": "7312eb73-99e7-44a6-82eb-b5099ee08357",
        "text": "Pure computation is pure all the way down, an advantage of this is the ability to verify a result by just putting the inputs in again. This is useful in the real world if you share a result with someone: for example when a bank tells a customer how much their mortgage repayment costs\n\nIt works not just for one result of interest, but for every other result that one depends on: in other words for the complete workings. So by sharing the pure computation code and it's inputs along with a number, the number is verifiable and you've also shared the complete workings (for free).\n\nI exploit this as much as I can in calculang, including while developing models, with reactive visualizations showing me current model behavior for some inputs (with controls; all experimental at this stage).\n\nIt surprises me that on developer tools, functional programming is not in it's own league in front. There are some application state developer tools that FP techniques enable and some are influential. But I don't know anything about interesting introspection- or validation type tools that especially exploit purity. Anyone know if I'm missing something in particular or have any good references to read on?\n\nI might consider a POC exploration on just this idea for some other language (maybe Haskell or PureScript but open to thoughts)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "5b4c95c70d98",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-04-10\/6931478324918_5b4c95c70d98784a05cc_72.jpg",
            "first_name": "Declan",
            "real_name": "Declan",
            "display_name": "Declan Naughton",
            "team": "T5TCAFTA9",
            "name": "declann1990",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W4vMs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Pure computation is pure all the way down, an advantage of this is the ability to verify a result by just putting the inputs in again. This is useful in the real world if you share a result with someone: for example when a bank tells a customer how much their mortgage repayment costs\n\nIt works not just for one result of interest, but for every other result that one depends on: in other words for the complete workings. So by sharing the pure computation code and it's inputs along with a number, the number is verifiable and you've also shared the complete workings (for free).\n\nI exploit this as much as I can in calculang, including while developing models, with reactive visualizations showing me current model behavior for some inputs (with controls; all experimental at this stage).\n\nIt surprises me that on developer tools, functional programming is not in it's own league in front. There are some application state developer tools that FP techniques enable and some are influential. But I don't know anything about interesting introspection- or validation type tools that especially exploit purity. Anyone know if I'm missing something in particular or have any good references to read on?\n\nI might consider a POC exploration on just this idea for some other language (maybe Haskell or PureScript but open to thoughts)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1745974416.421639",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1745975196.000000"
        },
        "client_msg_id": "276df594-1f28-4133-b4b3-58158d9c3166",
        "text": "I finally got around to Dave Ackley's latest video report on robust-first computing which <@UJFN50C00> shared <https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1745855290195199|here>, and it prompted me to zoom out and think about the territory of computation and what we know of it so far in the year 2025. Right now I imagine it as a 3D terrain. Along one axis, analogous to a <https:\/\/en.wikipedia.org\/wiki\/Multiview_orthographic_projection|plan view>, I see the following coarse _technical_ approaches to structuring computation, each equally valid:\n• Computation as the orchestration of precise instructions.\n• Computation as the learning of matrix weights.\n• Computation as the orchestration of fuzzy, imprecise cellular automata. Ackley's approach.\nI think that's it? Are there others?\n\nAlong an orthogonal axis, analogous to an elevation view, I see _social_ approaches to organizing the means of computation. So far we only have open questions here:\n• Does computational infrastructure necessarily require authoritarian dictators or at best feudal lords and vassals? Or is it possible to have something analogous to a democratic approach?\n• Can we reduce inequality between the haves and have-nots of tech knowledge and computer whispering?\n• Can we design incentives to keep computation working over time, in a secure and trustworthy way? (Can computation ever be biased less towards offense, can defense be viable?)\n• Can we design incentives to make the means of computation sustainable in their impact on the environment?\nAnd along a second orthogonal axis, analogous to a side view, I imagine ways to connect up computation with other fields of human endeavor. Here there has been much progress, though I am running out of steam:\n• Learning from the arts to improve visual and auditory design, e.g. typography.\n• Learning from math to better model the world, e.g. numerical methods.\n• Learning from the social sciences to nudge groups of people in productive and unproductive directions. Coevolving populations with these lessons that will inevitably grow robust to such nudging.\n• ...?\nFeel free to point out gaps, additional axes, add examples..",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1745974416.421639",
        "reply_count": 13,
        "reply_users_count": 4,
        "latest_reply": "1746165781.684539",
        "reply_users": [
            "U06SS0DHZD1",
            "U02E4DAQGSZ",
            "UJBAJNFLK",
            "UCUSW7WVD"
        ],
        "replies": [
            {
                "user": "U06SS0DHZD1",
                "ts": "1745993981.943749"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1745994487.028119"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1746025061.236739"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1746025247.789359"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1746026325.504339"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1746081832.489059"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1746082708.540329"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1746085275.462299"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1746086574.419789"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1746095679.378429"
            },
            {
                "user": "UCUSW7WVD",
                "ts": "1746111357.294129"
            },
            {
                "user": "U02E4DAQGSZ",
                "ts": "1746113708.974489"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1746165781.684539"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JI1Zi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I finally got around to Dave Ackley's latest video report on robust-first computing which "
                            },
                            {
                                "type": "user",
                                "user_id": "UJFN50C00"
                            },
                            {
                                "type": "text",
                                "text": " shared "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5U3SEW6A\/p1745855290195199",
                                "text": "here"
                            },
                            {
                                "type": "text",
                                "text": ", and it prompted me to zoom out and think about the territory of computation and what we know of it so far in the year 2025. Right now I imagine it as a 3D terrain. Along one axis, analogous to a "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Multiview_orthographic_projection",
                                "text": "plan view"
                            },
                            {
                                "type": "text",
                                "text": ", I see the following coarse "
                            },
                            {
                                "type": "text",
                                "text": "technical",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " approaches to structuring computation, each equally valid:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Computation as the orchestration of precise instructions."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Computation as the learning of matrix weights."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Computation as the orchestration of fuzzy, imprecise cellular automata. Ackley's approach."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI think that's it? Are there others?\n\nAlong an orthogonal axis, analogous to an elevation view, I see "
                            },
                            {
                                "type": "text",
                                "text": "social",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " approaches to organizing the means of computation. So far we only have open questions here:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Does computational infrastructure necessarily require authoritarian dictators or at best feudal lords and vassals? Or is it possible to have something analogous to a democratic approach?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Can we reduce inequality between the haves and have-nots of tech knowledge and computer whispering?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Can we design incentives to keep computation working over time, in a secure and trustworthy way? (Can computation ever be biased less towards offense, can defense be viable?)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Can we design incentives to make the means of computation sustainable in their impact on the environment?"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAnd along a second orthogonal axis, analogous to a side view, I imagine ways to connect up computation with other fields of human endeavor. Here there has been much progress, though I am running out of steam:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Learning from the arts to improve visual and auditory design, e.g. typography."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Learning from math to better model the world, e.g. numerical methods."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Learning from the social sciences to nudge groups of people in productive and unproductive directions. Coevolving populations with these lessons that will inevitably grow robust to such nudging."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "...?"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFeel free to point out gaps, additional axes, add examples.."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U089J8FNGB1",
                    "U06SS0DHZD1",
                    "UJFN50C00",
                    "UJBAJNFLK",
                    "U02E4DAQGSZ"
                ],
                "count": 5
            },
            {
                "name": "point_up_2",
                "users": [
                    "UJFN50C00"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U06SS0DHZD1",
        "type": "message",
        "ts": "1745993981.943749",
        "client_msg_id": "d9ed209f-763a-42c7-9c50-313b13669874",
        "text": "In the end computers tend to end up executing precise instructions anyway. The first approach that you listed is the bedrock abstraction that the second and third approaches are built on top. In principle it's possible to build machines that would implement other approaches natively but doing so is rarely practical (1, 2 &amp; 3-d cellular automata are some of the exceptions).\n\nI think the question that you asked (\"are there others\") is the main reason many of us are here :slightly_smiling_face: From the back of my memory, there is:\n• quantum computing (another case where building a native computer is essential)\n• spiking neural networks\n• expert systems, also fuzzy ones\n• fpga-style logic networks\n• a few cryptographic approaches (ethereum \/ unison \/ white-box cryptography \/ zero-knowledge proofs)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "287ba5559ee1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-04-04\/6922823105585_287ba5559ee1cedd6b98_72.png",
            "first_name": "Marek",
            "real_name": "Marek Rogalski",
            "display_name": "maf",
            "team": "T5TCAFTA9",
            "name": "mafikpl",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1745974416.421639",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q\/zox",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the end computers tend to end up executing precise instructions anyway. The first approach that you listed is the bedrock abstraction that the second and third approaches are built on top. In principle it's possible to build machines that would implement other approaches natively but doing so is rarely practical (1, 2 & 3-d cellular automata are some of the exceptions).\n\nI think the question that you asked (\"are there others\") is the main reason many of us are here "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " From the back of my memory, there is:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "quantum computing (another case where building a native computer is essential)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "spiking neural networks"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "expert systems, also fuzzy ones"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "fpga-style logic networks"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "a few cryptographic approaches (ethereum \/ unison \/ white-box cryptography \/ zero-knowledge proofs)"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U02E4DAQGSZ"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1745994487.028119",
        "edited": {
            "user": "U02E4DAQGSZ",
            "ts": "1746025498.000000"
        },
        "client_msg_id": "71e9a801-f8d9-4f09-b5b3-4507d2e5a1eb",
        "text": "There is a lot of passive mechanical computation in existence.\n\nFor an underwater robot we added floats to the bottom of our rotating wifi antenna so the antenna went vertical when on the water surface (maximizing range) but folded flat when underwater (reduce drag for locomotion).\nThis is a genuine computational device relying on a non-linearity and \"programmed\" by positioning hinges and orientated w.r.t. gravity and the environment to get a designed behaviour.\n\nA toilet flush is quite a complicated but common one. I consider these closed loop control systems but the feedback computation is done without silicon, which is often _*much*_ more robust albiet limited in expressivity. They don't require electricity to run, but in these two examples they _are_ _powered_ but with kinetic energy (and they lose energy via heat losses like everything powered).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1745974416.421639",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3EPyz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is a lot of passive mechanical computation in existence.\n\nFor an underwater robot we added floats to the bottom of our rotating wifi antenna so the antenna went vertical when on the water surface (maximizing range) but folded flat when underwater (reduce drag for locomotion).\nThis is a genuine computational device relying on a non-linearity and \"programmed\" by positioning hinges and orientated w.r.t. gravity and the environment to get a designed behaviour.\n\nA toilet flush is quite a complicated but common one. I consider these closed loop control systems but the feedback computation is done without silicon, which is often "
                            },
                            {
                                "type": "text",
                                "text": "much",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " more robust albiet limited in expressivity. They don't require electricity to run, but in these two examples they "
                            },
                            {
                                "type": "text",
                                "text": "are",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "powered",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " but with kinetic energy (and they lose energy via heat losses like everything powered)."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UP00ZLX6G",
                    "U06MCTWJKSR",
                    "UP28ETUSE"
                ],
                "count": 4
            }
        ]
    }
]