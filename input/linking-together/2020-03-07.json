[
    {
        "user": "UDLGND5GA",
        "type": "message",
        "ts": "1583604514.066600",
        "client_msg_id": "79138c04-5b5e-4f20-ba15-24c74a6e7b83",
        "text": "I love how the transfer speed of the 1x CD-ROM dictated an aesthetic",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g55e6ae108ed",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/455e6ae108edbb0568eb036d8cab103d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png",
            "first_name": "",
            "real_name": "Nick Fox-Gieg",
            "display_name": "n1ckfg",
            "team": "T5TCAFTA9",
            "name": "nick908",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1580627983.048800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n+T",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I love how the transfer speed of the 1x CD-ROM dictated an aesthetic"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDLGND5GA",
        "type": "message",
        "ts": "1583604531.066800",
        "edited": {
            "user": "UDLGND5GA",
            "ts": "1583604539.000000"
        },
        "client_msg_id": "6f378738-91c0-41d3-829b-ddaa8527018c",
        "text": "That video's an amazing historical document",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g55e6ae108ed",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/455e6ae108edbb0568eb036d8cab103d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png",
            "first_name": "",
            "real_name": "Nick Fox-Gieg",
            "display_name": "n1ckfg",
            "team": "T5TCAFTA9",
            "name": "nick908",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1580627983.048800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t6GG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That video's an amazing historical document"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1583620045.067100",
        "client_msg_id": "a6cefedf-c7cd-4614-b609-09391c620c29",
        "text": "Cross-link to a Ted Nelson rant from 2012: <https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1583565732099000>. Particularly for the following passage:\n\n&gt; I learned in high school that the craft of writing consists mainly of rewriting, and that rewriting consists mainly of rearrangement. Once you’ve written something it’s in the wrong order. Then you cut it apart and arrange the pieces of paper in the right order. This can take some time and you may have pieces of paper lying around your desk or your bedroom floor. For hundreds of years, this process was called “cut and paste.”\n&gt; \n&gt; Did PARC give us a good way to cut and paste? NO! PARC gave us an abominable editing mechanism propagandistically hidden behind the former term. The abominable mechanism is a hidey hole you can put something into, and it’s called “the clipboard”. And hiding something in the clipboard has since 1984 been called “cut”. Then you choose where this one piece goes and blurp it out. And this blurp-out action has since 1984 been called “paste”.\n&gt; \n&gt; Not only did PARC take away the fundamental method of reorganization, and give us a hidey hole instead, but they gave that hidey hole the name of the previous method. Which in true Orwellian style has made people forget. And the Macintosh laid it on us in 1984, the Orwellian year.\n&gt; \n&gt; Now, this twisting of the previous terminology for an entirely different function was perpetrated by… Larry Tesler, who is one of the nicest guys I know. As the Christians say, hate the sin but love the sinner. I’ve been corresponding with Larry, no time to read his beautiful reply until now. He thinks, old fashioned cut and paste is a complex method for professionals and researchers. And ordinary people don’t need anything better. I’ll be putting his beautifully written reply in the next edition of _Geeks_.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1582854486.016000",
        "parent_user_id": "UT60XSVCN",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/",
                "title": "Computers for Cynics 2 - It All Went Wrong at Xerox PARC",
                "title_link": "https:\/\/youtube.com\/watch?v=c6SUOeAqOjU",
                "author_name": "TheTedNelson",
                "author_link": "https:\/\/www.youtube.com\/user\/TheTedNelson",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/c6SUOeAqOjU\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Computers for Cynics 2 - It All Went Wrong at Xerox PARC",
                "video_html": "<iframe width=\"400\" height=\"300\" src=\"https:\/\/www.youtube.com\/embed\/c6SUOeAqOjU?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 300,
                "from_url": "https:\/\/youtube.com\/watch?v=c6SUOeAqOjU",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1583565732099000"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OOC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Cross-link to a Ted Nelson rant from 2012: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.slack.com\/archives\/C5T9GPWFL\/p1583565732099000"
                            },
                            {
                                "type": "text",
                                "text": ". Particularly for the following passage:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I learned in high school that the craft of writing consists mainly of rewriting, and that rewriting consists mainly of rearrangement. Once you’ve written something it’s in the wrong order. Then you cut it apart and arrange the pieces of paper in the right order. This can take some time and you may have pieces of paper lying around your desk or your bedroom floor. For hundreds of years, this process was called “cut and paste.”\n\nDid PARC give us a good way to cut and paste? NO! PARC gave us an abominable editing mechanism propagandistically hidden behind the former term. The abominable mechanism is a hidey hole you can put something into, and it’s called “the clipboard”. And hiding something in the clipboard has since 1984 been called “cut”. Then you choose where this one piece goes and blurp it out. And this blurp-out action has since 1984 been called “paste”.\n\nNot only did PARC take away the fundamental method of reorganization, and give us a hidey hole instead, but they gave that hidey hole the name of the previous method. Which in true Orwellian style has made people forget. And the Macintosh laid it on us in 1984, the Orwellian year.\n\nNow, this twisting of the previous terminology for an entirely different function was perpetrated by… Larry Tesler, who is one of the nicest guys I know. As the Christians say, hate the sin but love the sinner. I’ve been corresponding with Larry, no time to read his beautiful reply until now. He thinks, old fashioned cut and paste is a complex method for professionals and researchers. And ordinary people don’t need anything better. I’ll be putting his beautifully written reply in the next edition of "
                            },
                            {
                                "type": "text",
                                "text": "Geeks",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1583621179.067400",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1583622183.000000"
        },
        "client_msg_id": "48744aec-e3b1-4862-9904-ca30389863e3",
        "text": "Above i meant a fully modeled boolean has 4 states, 2 bits data store, not 4 bits.\n\nExcel has an extended arithmetic, which is carried in each cell. In Excel each cell holding a value has these 2 extra states (#UNDEF and #ERROR) so that you don't need a second cell. In a programming language, if you only allocate 1 bit for the boolean, you cannot represent these two additional states, so you then must allocate another variable to hold it. Or maybe you set it to false which is making up a possibly incorrect value (a bad thing).  A second value for tracking additional values is massively inconvenient, and would mean when you pass that value to a function you would also need to send the second parameter. Since every program is about manipulating data via code, when you start talking about type systems you are also assuming some kind of arithmetic system. Whether you like it or not, you always have these 2 extra states for every variable. You might have omitted to enter the value, or the value is derived from another value that was in error.  For example  a = sqrt(-1);  b=a*2; c = b&lt;2;  In this case, A would be ERROR, and B would evaluate to ERROR as well, and so would C. You can't claim that true or false is correct in the case of C. Yes this is a rarely encountered edge case. But if you want your program to survive erroneous or missing data, you need this extended and protected form of arithmetic. The problem i have with type discussions in this forum is the way people gloss over these exceptions. You won't bother to check every arithmetic operation for some missing data, so the correct approach is to let your arithmetic be closed, and no operation stops the program (unless you are in debugging mode). Every data type needs these base values, because strings can be missing too, and in loosely typed languages you might try to rotate a number instead of a bitmap...  since it is nonsensical, you need that error state to track this so you don't build on top of an error.\n\nHaving protected arithmetic means you won't have to do as much testing on your code, because you aren't so worried about bad inputs causing crazy behavior. Test driven design has become popular with some because they know how flabby their code is and they would prefer to more fully exercise the combinations and permutations. I say screw all that extra work on testing, just make the code impregnable and save the effort of doing exhaustive tests.\n\nNowadays with consumers running millions of copies of software, it isn't considered acceptable to crash on erroneous or missing data. Maybe it was okay back in the day where the person controlling the input data was the same person running the program, but exceptions are a terrible way to handle errors.\n\nMy assertion is that exceptions are a bad idea. You must be prepared to survive bad or missing data. You are not going to be able to figure out where all the numerical exceptions could originate, much less recover from them, and to have anything less than Excel's extended arithmetic is the wrong direction IMHO. There are too many statements in your program that do arithmetic.  Every atomic value in Beads has an error or undefined base value. JS got tantalizingly close with their undefined and NaN value sets, but not allow an Error value on booleans, nor did they consider it for strings or objects, etc.  The arithmetic in JS is asymmetrical and incomplete. This is a mathematical issue stemming from the improvement in logic that people called \"fuzzy logic\", which was popular perhaps 20 years ago, but now forgotten.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/fn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Above i meant a fully modeled boolean has 4 states, 2 bits data store, not 4 bits.\n\nExcel has an extended arithmetic, which is carried in each cell. In Excel each cell holding a value has these 2 extra states (#UNDEF and #ERROR) so that you don't need a second cell. In a programming language, if you only allocate 1 bit for the boolean, you cannot represent these two additional states, so you then must allocate another variable to hold it. Or maybe you set it to false which is making up a possibly incorrect value (a bad thing).  A second value for tracking additional values is massively inconvenient, and would mean when you pass that value to a function you would also need to send the second parameter. Since every program is about manipulating data via code, when you start talking about type systems you are also assuming some kind of arithmetic system. Whether you like it or not, you always have these 2 extra states for every variable. You might have omitted to enter the value, or the value is derived from another value that was in error.  For example  a = sqrt(-1);  b=a*2; c = b<2;  In this case, A would be ERROR, and B would evaluate to ERROR as well, and so would C. You can't claim that true or false is correct in the case of C. Yes this is a rarely encountered edge case. But if you want your program to survive erroneous or missing data, you need this extended and protected form of arithmetic. The problem i have with type discussions in this forum is the way people gloss over these exceptions. You won't bother to check every arithmetic operation for some missing data, so the correct approach is to let your arithmetic be closed, and no operation stops the program (unless you are in debugging mode). Every data type needs these base values, because strings can be missing too, and in loosely typed languages you might try to rotate a number instead of a bitmap...  since it is nonsensical, you need that error state to track this so you don't build on top of an error.\n\nHaving protected arithmetic means you won't have to do as much testing on your code, because you aren't so worried about bad inputs causing crazy behavior. Test driven design has become popular with some because they know how flabby their code is and they would prefer to more fully exercise the combinations and permutations. I say screw all that extra work on testing, just make the code impregnable and save the effort of doing exhaustive tests.\n\nNowadays with consumers running millions of copies of software, it isn't considered acceptable to crash on erroneous or missing data. Maybe it was okay back in the day where the person controlling the input data was the same person running the program, but exceptions are a terrible way to handle errors.\n\nMy assertion is that exceptions are a bad idea. You must be prepared to survive bad or missing data. You are not going to be able to figure out where all the numerical exceptions could originate, much less recover from them, and to have anything less than Excel's extended arithmetic is the wrong direction IMHO. There are too many statements in your program that do arithmetic.  Every atomic value in Beads has an error or undefined base value. JS got tantalizingly close with their undefined and NaN value sets, but not allow an Error value on booleans, nor did they consider it for strings or objects, etc.  The arithmetic in JS is asymmetrical and incomplete. This is a mathematical issue stemming from the improvement in logic that people called \"fuzzy logic\", which was popular perhaps 20 years ago, but now forgotten."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1583622030.067700",
        "client_msg_id": "7d5f72ea-d16d-4539-87dd-76c0bc5d3e5b",
        "text": "Doesn't catching exceptions at the right granularity address your criticism? There seem to be complementary strengths and weaknesses here. Operations that silently propagate errors make bugs hard to diagnose. Exceptions cause crashes. This is why my (implied but not explicitly stated) position in this thread has been that the extra states you need to represent error are a domain-dependent concern. And, what's more, you often want different solutions for different parts of your program. These are just tools. A decree that \"all variables shalt have #UNDEF and #ERROR\" seems too blunt. Particularly since it requires programmers to be mindful of these states to work. JavaScript programmers largely try to ignore `undefined` as much as possible, which entirely defeats the point.\n\nHere's an example of a major domain where you absolutely want 2-state booleans: Boolean satisfiability (SAT) solvers. Adding extra states here would make tractable problems intractable.\n\n(Apologies for the harshness of my previous comment in this thread. I plead sleep deprivation.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q8D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Doesn't catching exceptions at the right granularity address your criticism? There seem to be complementary strengths and weaknesses here. Operations that silently propagate errors make bugs hard to diagnose. Exceptions cause crashes. This is why my (implied but not explicitly stated) position in this thread has been that the extra states you need to represent error are a domain-dependent concern. And, what's more, you often want different solutions for different parts of your program. These are just tools. A decree that \"all variables shalt have #UNDEF and #ERROR\" seems too blunt. Particularly since it requires programmers to be mindful of these states to work. JavaScript programmers largely try to ignore "
                            },
                            {
                                "type": "text",
                                "text": "undefined",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as much as possible, which entirely defeats the point.\n\nHere's an example of a major domain where you absolutely want 2-state booleans: Boolean satisfiability (SAT) solvers. Adding extra states here would make tractable problems intractable.\n\n(Apologies for the harshness of my previous comment in this thread. I plead sleep deprivation.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1583622785.068000",
        "client_msg_id": "17d65041-ce2c-49fd-a7ae-c14eb8d86d5d",
        "text": "Exceptions in many languages create action at a distance, making it extremely hard to understand program flow. I think exceptions are one of the worst features of Java, and a major factor in its poor reliability. I can't recall how many times i have seen a 100 nested level deep nil pointer exception in some Java program. Erlang\/Elixir uses an interesting approach, that of crashing on an error, with the plan that the process will be automatically respawned by some monitor program. I like how Excel has never crashed on me. There is something comforting about a system that is sturdy and doesn't collapse or freeze the minute someone forgets to enter a value, or puts in a bad piece of data. Of course one validates input data as thoroughly as possible, but with data arriving over the internet, you can't assume it is going to be perfect.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1583191231.023700",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CKAJd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Exceptions in many languages create action at a distance, making it extremely hard to understand program flow. I think exceptions are one of the worst features of Java, and a major factor in its poor reliability. I can't recall how many times i have seen a 100 nested level deep nil pointer exception in some Java program. Erlang\/Elixir uses an interesting approach, that of crashing on an error, with the plan that the process will be automatically respawned by some monitor program. I like how Excel has never crashed on me. There is something comforting about a system that is sturdy and doesn't collapse or freeze the minute someone forgets to enter a value, or puts in a bad piece of data. Of course one validates input data as thoroughly as possible, but with data arriving over the internet, you can't assume it is going to be perfect."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]