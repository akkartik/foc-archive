[
    {
        "user": "U04JY2BF24E",
        "type": "message",
        "ts": "1714062480.601149",
        "client_msg_id": "a98736ec-edd5-47ff-a7a5-f74c6db73e9d",
        "text": "Does anyone else think of \"configuring\" as distinct from \"programming\"? Some activities I consider \"configuring\" and not \"programming\": much devops work such as Terraform, YML files for build pipelines, even commonly labeled \"programming\" of a VCR\/DVR.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "154a9d12968c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-06-13\/5441522160256_154a9d12968ca5a13cf5_72.jpg",
            "first_name": "Greg",
            "real_name": "Greg Bylenok",
            "display_name": "Greg Bylenok",
            "team": "T5TCAFTA9",
            "name": "gregory.bylenok",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1714062480.601149",
        "reply_count": 18,
        "reply_users_count": 9,
        "latest_reply": "1715009040.827459",
        "reply_users": [
            "U04JY2BF24E",
            "UK3LH8CF5",
            "U5STGTB3J",
            "U06H4766K42",
            "U03U0SCU5LH",
            "UP00ZLX6G",
            "UCS1K3QTH",
            "U05TJD2V4P2",
            "ULYDR7EP3"
        ],
        "replies": [
            {
                "user": "U04JY2BF24E",
                "ts": "1714062600.597209"
            },
            {
                "user": "UK3LH8CF5",
                "ts": "1714063576.189149"
            },
            {
                "user": "U04JY2BF24E",
                "ts": "1714064387.211259"
            },
            {
                "user": "U5STGTB3J",
                "ts": "1714065055.059049"
            },
            {
                "user": "UK3LH8CF5",
                "ts": "1714081240.001419"
            },
            {
                "user": "U06H4766K42",
                "ts": "1714081458.372869"
            },
            {
                "user": "U03U0SCU5LH",
                "ts": "1714112592.470409"
            },
            {
                "user": "UP00ZLX6G",
                "ts": "1714116893.449839"
            },
            {
                "user": "UCS1K3QTH",
                "ts": "1714139131.472379"
            },
            {
                "user": "UCS1K3QTH",
                "ts": "1714139216.639929"
            },
            {
                "user": "U04JY2BF24E",
                "ts": "1714139773.335279"
            },
            {
                "user": "UCS1K3QTH",
                "ts": "1714139808.780739"
            },
            {
                "user": "UCS1K3QTH",
                "ts": "1714142207.870779"
            },
            {
                "user": "U05TJD2V4P2",
                "ts": "1714609418.045629"
            },
            {
                "user": "ULYDR7EP3",
                "ts": "1714764956.820209"
            },
            {
                "user": "U05TJD2V4P2",
                "ts": "1715008576.117109"
            },
            {
                "user": "UK3LH8CF5",
                "ts": "1715008706.450159"
            },
            {
                "user": "U05TJD2V4P2",
                "ts": "1715009040.827459"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2BCzi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Does anyone else think of \"configuring\" as distinct from \"programming\"? Some activities I consider \"configuring\" and not \"programming\": much devops work such as Terraform, YML files for build pipelines, even commonly labeled \"programming\" of a VCR\/DVR."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04JY2BF24E",
        "type": "message",
        "ts": "1714062600.597209",
        "client_msg_id": "0bad6f95-e25a-40c1-9c6d-061570db2fb0",
        "text": "This question prompted by latest FoC podcast. Maybe my distinction is not academically interesting. But personally, I find \"configuring\" activities inherently unsatisfying, while \"programming\" demands enough creativity to keep me interested.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "154a9d12968c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-06-13\/5441522160256_154a9d12968ca5a13cf5_72.jpg",
            "first_name": "Greg",
            "real_name": "Greg Bylenok",
            "display_name": "Greg Bylenok",
            "team": "T5TCAFTA9",
            "name": "gregory.bylenok",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1714062480.601149",
        "parent_user_id": "U04JY2BF24E",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vJIlF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This question prompted by latest FoC podcast. Maybe my distinction is not academically interesting. But personally, I find \"configuring\" activities inherently unsatisfying, while \"programming\" demands enough creativity to keep me interested."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UDQBTJ211",
                    "UCS1K3QTH"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UK3LH8CF5",
        "type": "message",
        "ts": "1714063576.189149",
        "client_msg_id": "87C16F24-BC73-4C2D-9EAE-F643EB3BAE8D",
        "text": "I think many times the distinction for me ends up being a matter of interface. I feel much more like I’m programming when doing the CDK vs doing Cloudformation. Yet, I’m accomplishing the same task. I don’t think it is because one is TS and one yaml, but the kinds of concepts I have to think about and the ability to build abstractions. \n\nConfiguration, to me, ends up being a fill in the blank rather than a crafting. It’s like painting by numbers. Even though in the cdk, I am given a bunch of material to work with, and constraints on it, I still get to put that material together. I still can look at how it was implemented, I can still tear it apart and do something different. I can’t with configuration. I’m stuck listing details I don’t want to list. \n\nI definitely find all configuration tasks deeply unsatisfying and it’s one of the things I don’t like about “low code” tools as they are generally made. They are just configuration. No way to dive in, no way to remix, to take parts apart and make them do something new.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1714062480.601149",
        "parent_user_id": "U04JY2BF24E",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R1t7O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think many times the distinction for me ends up being a matter of interface. I feel much more like I’m programming when doing the CDK vs doing Cloudformation. Yet, I’m accomplishing the same task. I "
                            },
                            {
                                "type": "text",
                                "text": "don’t"
                            },
                            {
                                "type": "text",
                                "text": " think it is because one is TS and one "
                            },
                            {
                                "type": "text",
                                "text": "y"
                            },
                            {
                                "type": "text",
                                "text": "aml, but the kinds of concepts I have to think about and the ability to build abstractions. \n\nConfiguration, to me, ends up being a fill in the blank rather than a crafting. It’s like painting by numbers. Even though in the cdk, I am given a bunch of material to work with, and constraints on it, I still get to put that material together. I still can look at how it was implemented, I can still tear it apart and do something different. I can’t with configuration. I’m stuck listing details I don’t want to list. \n\nI definitely find all configuration tasks deeply unsatisfying and "
                            },
                            {
                                "type": "text",
                                "text": "it’s"
                            },
                            {
                                "type": "text",
                                "text": " one of the things I "
                            },
                            {
                                "type": "text",
                                "text": "don’t"
                            },
                            {
                                "type": "text",
                                "text": " like about “low code” tools as they are generally made. They are just configuration. No way to dive in, no way to remix, to take parts apart and make them do something new."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "URKQXRCAC",
                    "UP00ZLX6G",
                    "U06SAHMJCG2",
                    "U0112C10V4Y"
                ],
                "count": 4
            }
        ]
    },
    {
        "user": "U04JY2BF24E",
        "type": "message",
        "ts": "1714064387.211259",
        "client_msg_id": "0b88e804-077d-41be-a3c9-72af2cb29aff",
        "text": "Yes! This relates to the very end of the episode, where (if I interpret correctly) Ivan imagines a world where general purpose programming languages are replaced (or supplanted) by domain-specific tooling. To reach that point, it seems we need to constrain the problem space to the point where the activity of programming becomes less interesting. Maybe I focus my attention elsewhere, though, to the output of the activity rather than the activity itself.\n\nAnother small distinction in my mind is the addition of boolean logic and branching. I know, there are plenty of programming languages that don't involve branching. I know I shouldn't be constraining myself to the Von Neumann architecture. Still, branching offers freedom that makes the activity of programming more intellectually interesting.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "154a9d12968c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-06-13\/5441522160256_154a9d12968ca5a13cf5_72.jpg",
            "first_name": "Greg",
            "real_name": "Greg Bylenok",
            "display_name": "Greg Bylenok",
            "team": "T5TCAFTA9",
            "name": "gregory.bylenok",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1714062480.601149",
        "parent_user_id": "U04JY2BF24E",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "G8ypZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes! This relates to the very end of the episode, where (if I interpret correctly) Ivan imagines a world where general purpose programming languages are replaced (or supplanted) by domain-specific tooling. To reach that point, it seems we need to constrain the problem space to the point where the activity of programming becomes less interesting. Maybe I focus my attention elsewhere, though, to the output of the activity rather than the activity itself.\n\nAnother small distinction in my mind is the addition of boolean logic and branching. I know, there are plenty of programming languages that don't involve branching. I know I shouldn't be constraining myself to the Von Neumann architecture. Still, branching offers freedom that makes the activity of programming more intellectually interesting."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U5STGTB3J",
        "type": "message",
        "ts": "1714065055.059049",
        "client_msg_id": "7B98BDD2-88AC-4378-ADD7-BC09276EB54F",
        "text": "My naive distinction between programming and configuration is that the former is specifying dynamic behavior of a system while the latter is providing initial values to it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "649181907e06",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_72.jpg",
            "first_name": "Stefan",
            "real_name": "Stefan Lesser",
            "display_name": "Stefan",
            "team": "T5TCAFTA9",
            "name": "stefanlesser",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1714062480.601149",
        "parent_user_id": "U04JY2BF24E",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "twHAj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My naive distinction between programming and configuration is that the former is specifying dynamic behavior of a system while the latter is providing initial values to it"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCS1K3QTH",
                    "U06SAHMJCG2"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UK3LH8CF5",
        "type": "message",
        "ts": "1714081240.001419",
        "client_msg_id": "05025E5C-7B8C-49C4-8121-A0607F5CC62C",
        "text": "For what it’s worth Ivan’s definition of domain specific includes things like Elm. So I’d assume he’d imagine not a less powerful setup, but a tailor made approach. I definitely think there is a danger in going the direction of configuration though. ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4377ee2417eb",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-25\/886144219253_4377ee2417eb9eaacd4b_72.jpg",
            "first_name": "Jimmy",
            "real_name": "Jimmy Miller",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jimmyhmiller",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1714062480.601149",
        "parent_user_id": "U04JY2BF24E",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FSERA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For what it’s worth Ivan’s definition of domain specific includes things like Elm. So I’d assume he’d imagine not a less powerful setup, but a tailor made approach. I definitely think there is a danger in going the direction of configuration though. "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06H4766K42",
        "type": "message",
        "ts": "1714081458.372869",
        "client_msg_id": "C85EB00A-8F94-462B-B607-37917CF290FD",
        "text": "Sounds like Racket Lang could be a solid bet if they can withstand the elites knocking performance and distribution issues out. I do know someone was playing with emitting web assembly from Racket for distribution and runtimes. ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ead28e1d251c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-02-04\/6594898212609_ead28e1d251ce07fa4fa_72.jpg",
            "first_name": "Justin",
            "real_name": "Justin Janes",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "justinjjanes",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1714062480.601149",
        "parent_user_id": "U04JY2BF24E",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+INcT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sounds like Racket Lang could be a solid bet if they can withstand the elites knocking performance and distribution issues out"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " I do know someone was playing with emitting web assembly from Racket for distribution and runtimes"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U03U0SCU5LH",
        "type": "message",
        "ts": "1714110480.830759",
        "edited": {
            "user": "U03U0SCU5LH",
            "ts": "1714110503.000000"
        },
        "client_msg_id": "4337a891-95c6-4cf5-a58b-d8c2179bba83",
        "text": "Miqula also has value graphs. When I started coding it, I didn't even know blueprints had \"execution\" wires, how could one do such a hideous thing! To split the execution, I use subnets, for example in a condition, one for true and one that is executed for false. That doesn't solve all problems though, if one would do for example\n\n```foo != nullptr ->\nfoo->IsValid() ->\n-> both connected to an && node```\nyou don't need to do subnets, it just does the most sensible thing.\n\nAs for side effects, a \"regular graph\" has none, except assertions (exceptions). To do effects on the world, I use a behavior tree (which is nicely composable). The leaf nodes have regular graphs, which then  may contain nodes with side effects (for example to send messages \/ spawn objects).\n\nBe aware that dataflow programming (with pure functions) is a different model. Most people are used to do the \"little robot in your head\" that does stuff, one after the other (which is procedural programming). In dataflow, you are wiring dependencies \/ data together to create new data. You look at the data instead of the instruction.\nI'm curious as how you want to design around these problems and how it fit's into an ECS.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gdf6784b7d6d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/df6784b7d6d97fb67dec89320cc88a84.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0007-72.png",
            "first_name": "Dany",
            "real_name": "Dany",
            "display_name": "Dany",
            "team": "T5TCAFTA9",
            "name": "bitteldany",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1713941430.437429",
        "parent_user_id": "UFS53UWE5",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kJgtL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Miqula also has value graphs. When I started coding it, I didn't even know blueprints had \"execution\" wires, how could one do such a hideous thing! To split the execution, I use subnets, for example in a condition, one for true and one that is executed for false. That doesn't solve all problems though, if one would do for example\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "foo != nullptr ->\nfoo->IsValid() ->\n-> both connected to an && node"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nyou don't need to do subnets, it just does the most sensible thing.\n\nAs for side effects, a \"regular graph\" has none, except assertions (exceptions). To do effects on the world, I use a behavior tree (which is nicely composable). The leaf nodes have regular graphs, which then  may contain nodes with side effects (for example to send messages \/ spawn objects).\n\nBe aware that dataflow programming (with pure functions) is a different model. Most people are used to do the \"little robot in your head\" that does stuff, one after the other (which is procedural programming). In dataflow, you are wiring dependencies \/ data together to create new data. You look at the data instead of the instruction.\nI'm curious as how you want to design around these problems and how it fit's into an ECS."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U03U0SCU5LH",
        "type": "message",
        "ts": "1714112592.470409",
        "client_msg_id": "2a2b6de8-6069-4d96-af41-625298be096d",
        "text": "I see it the same way as <@U5STGTB3J>. The configuration is declarative programming that defines constant values (like HTML \/ CSS..). I think a PL should be able to do both (and distinguish between the two). You can have branching in a declarative PL, but it will be resolved at compile time.\nOne could argue that an executable is also a \"constant\", so all programming is configuration, but I think the difference is that the interactions are defined in the executable, if you have a constant, they are defined in the player.\nMy last blog post touches on this.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gdf6784b7d6d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/df6784b7d6d97fb67dec89320cc88a84.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0007-72.png",
            "first_name": "Dany",
            "real_name": "Dany",
            "display_name": "Dany",
            "team": "T5TCAFTA9",
            "name": "bitteldany",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1714062480.601149",
        "parent_user_id": "U04JY2BF24E",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JHQZC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I see it the same way as "
                            },
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": ". The configuration is declarative programming that defines constant values (like HTML \/ CSS..). I think a PL should be able to do both (and distinguish between the two). You can have branching in a declarative PL, but it will be resolved at compile time.\nOne could argue that an executable is also a \"constant\", so all programming is configuration, but I think the difference is that the interactions are defined in the executable, if you have a constant, they are defined in the player.\nMy last blog post touches on this."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]