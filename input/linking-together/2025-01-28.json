[
    {
        "user": "U089J8FNGB1",
        "type": "message",
        "ts": "1738070851.911179",
        "client_msg_id": "da224303-b974-45f6-a2ef-2ba176144ece",
        "text": "this is a small neat thing: <https:\/\/perthirtysix.com\/communal-plot-daily-poll>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5caead19f58",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5caead19f5842ccdc759880c60e7c699.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0005-72.png",
            "first_name": "Bill",
            "real_name": "Bill Mill",
            "display_name": "Bill Mill",
            "team": "T5TCAFTA9",
            "name": "bill",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "image_url": "https:\/\/perthirtysix.com\/img\/complot-banner.png",
                "image_width": 1561,
                "image_height": 975,
                "image_bytes": 190656,
                "from_url": "https:\/\/perthirtysix.com\/communal-plot-daily-poll",
                "service_icon": "https:\/\/perthirtysix.com\/favicon.ico",
                "id": 1,
                "original_url": "https:\/\/perthirtysix.com\/communal-plot-daily-poll",
                "fallback": "The Communal Plot | A Daily Visualization We All Build Together",
                "text": "Interactively respond to a daily poll and see how your responses compare to others in real-time!",
                "title": "The Communal Plot | A Daily Visualization We All Build Together",
                "title_link": "https:\/\/perthirtysix.com\/communal-plot-daily-poll",
                "service_name": "perthirtysix.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wyQ9D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this is a small neat thing: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/perthirtysix.com\/communal-plot-daily-poll"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U023V63MF6V",
                    "U02U0AS3J49"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "U08A3DJ5VKM",
        "type": "message",
        "ts": "1738080875.010749",
        "edited": {
            "user": "U08A3DJ5VKM",
            "ts": "1738099259.000000"
        },
        "client_msg_id": "63c57401-f7a9-41d6-880e-76c48d3071c3",
        "text": "If you squint a little you see that's very similar to how compiled code is actually executed at the low-level, where procedures put their return values on a stack, to then be picked up by the next procedure in the queue. There's no direct coupling except for the ordering of procedures. I think lifting this paradigm so we could program like this at a higher level would be tremendously fun! We sort of have it with languages like <https:\/\/github.com\/factor\/factor|Factor>, but I personally find this breed of languages awkward to work with. Once you have the high level words defined they're ok, but to get there you have to code lots of <https:\/\/github.com\/factor\/factor\/blob\/master\/extra\/html\/parser\/parser.factor|small procedures>, which IMO imposes some heavy cognitive load",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "f15ff7293c76",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-24\/8368890056976_f15ff7293c7610751dc7_72.jpg",
            "first_name": "Jon",
            "real_name": "Jon Secchis",
            "display_name": "Jon Secchis",
            "team": "T5TCAFTA9",
            "name": "jon979",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737733719.957079",
        "parent_user_id": "U08A3DJ5VKM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jZg7M",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you squint a little you see that's very similar to how compiled code is actually executed at the low-level, where procedures put their return values on a stack, to then be picked up by the next procedure in the queue. There's no direct coupling except for the ordering of procedures. I think lifting this paradigm so we could program like this at a higher level would be tremendously fun! We sort of have it with languages like "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/factor\/factor",
                                "text": "Factor"
                            },
                            {
                                "type": "text",
                                "text": ", but I personally find this breed of languages awkward to work with. Once you have the high level words defined they're ok, but to get there you have to code lots of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/factor\/factor\/blob\/master\/extra\/html\/parser\/parser.factor",
                                "text": "small procedures"
                            },
                            {
                                "type": "text",
                                "text": ", which IMO imposes some heavy cognitive load"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1738086207.135309",
        "client_msg_id": "021894da-e3fc-4547-8213-103af7df5a8f",
        "text": "&gt; code lots of <https:\/\/github.com\/factor\/factor\/blob\/master\/extra\/html\/parser\/parser.factor|small procedures>, which IMO imposes some heavy cognitive load\nThe cognitive loading does not come from the small-ness of the procedures, but, is due to the flat-ness of the namespace, i.e. the \"infinite canvas\" mentality. The UNIX shell gets around this problem by allowing layering. A shell script can invoke commands or other shell scripts to an infinite depth (as opposed to infinite breadth). The shell and functional programming, fail to restrict this concept. There should be one kind of part to choreograph parts and another kind of part to do the work. Functions allow you to do this, but, functions don't restrict you from doing something broader, too. It's kinda like the GOTO problem in the early days, you _could_ write structured programs using GOTOs but the existence of GOTOs tempted one to break structuring. Here, it's the same, you _can_ write layered programs, but, you tend not to. Just try to understand someone else's code, 90% of the time it's hard, only a few programmers actually shine through as being capable of \"writing good code\".\n\nAnother thing to note: UNIX worker commands cannot directly invoke other commands [*]. The UNIX kernel provides a privileged routine called the Dispatcher which decides which command gets to run and when. Again, it is easy to do this with closures choreographed by connecting layers, but, one tends not to structure code this way due to lack of enforced structuring constraints. A piece of worker code that CALLs another piece of code breaks the UNIX-y data-flow (message-sending) paradigm.\n\nOne must be careful of stack-based ideas. LIFO-based code works on single computer systems, but breaks down in distributed systems, due to under-the-hood coupling caused by the global-ness of the stack. Code that works on single computers, doesn't necessarily scale up when distributed across many computers. [Elsewhere, I argue that context-switching is a crutch that doesn't scale well. We'd be better off using closures and message-sending using FIFO queues. Using functions works on paper for mathematics, but, isn't such a good paradigm for distributed computing].\n\n[*] Modulo tricky uses of system calls, etc.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737733719.957079",
        "parent_user_id": "U08A3DJ5VKM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U0Gfq",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "code lots of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/factor\/factor\/blob\/master\/extra\/html\/parser\/parser.factor",
                                "text": "small procedures"
                            },
                            {
                                "type": "text",
                                "text": ", which IMO imposes some heavy cognitive load"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe cognitive loading does not come from the small-ness of the procedures, but, is due to the flat-ness of the namespace, i.e. the \"infinite canvas\" mentality. The UNIX shell gets around this problem by allowing layering. A shell script can invoke commands or other shell scripts to an infinite depth (as opposed to infinite breadth). The shell and functional programming, fail to restrict this concept. There should be one kind of part to choreograph parts and another kind of part to do the work. Functions allow you to do this, but, functions don't restrict you from doing something broader, too. It's kinda like the GOTO problem in the early days, you "
                            },
                            {
                                "type": "text",
                                "text": "could",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " write structured programs using GOTOs but the existence of GOTOs tempted one to break structuring. Here, it's the same, you "
                            },
                            {
                                "type": "text",
                                "text": "can",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " write layered programs, but, you tend not to. Just try to understand someone else's code, 90% of the time it's hard, only a few programmers actually shine through as being capable of \"writing good code\".\n\nAnother thing to note: UNIX worker commands cannot directly invoke other commands [*]. The UNIX kernel provides a privileged routine called the Dispatcher which decides which command gets to run and when. Again, it is easy to do this with closures choreographed by connecting layers, but, one tends not to structure code this way due to lack of enforced structuring constraints. A piece of worker code that CALLs another piece of code breaks the UNIX-y data-flow (message-sending) paradigm.\n\nOne must be careful of stack-based ideas. LIFO-based code works on single computer systems, but breaks down in distributed systems, due to under-the-hood coupling caused by the global-ness of the stack. Code that works on single computers, doesn't necessarily scale up when distributed across many computers. [Elsewhere, I argue that context-switching is a crutch that doesn't scale well. We'd be better off using closures and message-sending using FIFO queues. Using functions works on paper for mathematics, but, isn't such a good paradigm for distributed computing].\n\n[*] Modulo tricky uses of system calls, etc."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U08A3DJ5VKM",
        "type": "message",
        "ts": "1738099854.642659",
        "edited": {
            "user": "U08A3DJ5VKM",
            "ts": "1738099911.000000"
        },
        "client_msg_id": "423210cb-46bd-4c0e-b3d9-8896227b5d42",
        "text": "Very interesting remark regarding stack vs queue for coordination. On this context, doesn't using queues for inter-procedure messaging implies the need for \"actors\"? I mean, if there're per-procedure queue you'll always end up in Erlang land, no? Now you need addresses and lightweight processes, since all procedures need to be \"live\". I'm not saying it's bad, but definitely an explosion in complexity. I wonder if using something like a global tuple-space as a communication backbone isn't a simpler mechanism of equal capability, which further decouples components. Since retrieving a tuple from the space requires a query, the addressing scheme is lifted to the domain of application conventions, giving much more flexibility in exchange for more discipline. I'd be fine with that trade-off. The advantage of tuple-spaces is that the whole system can be made heterogeneous, you're not forced to use a single language and environment.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "f15ff7293c76",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-24\/8368890056976_f15ff7293c7610751dc7_72.jpg",
            "first_name": "Jon",
            "real_name": "Jon Secchis",
            "display_name": "Jon Secchis",
            "team": "T5TCAFTA9",
            "name": "jon979",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737733719.957079",
        "parent_user_id": "U08A3DJ5VKM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N3O+u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Very interesting remark regarding stack vs queue for coordination. On this context, doesn't using queues for inter-procedure messaging implies the need for \"actors\"? I mean, if there're per-procedure queue you'll always end up in Erlang land, no? Now you need addresses and lightweight processes, since all procedures need to be \"live\". I'm not saying it's bad, but definitely an explosion in complexity. I wonder if using something like a global tuple-space as a communication backbone isn't a simpler mechanism of equal capability, which further decouples components. Since retrieving a tuple from the space requires a query, the addressing scheme is lifted to the domain of application conventions, giving much more flexibility in exchange for more discipline. I'd be fine with that trade-off. The advantage of tuple-spaces is that the whole system can be made heterogeneous, you're not forced to use a single language and environment."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]