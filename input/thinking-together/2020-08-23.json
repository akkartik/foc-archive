[
    {
        "text": "FWIW, I watched this coding adventure yesterday; I'm a big fan of his and always wonder how he puts together such great videos - he seems to bend Unity to his will for the teaching parts as well as the rendering parts.  I have coincidentally implemented the same approach in the paper he used, as part of a game prototype I was playing with (some eye candy enclosed - must revisit this project at some point!)\nMy approach is probably slightly different though.  I'm  more of an 'implementer' than a scientist\/academic, and I often struggle with hard math.  My approach is typically to iterate towards a goal in very small steps without getting bogged down in the detail; and it can take several days to get through the technical challenge.  I'm in awe of anyone who can read a paper full of Integrals and translate it to code.  That would be highly efficient!  I rely on following my nose and looking at sample code far more than the math.\nPart of the reason I'm always messing with visualization tools and visual programming is that they are the only chance I have to understand.\n\"The way I truly understood integrals and summations was through implementing them as for loops.\" This + 1000, basically :wink:\nAnd Monads.... I've read a few articles, but until I actually get to use one in a program I won't understand them.\nPerhaps Sebastien is just really smart (I'm sure he is), but what intrigues me is, has he got to that place by building a set of tools and technologies around himself, such that he can break any problem up into pieces he understands?  i.e. The fact that he can plot and interact with graphs while building his code gives him a deeper\/quicker understanding of each step?  Just more validation of Bret Victor's approach, I guess....",
        "files": [
            {
                "id": "F019BHQ8CMR",
                "mode": "tombstone"
            },
            {
                "id": "F01A16YHR6U",
                "mode": "tombstone"
            }
        ],
        "upload": false,
        "user": "UUQ2EQW21",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1yg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FWIW, I watched this coding adventure yesterday; I'm a big fan of his and always wonder how he puts together such great videos - he seems to bend Unity to his will for the teaching parts as well as the rendering parts.  I have coincidentally implemented the same approach in the paper he used, as part of a game prototype I was playing with (some eye candy enclosed - must revisit this project at some point!)\nMy approach is probably slightly different though.  I'm  more of an 'implementer' than a scientist\/academic, and I often struggle with hard math.  My approach is typically to iterate towards a goal in very small steps without getting bogged down in the detail; and it can take several days to get through the technical challenge.  I'm in awe of anyone who can read a paper full of Integrals and translate it to code.  That would be highly efficient!  I rely on following my nose and looking at sample code far more than the math.\nPart of the reason I'm always messing with visualization tools and visual programming is that they are the only chance I have to understand.\n\"The way I truly understood integrals and summations was through implementing them as for loops.\" This + 1000, basically "
                            },
                            {
                                "type": "emoji",
                                "name": "wink",
                                "unicode": "1f609"
                            },
                            {
                                "type": "text",
                                "text": "\nAnd Monads.... I've read a few articles, but until I actually get to use one in a program I won't understand them.\nPerhaps Sebastien is just really smart (I'm sure he is), but what intrigues me is, has he got to that place by building a set of tools and technologies around himself, such that he can break any problem up into pieces he understands?  i.e. The fact that he can plot and interact with graphs while building his code gives him a deeper\/quicker understanding of each step?  Just more validation of Bret Victor's approach, I guess...."
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1598168499.063100",
        "edited": {
            "user": "UUQ2EQW21",
            "ts": "1598168594.000000"
        },
        "thread_ts": "1598125322.060600",
        "parent_user_id": "U01661S9F34",
        "reactions": [
            {
                "name": "amiga-tick",
                "users": [
                    "U01661S9F34",
                    "UBSMEUXAA"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1598170104.064000",
        "edited": {
            "user": "UJBAJNFLK",
            "ts": "1598170144.000000"
        },
        "client_msg_id": "b8df5a53-61ad-449c-b8fa-7553a2a58c5e",
        "text": "Quoting Donald Knuth (source: <http:\/\/www.jstor.org\/stable\/2318994>): \"It has often been said that a person does not really understand something until he teaches it to someone else. Actually a person does not really understand something until he can teach it to a computer, i.e. express it as an algorithm. The attempt to formalize things as algorithms leads to a much deeper understanding than if we simply try to comprehend things in the traditional way.\"",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598125322.060600",
        "parent_user_id": "U01661S9F34",
        "attachments": [
            {
                "title": "     Computer Science and Its Relation to Mathematics on JSTOR ",
                "title_link": "http:\/\/www.jstor.org\/stable\/2318994",
                "text": "Donald E. Knuth, Computer Science and Its Relation to Mathematics, The American Mathematical Monthly, Vol. 81, No. 4 (Apr., 1974), pp. 323-343",
                "fallback": "     Computer Science and Its Relation to Mathematics on JSTOR ",
                "from_url": "http:\/\/www.jstor.org\/stable\/2318994",
                "service_icon": "http:\/\/www.jstor.org\/assets\/global_20200804T2113\/build\/images\/favicons\/apple-touch-icon.png",
                "service_name": "jstor.org",
                "id": 1,
                "original_url": "http:\/\/www.jstor.org\/stable\/2318994"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TWI8n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Quoting Donald Knuth (source: "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/www.jstor.org\/stable\/2318994"
                            },
                            {
                                "type": "text",
                                "text": "): \"It has often been said that a person does not really understand something until he teaches it to someone else. Actually a person does not really understand something until he can teach it to a computer, i.e. express it as an algorithm. The attempt to formalize things as algorithms leads to a much deeper understanding than if we simply try to comprehend things in the traditional way.\""
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7",
                    "UKP3B2J5D"
                ],
                "count": 2
            },
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U015V233CFL",
                    "U01661S9F34",
                    "UML4ZEKDK",
                    "UJ6LDMMN0"
                ],
                "count": 5
            }
        ]
    },
    {
        "user": "U013ZLJARC7",
        "type": "message",
        "ts": "1598182224.064600",
        "client_msg_id": "ee472377-e73b-4fe0-ae92-ace216b93994",
        "text": "Re: personal style, I find mathematical concepts to be much more naturally expressed using functional programming rather than imperative, but no matter one's preferred style it seems clear to me that programming is <https:\/\/www.bootstrapworld.org|a better vehicle for teaching mathematics> than the standard mathematical pedagogy. Likewise, I'm in strong agreement with Sussman that traditional mathematical notation is strictly inferior to writing everything down in an <https:\/\/en.wikipedia.org\/wiki\/Structure_and_Interpretation_of_Classical_Mechanics|unambiguous machine executable notation>.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8ea58fc41bd6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-10-13\/6057269405632_8ea58fc41bd6baa7dda6_72.png",
            "first_name": "",
            "real_name": "Jack Rusher",
            "display_name": "Jack Rusher",
            "team": "T5TCAFTA9",
            "name": "jack529",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598125322.060600",
        "parent_user_id": "U01661S9F34",
        "attachments": [
            {
                "title": "Bootstrap",
                "title_link": "https:\/\/www.bootstrapworld.org\/",
                "text": "Teaching Algebra through Computer Science",
                "fallback": "Bootstrap",
                "image_url": "http:\/\/www.bootstrapworld.org\/images\/engineer.jpg",
                "image_width": 332,
                "image_height": 250,
                "from_url": "https:\/\/www.bootstrapworld.org\/",
                "image_bytes": 52533,
                "service_icon": "https:\/\/www.bootstrapworld.org\/favicon.ico",
                "service_name": "bootstrapworld.org",
                "id": 1,
                "original_url": "https:\/\/www.bootstrapworld.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ed3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Re: personal style, I find mathematical concepts to be much more naturally expressed using functional programming rather than imperative, but no matter one's preferred style it seems clear to me that programming is "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.bootstrapworld.org",
                                "text": "a better vehicle for teaching mathematics"
                            },
                            {
                                "type": "text",
                                "text": " than the standard mathematical pedagogy. Likewise, I'm in strong agreement with Sussman that traditional mathematical notation is strictly inferior to writing everything down in an "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Structure_and_Interpretation_of_Classical_Mechanics",
                                "text": "unambiguous machine executable notation"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UUQ2EQW21",
                    "UKP3B2J5D",
                    "UJUQESQ1Z",
                    "UFQQ3P867"
                ],
                "count": 4
            },
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U01661S9F34",
                    "UKP3B2J5D"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1598209565.065600",
        "client_msg_id": "13cef80b-fb94-4d34-a74e-9081f2222347",
        "text": "I used to agree with Sussman, but I have changed my mind a bit: unambiguous, yes, but not necessarily executable. Much of what you write down in mathematics and mathematically formulated science is specifications. For example differential equations such as Newton's. You really want to be able to write such specifications without necessarily doing something specific with them.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598125322.060600",
        "parent_user_id": "U01661S9F34",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hsa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I used to agree with Sussman, but I have changed my mind a bit: unambiguous, yes, but not necessarily executable. Much of what you write down in mathematics and mathematically formulated science is specifications. For example differential equations such as Newton's. You really want to be able to write such specifications without necessarily doing something specific with them."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1598221174.065800",
        "client_msg_id": "c4e9d8a9-eb26-471a-b558-dcd90071bd78",
        "text": "In the 1950's, Kenneth Iverson was a math professor at Harvard. He designed APL as an unambigous, expressive mathematical notation, for teaching math to undergrads, and for his personal use solving research problems and writing books and research papers. Iverson joined IBM as a mathematician, where he used his notation to formalize and specify the instruction sets of the 7090 and 360 computers. Only after that, the project at IBM to implement APL as a programming language.\n\nAPL doesn't usually get much credit for its influence on modern programming systems (although Mathematica, NumPy and TensorFlow are APL dialects), and it isn't usually credited as an early functional language, even though it was the first such language (to my knowledge) to have map\/reduce primitives (although under different names). APL now seems to be remembered for its syntax.\n\nFinally, my point. Re: Sussman, APL is a much better mathematical notation than Scheme.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598125322.060600",
        "parent_user_id": "U01661S9F34",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eec6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the 1950's, Kenneth Iverson was a math professor at Harvard. He designed APL as an unambigous, expressive mathematical notation, for teaching math to undergrads, and for his personal use solving research problems and writing books and research papers. Iverson joined IBM as a mathematician, where he used his notation to formalize and specify the instruction sets of the 7090 and 360 computers. Only after that, the project at IBM to implement APL as a programming language.\n\nAPL doesn't usually get much credit for its influence on modern programming systems (although Mathematica, NumPy and TensorFlow are APL dialects), and it isn't usually credited as an early functional language, even though it was the first such language (to my knowledge) to have map\/reduce primitives (although under different names). APL now seems to be remembered for its syntax.\n\nFinally, my point. Re: Sussman, APL is a much better mathematical notation than Scheme."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJN1TAYEQ",
        "type": "message",
        "ts": "1598221862.066000",
        "client_msg_id": "97b79a07-22e2-45ff-b162-8289e1749493",
        "text": "<@U0123H7JRDM> I implemented an endless slider to my Curv project, but I'm not in love with the UI. I'd appreciate some more specific references to good UIs for this, so that I can see what a better UI might look like.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4185a542241",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "",
            "real_name": "Doug Moen",
            "display_name": "Doug Moen",
            "team": "T5TCAFTA9",
            "name": "doug",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598051713.009800",
        "parent_user_id": "U85HCL7JP",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t4YR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0123H7JRDM"
                            },
                            {
                                "type": "text",
                                "text": " I implemented an endless slider to my Curv project, but I'm not in love with the UI. I'd appreciate some more specific references to good UIs for this, so that I can see what a better UI might look like."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UMWF81HTP",
        "type": "message",
        "ts": "1598239464.069200",
        "client_msg_id": "6258505F-DF1B-46FE-A154-5A23A8B26619",
        "text": "<@U85HCL7JP> curious what you mean by solving the problem of magic numbers. For physics params in games at least, to me everything is arbitrary and relative to other values, so I’m not sure what the problem to be solved is.(Maybe “magic numbers” isn’t the right word? Sorry if that was confusing)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "4022671f3400",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-03\/775814402657_4022671f340032b9eb75_72.jpg",
            "first_name": "yoshiki",
            "real_name": "yoshiki",
            "display_name": "yoshiki",
            "team": "T5TCAFTA9",
            "name": "yoshikischmitz",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598051713.009800",
        "parent_user_id": "U85HCL7JP",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XSRn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U85HCL7JP"
                            },
                            {
                                "type": "text",
                                "text": " curious what you mean by solving the problem of magic numbers. For physics params in games at least, to me everything is arbitrary and relative to other values, so I’m not sure what the problem to be solved is.(Maybe “magic numbers” isn’t the right word? Sorry if that was confusing)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1598245635.072100",
        "client_msg_id": "95ac4872-7c13-49c3-9e5f-ef3221247ece",
        "text": "Historical note: NumPy started out with a focus on implementing much of APL as a Python library. The function names in Numerical Python (as NumPy was originally called) are the names of APL operators. Later on, there was a movement to make NumPy more Matlab-like to win over Matlab users, so the APL heritage is no longer as clear as it used to be.\n\nAs for APL vs. Scheme: that really depends on what aspect of mathematical notation you focus. Sussman comes from a symbolic computation background, with an application focus on calculus (check his \"Structure and Interpretation of Classical Mechanics\" as the prime example). APL has a focus on numerics and algebra. The only decent attempt I know to unify both perspectives is Mathematica.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598125322.060600",
        "parent_user_id": "U01661S9F34",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k9qy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Historical note: NumPy started out with a focus on implementing much of APL as a Python library. The function names in Numerical Python (as NumPy was originally called) are the names of APL operators. Later on, there was a movement to make NumPy more Matlab-like to win over Matlab users, so the APL heritage is no longer as clear as it used to be.\n\nAs for APL vs. Scheme: that really depends on what aspect of mathematical notation you focus. Sussman comes from a symbolic computation background, with an application focus on calculus (check his \"Structure and Interpretation of Classical Mechanics\" as the prime example). APL has a focus on numerics and algebra. The only decent attempt I know to unify both perspectives is Mathematica."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1598245856.072500",
        "client_msg_id": "eabaa6e5-b629-499f-ad10-c5379d0f898c",
        "text": "Why isn't any kind of *logic programming* considered a <https:\/\/en.wikipedia.org\/wiki\/Model_of_computation|model of computation>? Why do we talk about Turing Machines and recursive functions as fundamental, but not *inference*? I can't find any resources discussing this disparity. It's like there are two classes of academics that don't talk to each other. Am I missing something?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598245856.072500",
        "reply_count": 12,
        "reply_users_count": 5,
        "latest_reply": "1599829655.269400",
        "reply_users": [
            "UT60XSVCN",
            "UCGAK10LS",
            "U016VUZGUUQ",
            "UE6EFEPTQ",
            "UDKTZSD6H"
        ],
        "replies": [
            {
                "user": "UT60XSVCN",
                "ts": "1598247221.072600"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1598247641.072800"
            },
            {
                "user": "UT60XSVCN",
                "ts": "1598248238.080300"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1598248717.080900"
            },
            {
                "user": "U016VUZGUUQ",
                "ts": "1598258729.089200"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1598262498.093100"
            },
            {
                "user": "UE6EFEPTQ",
                "ts": "1598263455.093300"
            },
            {
                "user": "UT60XSVCN",
                "ts": "1598265721.093800"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1598268550.098900"
            },
            {
                "user": "UCGAK10LS",
                "ts": "1598270638.105500"
            },
            {
                "user": "UT60XSVCN",
                "ts": "1598270768.105700"
            },
            {
                "user": "UDKTZSD6H",
                "ts": "1599829655.269400"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6\/W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Why isn't any kind of "
                            },
                            {
                                "type": "text",
                                "text": "logic programming",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " considered a "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Model_of_computation",
                                "text": "model of computation"
                            },
                            {
                                "type": "text",
                                "text": "? Why do we talk about Turing Machines and recursive functions as fundamental, but not "
                            },
                            {
                                "type": "text",
                                "text": "inference",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? I can't find any resources discussing this disparity. It's like there are two classes of academics that don't talk to each other. Am I missing something?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UC2A2ARPT",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UT60XSVCN",
        "type": "message",
        "ts": "1598247221.072600",
        "client_msg_id": "4a0745b0-6d7a-48d9-a7ce-6e6dd0bee36f",
        "text": "I'm not an expert, but logic programming a la prolog etc is usually based fundamentally on term rewriting, which is essentially what the untyped lambda calculus is. (Please correct me if I'm wrong, this is something I've been studying recently but I'm still quite new to the field)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gbc3e6041047",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/bc3e6041047849518d1b042f0a29d5af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "S.M Mukarram Nainar",
            "display_name": "S.M Mukarram Nainar",
            "team": "T5TCAFTA9",
            "name": "nainars",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598245856.072500",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Cho7I",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not an expert, but logic programming a la prolog etc is usually based fundamentally on term rewriting, which is essentially what the untyped lambda calculus is. (Please correct me if I'm wrong, this is something I've been studying recently but I'm still quite new to the field)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1598247641.072800",
        "client_msg_id": "9cda2433-864c-432c-8c5c-53fec3132df2",
        "text": "Isn't term rewriting destructive, i.e. it consumes an input to produce an output?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598245856.072500",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Sfusz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Isn't term rewriting destructive, i.e. it consumes an input to produce an output?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UT60XSVCN",
        "type": "message",
        "ts": "1598248238.080300",
        "client_msg_id": "ffa68ce7-b7ec-4563-9a61-469524243c88",
        "text": "I suppose? i am afraid I am not sure what the relation is and what you are getting at here.\nWould you consider beta-reduction \"destructive\"?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gbc3e6041047",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/bc3e6041047849518d1b042f0a29d5af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "S.M Mukarram Nainar",
            "display_name": "S.M Mukarram Nainar",
            "team": "T5TCAFTA9",
            "name": "nainars",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598245856.072500",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4Gs\/Y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I suppose? i am afraid I am not sure what the relation is and what you are getting at here.\nWould you consider beta-reduction \"destructive\"?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1598248276.080500",
        "client_msg_id": "1AF2F9C6-D256-40CE-8A62-1C81E5F9505A",
        "text": "<@UJN1TAYEQ> The knobs on the nord lead <https:\/\/www.wikiwand.com\/en\/Nord_Lead|https:\/\/www.wikiwand.com\/en\/Nord_Lead> line of hardware synths have endless knobs with a ring of leds to indicate the value. I'll look for other examples in software and will post them here",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "533c1a6943bf",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-03-16\/8613805779220_533c1a6943bfc0b7f150_72.jpg",
            "first_name": "Maikel",
            "real_name": "Maikel van de Lisdonk",
            "display_name": "Maikel",
            "team": "T5TCAFTA9",
            "name": "maikel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598051713.009800",
        "parent_user_id": "U85HCL7JP",
        "attachments": [
            {
                "service_name": "Wikiwand",
                "title": "Nord Lead | Wikiwand",
                "title_link": "https:\/\/www.wikiwand.com\/en\/Nord_Lead",
                "text": "The Nord Lead is a series of virtual analog subtractive synthesizers, manufactured by Clavia.",
                "fallback": "Wikiwand: Nord Lead | Wikiwand",
                "image_url": "https:\/\/upload.wikimedia.org\/wikipedia\/commons\/9\/9b\/Clavia_Nord_Rack.jpg",
                "from_url": "https:\/\/www.wikiwand.com\/en\/Nord_Lead",
                "image_width": 606,
                "image_height": 250,
                "image_bytes": 916884,
                "service_icon": "http:\/\/assets.wikiwand.com\/img\/wikiwand_icon_apple.png",
                "id": 1,
                "original_url": "https:\/\/www.wikiwand.com\/en\/Nord_Lead"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zzCwI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " The knobs on the nord lead "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.wikiwand.com\/en\/Nord_Lead",
                                "text": "https:\/\/www.wikiwand.com\/en\/Nord_Lead"
                            },
                            {
                                "type": "text",
                                "text": " line of hardware synths have endless knobs with a ring of leds to indicate the value. I'll look for other examples in software and will post them here"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCGAK10LS",
        "type": "message",
        "ts": "1598248717.080900",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1598249178.000000"
        },
        "client_msg_id": "3f1929ac-328e-4465-9db6-a263447c5641",
        "text": "I guess a better question is: what is the \"term\" that is getting re-written in evaluating a logic program? Is it the entire program? As a conjunction of clauses? I guess the destructivity doesn't manifest in such a case because you're producing a \"new program\" (term) which you guarantee is going to be strictly larger than the last one (adding new deductions). That suggests term rewriting might be \"too powerful\" for logic programming though, because it can also model the deletion of facts (unless you want that capability, for some reason).\n\nBut yeah, I'm now seeing how you could map inference to term rewriting!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6402e9775ed7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-13\/5095853045814_6402e9775ed73b75334f_72.jpg",
            "first_name": "",
            "real_name": "Nick Smith",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "nmsmith65",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1598245856.072500",
        "parent_user_id": "UCGAK10LS",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "g2qG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess a better question is: what is the \"term\" that is getting re-written in evaluating a logic program? Is it the entire program? As a conjunction of clauses? I guess the destructivity doesn't manifest in such a case because you're producing a \"new program\" (term) which you guarantee is going to be strictly larger than the last one (adding new deductions). That suggests term rewriting might be \"too powerful\" for logic programming though, because it can also model the deletion of facts (unless you want that capability, for some reason).\n\nBut yeah, I'm now seeing how you could map inference to term rewriting!"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]