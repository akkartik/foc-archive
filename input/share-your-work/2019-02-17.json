[
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1550391048.014700",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1550472299.000000"
        },
        "client_msg_id": "352544c7-eebd-4553-b19c-672136632040",
        "text": "In my work experience, I've observed a situation where \"modularity\" had replaced coherent system design, and got worse and worse over time as others continued to believe that we'd achieve scalability once we achieved some perfect modular system; but what I observed was the exact opposite.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1550137467.010900",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rMQC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In my work experience, I've observed a situation where \"modularity\" had replaced coherent system design, and got worse and worse over time as others continued to believe that we'd achieve scalability once we achieved some perfect modular system; but what I observed was the exact opposite."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "scream",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UE1JQM9HQ",
        "type": "message",
        "ts": "1550391970.014900",
        "client_msg_id": "30b2b5fa-9628-4304-aa12-8d27fbc4970d",
        "text": "That is an interesting observation. I'd be curious to learn more about how \"modularity\" came to be at odds with coherent system design. Would it be possible to provide more details?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g48924f215ef",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/f48924f215efa665f3c87affcdb14278.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png",
            "first_name": "Tudor",
            "real_name": "Tudor Girba",
            "display_name": "Tudor Girba",
            "team": "T5TCAFTA9",
            "name": "tudor",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1550137467.010900",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xsG4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That is an interesting observation. I'd be curious to learn more about how \"modularity\" came to be at odds with coherent system design. Would it be possible to provide more details?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1550395229.015200",
        "client_msg_id": "e811027d-5ca1-42d3-b6f0-59d165dde3f0",
        "text": "<@UAVCC2X70> please share your horror story.  In my experience, it's when modules are drawn with the wrong bounds so you get tight coupling plus communication overhead.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1550137467.010900",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LJ4I",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UAVCC2X70"
                            },
                            {
                                "type": "text",
                                "text": " please share your horror story.  In my experience, it's when modules are drawn with the wrong bounds so you get tight coupling plus communication overhead."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1550438893.015500",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1550438976.000000"
        },
        "client_msg_id": "192a24c4-2455-49f1-ad06-eab788f5a47b",
        "text": "So I read this and first I think - are Haskell and Lisp really opposites? They both seemed similarly overwhelming to me. Lisp because it was different than everything I was used to (being invented in 1958 makes it an alien world, and I have no doubt that you could easily get hopelessly lost in a maze of twisty little macros like the OP said, if the original author wasn't good at both designing good abstractions and documenting them.) Haskell because it has so many unusual abstractions that you must learn before you can understand others' code or write effective code yourself. I think I prefer Haskell's form of Hell, because it's strongly typed, more modern, and better-planned-out, but I'm not really satisfied with either of them.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1542958731.034300",
        "parent_user_id": "UCKRZS3DZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "E8JH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So I read this and first I think - are Haskell and Lisp really opposites? They both seemed similarly overwhelming to me. Lisp because it was different than everything I was used to (being invented in 1958 makes it an alien world, and I have no doubt that you could easily get hopelessly lost in a maze of twisty little macros like the OP said, if the original author wasn't good at both designing good abstractions and documenting them.) Haskell because it has so many unusual abstractions that you must learn before you can understand others' code or write effective code yourself. I think I prefer Haskell's form of Hell, because it's strongly typed, more modern, and better-planned-out, but I'm not really satisfied with either of them."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1550439744.016000",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1550439766.000000"
        },
        "client_msg_id": "8ef3b155-6d56-42c8-86a9-fd79d7b70adc",
        "text": "I like having a Lisp-style macro system available, but I think creating a macro system so people can *write* macros is the wrong approach. What I want from a macro system is a good set of well-designed macros designed by professionals, that everybody knows, so that you rarely need to write a new macro of your own.\n\nHaskell, similarly, has a lot of good things to offer, but pure functional programming is not a form of thought that comes naturally, nor is the various abstractions based on higher mathematics.\n\nI actually think it's important to teach some of these abstractions and probably someday they will be a part of every school curriculum - but I think a good programming language embraces diverse forms of thought - imperative, declarative, functional, domain-specific - and allows programmers to write programs in a way that resembles the way they think about the problem they're solving. The role of the programming language is not to enforce \"purity\", but to provide rich, intuitive functionality and to guide people into the \"pit of success\" - by making the probably-better way of doing things easier than the probably-worse way.\n\nShort pit-of-success example: in languages like JavaScript creating a global variable is super easy, but a member variable must be accessed through \"this\", as in `this.v`. This should be flipped on its head so the member variable is easy to reach and the global variable is written `global.v`.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1542958731.034300",
        "parent_user_id": "UCKRZS3DZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BrC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like having a Lisp-style macro system available, but I think creating a macro system so people can "
                            },
                            {
                                "type": "text",
                                "text": "write",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " macros is the wrong approach. What I want from a macro system is a good set of well-designed macros designed by professionals, that everybody knows, so that you rarely need to write a new macro of your own.\n\nHaskell, similarly, has a lot of good things to offer, but pure functional programming is not a form of thought that comes naturally, nor is the various abstractions based on higher mathematics.\n\nI actually think it's important to teach some of these abstractions and probably someday they will be a part of every school curriculum - but I think a good programming language embraces diverse forms of thought - imperative, declarative, functional, domain-specific - and allows programmers to write programs in a way that resembles the way they think about the problem they're solving. The role of the programming language is not to enforce \"purity\", but to provide rich, intuitive functionality and to guide people into the \"pit of success\" - by making the probably-better way of doing things easier than the probably-worse way.\n\nShort pit-of-success example: in languages like JavaScript creating a global variable is super easy, but a member variable must be accessed through \"this\", as in "
                            },
                            {
                                "type": "text",
                                "text": "this.v",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". This should be flipped on its head so the member variable is easy to reach and the global variable is written "
                            },
                            {
                                "type": "text",
                                "text": "global.v",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1550448457.016600",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1550448640.000000"
        },
        "client_msg_id": "ae45c593-5623-4e75-80ad-8da0acf96cad",
        "text": "I can't say I understand what you're trying to accomplish by revisiting assembly language - particularly assembly language for a specific processor. I myself would kill (like, a mouse or something) to get a job working on the design of WebAssembly, but then I'd be programming everything in a higher-level language, except if I had to write some WebAssembly code (in which case I'd be interested in higher-level representations of it). x86? Yeah, I used it a bit 20 years ago when I had no choice.\n\nSo what are your goals and motivation?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1544261823.037100",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "44ubF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I can't say I understand what you're trying to accomplish by revisiting assembly language - particularly assembly language for a specific processor. I myself would kill (like, a mouse or something) to get a job working on the design of WebAssembly, but then I'd be programming everything in a higher-level language, except if I had to write some WebAssembly code (in which case I'd be interested in higher-level representations of it). x86? Yeah, I used it a bit 20 years ago when I had no choice.\n\nSo what are your goals and motivation?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1550476186.017100",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1550480041.000000"
        },
        "client_msg_id": "0a561367-425e-4867-af7d-fa5178cb0129",
        "text": "<@UA14TGLTC> - That's essentially what happened.\n\nLet's say the product was a UI widget, with multiple similar but highly customized variations.\n\nVersion 1 had inconsistencies and unclear boundaries between features, which made it difficult to share (or even identify) features across different code-bases. Each feature was developed in whatever code-base needed it at the time, and then copied ad-hoc to others as needed. Let's say the code was 10 Smurfs in size.\n\nVersion 2 included *all* features in a single \"I can be anything\" code-base (single repository). Each feature was factored nicely into it's own \"module\"; but there was a lot of complex mechanism to dynamically load or enable\/disable modules on the fly. This code was 30 Smurfs in size.\n\nVersion 3 allowed you to statically include *just* the modules you need, from the start. However, each module now lived in it's own repository, had its own version, it's own CI\/CD system, and was built on top of a swarm of the latest tools\/technologies\/frameworks\/etc. The modules would listen to each other's events and monitor each other's state, and proactively try to cause their own behavior(s) to happen at the right time and\/or trigger each other to pick up the next step. Many of these modules equated to tiny steps (one-liners) before, but had become full-fledged modules with their own state &amp; events, and watching the state &amp; events of others, and also with all the configuration files that each module then came with (new retirement imposed by the new technology stack). The whole thing had undergone changes &amp; refactorings across all modules over time. The typical size of one of these (after combining all modules used for a given instance of the widget) was 400 Smurfs.\n\nSo sure, it only included the modules you needed, BUT:\n* The code was MUCH larger and more complicated to follow (especially being split across MANY repositories)\n* Most instances needed most of the modules, anyway\n* There was CONSTANT breakages and build errors related to not having the right combination of modules (or incompatible versions of different modules).\n* ... I won't go on any further.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1550137467.010900",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Z7t",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " - That's essentially what happened.\n\nLet's say the product was a UI widget, with multiple similar but highly customized variations.\n\nVersion 1 had inconsistencies and unclear boundaries between features, which made it difficult to share (or even identify) features across different code-bases. Each feature was developed in whatever code-base needed it at the time, and then copied ad-hoc to others as needed. Let's say the code was 10 Smurfs in size.\n\nVersion 2 included "
                            },
                            {
                                "type": "text",
                                "text": "all",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " features in a single \"I can be anything\" code-base (single repository). Each feature was factored nicely into it's own \"module\"; but there was a lot of complex mechanism to dynamically load or enable\/disable modules on the fly. This code was 30 Smurfs in size.\n\nVersion 3 allowed you to statically include "
                            },
                            {
                                "type": "text",
                                "text": "just",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the modules you need, from the start. However, each module now lived in it's own repository, had its own version, it's own CI\/CD system, and was built on top of a swarm of the latest tools\/technologies\/frameworks\/etc. The modules would listen to each other's events and monitor each other's state, and proactively try to cause their own behavior(s) to happen at the right time and\/or trigger each other to pick up the next step. Many of these modules equated to tiny steps (one-liners) before, but had become full-fledged modules with their own state & events, and watching the state & events of others, and also with all the configuration files that each module then came with (new retirement imposed by the new technology stack). The whole thing had undergone changes & refactorings across all modules over time. The typical size of one of these (after combining all modules used for a given instance of the widget) was 400 Smurfs.\n\nSo sure, it only included the modules you needed, BUT:\n* The code was MUCH larger and more complicated to follow (especially being split across MANY repositories)\n* Most instances needed most of the modules, anyway\n* There was CONSTANT breakages and build errors related to not having the right combination of modules (or incompatible versions of different modules).\n* ... I won't go on any further."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UFD2JRE58"
                ],
                "count": 1
            },
            {
                "name": "scream",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    }
]