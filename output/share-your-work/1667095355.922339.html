<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../share-your-work/1667095355.922339.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2022-10-29 19:02</span><br/>
Future of Coding • Episode 59<br/>Richard P. Gabriel • Worse is Better<br/>:link: <a href="https://futureofcoding.org/episodes/059">https://futureofcoding.org/episodes/059</a><br/><br/>Following our <a href="https://futureofcoding.org/episodes/058">previous episode</a> on Richard P. Gabriel's <em>Incommensurability</em> paper, we're back for round two with an analysis of what we've dubbed the <em>Worse is Better family of thought products:</em><br/>1. <a href="https://dreamsongs.com/RiseOfWorseIsBetter.html">The Rise of Worse Is Better</a> by Richard P. Gabriel<br/>2. <a href="https://www.dreamsongs.com/Files/worse-is-worse.pdf">Worse is Better is Worse</a> by Nickieben Bourbaki<br/>3. <a href="https://www.dreamsongs.com/Files/IsWorseReallyBetter.pdf">Is Worse Really Better?</a> by Richard P. Gabriel<br/>Next episode, we've got a recent work by a real up-and-comer in the field. While you may not have heard of him yet, he's a promising young lad who's sure to become a household name.<br/>• <a href="http://worrydream.com/MagicInk/">Magic Ink</a> by Bret Victor<br/>I am usually really thorough in my editing of the show, but this one I sort of had to rush out the door because the month is rapidly drawing to a close. If anyone spots any weird edits, or anything that sounds out of place, let me know. In particular, the sponsors (which now come at the end of the episode) might be a little rough. Oh well — pays the bills, amirite?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1667105075.864229"></a>
      <img src="https://avatars.slack-edge.com/2022-05-21/3558879757875_3e8345518ba82b825c6d_72.jpg" style="float:left"/>
      <a href="../share-your-work/1667095355.922339.html#1667105075.864229" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jim Meyer</b>
<span style="margin:2em; color:#606060">2022-10-29 21:44</span><br/>
<li>i*Land :joy:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1667106555.058219"></a>
      <img src="https://secure.gravatar.com/avatar/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../share-your-work/1667095355.922339.html#1667106555.058219" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Personal Dynamic Media</b>
<span style="margin:2em; color:#606060">2022-10-29 22:09</span><br/>
Thank you, this was a fun listen. I also really appreciate that you have dropped the disrespectful nicknames. Thank you.<br/><br/>When comparing the priorities of the authors of Unix versus the authors of ITS, I think it's worth remembering some of the technical differences between the hardware.<br/><br/>Unix grew up on a mini computer, the PDP-11 (Yes, it started life on a PDP-7, but the real growth into the operating system we would recognize today occurred on the PDP 11.), where the kernel had to fit in 64K, and each program had to fit in its own 64K (later models let you use 64K for code and a separate 64K for data). This environment will naturally encourage one to prioritize performance and simplicity of implementation.<br/><br/>On the other hand, ITS grew up on a mainframe, the PDP-6 (later PDP-10), which had a 36-bit word and 18-bit addressing, making it possible for a single address space to contain substantially more memory. It's much easier to put more complexity into your kernel in this environment.<br/><br/>As a result, I'm not convinced that the differences in prioritization were fundamentally the results of the two cultures in question. I suspect the different priorities may have arisen partly from the technologies in question.<br/><br/>With respect to the question of how well the Unix interface hides complexity, I would argue that many Unix tools provide a good, simple interface for utilizing some pretty deep complexity. In fact, I think the relevant comparison is not Lisp versus C, but Lisp versus sh. The ubiquitous data type in Lisp is the list, while the ubiquitous data type in sh is the file full of variable length one line records. Pipelines in sh fill the role of function composition in Lisp. The equivalent of C in ITS was the MIDAS assembler, which WAS really nice for an assembler. See <a href="https://wiki.c2.com/?SymbioticLanguages">https://wiki.c2.com/?SymbioticLanguages</a> for some elaboration on where I'm coming from with this comparison.<br/><br/>For example, make provides a relatively easy way to make use of a topological sort, without having to understand the implementation details or even what a topological sort is.<br/><br/>The sort command allows you to sort files substantially larger than RAM, handling all issues of breaking files into chunks that can be sorted within RAM, merging those chunks into larger chunks, storing intermediate results on disc, etc.<br/><br/>The diff command provides a simple interface for finding the longest common substring between two sets of lines.<br/><br/>lex and yacc pack a lot of powerful computer science into a relatively straightforward interface for specifying tokens and grammars.<br/><br/>join, comm, awk, dc, bc, and many other tools that were already available in v7 Unix also present simple interfaces for making use of powerful code.<br/><br/>Speaking as a huge Smalltalk and Lisp fan, as well as a huge Unix fan, I think the question of how Unix won extends far beyond Gabriel's analysis, though I appreciate the factors that he identified.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1667197326.494819"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1667095355.922339.html#1667197326.494819" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-10-30 23:22</span><br/>
Interesting episode, once more! I had read these papers many years ago, with mixed feelings about the relevance of the "worse is better" idea. Your discussion framing it as "where does the complexity go" is illuminating here. But I agree with <span style="background-color:#ccf">@Personal Dynamic Media</span> that it's not so much "developer vs. user" but "where on the many layers of a real-life software system does the complexity go?" Unix at the shell programming level is indeed free from the low-level considerations that PG mentions. Which explains why I found the topic only moderately relevant since my own focus as a power user (rather than software developer) is on levels clearly above the Linux kernel APIs. For me,  Lisp machine vs. Unix is about Lisp vs. shell as the layer that defines the coherence and accessability of system features. With Lisp clearly "winning" here, but at the cost of much higher resource usage.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1667199657.995029"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1667095355.922339.html#1667199657.995029" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2022-10-31 00:00</span><br/>
On Ruby, Matz put it this way, "Actually, I'm trying to make Ruby natural, not simple."<br/><br/>Concrete example.  The keyword <tt>alias</tt> is a for giving multiple names to the same method so that you can call the synonym that feels the most natural.  Examples from the often used <tt>Enumerable</tt> module:<br/>• <tt>include?</tt> and <tt>member?</tt><br/>• <tt>to_a</tt> and <tt>entries</tt><br/>• <tt>detect</tt> and <tt>find</tt><br/>• <tt>select</tt> and <tt>filter</tt> and <tt>find_all</tt> <br/>• <tt>map</tt> and <tt>collect</tt><br/>• <tt>flat_map</tt> and <tt>collect_concat</tt><br/>• <tt>reduce</tt> and <tt>inject</tt><br/>The -ect names (<tt>select</tt>, <tt>reject</tt>, <tt>detect</tt>, <tt>inject</tt>) come from Smalltalk.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1667225181.392229"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../share-your-work/1667095355.922339.html#1667225181.392229" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2022-10-31 07:06</span><br/>
<span style="background-color:#ccf">@William Taysom</span> I'm not sure what you're responding to. Something from a previous comment? Something from the episode? (Perhaps Jimmy's mention that Ruby is difficult to parse?)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1667268920.667379"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1667095355.922339.html#1667268920.667379" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2022-10-31 19:15</span><br/>
Yes, Jimmy's comment from the episode that Ruby is complex in implementation and complex in API.  Yet somehow using it often feels good.  How?  Comes from the complexity being in service of a kind of naturalness.  The syntax, for example, if enough people interested people think something should work eventually it does.<br/><br/>Now does anyone actually know the syntax of the language?  Not me!  And I've been writing this language for twenty years.  I was today days old when I learned you can use <tt>::</tt> for method calls, as in <tt>Object.new::is_a?(Object)</tt>.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1668839304.727229"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../share-your-work/1667095355.922339.html#1668839304.727229" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2022-11-18 22:28</span><br/>
For the search engine: <b>Who should own the complexity?</b><br/><br/>---<br/><br/>Important context: the first "paper" was just a few pages in the middle of a much larger paper. (Then RPG went all MCU with the sequels.)<br/><br/>---<br/><br/>Portability and performance are merely examples. I'd say the philosophy still holds in a general form:<br/><br/>&gt; To be adaptive, you can be worse along any axis <em>where the competing approach will take 20 years to build</em>.<br/>On the other hand, most things don't get adoption. There's lots of bottlenecks to get through before life-or-death Worse vs Right trade-offs. So it's not very actionable.<br/><br/>---<br/><br/>If you think, "oh, I failed at adoption because Worse is Better," that might be a symptom that you misunderstood the target audience for your product. It's the developers (who care about ease of porting) not the users. In the '60s you don't get users directly. You only get users at the end of a trade network mediated by developers/porters. It's a failure of positioning.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
