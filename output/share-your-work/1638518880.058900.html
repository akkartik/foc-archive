<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-03 00:08</span><br/>
Hi, I have built a serverless runtime for <a href="http://observablehq.com">observablehq.com</a> called <a href="https://webcode.run">https://webcode.run</a>. This extends Observable's reactive notebooks to the backend. Its unique features are instant deploys, and it can redirect traffic to your browser, so you can do devtool or console.log debugging against production traffic. It's a unique way of sharing code across frontend and backend.<br/><br/>My aim is to create a serverless environment that is a pleasure to use as a developer. I am really desperate for feedback, so if you give it a go let know the positives and negatives.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1638526018.059400"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1638526018.059400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-12-03 02:06</span><br/>
Interesting! Also a bit frustrating for me. This looks like something I could and would like to use, for making custom computations easily accessible as Web services, but it also seems to be aimed at Web professionals familiar with a lot of technology that I merely know the names of.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1638529051.059600"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1638529051.059600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-03 02:57</span><br/>
You are not the first person to say this. I am a bit worried about getting sucked into an effort vortex to teach HTTP fundamentals. I am also worried about making a simplified version that cannot be applied to novel situations because expressivity has been lost. It is as complicated as HTTP is (i.e. very).<br/><br/>Though perhaps it is time to think of a simple version. If you want to expose a computation maye could be guided with functional programming.<br/><pre style="white-space:pre-wrap">//server<br/>remoteFunction = serve((x) =&gt; x*x), options)</pre><br/><pre style="white-space:pre-wrap">answer = await remoteFunction(5)</pre><br/>I think there is enough wiggle room for people to add their own abstractions, and because the result is a promise we can put in network errors.<br/><br/>Would this cover your usecase? (if anyone knows of any simple RPC abstractions I should draw inspiration from I would love to see)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1638534446.059900"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1638534446.059900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-03 04:27</span><br/>
Is this hlepful?<br/><br/><a href="https://observablehq.com/@endpointservices/servefunction">https://observablehq.com/@endpointservices/servefunction</a><br/><br/>but I am wondering how you could use this outside the ecosystem as it has some custom encoding on the URL endpoint
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1638963628.079400"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1638963628.079400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-08 03:40</span><br/>
I guess not.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1638970032.085800"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1638970032.085800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-12-08 05:27</span><br/>
Simple RPC-style interaction covers most use cases I can personally think of. The role of your serverless runtime would then be to make the code called via RPC debuggable. That looks useful in the abstract. Unfortunately, I can't really say what features would be required to make it useful in real life.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1638970150.086000"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1638970150.086000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-12-08 05:29</span><br/>
Another question I wonder about: how does your project differ from other interactive systems being used on the server via some remote control? Thinking of Common Lisp image managed from Emacs (SLIME) from a desktop machines, or of Smalltalk systems (e.g. via TelePharo, <a href="https://github.com/pharo-ide/TelePharo">https://github.com/pharo-ide/TelePharo</a>). Are you doing the same but in JavaScript? Or is there a more fundamental difference I am missing?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1638971673.086400"></a>
      <a href="../share-your-work/1638518880.058900.html#1638971673.086400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-08 05:54</span><br/>
Why webcode is different<br/>1. a notebook is both front end and the backend and the technical documentation and the code repository and runtime. True seamless code sharing. No additional infra required. corrorally -&gt; libraries can be packaged as frontend and backend too<br/>2. The environment is 100% browser. No tools to install. No "pip install", no "webpack", no compiling. You can do it all from a chromebook or mobile device, for instance<br/>3. It takes about 40ms for code changes to become visible remotely. Compared to 2 mins for lambda. The inner development loop is supercharged. You can develop live in prod. The iteration speed is incredible, partly due to instant deploys, partly due to Observable hot code reloading No setup required, its like that out of the box.<br/>4. True production debugging using vanilla browser tools. No simulacrum of a debugger. It's just the normal debugger everyone already uses, which means other debugging technology can be layered on top without problems (e.g. time travel debugging <a href="https://www.replay.io/">https://www.replay.io/</a>)<br/>This is built on Observablehq, so it gets all its FoC features. Literate programming, Commenting, 1-click forking, version control, Functional Reactive Programming env, partial recompilation etc. No need for Github or git, remember, this is 100% browser based, you get all this on any device that supports a web browser. You can fix and deploy things on your mobile phone.<br/><br/>You can manage a whole microservice, including technical documentation and project management, in a single page of web editable code. For instance, this twitter bot is hosted on webcode <a href="https://observablehq.com/@endpointservices/twitter-bot">https://observablehq.com/@endpointservices/twitter-bot</a>. This is a whole IndieAuth oauth server. (<a href="https://observablehq.com/@endpointservices/auth">https://observablehq.com/@endpointservices/auth</a>)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1638971798.086800"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1638971798.086800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-08 05:56</span><br/>
So if you want your own Oauth server, its  1-click fork, change the config to point to your Firebase, and its live. There is no deploy step required, a notebook becomes infra instantly.<br/><br/>I guess the overall draw is it's a single tool to do everything (<a href="http://Observablehq.com">Observablehq.com</a> being the single tool, webcode is just filling a missing gap)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639036960.089100"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639036960.089100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-12-09 00:02</span><br/>
Thanks <span style="background-color:#ccf">@Tom Larkworthy</span>, those are all very good arguments! But I have to admit that some sound too good to be true. A one-click fork to get an Oauth server? I need to set up some server first, right? There must be some physical machine doing the work, and also hosting my domain. Also, I doubt many practically useful server applications can do without any preinstalled dependencies. Sure, I can in theory rewrite everything as notebooks, but in practice everything is based on a lot of existing code.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639037933.089300"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639037933.089300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-09 00:18</span><br/>
&gt;  I need to set up some server first, right?<br/>No! The webcode runtime is a <b>generic</b> container [1] that knows how to run notebooks (it has puppeteer inside it). So that one container runs <b>all</b> the notebooks. If you looks at the outbound requests to webcode, the URL encodes which notebook to dynamically lookup. The Oath implementation is at the application level in a notebook. Often, you also need persistence, so I use Firebase as that works well with browser. The server is pupeteer, i.e., also a browser.  So if you want to run your own Oauth server you need to bring-your-own-firebase after forking my notebook.<br/><br/>[1] <a href="https://github.com/endpointservices/webcode.run/blob/main/Dockerfile">https://github.com/endpointservices/webcode.run/blob/main/Dockerfile</a><br/><br/>&gt;  practically useful server applications can do without any preinstalled dependencies.<br/>All dependencies come in via normal Javascript imports.<br/><br/>The major limitations is that many javascript dependencies are node only, but that is changing to ES6 modules (if no other reason than to support Deno). It's kind of like Deno but when you mix in Observablehq you have a whole IDE and its trivial to switch the execution from serverside to clientside and vice versa as they are all just browsers.<br/><br/>When you turn on "live debugging", a tunnel is setup like ngrok, that tunnels production traffic to the developers machine. The developers browser processes the request (giving opportunity for debugging) and sends back the response. This is how code changes are immediate with 0 latency, the developers latest code is the server when in live mode. This is enabled by the browser being the normalized environment.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639048379.090000"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639048379.090000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-09 03:12</span><br/>
Oh another headwind is if your server needs a TCP connection, like a postgres db connection. There is no easy way to achieve that, you are limited to HTTP and websocket comms. I do have a plan to get TCP deployed but not currently
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639129255.090200"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639129255.090200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2021-12-10 01:40</span><br/>
OK, thanks for the details! I was indeed thinking of the node-based JS packages as an obstacle. If people are moving away from that, that's good news!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639162326.092000"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639162326.092000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-10 10:52</span><br/>
I dunno if you are familiar with skypack, but that is a huge adapter for npm -&gt; ES6 (i.e. browser compatibility) <a href="https://www.skypack.dev/">https://www.skypack.dev/</a>, there are a few others but that's currently the coolest one. There is a lot of JS in the world so you are not hugely limited except unless their is a network technology requirement. (BTW, my serverside puppeteer has CORS disabled). If it has an API, no problem (even if not configured for CORS).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639201894.104100"></a>
      <img src="https://avatars.slack-edge.com/2021-05-26/2104531310403_4d4f0ee36615313d19e3_72.jpg" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639201894.104100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Florian Schulz</b>
<span style="margin:2em; color:#606060">2021-12-10 21:51</span><br/>
<span style="background-color:#ccf">@Tom Larkworthy</span> Wow I really like the user experience aspect of this: you can write and document “server” code, fork it and there’s not really a “deploy” step other than saving. This is really compelling. My only concern: since your piggybacking ObservableHQ does that mean that your own server code/infrastructure depends/relies on that? What if you write a crazy service that causes way too much load? Do you think this can fly for real world projects? Or is there a way to host/install the environment on your own cloud infrastructure of choice?<br/><br/>Or am I getting it wrong? Is only the source code (as text) from Observable used but the actual executing server is deployed elsewhere?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639207367.104500"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639207367.104500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-10 23:22</span><br/>
&gt;  What if you write a crazy service that causes way too much load?<br/>1. Its rate limited but also 2. I hit their "embed" endpoint which is hosted on a CDN and targeted at 3rd party embedding on external websites.<br/>&gt; Do you think this can fly for real world projects?<br/>Yes! Most features are implemented as webcode, for example, the <a href="https://observablehq.com/@endpointservices/secrets">secrets API</a> is webcode hosted and wraps Google Secret Manager<br/>The <a href="https://observablehq.com/@tomlarkworthy/serverless-cell-latency-monitor">latency prober</a> I use to measure performance is also webcode implemented. We have got hot performance down to 30ms! It's not quite as fast as a dedicated lambda but its in an acceptable engineering trade off zone IMHO (devX for a little perf hit).<br/>&gt;  is there a way to host/install the environment on your own cloud infrastructure of choice?<br/>Yes it is technically possible, if you look at the API <a href="https://observablehq.com/@endpointservices/webcode-docs#options">options</a>, you can set the remote and region, so you can host your own webcode.run container (and you can set it to localhost for testing). I have not documented the self hosting path yet, but I would like to encourage it when I have some demand for that. The runtime is in a single container, so it should be fairly portable. I use Cloud Run.<br/>&gt;  Is only the source code (as text) from Observable used but the actual executing server is deployed elsewhere?<br/>Yeah Observable is the code hosting platform + reactive runtime. The compute is external (webcode.run uses Google Cloud Run but any docker hosting service "should" work, I am thinking about migrating to <a href="http://fly.io">fly.io</a>). The realtime user control plane is Firestore though, and that is unlikely to be switchable.<br/><br/>I would say the state of it is still a little pre-production. I am not providing an SLO or carrying a pager yet, but it is actively monitored and robustness has hugely improved in the last 6 months. I think it's amazing for API glue, but it struggles when you need a filesystem, like technically it can be a webserver, but uploading static assets is kinda hard so it can only really do small util endpoints at the moment.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639207795.105000"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639207795.105000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-10 23:29</span><br/>
Oh I have a how-it-works notebook (which is very much work in progress) so do leave comments in places that need expanding <a href="https://observablehq.com/@endpointservices/how-it-works">https://observablehq.com/@endpointservices/how-it-works</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639753087.115300"></a>
      <a href="../share-your-work/1638518880.058900.html#1639753087.115300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-17 06:58</span><br/>
I just make a fake Firebase realtime database in the browser, to demonstrate reverse engineering the Firebase realtime database wire protocol and showing that it can all be done 100% in the browser, with one click forking<br/><br/><a href="https://observablehq.com/@tomlarkworthy/rtdb-protocol">https://observablehq.com/@tomlarkworthy/rtdb-protocol</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639807935.118600"></a>
      <img src="https://avatars.slack-edge.com/2021-05-26/2104531310403_4d4f0ee36615313d19e3_72.jpg" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639807935.118600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Florian Schulz</b>
<span style="margin:2em; color:#606060">2021-12-17 22:12</span><br/>
Feels like “View Source” but for server code. But even better because it comes with a notebook full of explanations ;)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1639819629.118800"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1638518880.058900.html#1639819629.118800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2021-12-18 01:27</span><br/>
Another way its beyond "view source" is because you can change the source and the thing updates. view source is read only. This is read/write
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1642509943.002100"></a>
      <a href="../share-your-work/1638518880.058900.html#1642509943.002100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-01-18 04:45</span><br/>
I have listed webcode.run on product hunt. I hope maybe some people like it here??? I am not sure people like Observable that much but I see it as a future of code technology. I made WEBCode.run so Observable could work with more things by adding a serverless compute layer. Now it can be part of the internet network and combine with other tools better.<br/><br/>Anyway, here is the listing :pray: <a href="https://www.producthunt.com/posts/webcode-run">https://www.producthunt.com/posts/webcode-run</a><br/><br/>Ask me anything though. Most of webcode is written in webcode, you can surf most of its implementation on Observable. I have a side hope of teaching people how to build secure backend services as that knowledge took a long time to learn and I think open forkable literate notebooks containing executing services is a good way to learn how to build services. We shall see!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1654156141.365219"></a>
      <a href="../share-your-work/1638518880.058900.html#1654156141.365219" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-06-02 00:49</span><br/>
So I hope to demonstrate the ability for webcode to scale to difficult programs, and to actually improve development readability, by creating a database within webcode.<br/><br/>I want my reference code to exploit the literate programming affordances to create compelling artifacts that are simultaneously interesting to read and actually solve difficult problems. In other words I want to smoosh marketing and development together.<br/><br/>So here is the next component of my 3rd party Firebase compatible realtime database. It's the messaging and storage backend, which is built with causal consistency in mind. If you don't know what causal consistency is, you might find the notebook interesting!<br/><br/><a href="https://observablehq.com/@tomlarkworthy/redis-backend-1">https://observablehq.com/@tomlarkworthy/redis-backend-1</a>
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
