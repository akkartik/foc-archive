<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-02-14/551655871797_2624b1e78c0a9eaed529_72.jpg" style="float:left"/>
      <a href="../thinking-together/1605186819.404500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Knott</b>
<span style="margin:2em; color:#606060">2020-11-12 05:13</span><br/>
Are there any languages/compilers in existence which perform optimization steps while staying in the high level language, and makes these steps visible to the user?<br/><br/>For example, instead of compiling from a tail-recursive C function, directly to a loop in assembly, it first optimises to a loop in C, then the translation to ASM is a dumb single-pass compilation.<br/><br/>For example, this (contrived) tail call elimination is quite hard to follow if you are expecting function calls to appear in the assembly <a href="https://godbolt.org/z/jhecj5">https://godbolt.org/z/jhecj5</a><br/><br/>You could have a compiler that first said, "You code is equivalent to this code" <a href="https://godbolt.org/z/3v6ezj">https://godbolt.org/z/3v6ezj</a> - which is easier to see why it compiles to those same instructions.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605187174.404700"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1605186819.404500.html#1605187174.404700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2020-11-12 05:19</span><br/>
<a href="http://nanopass.org/">http://nanopass.org/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605187224.404900"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1605186819.404500.html#1605187224.404900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2020-11-12 05:20</span><br/>
<a href="https://www.youtube.com/watch?v=Os7FE3J-U5Q">https://www.youtube.com/watch?v=Os7FE3J-U5Q</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605194047.413700"></a>
      <img src="https://secure.gravatar.com/avatar/58ad4af42f7cff8698951a7befb26f0f.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0010-72.png" style="float:left"/>
      <a href="../thinking-together/1605186819.404500.html#1605194047.413700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Oleksii Shmalko</b>
<span style="margin:2em; color:#606060">2020-11-12 07:14</span><br/>
GHC has a couple of intermediate forms that the code goes through. <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html">https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605194219.413900"></a>
      <img src="https://secure.gravatar.com/avatar/58ad4af42f7cff8698951a7befb26f0f.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0010-72.png" style="float:left"/>
      <a href="../thinking-together/1605186819.404500.html#1605194219.413900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Oleksii Shmalko</b>
<span style="margin:2em; color:#606060">2020-11-12 07:16</span><br/>
Another interesting thing in GHC are rewrite rules: the programmer can specify how to transform expressions in high-level language into equivalent but faster expressions. <a href="https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/rewrite-rules.html">https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_gui&hellip;</a> <a href="https://wiki.haskell.org/GHC/Using_rules">https://wiki.haskell.org/GHC/Using_rules</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605211967.414200"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1605186819.404500.html#1605211967.414200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2020-11-12 12:12</span><br/>
to add more, almost all optimization passes on Erlang/Elixir are done one a representation called "core erlang" which is a low level yet human readabble functional language
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1605383420.460600"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1605186819.404500.html#1605383420.460600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2020-11-14 11:50</span><br/>
Meta-programming in general have been used for this kind of thing for a long time. I often see macros as a way to "add your own user defined compiler stage." There are many examples of lisp macros that try to optimize code. <a href="https://youtu.be/8FoAxasNssA">Here is an example</a> of C++ templates being used to generate optimized shader code depending on the compile target.<br/><br/>To be a shill for my favorite hobby lang for a bit: Nim is interesting on this topic. Nim has lisp style macros, and liberally uses high level rewrite passes to generate optimized code. For example, Nim has the concept of an <a href="https://nim-lang.org/docs/manual.html#iterators-and-the-for-statement-first-class-iterators">inline iterator</a>, which gives you convenient python style iterator syntax, but rewrites the code into a more optimal for loop. <a href="https://nim-lang.org/docs/asyncdispatch.html">Async / Await</a> in Nim is entirely built as a macro library. But, as interesting as those examples are, any language with a macro system can accomplish something similar in theory.<br/><br/>What is interesting about Nim is that it is purely a "compiler front end" to use compiler terminology. Nim does not produce assembly language. It produces C code that can then be fed into any C compiler. This means the output is fairly high level, and while it's not "pretty" or  "elegant", it's inspectable! You can read it and understand what is going on.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
