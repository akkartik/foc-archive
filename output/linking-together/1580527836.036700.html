<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../linking-together/1580527836.036700.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2020-01-31 19:30</span><br/>
Summary of (the interesting parts of) a compiler in one (very large) page:<br/><br/><a href="https://mastodon.social/@akkartik/103581348949359372">https://mastodon.social/@akkartik/103581348949359372</a><br/><br/>This is just a draft. Feedback most appreciated on how to make it more clear/accessible.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580546324.037300"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../linking-together/1580527836.036700.html#1580546324.037300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-02-01 00:38</span><br/>
I think imitating the irregularities of the X86 instruction set is an incorrect decision. I think your virtual machine should idealize an x86 architecture stripped of the legacy of its past. The reason x86 is so popular is that it is backward compatible to a frightening degree. You don't need this for Mu, and can presume as many registers, and memory to memory, and bitshift instructions that X86 didn't implement. Yes one has to admit that it might well end up looking a lot like the National chip instead of the intel chip, but Prof. Wirth wrote the code generator for one of his compilers for the Intel, Motorola 68k and National chips, and found that the National chip had the smallest code generator, motorola 2nd place, and Intel way larger. Of course in terms of commercial success they came out in opposite order to their regularity. Although the race is not always to the swiftest, we shouldn't immortalize ugly designs. Just don't copy the PowerPC which must have had 100 branch instructions because they had space left over and made probably the worst assembly language ever devised.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1580611673.046600"></a>
      <img src="https://secure.gravatar.com/avatar/2ab0171744564df5b57138d2f081cbe7.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0004-72.png" style="float:left"/>
      <a href="../linking-together/1580527836.036700.html#1580611673.046600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brandon Hudgeons</b>
<span style="margin:2em; color:#606060">2020-02-01 18:47</span><br/>
all processors are optimized for x86 instructions. If youâ€™re not going to build hardware, it is as low as you should get, and Mu goes there. You could build higher-lever abstractions on top of that (and Mu does), but the point is not to have any unpiercable opaque layer. 
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
