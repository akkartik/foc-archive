[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1751199837.273439",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1751199894.000000"
        },
        "client_msg_id": "2b04c11d-9a3c-4f84-a5d7-734983d1f665",
        "text": "<@U06SS0DHZD1> - is there a separate URL for your build stuff? Or, is one expected to pry it out of the Automat repo? I totally agree that build-ing needs to be heavily revamped. Our current build processes are rife with out-dated biases from the 1960s.\n<@U02E4DAQGSZ> - You use the words \"microkernel\" and \"reactive\". I'm trying to figure out whether there is a direct connection between Lopecode and PBP(0D). I am hampered by a general ignorance of Observable. Comments (from anyone) might help me come down the learning curve. And, comments \/ questions \/ brainstorming (from anyone) about interrelationships (or non-interrelationships) between these ideas would be welcome.\n<@U06MJU6LBN3> - PLs and OSs are dead to me. It's not 1960 anymore and we need fresh ways to look at program development workflows. This looks quite interesting and fires various of my neurons regarding steal-able ideas.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CUKrZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U06SS0DHZD1"
                            },
                            {
                                "type": "text",
                                "text": " - is there a separate URL for your build stuff? Or, is one expected to pry it out of the Automat repo? I totally agree that build-ing needs to be heavily revamped. Our current build processes are rife with out-dated biases from the 1960s.\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U02E4DAQGSZ"
                            },
                            {
                                "type": "text",
                                "text": " - You use the words \"microkernel\" and \"reactive\". I'm trying to figure out whether there is a direct connection between Lopecode and PBP(0D). I am hampered by a general ignorance of Observable. Comments (from anyone) might help me come down the learning curve. And, comments \/ questions \/ brainstorming (from anyone) about interrelationships (or non-interrelationships) between these ideas would be welcome.\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U06MJU6LBN3"
                            },
                            {
                                "type": "text",
                                "text": " - PLs and OSs are dead to me. It's not 1960 anymore and we need fresh ways to look at program development workflows. This looks quite interesting and fires various of my neurons regarding steal-able ideas."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1751200390.644259",
        "client_msg_id": "ae1b16b4-8507-407c-b1af-2b8085b92396",
        "text": "<@U02E4DAQGSZ> One more question that remains after going through the tour: what's the relation, if any, between cells and modules? Cells seem to be the same as in Observable notebooks. But the latter don't have modules, which in Lopecode are quite central.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YrLiM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U02E4DAQGSZ"
                            },
                            {
                                "type": "text",
                                "text": " One more question that remains after going through the tour: what's the relation, if any, between cells and modules? Cells seem to be the same as in Observable notebooks. But the latter don't have modules, which in Lopecode are quite central."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1751201308.738059",
        "client_msg_id": "c4e3f6c5-e158-462c-9503-6323c4fb1ebc",
        "text": "the runtime has modules and modules have reactive variables. thats the low level programming model and the core runtime state of the mu-kernel.\n\nCells are an artificial construct of the higher level language of Observable JS. This is what you see a notebook comprised of. Certain special cells actually map to more than one variables. A \"viewof X\" is two reactive variables, one holding a DOM node (the control plane, the UI, called \"viewof X\") and an inner one, the data plane (the \"X\") which is the data channel. A cell that imports looks like \"import {a,b,c} from \"z\"\", which is 1 cell, but it creates a dynamic import + a variable for each alias in the import (a,b,c), so is actually 4 reactive variables in total for that example.\n\nSo the concept of cells is the front end language and not a runtime concept directly. We don't need to really stick to that, I currently do for simplicity but Observable's new canvas product, for instance, is still sharing the same runtime but has done away with the notebook and cell concept entirely.\n\nSo a notebook _is_ a module (literally an ES module). The module is composed of variables in the runtime. Those variables are grouped in cells. So transitively, cells also belong to a module, but I think it would be more accurate to say cells belong to a notebook which is implemented as a module. There is a function called cellMap which will scan a module and figure out the variable groupings in the <https:\/\/observablehq.com\/@tomlarkworthy\/observablejs-toolchain#cell-4378|decompiler>.\n\nI have more notes <https:\/\/observablehq.com\/@tomlarkworthy\/observable-notes#cell-335|here> which I am slowly filling out with finer details, although its not very proof read and super well structurally thought out, its more for me to remember some of the stranger things I discover while stepping through the code.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "attachments": [
            {
                "image_url": "https:\/\/static.observableusercontent.com\/thumbnail\/f7e5be7747535b6e526cfd42de66b48a4f3a3b01c4be740eade7ae964805f284.jpg",
                "image_width": 640,
                "image_height": 400,
                "image_bytes": 32153,
                "from_url": "https:\/\/observablehq.com\/@tomlarkworthy\/observablejs-toolchain#cell-4378",
                "service_icon": "https:\/\/static.observablehq.com\/favicon-512.0667824687f99c942a02e06e2db1a060911da0bf3606671676a255b1cf97b4fe.png",
                "ts": 1726549488,
                "id": 1,
                "original_url": "https:\/\/observablehq.com\/@tomlarkworthy\/observablejs-toolchain#cell-4378",
                "fallback": "Observable: Bidirectional Observable JS  Runtime Toolchain",
                "text": "Compilation, source to runtime variable(s) Compilation takes notebook source cells written in `Observable Javascript` and turns them into reactive variables for execution in the `Observable Runtime`. A cell is usually compiled to one runtime variable, however, mutable variables are more complicated and are represented as three runtime variables. ObservableHQ does the compilation process as part of the hosted notebook experience but in this notebook we provide a way to do it in userspace. Decompilation, Runt",
                "title": "Bidirectional Observable JS  Runtime Toolchain",
                "title_link": "https:\/\/observablehq.com\/@tomlarkworthy\/observablejs-toolchain#cell-4378",
                "service_name": "Observable"
            },
            {
                "image_url": "https:\/\/static.observableusercontent.com\/thumbnail\/dab1604ccf4a760060379630da0876da27b79509b738f8d5c300c9a9a320e38a.jpg",
                "image_width": 640,
                "image_height": 400,
                "image_bytes": 17286,
                "from_url": "https:\/\/observablehq.com\/@tomlarkworthy\/observable-notes#cell-335",
                "service_icon": "https:\/\/static.observablehq.com\/favicon-512.0667824687f99c942a02e06e2db1a060911da0bf3606671676a255b1cf97b4fe.png",
                "ts": 1732356568,
                "id": 2,
                "original_url": "https:\/\/observablehq.com\/@tomlarkworthy\/observable-notes#cell-335",
                "fallback": "Observable: How the Observable Runtime works",
                "text": "Living documentation A lot of Observable is open source and MIT\/ISC licensed. Additional tools have been built by the community 1st party Observable JS parser Lezer Grammar for Observable JS Observable Runtime Standard Library Inspector 3rd party Access the runtime The Unofficial Observable Compiler Userspace Observable compiler and decompiler Notebook Distiller Single File Exporter How Observable works In this section I try to explain the main concepts, surfacing the runtime concepts as live variables you",
                "title": "How the Observable Runtime works",
                "title_link": "https:\/\/observablehq.com\/@tomlarkworthy\/observable-notes#cell-335",
                "service_name": "Observable"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PZe5Y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the runtime has modules and modules have reactive variables. thats the low level programming model and the core runtime state of the mu-kernel.\n\nCells are an artificial construct of the higher level language of Observable JS. This is what you see a notebook comprised of. Certain special cells actually map to more than one variables. A \"viewof X\" is two reactive variables, one holding a DOM node (the control plane, the UI, called \"viewof X\") and an inner one, the data plane (the \"X\") which is the data channel. A cell that imports looks like \"import {a,b,c} from \"z\"\", which is 1 cell, but it creates a dynamic import + a variable for each alias in the import (a,b,c), so is actually 4 reactive variables in total for that example.\n\nSo the concept of cells is the front end language and not a runtime concept directly. We don't need to really stick to that, I currently do for simplicity but Observable's new canvas product, for instance, is still sharing the same runtime but has done away with the notebook and cell concept entirely.\n\nSo a notebook "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a module (literally an ES module). The module is composed of variables in the runtime. Those variables are grouped in cells. So transitively, cells also belong to a module, but I think it would be more accurate to say cells belong to a notebook which is implemented as a module. There is a function called cellMap which will scan a module and figure out the variable groupings in the "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/observablehq.com\/@tomlarkworthy\/observablejs-toolchain#cell-4378",
                                "text": "decompiler"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nI have more notes "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/observablehq.com\/@tomlarkworthy\/observable-notes#cell-335",
                                "text": "here"
                            },
                            {
                                "type": "text",
                                "text": " which I am slowly filling out with finer details, although its not very proof read and super well structurally thought out, its more for me to remember some of the stranger things I discover while stepping through the code."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJBAJNFLK",
                    "U08LU2QRWB0"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U06SS0DHZD1",
        "type": "message",
        "ts": "1751201310.803219",
        "client_msg_id": "a2877f9c-37fd-4a94-bf60-894da415385b",
        "text": "<@UGWUJUZHT> no, it's a rather bespoke build script. I use it in a couple projects but copy it over and change a little each time.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "287ba5559ee1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-04-04\/6922823105585_287ba5559ee1cedd6b98_72.png",
            "first_name": "Marek",
            "real_name": "Marek Rogalski",
            "display_name": "maf",
            "team": "T5TCAFTA9",
            "name": "mafikpl",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PZ0nL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " no, it's a rather bespoke build script. I use it in a couple projects but copy it over and change a little each time."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1751201895.318289",
        "client_msg_id": "f151fa18-6906-470c-a571-0456f61c451e",
        "text": "&gt;  direct connection between Lopecode and PBP(0D)  -- <@UGWUJUZHT> \nbased on my reading of <https:\/\/programmingsimplicity.substack.com\/p\/towards-pbp-0d-for-bash-pondring?utm_campaign=post&amp;utm_medium=web|this>. Yes! Its a very similar programming model! In Observable each named cell has 1 output and n inputs which are late bound together to form a dataflow DAG. You can update the code for any cell and only the downstream cells are reevaluated. I see PBP allows multiple outputs per part, and technically the Observable runtime could also do this but currently the front end language Observable Javascript does not manifest that semantic, its only one output per cell. Roughly speaking a Part is a Cell. Also Observable Runtime \/ Lopecode its all clientside javascript so the environment is very different, but there are is a lot of conceptual overlap.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "attachments": [
            {
                "from_url": "https:\/\/programmingsimplicity.substack.com\/p\/towards-pbp-0d-for-bash-pondring?utm_campaign=post&utm_medium=web",
                "image_url": "https:\/\/substackcdn.com\/image\/fetch\/$s_!AlFl!,w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto\/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc13ef7d8-5f9c-497f-9d49-3735eb619be7_451x272.png",
                "image_width": 451,
                "image_height": 272,
                "image_bytes": 11163,
                "service_icon": "https:\/\/substackcdn.com\/image\/fetch\/%24s_!9I6g!,f_auto,q_auto:good,fl_progressive:steep\/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9bf28261-3dbc-4931-99f3-57bb47beeb02%2Fapple-touch-icon-57x57.png",
                "id": 1,
                "original_url": "https:\/\/programmingsimplicity.substack.com\/p\/towards-pbp-0d-for-bash-pondring?utm_campaign=post&amp;utm_medium=web",
                "fallback": "Towards PBP \/ 0D for Bash - Pond’ring Aloud",
                "text": "2025-03-20",
                "title": "Towards PBP \/ 0D for Bash - Pond’ring Aloud",
                "title_link": "https:\/\/programmingsimplicity.substack.com\/p\/towards-pbp-0d-for-bash-pondring?utm_campaign=post&utm_medium=web",
                "service_name": "programmingsimplicity.substack.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "joRoz",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " direct connection between Lopecode and PBP(0D)  -- "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nbased on my reading of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/programmingsimplicity.substack.com\/p\/towards-pbp-0d-for-bash-pondring?utm_campaign=post&utm_medium=web",
                                "text": "this"
                            },
                            {
                                "type": "text",
                                "text": ". Yes! Its a very similar programming model! In Observable each named cell has 1 output and n inputs which are late bound together to form a dataflow DAG. You can update the code for any cell and only the downstream cells are reevaluated. I see PBP allows multiple outputs per part, and technically the Observable runtime could also do this but currently the front end language Observable Javascript does not manifest that semantic, its only one output per cell. Roughly speaking a Part is a Cell. Also Observable Runtime \/ Lopecode its all clientside javascript so the environment is very different, but there are is a lot of conceptual overlap."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1751202569.480229",
        "client_msg_id": "b6fa4653-cd76-497f-9418-eaa0b026d871",
        "text": "&gt; And dataflow was originally represented in text, not visually!\nPlease expand on this point. Thanks. <@UH85W1ML1>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1751025396.555809",
        "parent_user_id": "U02E4DAQGSZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pH6fr",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And dataflow was originally represented in text, not visually!"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nPlease expand on this point. Thanks. "
                            },
                            {
                                "type": "user",
                                "user_id": "UH85W1ML1"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1751203490.187409",
        "client_msg_id": "dbd9f049-3868-4f33-b0fc-857b68a5b49e",
        "text": "<@U02E4DAQGSZ>\n\n&gt; ... I see PBP allows multiple outputs per part ...\nbrainstorming: From playing with electronics, I call multiple inputs \"fan-in\" and multiple outputs \"fan-out\". Fan-out seems to be eschewed by FP. Multiple inputs and multiple outputs in FP is an illusion created by the power of destructuring (one blob of data, containing many non-homogenous datums). Fan-out, IMO, means data coming at different *times* (like requests to servers and daemons). Function-based thinking rules this kind of thing out. For example, Morrison's <https:\/\/jpaulm.github.io\/fbp\/index.html|FBP> does not allow fan-out, mostly (I think) on the basis that it is mathematically difficult to express in typeset text (`\/bin\/*sh` took a stab at this using clumsy textual syntax like `|2` and program-lets like `tee`, but that clumsiness just makes the goodness go away)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "attachments": [
            {
                "from_url": "https:\/\/jpaulm.github.io\/fbp\/index.html",
                "id": 1,
                "original_url": "https:\/\/jpaulm.github.io\/fbp\/index.html",
                "fallback": "Official website for flow-based programming",
                "text": "Official website for flow-based programming",
                "service_name": "jpaulm.github.io"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kzmD9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U02E4DAQGSZ"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... I see PBP allows multiple outputs per part ..."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nbrainstorming: From playing with electronics, I call multiple inputs \"fan-in\" and multiple outputs \"fan-out\". Fan-out seems to be eschewed by FP. Multiple inputs and multiple outputs in FP is an illusion created by the power of destructuring (one blob of data, containing many non-homogenous datums). Fan-out, IMO, means data coming at different "
                            },
                            {
                                "type": "text",
                                "text": "times",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (like requests to servers and daemons). Function-based thinking rules this kind of thing out. For example, Morrison's "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/jpaulm.github.io\/fbp\/index.html",
                                "text": "FBP"
                            },
                            {
                                "type": "text",
                                "text": " does not allow fan-out, mostly (I think) on the basis that it is mathematically difficult to express in typeset text ("
                            },
                            {
                                "type": "text",
                                "text": "\/bin\/*sh",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " took a stab at this using clumsy textual syntax like "
                            },
                            {
                                "type": "text",
                                "text": "|2",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and program-lets like "
                            },
                            {
                                "type": "text",
                                "text": "tee",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but that clumsiness just makes the goodness go away)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1751206012.994739",
        "client_msg_id": "f5947c45-636f-438e-9933-2a2458a1dc1c",
        "text": "I think the clearest use case for fan-out is a switch (where the dataflow goes to 1-of-n mutually exclusive ways), which is missing from Observable, in electronics this is a tristate bus where a component decides which of n components its currently connected to (its dataflow is turned off to all but one). You can't build that kind of logic with one output value. However, if you consider a reactive variable to be the wiring of the ports in the PBD diagram, and not the parts themselves, then you can make parts out of \"collections of ports\". So in that sense, you don't need multiple returns values, you need to be able to construct higher order components out of these lower level reactive wires.\n\nI guess important to understanding PBP is what are the semantics of notification. Probably there are massive differences in the approach on that detail. In observable the variable is a scheduled function, but that function can also be a generator, which means that when recomputed, the variable can emit a stream of values onto the dataflow graph, and thus trigger its dependants to recompute many times. I don't expect many reactive systems to have that fanout-over-time semantics. Its useful to have a gameloop defined like this, where the one gameloop is triggering dataflow ticks every animation frame autonomously.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hMi+c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think the clearest use case for fan-out is a switch (where the dataflow goes to 1-of-n mutually exclusive ways), which is missing from Observable, in electronics this is a tristate bus where a component decides which of n components its currently connected to (its dataflow is turned off to all but one). You can't build that kind of logic with one output value. However, if you consider a reactive variable to be the wiring of the ports in the PBD diagram, and not the parts themselves, then you can make parts out of \"collections of ports\". So in that sense, you don't need multiple returns values, you need to be able to construct higher order components out of these lower level reactive wires.\n\nI guess important to understanding PBP is what are the semantics of notification. Probably there are massive differences in the approach on that detail. In observable the variable is a scheduled function, but that function can also be a generator, which means that when recomputed, the variable can emit a stream of values onto the dataflow graph, and thus trigger its dependants to recompute many times. I don't expect many reactive systems to have that fanout-over-time semantics. Its useful to have a gameloop defined like this, where the one gameloop is triggering dataflow ticks every animation frame autonomously."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1751210328.938629",
        "client_msg_id": "5bbfebe9-1053-472a-813c-13f48b7f5d79",
        "text": "Thanks <@U02E4DAQGSZ>, that was very helpful. I hadn't realized that Lopecode modules were ES modules. That's one concept less to keep in mind! :laughing:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NBxDr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "U02E4DAQGSZ"
                            },
                            {
                                "type": "text",
                                "text": ", that was very helpful. I hadn't realized that Lopecode modules were ES modules. That's one concept less to keep in mind! "
                            },
                            {
                                "type": "emoji",
                                "name": "satisfied",
                                "unicode": "1f606"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1751211817.332899",
        "client_msg_id": "9e8ef105-34e5-4604-bd6d-da1afc415e1f",
        "text": "This is actually a question, but, I don't know how to form it as a question. A scheduled function is just a tiny \"process\". A scheduled function can trigger other scheduled functions. A scheduled function \"call\" is a non-blocking \"call\" to some other tiny process. Can a scheduled function trigger itself? A non-scheduled function can call itself - that's called \"recursion\". But, it's not \"recursion\" when a scheduled function triggers itself. I call that \"feedback\". Are scheduled functions required to return a result to their \"callers\" (triggerers)? AFAICT in FP, this routing policy is enforced and has resulted in clumsiness like \".then\". OTOH if a scheduled function is not required to return a result to its triggerer, then it's not a \"function\" it's a \"procedure\" with side-effects. (IMO, that's a good thing).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wHiIG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is actually a question, but, I don't know how to form it as a question. A scheduled function is just a tiny \"process\". A scheduled function can trigger other scheduled functions. A scheduled function \"call\" is a non-blocking \"call\" to some other tiny process. Can a scheduled function trigger itself? A non-scheduled function can call itself - that's called \"recursion\". But, it's not \"recursion\" when a scheduled function triggers itself. I call that \"feedback\". Are scheduled functions required to return a result to their \"callers\" (triggerers)? AFAICT in FP, this routing policy is enforced and has resulted in clumsiness like \".then\". OTOH if a scheduled function is not required to return a result to its triggerer, then it's not a \"function\" it's a \"procedure\" with side-effects. (IMO, that's a good thing)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1751212320.074439",
        "client_msg_id": "e1c2375e-1757-4d13-8d8e-cc6ac80a0d41",
        "text": "... fan-out: fan-out requires copying or, at least, copy-on-write - concepts that were not memetically available in the 1960s. Now, with abundant GC, this kind of thing is a no-brainer ....",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6Kkc0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "... fan-out: fan-out requires copying or, at least, copy-on-write - concepts that were not memetically available in the 1960s. Now, with abundant GC, this kind of thing is a no-brainer ...."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1751217634.511119",
        "client_msg_id": "14cba705-3a6d-4a3a-a0b7-03530c8e483c",
        "text": "Hi, we have a date for our new online FoC meetup : Wednesday 23th of July 18:00UTC ..this is the link for the event on luma : <https:\/\/lu.ma\/1d5mc44t> .. and more information about the setup of our virtual meetups can be found here: <https:\/\/futureofcoding.org\/meetups> (please read carefully if you want to demo\/present) .. for next meetup we already have one confirmed guest so we're looking for2 more demo\/presenter. Let us know in the chat here or contact me directly. Thanks!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "533c1a6943bf",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-03-16\/8613805779220_533c1a6943bfc0b7f150_72.jpg",
            "first_name": "Maikel",
            "real_name": "Maikel van de Lisdonk",
            "display_name": "Maikel",
            "team": "T5TCAFTA9",
            "name": "maikel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "image_url": "https:\/\/social-images.lu.ma\/cdn-cgi\/image\/format=auto,fit=cover,dpr=1,anim=false,background=white,quality=75,width=800,height=419\/api\/event-one?calendar_avatar=https%3A%2F%2Fimages.lumacdn.com%2Fcalendars%2Fv7%2F0006490f-40ea-4246-8240-478fb643d1d7&calendar_name=Future%20of%20Coding%20Virtual%20Meetup&color0=%2301cc88&color1=%23fbfdfd&color2=%2357dcae&color3=%23aceed8&host_avatar=https%3A%2F%2Fimages.lumacdn.com%2Favatars%2Fds%2F240da0e6-d661-4e38-9d15-f5c8022b2a28.jpg&host_name=Maikel%20van%20de%20Lisdonk&img=https%3A%2F%2Fimages.lumacdn.com%2Fevent-covers%2Fqy%2Fedb27d55-0bc0-4ec8-a577-3233766b5761.png&name=FoC%20Meetup",
                "image_width": 800,
                "image_height": 419,
                "image_bytes": 14685,
                "from_url": "https:\/\/lu.ma\/1d5mc44t",
                "service_icon": "https:\/\/lu.ma\/apple-touch-icon.png",
                "id": 1,
                "original_url": "https:\/\/lu.ma\/1d5mc44t",
                "fallback": "FoC Meetup · Luma",
                "text": "Information about our meetup can be found here : <https:\/\/futureofcoding.org\/meetups>",
                "title": "FoC Meetup · Luma",
                "title_link": "https:\/\/lu.ma\/1d5mc44t",
                "service_name": "lu.ma"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mh1OX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi, we have a date for our new online FoC meetup : Wednesday 23th of July 18:00UTC ..this is the link for the event on luma : "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/lu.ma\/1d5mc44t"
                            },
                            {
                                "type": "text",
                                "text": " .. and more information about the setup of our virtual meetups can be found here: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/futureofcoding.org\/meetups"
                            },
                            {
                                "type": "text",
                                "text": " (please read carefully if you want to demo\/present) .. for next meetup we already have one confirmed guest so we're looking for2 more demo\/presenter. Let us know in the chat here or contact me directly. Thanks!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "tada",
                "users": [
                    "U02E4DAQGSZ",
                    "U05UK5T7LPP",
                    "U08LU2QRWB0"
                ],
                "count": 3
            },
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U04BQN4K3AP"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02E4DAQGSZ",
        "type": "message",
        "ts": "1751220383.490669",
        "client_msg_id": "81343ab6-fc8a-4c2f-9a1b-2ae548f7d68f",
        "text": "&gt;  A scheduled function can trigger other scheduled functions\nOnly indirectly though (in runtime), due to late binding. So a schedule function publishes a value to a named location. There might not be a consumer of that value at the time of publishing. Later on you might later add the code to consume it, so the delivery to the next schedule function might occur much later.\n\nA synchronised function calling itself is recursion. A scheduled function could refer to its previous value, which is more like a fold over time. This is actually possible in observable by using the keyword \"this\", which refers to the prior value of the variable (<https:\/\/github.com\/observablehq\/runtime?tab=readme-ov-file#variabledefinename-inputs-definition|docs>).\n\n```When the definition is invoked, the value of this is the variable's previous value, or undefined if this is the first time the variable is being computed under its current definition. Thus, the previous value is preserved only when input values change; it is not preserved if the variable is explicitly redefined.```\nSome of your words imply scheduled functions are triggering other functions directly. This is not how it works in Observable runtime. The dataflow scheduler is like a trampoline that is managing invoking functions, and it manages gathering the data to populate the input args. The functions themselves jsut declare what inputs they want (what outputs of other functions they depend on). If those inputs do not exist, the function is not scheduled. If any of those inputs change, the function is called, and it emits a value, which is then used to chain onto other functions if the runtime deems necessary. The scheduled functions do not trigger each other! The runtime triggers them, and makes decisions about whether more functions need to be triggered or not based on the dependancy graph.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "27dffd0e73bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2483463922595_27dffd0e73bd6f709927_72.gif",
            "first_name": "Tom",
            "real_name": "Tom Larkworthy",
            "display_name": "Tom Larkworthy",
            "team": "T5TCAFTA9",
            "name": "tom.larkworthy",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A0c6k",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " A scheduled function can trigger other scheduled functions"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Only indirectly though (in runtime), due to late binding. So a schedule function publishes a value to a named location. There might not be a consumer of that value at the time of publishing. Later on you might later add the code to consume it, so the delivery to the next schedule function might occur much later.\n\nA synchronised function calling itself is recursion. A scheduled function could refer to its previous value, which is more like a fold over time. This is actually possible in observable by using the keyword \"this\", which refers to the prior value of the variable ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/observablehq\/runtime?tab=readme-ov-file#variabledefinename-inputs-definition",
                                "text": "docs"
                            },
                            {
                                "type": "text",
                                "text": ").\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When the definition is invoked, the value of this is the variable's previous value, or undefined if this is the first time the variable is being computed under its current definition. Thus, the previous value is preserved only when input values change; it is not preserved if the variable is explicitly redefined."
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSome of your words imply scheduled functions are triggering other functions directly. This is not how it works in Observable runtime. The dataflow scheduler is like a trampoline that is managing invoking functions, and it manages gathering the data to populate the input args. The functions themselves jsut declare what inputs they want (what outputs of other functions they depend on). If those inputs do not exist, the function is not scheduled. If any of those inputs change, the function is called, and it emits a value, which is then used to chain onto other functions if the runtime deems necessary. The scheduled functions do not trigger each other! The runtime triggers them, and makes decisions about whether more functions need to be triggered or not based on the dependancy graph."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UH85W1ML1",
        "type": "message",
        "ts": "1751221032.525779",
        "client_msg_id": "603e426a-1538-4dea-86a9-1dd8234ffa26",
        "text": "I don't think we had graphical representations of programs before Sutherland '66 and GRAIL '69?  But, dataflow programming existed before that.  Sutherland built his <https:\/\/dspace.mit.edu\/handle\/1721.1\/13474|thesis> atop <https:\/\/mirrors.meulie.net\/bitsavers.org\/pdf\/mit\/tx-2\/rcsri.org_library_tx2\/TX2-Memos-Coral_196407.pdf|CORAL>, from '64, which calls out \"flow diagram\" as a thing it might be good for.  Morrison claims \"late 60s\" for flow-based programming, and wrote <https:\/\/wiki.c2.com\/?BmoMech|its first implementation (AMPS) in S\/360 assembly language>, decidedly not graphically.  Bell Labs had <https:\/\/archive.org\/details\/bstj40-3-669|BLODI> in '61.  Wikipedia lists a bunch of more recent ones, but also, as a development paradigm, can't you do a dataflow architecture in basically any programming language (but especially functional ones, so, LISP was '50s)?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2c0e4a3979e8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-02-28\/8529852667013_2c0e4a3979e8e92c4924_72.jpg",
            "first_name": "",
            "real_name": "Vitorio Miliano",
            "display_name": "vitorio",
            "team": "T5TCAFTA9",
            "name": "vito_futureofcoding",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1751025396.555809",
        "parent_user_id": "U02E4DAQGSZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ABTHI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't think we had graphical representations of programs before Sutherland '66 and GRAIL '69?  But, dataflow programming existed before that.  Sutherland built his "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/dspace.mit.edu\/handle\/1721.1\/13474",
                                "text": "thesis"
                            },
                            {
                                "type": "text",
                                "text": " atop "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/mirrors.meulie.net\/bitsavers.org\/pdf\/mit\/tx-2\/rcsri.org_library_tx2\/TX2-Memos-Coral_196407.pdf",
                                "text": "CORAL"
                            },
                            {
                                "type": "text",
                                "text": ", from '64, which calls out \"flow diagram\" as a thing it might be good for.  Morrison claims \"late 60s\" for flow-based programming, and wrote "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/wiki.c2.com\/?BmoMech",
                                "text": "its first implementation (AMPS) in S\/360 assembly language"
                            },
                            {
                                "type": "text",
                                "text": ", decidedly not graphically.  Bell Labs had "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/archive.org\/details\/bstj40-3-669",
                                "text": "BLODI"
                            },
                            {
                                "type": "text",
                                "text": " in '61.  Wikipedia lists a bunch of more recent ones, but also, as a development paradigm, can't you do a dataflow architecture in basically any programming language (but especially functional ones, so, LISP was '50s)?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1751265203.335719",
        "client_msg_id": "df3b9737-c307-4b81-9b52-dba1958e073c",
        "text": "Wondering: would the <https:\/\/en.wikipedia.org\/wiki\/Linda_(coordination_language)|Linda> execution model be appropriate here? You get fan-out and parallel evaluation. But it's not lazy.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1750965548.013389",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DoSei",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wondering: would the "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Linda_(coordination_language)",
                                "text": "Linda"
                            },
                            {
                                "type": "text",
                                "text": " execution model be appropriate here? You get fan-out and parallel evaluation. But it's not lazy."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]