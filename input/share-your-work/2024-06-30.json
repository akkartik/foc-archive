[
    {
        "user": "U0123H7JRDM",
        "type": "message",
        "ts": "1719749744.872729",
        "client_msg_id": "F5844A7C-E109-41A0-9345-5A664A71C234",
        "text": "I was wondering why asynchronous dataflow leads to less bugs the synchronous dataflow? Can you elaborate on this <@UGWUJUZHT> ? :blush: ",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "533c1a6943bf",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-03-16\/8613805779220_533c1a6943bfc0b7f150_72.jpg",
            "first_name": "Maikel",
            "real_name": "Maikel van de Lisdonk",
            "display_name": "Maikel",
            "team": "T5TCAFTA9",
            "name": "maikel",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ctuz6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was wondering why asynchronous dataflow leads to less bugs the synchronous dataflow? Can you elaborate on this "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " ? "
                            },
                            {
                                "type": "emoji",
                                "name": "blush",
                                "unicode": "1f60a"
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719761155.782009",
        "client_msg_id": "9595928d-3059-4912-a6a1-894769629a8c",
        "text": "#1: Observation - I know how to build hardware and read schematics, and, I know how to write code. The observation which has perplexed me for decades is that when I build hardware, it is much more reliable than when I build software.  Hardware producers would provide guarantees on their products, while software producers hide behind EULAs. (Why?)\n\n#2: Observation - hardware “programming language” (schematics) is much more concise than most software programming languages. For example, the game of Pong in 1972 fit on one piece of paper, long before Functional Programming and Type Checking hit the mainstream. The 1972 version of Pong doesn’t even have a CPU in it.\n\n#3: Observation - something in our software workflow is causing bloat. Apps are ridiculously huge today. Software has become ridiculously complicated. For example, I can build a new language much, much faster (10x?, 100x?, …) using t2t (OhmJS + my own nano-DSL “RWR”) than if I use LLVM and friends. I can finish the new language in less time than it takes me to RTFM and to learn LLVM.\n\n#4: Observation: in hardware, every component is - by default - asynchronous. In software, though, every component is - by default - synchronous.\n\nMy guess, my gut feel: simplicity. Asychronousity allows me to use divide-and-conquer and to solve-problems-and-implement components in small pieces, whereas building software is like crafting an intricate Swiss watch with 100’s of tiny gears. If a tooth breaks in any of the synchronous gears, the whole thing doesn’t work. If an async component breaks, I can isolate it and focus on it and fix it. It ain’t inherently more reliable, but, I can fix things easier and better. The simplicity of asynchronous design is like using LEGO blocks - I can imagine and implement much more interesting (aka “complicated”) apps using software asynchronous blocks. [aside: today’s “code libraries” are not LEGO blocks, they must be used in a synchronous manner, it’s synchrony all the way down]. [aside, knowing hardware, I see function-based programming as an inefficient use of CPU power, requiring extra software to support the function-based paradigm (note the use of the term “function-based” which is a superset of what we call “functional programming” today).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1zojt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "#1: Observation - I know how to build hardware and read schematics, and, I know how to write code. The observation which has perplexed me for decades is that when I build hardware, it is much more reliable than when I build software.  Hardware producers would provide guarantees on their products, while software producers hide behind EULAs. (Why?)\n\n#2: Observation - hardware “programming language” (schematics) is much more concise than most software programming languages. For example, the game of Pong in 1972 fit on one piece of paper, long before Functional Programming and Type Checking hit the mainstream. The 1972 version of Pong doesn’t even have a CPU in it.\n\n#3: Observation - something in our software workflow is causing bloat. Apps are ridiculously huge today. Software has become ridiculously complicated. For example, I can build a new language much, much faster (10x?, 100x?, …) using t2t (OhmJS + my own nano-DSL “RWR”) than if I use LLVM and friends. I can finish the new language in less time than it takes me to RTFM and to learn LLVM.\n\n#4: Observation: in hardware, every component is - by default - asynchronous. In software, though, every component is - by default - synchronous.\n\nMy guess, my gut feel: simplicity. Asychronousity allows me to use divide-and-conquer and to solve-problems-and-implement components in small pieces, whereas building software is like crafting an intricate Swiss watch with 100’s of tiny gears. If a tooth breaks in any of the synchronous gears, the whole thing doesn’t work. If an async component breaks, I can isolate it and focus on it and fix it. It ain’t inherently more reliable, but, I can fix things easier and better. The simplicity of asynchronous design is like using LEGO blocks - I can imagine and implement much more interesting (aka “complicated”) apps using software asynchronous blocks. [aside: today’s “code libraries” are not LEGO blocks, they must be used in a synchronous manner, it’s synchrony all the way down]. [aside, knowing hardware, I see function-based programming as an inefficient use of CPU power, requiring extra software to support the function-based paradigm (note the use of the term “function-based” which is a superset of what we call “functional programming” today)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U079PRQNZQD",
        "type": "message",
        "ts": "1719774802.282559",
        "client_msg_id": "FB2AA108-5411-4BA6-85DD-44261051D4D6",
        "text": "Great points <@UGWUJUZHT>. Do you have any experience with LabVIEW? It’s a very structured visual programming environment. Just in the last four or five years, they introduced asynchronous data flow wires. They started working on an asynchronous diagram, but that was part of a new, next generation platform that was mothballed.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "f8e9e1123d49",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-06-25\/7345443578225_f8e9e1123d49f08bf7e8_72.png",
            "first_name": "Jim",
            "real_name": "Jim Kring",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jim.kring",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1rkOS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great points "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": ". Do you have any experience with LabVIEW? "
                            },
                            {
                                "type": "text",
                                "text": "It’s"
                            },
                            {
                                "type": "text",
                                "text": " a very structured visual programming environment. Just in the last four or five years, they introduced asynchronous data flow wires. They started working on an asynchronous diagram, but that was part of a new, next generation platform that was mothballed."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719775035.106879",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1719775153.000000"
        },
        "client_msg_id": "9276ab61-a9bf-40ac-a180-b03b1b2f9e28",
        "text": "I've looked at LabVIEW but haven't used it. Feel free to educate me. <@U079PRQNZQD>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cKuuN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've looked at LabVIEW but haven't used it. Feel free to educate me. "
                            },
                            {
                                "type": "user",
                                "user_id": "U079PRQNZQD"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1719775876.539919",
        "client_msg_id": "94915fe8-b6ec-4360-b74e-d18c1ff86ced",
        "text": "<@UGWUJUZHT> While I agree with all your observations, I am not convinced by the explanation. My own speculative hypothesis for the relevant difference between hardware and software is Turing-completeness leading to chaotic dynamics and thus an infinity of failure modes (see <https:\/\/hal.science\/hal-02071770\/document|here> for a more detailed argumentation). But I am not that convinced of my own hypothesis either.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZMMyp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " While I agree with all your observations, I am not convinced by the explanation. My own speculative hypothesis for the relevant difference between hardware and software is Turing-completeness leading to chaotic dynamics and thus an infinity of failure modes (see "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/hal.science\/hal-02071770\/document",
                                "text": "here"
                            },
                            {
                                "type": "text",
                                "text": " for a more detailed argumentation). But I am not that convinced of my own hypothesis either."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U079PRQNZQD",
        "type": "message",
        "ts": "1719779496.037489",
        "client_msg_id": "F20409CC-63A6-4753-B04D-F462F55ED21F",
        "text": "<@UGWUJUZHT> you can download the LabVIEW community edition for free. This is a really good book. The author is fantastic :wink:\nLabVIEW for Everyone: Graphical Programming Made Easy and Fun <https:\/\/a.co\/d\/0fPloe9u|https:\/\/a.co\/d\/0fPloe9u>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "f8e9e1123d49",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-06-25\/7345443578225_f8e9e1123d49f08bf7e8_72.png",
            "first_name": "Jim",
            "real_name": "Jim Kring",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jim.kring",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+Lcpi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " you can download the LabVIEW community edition for free. This is a really good book. The author is fantastic "
                            },
                            {
                                "type": "emoji",
                                "name": "wink",
                                "unicode": "1f609"
                            },
                            {
                                "type": "text",
                                "text": "\nLabVIEW for Everyone: Graphical Programming Made Easy and Fun "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/a.co\/d\/0fPloe9u",
                                "text": "https:\/\/a.co\/d\/0fPloe9u"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719803252.126019",
        "client_msg_id": "e611b0f5-4db7-47d3-b2f7-1c566c5192e2",
        "text": "<@UJBAJNFLK> Hmm, I sense that I should want to understand your argument, but, as it stands I don’t get it yet. I think that you’re saying that software can veer wildly off-course if nudged or perturbed, but, I don’t understand how this contrasts with hardware. These thoughts fire neurons regarding Dave Ackley’s “robust first computing” (a way of making software survive severe damage and perturbation). To prime the pump, since we’re in vastly different timezones, let me say that from my perspective, Smalltalk does not do “message passing” (!), it, instead, does synchronous method calling. If the Smalltalk class hierarchy were rewritten in an asynchronous manner all the way down, like I perceive hardware to be, then Smalltalk’s std hierarchy would change drastically. How does this perspective dovetail with your argument?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2+BeE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " Hmm, I sense that I should want to understand your argument, but, as it stands I don’t get it yet. I think that you’re saying that software can veer wildly off-course if nudged or perturbed, but, I don’t understand how this contrasts with hardware. These thoughts fire neurons regarding Dave Ackley’s “robust first computing” (a way of making software survive severe damage and perturbation). To prime the pump, since we’re in vastly different timezones, let me say that from my perspective, Smalltalk does not do “message passing” (!), it, instead, does synchronous method calling. If the Smalltalk class hierarchy were rewritten in an asynchronous manner all the way down, like I perceive hardware to be, then Smalltalk’s std hierarchy would change drastically. How does this perspective dovetail with your argument?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1719814320.768409",
        "client_msg_id": "0210d7f5-9a87-47ea-8be1-32fa2ff220cd",
        "text": "<@UGWUJUZHT> Yes, Dave Ackley's \"robust computing\" is very much aligned with my arguments. For me, the difference between hardware engineering and software engineering is that the former avoids chaotic behavior, and thus unpredictable failure modes,  at all levels of design, whereas the latter goes for the \"full power\" of Turing completeness and tacitly accepts the unreliability of large assemblies as a consequence.\nThere is then, of course, the question of why the two disciplines took different paths. My (now highly speculative) ideas are: (1) Maturity. Hardware engineering grew slowly, software engineering grew explosively. (2) Cost constraints. Production costs make investment into good design more valuable. And from your arguments, I'd be happy to add (3) Synchronicity. Asynchronous evolution makes chaotic behavior problematic even at small scales, and thus provides the incentives to avoid it much earlies in the disciplines evolution.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dk+Q9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " Yes, Dave Ackley's \"robust computing\" is very much aligned with my arguments. For me, the difference between hardware engineering and software engineering is that the former avoids chaotic behavior, and thus unpredictable failure modes,  at all levels of design, whereas the latter goes for the \"full power\" of Turing completeness and tacitly accepts the unreliability of large assemblies as a consequence.\nThere is then, of course, the question of why the two disciplines took different paths. My (now highly speculative) ideas are: (1) Maturity. Hardware engineering grew slowly, software engineering grew explosively. (2) Cost constraints. Production costs make investment into good design more valuable. And from your arguments, I'd be happy to add (3) Synchronicity. Asynchronous evolution makes chaotic behavior problematic even at small scales, and thus provides the incentives to avoid it much earlies in the disciplines evolution."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]