<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2020-09-19/1372124144885_40f3551ff56134e83fb6_72.png" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robbie Gleichman</b>
<span style="margin:2em; color:#606060">2020-05-29 22:47</span><br/>
I've put together a few slides about Glance's goals and strategy. Questions and criticism welcome. TLDR: The Glance project aims to "dramatically increase the programming capabilities of everyone (especially beginners) by creating a visual programming inspired software creation tool that is both easy to learn and powerful enough to solve complex problems." <a href="https://docs.google.com/presentation/d/1vm0uyc_swsSMTe_uIigCH-TBWj3QAX_4wYFoamFgI4w/edit?usp=sharing">https://docs.google.com/presentation/d/1vm0uyc_swsSMTe_uIigC&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590822732.232500"></a>
      <img src="https://avatars.slack-edge.com/2025-03-16/8613805779220_533c1a6943bfc0b7f150_72.jpg" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1590822732.232500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Maikel van de Lisdonk</b>
<span style="margin:2em; color:#606060">2020-05-30 00:12</span><br/>
Very interesting and thanks for sharing! Are your findings based on (existing) research? I am building a visual programming environment myself and try to map it less directly on textual program language commands although some nodes in the flow perform very simple taks like checking a condition or performing an assignment. I want to abstract away certain bigger tasks inside the nodes themselves (which can be extended by plugins)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590825751.232700"></a>
      <img src="https://avatars.slack-edge.com/2020-09-19/1372124144885_40f3551ff56134e83fb6_72.png" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1590825751.232700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robbie Gleichman</b>
<span style="margin:2em; color:#606060">2020-05-30 01:02</span><br/>
&gt; Are your findings based on (existing) research?<br/>Not really. My supposition that<br/>&gt; <b>The visual programming complexity ceiling exists because</b> visual syntax becomes large and cluttered when representing large programs <br/>&gt; and the semantics of the visual language do not support sufficient abstractions.<br/>is a bit of a simplification, and there are other problems with visual programming that aren't mentioned. Also, there are some visual languages that are general purpose ("support sufficient abstractions"), but it's uncommon.<br/><br/>The proposed solutions are not directly based on research.<br/><br/>There has been some research comparing the understandability of visual representations vs. textual representations. The paper "<a href="https://www.cl.cam.ac.uk/~afb21/publications/aire.pdf">Cognitive Factors in Programming with Diagrams"</a> has an overview of some of the older research.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590851167.238400"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1590851167.238400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-05-30 08:06</span><br/>
I read your slideshow with great interest. One thing I would like to caution you about is that the example you chose the fizz buzz program is far too small a task. If you measure length of programs by counting the words, in the textual version a task like fizzbuzz is so near zero words that it doesn’t provide any information about whether or not the graphic of notation is helpful at mitigating complexity. In my Beads project samples I show a ramp of difficulty starting with a clock and going to TicTacToe, minesweeper, to chess, and then to the start of an IDE. Chess is over 1000 words, and is an excellent small test, as it combines both graphics and somewhat complex rules. I suggest you pick a task to program that has enough complexity that it cannot be represented on one screen and directly confront the central problem we are trying to solve. Which is how to make something more understandable then textual format does. If you limit yourself to trivial examples you will generate a false positive on the value Of your graphical representation. Even TicTacToe is hard enough that your diagrams would get A little messy. So I think you should Avoid basing your examples on a task too simple.  Another example that’s too simple is the to do list, which is often presented to show how simple a new language would be, Any example based on data entry Fields is inevitably going to hide the million lines of code that goes into properly handling a multi lingual text entry box. operating systems exist just to handle the text entry box, Because the intrinsic complexity of rendering Truetype fonts and input method editors for Asian languages, and you are talking thousands of man-months, all concealed in the underlying layers.<br/><br/>You can pick a graphical task or a business task or a Database kind of task, but whatever task area you do select for your example, please be sure it has enough intrinsic complexity to go beyond what can be shown with a dozen nodes.<br/><br/>I would also caution you that a goal of delivering "an easy to read visual representation of Haskell" is probably an oxymoron, because there is nothing that easy about reading Haskell. Some of Haskell's fancy features like currying are of negligible practical value, and make it very hard to read, because now you have to know at all times how many arguments a function expects, so you can tell the difference between passing a function pointer with a missing arg, or calling a function. Nothing easy to read about that feature; it is pure poison to a reader and for that reason i rejected it instantly as a feature in Beads.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590879190.252000"></a>
      <img src="https://avatars.slack-edge.com/2020-07-25/1286770110448_0c5d8f6a2266551a36f2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1590879190.252000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Garcia</b>
<span style="margin:2em; color:#606060">2020-05-30 15:53</span><br/>
I’m interested in pair programming <span style="background-color:#ccf">@Robbie Gleichman</span>! How are you thinking about managing the pair programming sessions?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590898482.252500"></a>
      <img src="https://avatars.slack-edge.com/2020-09-19/1372124144885_40f3551ff56134e83fb6_72.png" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1590898482.252500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robbie Gleichman</b>
<span style="margin:2em; color:#606060">2020-05-30 21:14</span><br/>
<span style="background-color:#ccf">@Daniel Garcia</span> Awesome! I'm open to suggestions. I'll send you a direct message to set something up.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590905897.259900"></a>
      <img src="https://avatars.slack-edge.com/2025-03-16/8613805779220_533c1a6943bfc0b7f150_72.jpg" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1590905897.259900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Maikel van de Lisdonk</b>
<span style="margin:2em; color:#606060">2020-05-30 23:18</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> I think you raise some good points also valid for a lot other projects (including mine). But I think it's also important to look at the domain your targeting and look at complex examples within that domain. <span style="background-color:#ccf">@Robbie Gleichman</span> are you also planning to go commercial with your project or are you developing this from a research perspective? Which domain are you targeting?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590911061.260100"></a>
      <img src="https://avatars.slack-edge.com/2020-09-19/1372124144885_40f3551ff56134e83fb6_72.png" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1590911061.260100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robbie Gleichman</b>
<span style="margin:2em; color:#606060">2020-05-31 00:44</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> Yes, I agree that it will be necessary to demonstrate its capabilities with sufficiently complex examples. In terms of the readability of Haskell, I do see the project moving beyond Haskell after Step 0 to a simpler language. Partially applied functions however, are something that a visual editor could make explicit. For example, ((+) 1) could be displayed as ((+) 1 O) where O represents the missing argument.<br/><br/>On a side note, I don't fully understand your criticism of currying. Are you talking about reading code that you know is correct, buggy code where you suspect some arguments are missing, or code you are in the middle of writing?  To paraphrase your argument, with currying you don't know if the type of (f x) is a plain value or a function. But that ambiguity exists in any language where functions can return functions.<br/><span style="background-color:#ccf">@Maikel van de Lisdonk</span> I'm presenting it as a research project, although if successful I could see it inspiring commercial projects. My goal is to create something general purpose, so right now I'm not targeting a specific domain. My plan is to start by dogfooding it by developing Glance using Glance, and once all of the obvious bugs are fixed pick a substantial project to implement.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590963647.260500"></a>
      <img src="https://avatars.slack-edge.com/2025-02-08/8407560079991_6d3ec7cc938bc2e0cdb7_72.png" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1590963647.260500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Cole Lawrence</b>
<span style="margin:2em; color:#606060">2020-05-31 15:20</span><br/>
<span style="background-color:#ccf">@Robbie Gleichman</span> thanks for sharing these graphics! I know how much work it can be to put diagrams like that together. I have similar feelings as <span style="background-color:#ccf">@magicmouse94937</span>, in that I would worry the examples are too low level. The majority of "business people" (for example) who need to program are not doing complex math with reducers or functional programming. So, I would really conceptualize the kinds of problems you want your language users to be able to solve. At my company, we are building a textual language which operates at a far higher level like<br/><tt>once daily (at: 9am):</tt><br/>    <tt>(@Postmates) (send) (item description: "Any kind of flowers") (to address: 📍324 Madison)</tt><br/>Parens would not be necessary in our editor and our language is a bit richer allowing you to use things like <a href="http://like%20this">links</a> to reference variables.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1590970123.261200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1590970123.261200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-05-31 17:08</span><br/>
<span style="background-color:#ccf">@Robbie Gleichman</span> I cannot think of an example in any of the 20 sample programs i have written so far, where currying could be applied. Ambiguity is the enemy of comprehension, and in any language where you can't tell if something is a simple function call or instead a function that returns a function without checking the tail end of the parameter list, creates a difficulty in reading that is just not worth it. It means you have to know when reading the exact parameter list of every function call you see. Given that larger programs are mostly function calls, this imposes a significant memory burden on the reader. The idea of long sequences of positional parameters is an archaic notion dating back to FORTRAN, and is also not readable. I adopted the Smalltalk practice of using optional named parameters, which was also used in Objective-C. It is much more readable. Always a tradeoff between full named parameters and positional; i have adopted a mixed approach because they can get annoying.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591124530.285200"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1591124530.285200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2020-06-02 12:02</span><br/>
A few comments on this thread.<br/>1. This presentation ignores a lot of research on visual programming languages. Specifically there is a large focus in current computing education research on transitioning from a visual language to a text based one gradually (some with real quant and qual behind them)<br/>2. Haskell’s currying exists because all functions take a single argument. But if you wanted to address the issue you mention, you could color each “type” in the signature and show the result under the type variable (with parens as boxes) so you can keep track (like rainbow paren for LISPs). I believe Haskell treats modeling the problem (and determining sig) as the hard part and it usually means implementations are “simple and obvious” (to those that really know the stdlib). Typed holes in purescript did wonders for me when I was learning (though it didn’t help with heavy aliasing)<br/><br/>3. I really like the idea of keeping the learning curve flat, but there is always a dropoff. Also, good pedagogy goes a long way towards keeping learning curves flat as a crutch to design.<br/>4. If you are really focused on developing a first language, I recommend you actually practice it on people, document/record the pedagogy (ethically), and keep track of how people are actually modeling the problem in their head as they build conceptions, test hypothesis, and develop the dreaded misconceptions. It works for frameworks too :) Also google scholar the rainfall problem :)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1591299879.290000"></a>
      <img src="https://avatars.slack-edge.com/2025-02-08/8407560079991_6d3ec7cc938bc2e0cdb7_72.png" style="float:left"/>
      <a href="../share-your-work/1590817630.225600.html#1591299879.290000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Cole Lawrence</b>
<span style="margin:2em; color:#606060">2020-06-04 12:44</span><br/>
<span style="background-color:#ccf">@Robbie Gleichman</span> also a heads up, on the visual programming side, <span style="background-color:#ccf">@Ivan Reese</span> has a pretty nice collection of visual programming tools that might spark more inspiration for your work!<br/><a href="https://github.com/ivanreese/visual-programming-codex">https://github.com/ivanreese/visual-programming-codex</a>
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
