[
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1549786956.967200",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1551513503.000000"
        },
        "client_msg_id": "05620c22-1094-41d5-a7cb-612c935a1e11",
        "text": "(continuing from previous ... sorry, I mentioned that I am not concise)\n\nIt might sound like I've invented a \"language\" with a LISP-like structure. However, that structure is NOT textual, nor is it intended to be \"source code\". It is just an *underlying representation* of generic code (i.e. an AST), of which the operations \/ commands \/ etc. are entirely customizable.\n\nSure, it's executable within the tool, but it's also a stored representation that can be processed as data, generated dynamically, or sent as JSON.\n\nThe point is to make the development, visualization, representation, or execution of software (or other entities like videos or images), completely moldable from top to bottom -- and the tools for doing the molding are also moldable.\n\nAnd not just for making and editing things, but this can actually BE the environment that one thinks of as \"the computer\".\n\nFor example, the tool can be used to:\n* Build other programs\n* Be an execution environment itself, and add, inspect, or modify anything running in it\n* Alter the tools that the tool gives you to do any of these things. This can include how code\/data is built, visualized, manipulated, and\/or compiled or serialized to something else. This can include \"languages\", UI widgets, or whatever.\n* Immediately inspect or run \/ invoke any piece of code (and then do the same with the result that it generates).\n* Compile a common code format to any (or multiple) target languages, environments, or data formats.\n* Model &amp; simulate full-stack (distributed) applications all in one place (\"sandbox\"), and then compile \/ generate to its constituent parts to be installed elsewhere.\n* Same as above, but actually host the application in itself.\n* The tool itself can serialize \/ compile itself (and all its contents) into another context. The result can be, a program that bootstraps the tool into existence in a new place (e.g. web browser or JVM \/ CLR); or code that can be embedded in another program; or a message sent to another copy of the tool somewhere else (e.g. on a different machine), which then recreates itself on the other side.\n\nThese are just examples, and note that anything that can applied to a program can also be applied to the tool itself. This means that any other tool or approach for making, visualizing, or representing software or data, can be added to the tool and applied to anything else, and perhaps be combined with each other.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1527044282.000289",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DVd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(continuing from previous ... sorry, I mentioned that I am not concise)\n\nIt might sound like I've invented a \"language\" with a LISP-like structure. However, that structure is NOT textual, nor is it intended to be \"source code\". It is just an "
                            },
                            {
                                "type": "text",
                                "text": "underlying representation",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of generic code (i.e. an AST), of which the operations \/ commands \/ etc. are entirely customizable.\n\nSure, it's executable within the tool, but it's also a stored representation that can be processed as data, generated dynamically, or sent as JSON.\n\nThe point is to make the development, visualization, representation, or execution of software (or other entities like videos or images), completely moldable from top to bottom -- and the tools for doing the molding are also moldable.\n\nAnd not just for making and editing things, but this can actually BE the environment that one thinks of as \"the computer\".\n\nFor example, the tool can be used to:\n* Build other programs\n* Be an execution environment itself, and add, inspect, or modify anything running in it\n* Alter the tools that the tool gives you to do any of these things. This can include how code\/data is built, visualized, manipulated, and\/or compiled or serialized to something else. This can include \"languages\", UI widgets, or whatever.\n* Immediately inspect or run \/ invoke any piece of code (and then do the same with the result that it generates).\n* Compile a common code format to any (or multiple) target languages, environments, or data formats.\n* Model & simulate full-stack (distributed) applications all in one place (\"sandbox\"), and then compile \/ generate to its constituent parts to be installed elsewhere.\n* Same as above, but actually host the application in itself.\n* The tool itself can serialize \/ compile itself (and all its contents) into another context. The result can be, a program that bootstraps the tool into existence in a new place (e.g. web browser or JVM \/ CLR); or code that can be embedded in another program; or a message sent to another copy of the tool somewhere else (e.g. on a different machine), which then recreates itself on the other side.\n\nThese are just examples, and note that anything that can applied to a program can also be applied to the tool itself. This means that any other tool or approach for making, visualizing, or representing software or data, can be added to the tool and applied to anything else, and perhaps be combined with each other."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAVCC2X70",
        "type": "message",
        "ts": "1549825422.969100",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1549950089.000000"
        },
        "client_msg_id": "376fa4f7-dd68-40c3-9e76-a68cd21958de",
        "text": "(revoked comment -- I had a false understanding of SmallTalk being text-based. I stand corrected! Thanks, Tudor. I am leaving the below portion as it was)\n\nConsider that the web is based on REST messages, and compare that to the user experience that actually comes out of a web browser. I think the same kind of thing can be done to change how we interact with code.\n\nThe current state of programming is like replacing a web browser with a really good JSON viewer \/ editor, combined with the ability to send arbitrary REST requests. We'd still have access to the same \"information\" and the same ability to process\"data\" -- isn't that good enough?\n\nThe only reason that we (as an industry) tolerate that for software development is because we don't know what's missing.\n\nAnd there is SO much more good visualization \/ UI of the underlying data, than spitting out a 1:1 representation. BV elaborates *really well* in his \"Magic Ink\" paper (link below), and I hope to open the door to exploring (with ease) that same space for code.\n\n<http:\/\/worrydream.com\/MagicInk>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ec35ac5b251f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-05-22\/369438371830_ec35ac5b251f37e26aca_72.jpg",
            "first_name": "",
            "real_name": "Dan Cook",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "dcook0819",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1527044282.000289",
        "parent_user_id": "UAVCC2X70",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IqLvj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(revoked comment -- I had a false understanding of SmallTalk being text-based. I stand corrected! Thanks, Tudor. I am leaving the below portion as it was)\n\nConsider that the web is based on REST messages, and compare that to the user experience that actually comes out of a web browser. I think the same kind of thing can be done to change how we interact with code.\n\nThe current state of programming is like replacing a web browser with a really good JSON viewer \/ editor, combined with the ability to send arbitrary REST requests. We'd still have access to the same \"information\" and the same ability to process\"data\" -- isn't that good enough?\n\nThe only reason that we (as an industry) tolerate that for software development is because we don't know what's missing.\n\nAnd there is SO much more good visualization \/ UI of the underlying data, than spitting out a 1:1 representation. BV elaborates "
                            },
                            {
                                "type": "text",
                                "text": "really well",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in his \"Magic Ink\" paper (link below), and I hope to open the door to exploring (with ease) that same space for code.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/worrydream.com\/MagicInk"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]