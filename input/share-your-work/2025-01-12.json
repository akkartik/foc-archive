[
    {
        "user": "U0887QU9G2V",
        "type": "message",
        "ts": "1736691620.968939",
        "client_msg_id": "ad725029-29fc-4cad-a95f-e94473cec4fb",
        "text": "<@UK3LH8CF5>\nFirst of all, you're not coming off as negative at all. Your arguments are thoughtful and got me thinking. The fact that you see things quite differently makes your perspective all the more enriching to me. So, truly, thank you for that!\n\nJust a few points replying to yours, and honestly no need to re-reply unless you really want to!\n\n- I do consider compilers to be a DIS. They don't store data, but they surely communicate it and transform it. I'd actually love to apply this approach to a compiler, and will soon have to do this in one way or other when I implement cell.\n\n- I indeed recently found out about unavailability being indistinguishable (or rather, at the end of the continuum) of latency. And it's quite elegant to see it like that! And indeed, with distributed systems you have an eternal recurse: how do you know if the acknowledgment of the acknowledgment of the acknowledgment reaches its destination? I think this can be thought of as a probability: each call (not even each side) has an error threshold, and above it it considers the operation to be successful (and failed otherwise). I think that distributed systems only makes the probability of error higher (and the probability of not finding about it also higher), but that could still happen in a single system (solar flares?). Your point has uncovered this angle for me: the assumption of dealing with certainties (rather than probabilities) of knowing what's happening.\n\n- I'll check the podcast episode and also the work of Peter Alvaro, thank you for the recommendation!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6b9d24756ac1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-08\/8269664865108_6b9d24756ac1aa304bb9_72.jpg",
            "first_name": "Federico",
            "real_name": "Federico Pereiro",
            "display_name": "Federico Pereiro",
            "team": "T5TCAFTA9",
            "name": "fpereiro",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1736460195.528239",
        "parent_user_id": "U0887QU9G2V",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vTSH6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UK3LH8CF5"
                            },
                            {
                                "type": "text",
                                "text": "\nFirst of all, you're not coming off as negative at all. Your arguments are thoughtful and got me thinking. The fact that you see things quite differently makes your perspective all the more enriching to me. So, truly, thank you for that!\n\nJust a few points replying to yours, and honestly no need to re-reply unless you really want to!\n\n- I do consider compilers to be a DIS. They don't store data, but they surely communicate it and transform it. I'd actually love to apply this approach to a compiler, and will soon have to do this in one way or other when I implement cell.\n\n- I indeed recently found out about unavailability being indistinguishable (or rather, at the end of the continuum) of latency. And it's quite elegant to see it like that! And indeed, with distributed systems you have an eternal recurse: how do you know if the acknowledgment of the acknowledgment of the acknowledgment reaches its destination? I think this can be thought of as a probability: each call (not even each side) has an error threshold, and above it it considers the operation to be successful (and failed otherwise). I think that distributed systems only makes the probability of error higher (and the probability of not finding about it also higher), but that could still happen in a single system (solar flares?). Your point has uncovered this angle for me: the assumption of dealing with certainties (rather than probabilities) of knowing what's happening.\n\n- I'll check the podcast episode and also the work of Peter Alvaro, thank you for the recommendation!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0887QU9G2V",
        "type": "message",
        "ts": "1736691638.314219",
        "client_msg_id": "a695ac47-6a5e-46f1-a7da-4d1d5a530556",
        "text": "<@U016VUZGUUQ>\n- My fear about putting the pillars \"up there\" is that the document will be too geared towards programmers; I still have the hope that non-programmers that are interested enough in information systems might get some value from that intro that, from a programmer's perspective, seems to be a \"fish describing the water\". I could be utterly wrong, though.\n\n- I'm interested in your take that calls come first, data comes afterwards. If you have something in writing about it (or want to post about it here), I'd gladly take a look. To me, I feel that you first have to have the chemical elements in order to later get the unicellular organisms. If data are the elements, the coming to life comes afterrwards. Then, you might reach a situation where most of the matter in an area is actually within live organisms, and it flows according to their own logic.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6b9d24756ac1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-08\/8269664865108_6b9d24756ac1aa304bb9_72.jpg",
            "first_name": "Federico",
            "real_name": "Federico Pereiro",
            "display_name": "Federico Pereiro",
            "team": "T5TCAFTA9",
            "name": "fpereiro",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1736460195.528239",
        "parent_user_id": "U0887QU9G2V",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6yqG0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U016VUZGUUQ"
                            },
                            {
                                "type": "text",
                                "text": "\n- My fear about putting the pillars \"up there\" is that the document will be too geared towards programmers; I still have the hope that non-programmers that are interested enough in information systems might get some value from that intro that, from a programmer's perspective, seems to be a \"fish describing the water\". I could be utterly wrong, though.\n\n- I'm interested in your take that calls come first, data comes afterwards. If you have something in writing about it (or want to post about it here), I'd gladly take a look. To me, I feel that you first have to have the chemical elements in order to later get the unicellular organisms. If data are the elements, the coming to life comes afterrwards. Then, you might reach a situation where most of the matter in an area is actually within live organisms, and it flows according to their own logic."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0887QU9G2V",
        "type": "message",
        "ts": "1736691719.438199",
        "edited": {
            "user": "U0887QU9G2V",
            "ts": "1736691735.000000"
        },
        "client_msg_id": "4291701d-5961-45b6-8a03-1975b1c8fe7f",
        "text": "<@UE6EFEPTQ>\n- You've squarely earned an acknowledgment, in my eyes. You're the fourth human to give me feedback about TODIS!\n\n- I'm not stealing your work in Onex, yet. Now that you linked it and I know about it, I might :smile:. But always giving due credit. And cell will be fully open source and public domain.\n\n- Concerning the fourfold mapping, amazing! It means we're seeing convergence; we were working separately on similar problems and are finding that we need the same things. To me, that's very healthy; it indicates the problem domain is not a solipsistic figment of individual imaginations, but something rather more objective. As for interface, I see it as an \"interface maker\", rather than i\/o. But if you were referring to interfaces by i\/o, then the mapping is 100% the same.\n\n- To me, number needs to be its own type, conceptually. The operations on them are very different from the ones we do on text. And I'm in love with the notion that from the two single data types (number and text) you can extend to the two multiple data types (list and hash), where numbers are the keys of list and texts are the keys of hash. It's just too elegant to pass up. Now, ask me in some time when I'm in the cauldron of implementation. But I'm a sucker for conceptual integrity.\n\n- Concerning null or undefined, I really don't want to add any values that are not part of the four base types. That's why I narrowed down on the empty text as my only null-like value. It's still a convention, which I like, because it gives others the possibility of picking something else, as long as they make it a value. The other thing I want to do concerning this (warning: vaporware) is to make references to nested objects that don't resolve to anything respond with an empty text, rather than throwing an error. Redis has this attitude towards structures that don't exist and I think it's the mother lode.\n\n- On declarative vs imperative, my contention is that you can put any operation in terms of a call, and that you can consider really anything as declarative or imperative (I know, bring the kindling and the stake, I'll even help you light it up). This is not a troll, though, I do mean it. Let's take a declarative call, like a SQL statement (is that a good example? If you have another one, please do send it to see if I can still make a point about it). Let's say that the SQL statement has some order required to it, but it's safe to say that you're not sending a search algorithm over the wire that the database will execute for you. Still, you're sending a message to a destination (that's what I consider a call, by the way). As a response, you obtain the result to your query. Is that declarative? It can be. But consider now me sending an opcode. I'm also sending a message (this time, to the CPU), saying that it should perform an operation. Now, am I telling the CPU how to organize its logic gates to achieve that result? Hardly. Whether the CPU uses complex logic, or microcode, I haven't specified. All I care about is that I get my response. The lack of ordering in what is normally considered a declarative call is simply a convention, in the same way that the order of arguments you send to an opcode is also a convention. It is a way to express what you want; the destination, which processes (expands) your call into a response, is in charge of that how. And even very declarative layers, like DSLs (including SQL) are actually quite structured in how they take their inputs. Even more unstructured\/higher level paradigms (like LLMs) an still be seen in the call\/response model. Does this make any sense?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6b9d24756ac1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-08\/8269664865108_6b9d24756ac1aa304bb9_72.jpg",
            "first_name": "Federico",
            "real_name": "Federico Pereiro",
            "display_name": "Federico Pereiro",
            "team": "T5TCAFTA9",
            "name": "fpereiro",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1736460195.528239",
        "parent_user_id": "U0887QU9G2V",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0eU7j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UE6EFEPTQ"
                            },
                            {
                                "type": "text",
                                "text": "\n- You've squarely earned an acknowledgment, in my eyes. You're the fourth human to give me feedback about TODIS!\n\n- I'm not stealing your work in Onex, yet. Now that you linked it and I know about it, I might "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            },
                            {
                                "type": "text",
                                "text": ". But always giving due credit. And cell will be fully open source and public domain.\n\n- Concerning the fourfold mapping, amazing! It means we're seeing convergence; we were working separately on similar problems and are finding that we need the same things. To me, that's very healthy; it indicates the problem domain is not a solipsistic figment of individual imaginations, but something rather more objective. As for interface, I see it as an \"interface maker\", rather than i\/o. But if you were referring to interfaces by i\/o, then the mapping is 100% the same.\n\n- To me, number needs to be its own type, conceptually. The operations on them are very different from the ones we do on text. And I'm in love with the notion that from the two single data types (number and text) you can extend to the two multiple data types (list and hash), where numbers are the keys of list and texts are the keys of hash. It's just too elegant to pass up. Now, ask me in some time when I'm in the cauldron of implementation. But I'm a sucker for conceptual integrity.\n\n- Concerning null or undefined, I really don't want to add any values that are not part of the four base types. That's why I narrowed down on the empty text as my only null-like value. It's still a convention, which I like, because it gives others the possibility of picking something else, as long as they make it a value. The other thing I want to do concerning this (warning: vaporware) is to make references to nested objects that don't resolve to anything respond with an empty text, rather than throwing an error. Redis has this attitude towards structures that don't exist and I think it's the mother lode.\n\n- On declarative vs imperative, my contention is that you can put any operation in terms of a call, and that you can consider really anything as declarative or imperative (I know, bring the kindling and the stake, I'll even help you light it up). This is not a troll, though, I do mean it. Let's take a declarative call, like a SQL statement (is that a good example? If you have another one, please do send it to see if I can still make a point about it). Let's say that the SQL statement has some order required to it, but it's safe to say that you're not sending a search algorithm over the wire that the database will execute for you. Still, you're sending a message to a destination (that's what I consider a call, by the way). As a response, you obtain the result to your query. Is that declarative? It can be. But consider now me sending an opcode. I'm also sending a message (this time, to the CPU), saying that it should perform an operation. Now, am I telling the CPU how to organize its logic gates to achieve that result? Hardly. Whether the CPU uses complex logic, or microcode, I haven't specified. All I care about is that I get my response. The lack of ordering in what is normally considered a declarative call is simply a convention, in the same way that the order of arguments you send to an opcode is also a convention. It is a way to express what you want; the destination, which processes (expands) your call into a response, is in charge of that how. And even very declarative layers, like DSLs (including SQL) are actually quite structured in how they take their inputs. Even more unstructured\/higher level paradigms (like LLMs) an still be seen in the call\/response model. Does this make any sense?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U0887QU9G2V",
        "type": "message",
        "ts": "1736692160.023739",
        "client_msg_id": "66974b4d-357b-49cc-b694-4545d5639463",
        "text": "- Clearly there's a difference between a SQL query and an opcode. The former is built with the latter. SQL is more high level than opcodes, but that doesn't preclude us from using the same model to describe each of these operations as calls, and to see all the commonalities between them (destination, message, response and expansion).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6b9d24756ac1",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-08\/8269664865108_6b9d24756ac1aa304bb9_72.jpg",
            "first_name": "Federico",
            "real_name": "Federico Pereiro",
            "display_name": "Federico Pereiro",
            "team": "T5TCAFTA9",
            "name": "fpereiro",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1736460195.528239",
        "parent_user_id": "U0887QU9G2V",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wT4C8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "- Clearly there's a difference between a SQL query and an opcode. The former is built with the latter. SQL is more high level than opcodes, but that doesn't preclude us from using the same model to describe each of these operations as calls, and to see all the commonalities between them (destination, message, response and expansion)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1736696967.603479",
        "client_msg_id": "4a55b833-3ef0-41dd-b916-40980ba5fbee",
        "text": "It's really hard for a document to serve two such different audiences, and frankly I don't think non-programmers are going to be reading this any time soon.\n\nI don't have anything written about my ideas yet. I can say it's inspired in part by tagless-final encodings of data, where the data is basically represented by a function that traverses\/outputs the data into an interpreter. I can't find a good concise intro about that either at the moment, but if you want to dive in the deep end: <https:\/\/okmij.org\/ftp\/tagless-final\/|https:\/\/okmij.org\/ftp\/tagless-final\/> (very heavy on the DSL interpretation rather than as data, but hopefully you can see how data could be a specialized DSL if you squint).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1736460195.528239",
        "parent_user_id": "U0887QU9G2V",
        "attachments": [
            {
                "from_url": "https:\/\/okmij.org\/ftp\/tagless-final\/",
                "id": 1,
                "original_url": "https:\/\/okmij.org\/ftp\/tagless-final\/",
                "fallback": "Tagless-Final Style",
                "text": "The main page introducing the tagless-final style and serving as a reference to further explanations and examples",
                "title": "Tagless-Final Style",
                "title_link": "https:\/\/okmij.org\/ftp\/tagless-final\/",
                "service_name": "okmij.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6J6pt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's really hard for a document to serve two such different audiences, and frankly I don't think non-programmers are going to be reading this any time soon.\n\nI don't have anything written about my ideas yet. I can say it's inspired in part by tagless-final encodings of data, where the data is basically represented by a function that traverses\/outputs the data into an interpreter. I can't find a good concise intro about that either at the moment, but if you want to dive in the deep end: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/okmij.org\/ftp\/tagless-final\/",
                                "text": "https:\/\/okmij.org\/ftp\/tagless-final\/"
                            },
                            {
                                "type": "text",
                                "text": " (very heavy on the DSL interpretation rather than as data, but hopefully you can see how data could be a specialized DSL if you squint)."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]