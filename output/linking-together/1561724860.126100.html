<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #linking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-06-28 05:27</span><br/>
A young aspiring programmer asks you as an expert and mentor:<br/>&gt;"I want to understand the most important programming paradigms and learn about the broadest set of language features out there. What is the minimal set of programming languages I should look at? Popularity and how widely used these languages are doesn't matter, I just want the highest :exploding_head:::nerd_face: ratio to maximize my learning."<br/><br/>Here's what I think:<br/>• <b>C</b> — for a simple, pragmatic, influential, and still widely used procedural language and to understand memory management<br/>• <b>Smalltalk</b> — for a highly dynamic language and environment, message passing and the origins of OOP<br/>• <b>Lisp</b> — because you wouldn't take me seriously if I left it off such a list<br/>• <b>Haskell</b> — for a pure functional, strongly typed language with laziness and strong compiler support (error checking, synthesis, etc.)<br/>• <b>Forth</b> — for an even simpler, but still highly expressive, extensible, and dynamic language<br/>• <b>Datalog</b> — for logic programming and constraint solvers (or maybe <em>Prolog</em> instead?)<br/>• <b>Erlang</b> — for actor model and concurrent programming<br/><br/>What would you respond?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561725941.126200"></a>
      <img src="https://secure.gravatar.com/avatar/6191fa9e32605141275a68a8bb5f04fa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561725941.126200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Hines</b>
<span style="margin:2em; color:#606060">2019-06-28 05:45</span><br/>
I end up taking a lot of 3-4 hour introductory courses on PluralSight or <a href="http://Lynda.com">Lynda.com</a>. I’ve taken those for Haskell, Elixir, and C. While I’ve never programmed in them, the courses have been invaluable to understand the different paradigms, and I’ve found this range (anywhere between 3 and 8 hours) of pretty nice optimization of value vs time invested. I’ve spent much much more time learning Lisp in the form of Scheme (SICP is amazing) and Clojure, and I feel Clojure specifically has improved my taste in languages beyond what it otherwise would be.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561726149.126400"></a>
      <img src="https://secure.gravatar.com/avatar/da3a20a76a69532fa83e790e89cb4c6c.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561726149.126400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Eyal Lotem</b>
<span style="margin:2em; color:#606060">2019-06-28 05:49</span><br/>
Nice list :slightly_smiling_face:<br/><br/>I'd add:<br/><li> <b>Assembly</b> - to understand the low-level.<br/><li> <b>Rust</b> - Enforcable patterns for safe memory use<br/><li> <b>Agda</b>/*Idris* - To glimpse at the power of dependent types<br/><li> <b>Coq</b> - To dive deeper into formal logic
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561742894.126700"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561742894.126700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2019-06-28 10:28</span><br/>
• Max/MSP — It's probably the most polished visual programming language.<br/>• Notations for things that aren't programming — It's worth seeing how other domains have solved the problem of "process communication". I'm thinking various notations for music, weaving &amp; patterning, semaphore, electrical schematics, etc<br/>• SpaceChem, Factorio, Opus Magnum, etc — Video games that take the act of programming and permute into a different kind of joyful experience.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561747973.126900"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561747973.126900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-06-28 11:52</span><br/>
For the broadest possible range, i would suggest the following languages to look at<br/><br/>• Modula2 (highly superior to C, free compiler at the ADW website) for how to do separate compilation and modules properly (JS modules are a bad copy)<br/>• skip smalltalk, it was a cumbersome language whose only enduring contribution is named optional parameters on function calls. But the IDE for smalltalk, called Pharo is among the most advanced of any language.<br/>• Mathematica - the only commercially successful symbolic language, and has a  sensible business model where schools and big companies pay for the staff of 700+ workers via license fees while students get it for free.<br/>• Icon - the evolution of Spitbol, one of the best text processing languages<br/>• Forth - the most compact language ever devised. Almost completely unreadable like Lisp, but it shows the power of stack based languages (of which Postscript is another more commercially successful example).<br/>• Skip APL, study J instead, Iverson's successor language which ditched the crazy alphabet. Another almost impossible to read language, but very compact.<br/>• Elixir (skip Erlang, as it has a very ugly syntax for the same runtime). The only runtime that can handle hundreds of thousands of threads no problem; has a unique memory approach by giving each thread its own stack and heap.<br/>• Delphi (or VB6) for an example of how an integrated product delivers terrific productivity and a marketplace of interchangeable parts). Delphi gets no love from academics but it is incredibly productive.<br/>• Filemaker Pro for an example of how to make a terrific user interface for screens and forms (and how not to make a scripting language, because its scripting language is archaic and painful to use)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561774907.127200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561774907.127200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-06-28 19:21</span><br/>
APL had a huge impact on how I think about programming. Array programming is one part of it. The other part is the incredible compactness of the notation. You asked for a "minimal set": I'd consider swapping Forth for APL, because they both convey the idea of writing programs as a string of combinators, but APL has more depth and embodies a more radical way of thinking about programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561837006.127500"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561837006.127500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-06-29 12:36</span><br/>
I updated my list to mention APL, although Iverson whom i was fortunate enough to talk to before he died, had finally recognized the awkwardness of an invented alphabet, and recast it as J, which tries to beat Mathematica.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561838495.128300"></a>
      <img src="https://avatars.slack-edge.com/2019-05-06/616300651267_e35958b94f07da17cf17_72.png" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561838495.128300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Andreas S.</b>
<span style="margin:2em; color:#606060">2019-06-29 13:01</span><br/>
Adding assembly might be a good idea I agree 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561863900.128500"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561863900.128500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-06-29 20:05</span><br/>
Max/MSP is worth a look.  With Smalltalk, it's not the language so much as the environment, so jump straight to Glamorous Toolkit.  At this point, so much of C is... dated... perhaps Go is better for non-GC, yet still focused on memory layout.  Has concurrency that is interesting to compare with Erlang.  For the novice, Lisp and Forth's execution models are the least mysterious.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561933384.132100"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561933384.132100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-06-30 15:23</span><br/>
Lots of great additions, thanks! But adding more is easy — what would you remove?<br/><br/>Also for those who suggested assembly: which kind? <br/>A good friend of mine would say, “Clearly 6502 — the last platform we built that a single individual could completely comprehend down to every component.”<br/><a href="https://m.youtube.com/watch?v=ZsRRCnque2E">https://m.youtube.com/watch?v=ZsRRCnque2E</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561936456.132600"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561936456.132600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2019-06-30 16:14</span><br/>
remove: the call-stack
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561966417.132800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561966417.132800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-07-01 00:33</span><br/>
Prof. Wirth wrote a code generator for one of his computer projects, and he write one for the National 32000, the Motorola 68000 and the Intel 386, and because the National chip was the most regular instruction set it was the simplest and smallest code, followed by the Motorola, and then the absolute worst was the Intel. And yes, just as one might predict, the Intel was by far the most popular chip, followed by the Motorola, and the National chip died out quickly. It is one of the more perverse things about computer industry that the simplest and best solution usually fails in the marketplace, because underlying our industry is the normal human desire for job protection and increasing billable hours. Hence the most irregular funky instruction set dominates, and the clean simple as can be stuff bombs out. You can see it where the really terrific MULTICS OS gets wiped out by the a monstrosity like OS/360, or COBOL beats the pants of FORTRAN. Or how Java got picked as the enterprise language of choice when it is one of the worst languages ever devised, a build-once, debug-everywhere hunk of junk (IMHO).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1561966766.133000"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1561966766.133000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-07-01 00:39</span><br/>
I never learned the National chip, but the Moto 68,000 was a great chip, far superior to the intel architecture. Very easy to learn, with a nice macro assembler. The 6502 is very old, I don't think its assembler was particularly great, but the original Apple BIOS which Wozniak wrote is the work of genius and a testimony to how good a programmer he was. Back in the 6502 days you could poke a byte into a fixed memory location and draw on the screen. That was character graphics of course, but it had some box drawing characters, and i am telling you that the productivity on that Apple 2 was stupendous for programmers. It takes about a million lines of code to draw a letter on a bitmap screen nowadays with all the stuff under the hood. The Z80 is still used today, that is a very simple 8 bit chip.  The microsoft assembler as far as assemblers go is super fantastic. it has IF / THEN / ELSE, all sorts of macros that elevate it far above what you might expect.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1562785902.211500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1562785902.211500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-07-10 12:11</span><br/>
Big fan on the 68k (once wrote an entire compiler in 68k asm), but blaming crappier designs winning on "job security" is a bit simple, imho. In many of these cases, the market simply does not care for elegant (to the programmer), it cares about cost, right place right time, and lucky connections to other tech / other companies etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1562786014.211700"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../linking-together/1561724860.126100.html#1562786014.211700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-07-10 12:13</span><br/>
Intel managed to make the iterations of the 386 faster (than the 68k) and cheaper (than the risc alternatives), with its horrible ISA never much of a disadvantage
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
