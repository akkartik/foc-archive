[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1727954487.856939",
        "client_msg_id": "3f7ad5c6-8673-41d7-b246-81c7477306a4",
        "text": "<@UDCLA1HU4>\n1) WRT to \"current node\", we already know how to do this using textual code and have many programming languages for this purpose. So, divide-and-conquer says that all you need to do is to map \"trees\" onto textual code, then you're done.\n\n2) Here is my (probably over-simplified) understanding of term rewriting augmented by the concept of \"current node\":\n\n1. Programmer writes an AST (the \"inhaler AST\")\n2. Programmer writes a 1:1 corresponding rewrite AST that dove-tails with the inhaler AST. (Or, programmer annotates the above inhaler AST (this, though, violates the principles of KISS and human-readability))\n3. Term rewriter app inhales linear text and makes a CST (concrete parse tree) by culling the AST driven by the inhaled text (commonly known as \"parsing\")\n4. Term rewriter app walks the rewrite AST using the newly-created CST.\n5. Term rewriter app unparses the rewritten walked-tree into (new) linear text (\"code\").\n6. Run the generated code.\nIf that's even close to what you're imagining, then I contend that this is \"easily possible\" to do using modern technology whilst loosening the thumbscrews, i.e. using OhmJS plus a nano-DSL written in OhmJS. I call it \"t2t\" (text-to-text transpilation) and am actively experimenting with it and its implications (meta-syntaxes, metaprogramming, etc.). More info\/blather\/discussion if interested.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lQaHm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDCLA1HU4"
                            },
                            {
                                "type": "text",
                                "text": "\n1) WRT to \"current node\", we already know how to do this using textual code and have many programming languages for this purpose. So, divide-and-conquer says that all you need to do is to map \"trees\" onto textual code, then you're done.\n\n2) Here is my (probably over-simplified) understanding of term rewriting augmented by the concept of \"current node\":\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Programmer writes an AST (the \"inhaler AST\")"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Programmer writes a 1:1 corresponding rewrite AST that dove-tails with the inhaler AST. (Or, programmer annotates the above inhaler AST (this, though, violates the principles of KISS and human-readability))"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Term rewriter app inhales linear text and makes a CST (concrete parse tree) by culling the AST driven by the inhaled text (commonly known as \"parsing\")"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Term rewriter app walks the rewrite AST using the newly-created CST."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Term rewriter app unparses the rewritten walked-tree into (new) linear text (\"code\")."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Run the generated code."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIf that's even close to what you're imagining, then I contend that this is \"easily possible\" to do using modern technology whilst loosening the thumbscrews, i.e. using OhmJS plus a nano-DSL written in OhmJS. I call it \"t2t\" (text-to-text transpilation) and am actively experimenting with it and its implications (meta-syntaxes, metaprogramming, etc.). More info\/blather\/discussion if interested."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "URKQXRCAC",
        "type": "message",
        "ts": "1727961015.855419",
        "client_msg_id": "8be77133-7d15-40fc-a762-bbecb947248c",
        "text": "[Shameless plug approaching] Or using something like CodeParadise to run Smalltalk in the browser as well as on the server. <https:\/\/github.com\/ErikOnBike\/CodeParadise>\n<@U017SHBAFE3> I'm also interested in this topic. (The start of CodeParadise was to create a development environment for kids.). My current idea (only in thought, nothing tried out yet) is to have a language like Smalltalk, but without the static class hierarchy. Somewhere between Self and Smalltalk. Allowing the addition and removal of behaviour to\/from objects. Using the Smalltalk syntax. The static class hierarchy sometimes feels as a hindrance. Only if you're already comfortable with such a structure and\/or can do the 'abstraction thing' you're able to create class hierarchies that actually work\/are beneficial (even in the long(er) run).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a55b20870fb9",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-11-23\/6253994675665_a55b20870fb92473e7e8_72.png",
            "first_name": "Erik",
            "real_name": "Erik Stel",
            "display_name": "Erik Stel",
            "team": "T5TCAFTA9",
            "name": "foc572",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727916773.338669",
        "parent_user_id": "U017SHBAFE3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A\/NdY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Shameless plug approaching] Or using something like CodeParadise to run Smalltalk in the browser as well as on the server. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/ErikOnBike\/CodeParadise"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U017SHBAFE3"
                            },
                            {
                                "type": "text",
                                "text": " I'm also interested in this topic. (The start of CodeParadise was to create a development environment for kids.). My current idea (only in thought, nothing tried out yet) is to have a language like Smalltalk, but without the static class hierarchy. Somewhere between Self and Smalltalk. Allowing the addition and removal of behaviour to\/from objects. Using the Smalltalk syntax. The static class hierarchy sometimes feels as a hindrance. Only if you're already comfortable with such a structure and\/or can do the 'abstraction thing' you're able to create class hierarchies that actually work\/are beneficial (even in the long(er) run)."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1727961243.777349",
        "client_msg_id": "16dfd1d6-4e21-429b-82a5-32e41c0cda89",
        "text": "<@UGWUJUZHT> The problem with your proposal is that it doesn't fit the way rewriting-based documents are used in practice. They are more like spreadsheets. The fundamental action of the computer is not \"run a program\" but \"update everything after the user has made a change to the document\". The point of a \"current node\", as I see it, would be to make it clearer to the user what exactly happens during such an update. It's more of a user interface than a programming issue.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1727827197.316359",
        "parent_user_id": "UDCLA1HU4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RAQyV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " The problem with your proposal is that it doesn't fit the way rewriting-based documents are used in practice. They are more like spreadsheets. The fundamental action of the computer is not \"run a program\" but \"update everything after the user has made a change to the document\". The point of a \"current node\", as I see it, would be to make it clearer to the user what exactly happens during such an update. It's more of a user interface than a programming issue."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    }
]