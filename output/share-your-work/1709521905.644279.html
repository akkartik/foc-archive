<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-03-03 19:11</span><br/>
<a href="https://futureofcoding.org/episodes/070">Future of Coding 70 • Beyond Efficiency</a> by <span style="background-color:#ccf">@Dave Ackley</span><br/><br/>Dave Ackley’s paper Beyond Efficiency is three pages long. With just these three pages, he mounts a compelling argument against the conventional way we engineer software. Instead of inflexibly insisting upon correctness, maybe allow a lil slop? Instead of chasing peak performance with cache and clever tricks, maybe measure many times before you cut. So in this episode, we’re putting every CEO in the guillotine… (oh, that stands for “correctness and efficiency only”, don’t put us on a list)… and considering when, where, and how to do the robust thing.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709581263.015259"></a>
      <img src="https://secure.gravatar.com/avatar/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709581263.015259" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Personal Dynamic Media</b>
<span style="margin:2em; color:#606060">2024-03-04 11:41</span><br/>
I was unaware of the Knuth response to Naur. Thanks for mentioning it! I found a copy at<br/><a href="https://tug.org/TUGboat/tb10-4/tb26complete.pdf">https://tug.org/TUGboat/tb10-4/tb26complete.pdf</a><br/><br/>Knuth invented a new kind of documentation, one that hardly anyone uses, but that is specifically designed for communicating how a program works to other human beings.<br/><br/>Knuth has also expended great effort in the study of other people's code and programs, including code written in long dead programming languages.<br/><br/>If there is anyone in the world capable of transcending the limits described by Peter Naur, both by transmitting the theory of a program and by recreating it, it would be Donald Knuth. I see no reason to doubt the truth of Knuth's claims, but I also don't see them as contradicting Naur.<br/><br/>Naur does not claim it is impossible to revive a program in practical terms, only that it is difficult, frustrating, and time-consuming, and "may lead to a revived theory that differs from the one originally had by the program authors and so may contain discrepancies with the program text." I believe his point is that you cannot be certain the revived theory is the same as the original theory, however I do not have enough experience with literate programming to judge Knuth's claim that a well-written literate program might have a good chance of being accurately revived.<br/><br/>Calling the stored program computer a "von Neumann model" does a tremendous disservice to J. Presper Eckert who invented and wrote up the idea around 6 months before von Neumann joined the ENIAC project. See the book A History of Computing in the<br/>Twentieth Century for a copy of the original memo.<br/><br/>von Neumann wrote a draft report that was widely shared informally (<a href="https://en.m.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC">https://en.m.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC</a>), but to the best of my knowledge he never claimed the ideas were his. He was writing up the ENIAC team's plans for the EDVAC.<br/><br/>Y'all may also enjoy von Neumann's paper "PROBABILISTIC LOGICS AND THE SYNTHESIS OF RELIABLE<br/>ORGANISMS FROM UNRELIABLE COMPONENTS." <a href="https://static.ias.edu/pitp/archive/2012files/Probabilistic_Logics.pdf">https://static.ias.edu/pitp/archive/2012files/Probabilistic_Logics.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709586600.804779"></a>
      <img src="https://avatars.slack-edge.com/2023-04-28/5179303716261_07fbb70c0e3980e07e51_72.jpg" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709586600.804779" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Buckmaster</b>
<span style="margin:2em; color:#606060">2024-03-04 13:10</span><br/>
I was glad to hear the new discussion generated by Programming as Theory Building - both the episode and the paper. It is my favourite episode and was very influential on me!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709606317.008129"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2508698086192_565c54a4fa91a0c8c75a_72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709606317.008129" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Lieber</b>
<span style="margin:2em; color:#606060">2024-03-04 18:38</span><br/>
I appreciated the examples of non-distributed systems that benefit from robustness that had to do with being robust to <em>programmer error</em>. That type of error is harder to characterize than the random bit-flipping of cosmic rays because it’s so human, but it’s the type of error that I most often think of robustness in terms of.<br/><br/>I didn’t have as good a word for it before. “Defensive programming” doesn’t really capture it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709606916.754259"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2508698086192_565c54a4fa91a0c8c75a_72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709606916.754259" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Lieber</b>
<span style="margin:2em; color:#606060">2024-03-04 18:48</span><br/>
Implementing invariants directly like Jimmy mentioned. Sort the thing every time if it’s supposed to be sorted, rather than trying to maintain that property indirectly. It’s not just about doing the easiest thing first, or avoiding premature optimization. It’s like, when I mess up code elsewhere, how do I make sure that this part won’t make it worse.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709606934.486319"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2508698086192_565c54a4fa91a0c8c75a_72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709606934.486319" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Lieber</b>
<span style="margin:2em; color:#606060">2024-03-04 18:48</span><br/>
I dunno, good episode.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709701992.163029"></a>
      <img src="https://avatars.slack-edge.com/2023-07-05/5533188035202_402a5ff55c77365d5465_72.jpg" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709701992.163029" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alexander Bandukwala</b>
<span style="margin:2em; color:#606060">2024-03-05 21:13</span><br/>
I still haven’t read the paper but one aspect of the episode I found interesting was that having simpler software avoids bugs. It seems like this is being conflated with the idea of sacrificing efficiency for robustness. Where sometimes the simpler code/algorithm is in fact less robust and the more robust implementation requires more code (and potentially more bugs).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709702334.819469"></a>
      <img src="https://avatars.slack-edge.com/2023-07-05/5533188035202_402a5ff55c77365d5465_72.jpg" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709702334.819469" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Alexander Bandukwala</b>
<span style="margin:2em; color:#606060">2024-03-05 21:18</span><br/>
I’d be interested in trying to disentangle the robustness from the simplicity dimensions when making tradeoffs. So finding new ways to structure software to be inherently more robust to bugs seems compelling yet difficult.<br/><br/>Overall the contention between correctness, efficiency, and robustness seems to arise from the viewpoint that correctness is a binary proposition rather than a probabilistic measurement of the values we want our software to achieve. If we have a myopic view of correctness we’re leaving all the tradeoffs off the table.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709702451.625319"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709702451.625319" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-03-05 21:20</span><br/>
Something we ought to consider — was <a href="https://en.m.wikipedia.org/wiki/Stuxnet">stuxnet</a> robust-first?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709702527.989889"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709702527.989889" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-03-05 21:22</span><br/>
And yeah — I'm no friend to binary views of correctness! Glad to be reminded of that.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709713087.015829"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709713087.015829" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2024-03-06 00:18</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> loved the musical interlude and the mix on the quotation effect seemed perfectly dialed in.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709865940.709629"></a>
      <img src="https://secure.gravatar.com/avatar/cd02882a83b643d0f595c605d960c28f.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709865940.709629" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Scott Antipa</b>
<span style="margin:2em; color:#606060">2024-03-07 18:45</span><br/>
Reminds me of how analog computers can be more robust because they arent susceptible to things like accidental, cosmic ray style, bit flips causing a major change in the value of the computation. 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709867278.877809"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709867278.877809" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-03-07 19:07</span><br/>
Right. Though they then need to be robust against, say, results being influenced by ambient temperature :)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709867704.323789"></a>
      <img src="https://avatars.slack-edge.com/2023-04-28/5179303716261_07fbb70c0e3980e07e51_72.jpg" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709867704.323789" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Daniel Buckmaster</b>
<span style="margin:2em; color:#606060">2024-03-07 19:15</span><br/>
Deutsch discusses digital versus analogue at length in <em>The Beginning Of Infinity</em>, here's a bit from that chapter-<br/>&gt; ... during lengthy computations, the accumulation of errors due to things like imperfectly constructed components, thermal fluctuations, and random outside influences makes analogue computers wander off the intended computational path. This may sound like a minor or parochial consideration. But it is quite the opposite. Without error-correction all information processing, and hence all knowledge-creation, is necessarily bounded. ... So all universal computers are digital; and all use error-correction with the same basic logic that I have just described, though with many different implementations. Thus Babbage’s computers assigned only ten different meanings to the whole continuum of angles at which a cogwheel might be oriented. Making the representation digital in that way allowed the cogs to carry out error-correction automatically: after each step, any slight drift in the orientation of the wheel away from its ten ideal positions would immediately be corrected back to the nearest one as it clicked into place. Assigning meanings to the whole continuum of angles would nominally have allowed each wheel to carry (infinitely) more information; but, in reality, information that cannot be reliably retrieved is not really being stored.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709888955.862329"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709888955.862329" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2024-03-08 01:09</span><br/>
An analog virtue / limitation is that you cannot have a huge tower of abstraction because noise accumulates: indirection has a direct cost!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1709907617.349939"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1709907617.349939" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2024-03-08 06:20</span><br/>
Relevant reading folks might enjoy: <a href="https://arxiv.org/pdf/1811.09989.pdf">The dry history of liquid computers</a> 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1710120685.544579"></a>
      <img src="https://avatars.slack-edge.com/2021-03-02/1799806928087_2ac81d2f698aba3bf267_72.jpg" style="float:left"/>
      <a href="../share-your-work/1709521905.644279.html#1710120685.544579" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tony Fader</b>
<span style="margin:2em; color:#606060">2024-03-10 18:31</span><br/>
Thanks for the great episode. "The Fiverr Vaccine" was super funny. And I loved reading the paper.<br/><br/>I started out robustbrained. I was ready to salute the robustness flag. I started memorizing the robustness national anthem (which is twice as long as it needs to be).<br/><br/>But now it feels like that's missing the point...<br/><br/>I should be saluting the local first flag! I should sing the permacomputing national anthem and get my hair done at the convivial computing salon! These are actual value systems that imagine a different world and say "this would be better". Robustness is a means to an end, just like efficiency.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
