<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-05 17:01</span><br/>
Does anyone know the current state of the art in functional reactive animation? I‘ve been reading about Conal Elliott’s Fran DSL but it seems there hasn’t been any recent progress in this space. I’m considering writing a JavaScript implementation of that hasn’t been done already <a href="http://conal.net/fran/">http://conal.net/fran/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578277230.421000"></a>
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578277230.421000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-05 18:20</span><br/>
Just to clarify this a bit: I’m aware of a few recent attempts at realizing FRP on the web (Cycle/Turbine), but I’m wondering about anything in animation specifically.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578289059.421500"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578289059.421500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2020-01-05 21:37</span><br/>
What would you constitute as progress?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578317723.434200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578317723.434200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-06 05:35</span><br/>
My project, Curv, is a pure functional graphics language. Most of the effort right now is being spent on providing a powerful set of composable graphics primitives. The pure functional animation and reactive parts are very underdeveloped, but matching what is shown in the Fran tutorial is one of my goals.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578324510.436400"></a>
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578324510.436400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-06 07:28</span><br/>
The goal of Fran as I understand it was to make animation more accessible to beginner programmers. I see this concept eventually replacing Processing for generative art and animation. Progress is anything that brings us closer to mass adoption of FRP in the computer art world. Fran may have the perfect API for that already (I haven’t actually used it to create anything) but the project is currently deprecated with no clear successors
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578325078.436600"></a>
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578325078.436600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-06 07:37</span><br/>
Thanks for the link <span style="background-color:#ccf">@Doug Moen</span>! Really interesting, looks like the functional language compiles to frag shader code. Did you run into any major roadblocks implementing this? Conditional looping typically isn’t available in shaders for example
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578328009.436800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578328009.436800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-06 08:26</span><br/>
I'm working on this. Or rather, I'm working on an animation-programming hybrid tool that takes some inspiration from Conal's FRP, Fran, etc. I'd be excited to talk to you about FRP, your project, my project, anything!<br/><br/>As an aside: I ran into a wall when it came to representing numbers in the way Conal advocates — he wants everything to be exactly precise real numbers, rather than approximations using rational numbers. But of course you can't store infinite-precision real numbers in a computer.  I had a number of intense twitter thread conversations with him (and others) and arrived at the conclusion that there's no practical way to commit to real numbers once your animations pass a certain threshold of complexity. For example, there's probably no way to make something like a modern realtime 3d game where all your object positions are stored as arbitrary-precision real numbers AND you have complex collisions, since your number representations will likely explode in size as they accrete terms from all their interactions. So instead, in my system, I'm actually using only integers, since that puts me in control over when and how to throw away precision. /shrug/
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578341620.443000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578341620.443000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-06 12:13</span><br/>
&gt; <span style="background-color:#ccf">@Jonas Luebbers</span> Did you run into any major roadblocks implementing this?<br/>Lots of things.<br/>• GPU programming is terrible.<br/>• I wrote a multi-stage compiler that performs partial evaluation and optimization. It is difficult to write, and I'm still working on it.<br/>• I use reference counting to manage memory. I don't know any online resources that explain how to create recursive function closures without cycles, but I figured it out.<br/>• I use signed distance fields and implicit functions to represent geometric shapes. That's a niche technology, and I'm doing original research and inventing new techniques to overcome some of the limitations I have run into.<br/>• Conal's design for the Reactive part of FRP is looks complicated to implement. I'm not working on that bit right now, but I expect to encounter some challenges when I do.<br/>&gt; Conditional looping typically isn’t available in shaders for example<br/>My oldest test machine has a 2010 Nvidia GPU: the GPU driver will accept <tt>for</tt> loops with a compile time bound on the number of iterations, but it will not accept <tt>while</tt> loops, so a subset of the Curv language doesn't work on that machine. Modern GPUs have no problem with looping, and loops are required for general 3D fractals and noise based procedural modelling. My eventual plan is to drop support for GPU hardware that predates 2012, and migrate to a modern, cross-platform GPU API (probably WebGPU).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578342194.443200"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578342194.443200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-06 12:23</span><br/>
<span style="background-color:#ccf">@Doug Moen</span><br/>&gt; I use signed distance fields and implicit functions to represent geometric shapes. That's a niche technology [...]<br/>Is it niche? I'm pretty sure both implicits and SDF are pretty common in games. If I recall correctly, it's common to use implicit surfaces for physics and SDF for some lighting effects, for instance. Am I missing something?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578342293.443400"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578342293.443400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-06 12:24</span><br/>
I'm also really eager for WebGPU to be finalized. Fingers crossed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578342602.443600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578342602.443600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-06 12:30</span><br/>
&gt; <span style="background-color:#ccf">@Ivan Reese</span> Conal wants everything to be exactly precise real numbers, rather than approximations using rational numbers.<br/>I could do cool things with that technology if it was practical, but obviously it isn't. Besides being too slow to actually use, you also can't compare exact real numbers (computational reals) for equality--that's the same as solving the halting problem.<br/><br/>On a GPU, 32 bit floating point arithmetic is never slower than 32 bit int arithmetic, and is typically faster. So on the GPU, I just use 32 bit floats for everything, unless I actually <b>need</b> an int. I honestly didn't put a lot of thought into that, it just seemed like the only good choice. Sounds like you are doing something more clever than that.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578342829.443800"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578342829.443800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-06 12:33</span><br/>
I'm not doing any logic on the GPU, just rendering, so representations there don't matter as much. The logic is all done in JS, so I'm forced to use floats, but I stick to whole numbers (what I would call "shitty ints"). I choose the granularity of time/space representation to be fine enough that, in practice, you don't care. I don't care about average case perf (JS, what can you do) so much as I care about perf cliffs (which arbitrary precision representations seem to dance along the edge of)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578342863.444100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578342863.444100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-06 12:34</span><br/>
<span style="background-color:#ccf">@Ivan Reese</span> I'm not a game programmer, so I may be missing something. I know the SDF technique is used for some particular techniques in games, but I've only heard of a few games that use SDFs to model all of their geometry. I am also not aware of any professional 3D modelling tools that output SDFs. Maya, Z-Brush, etc, all output triangle meshes, as far as I am aware.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578342991.444600"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578342991.444600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-06 12:36</span><br/>
Yeah, that's also my understanding. Games that do SDF will generate the SDF representation from the triangle meshes. They then use the SDF representation for things like cone tracing, to do raytrace-esq reflections. I've also seen some games do the poly mesh -&gt; SDF conversion so that they can do more interesting deformations of the geometry as part of gameplay.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578343178.449000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578343178.449000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-06 12:39</span><br/>
I am in the market for a good open source library for triangle mesh -&gt; SDF conversion. Any recommendations?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578343408.450500"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578343408.450500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-06 12:43</span><br/>
No clue, sorry. I know from watching their twitch stream that the indie dev XRA does this in their game (<a href="http://www.brokendimension.com">http://www.brokendimension.com</a>), but I believe they wrote their own code to do it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578343469.450900"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578343469.450900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-06 12:44</span><br/>
I'll try to remember to ask them about it the next time they stream.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578344315.451600"></a>
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578344315.451600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-06 12:58</span><br/>
A lot of demoscene stuff is all SDFs right? I’m not sure whether that counts as niche or not but I know there’s a lot of crossover into the games industry. I’ve only seen them used for volumetric effects like clouds in games but I’m not an expert here
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578344477.452300"></a>
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578344477.452300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-06 13:01</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> Yeah the state of GPU programming is pretty bleak. I’m impressed by how much you seem to have been able to do with shaders only. I’m excited to try it out when I get a chance
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578344562.452500"></a>
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578344562.452500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-06 13:02</span><br/>
I was aware you could use bounded <tt>for</tt> loops but I didn’t know <tt>while</tt> is available on some machines
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578345315.452700"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578345315.452700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-06 13:15</span><br/>
<span style="background-color:#ccf">@Jonas Luebbers</span> John Hart made the important breakthrough in the late 1990's when he invented Sphere Tracing. The demoscene did a lot of the important subsequent research on SDF technology. Almost everything on <a href="http://shadertoy.com">shadertoy.com</a> uses SDFs. The other important community is Fractal Forums (general 3D fractals like the Mandelbulb).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578345999.453500"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578345999.453500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-06 13:26</span><br/>
<span style="background-color:#ccf">@Jonas Luebbers</span> You can't use while loops in WebGL 1 shaders on Chrome AFAIK. WebGL 1 is stone age technology, and WebGL 2 is maybe bronze age. WebGPU will leap ahead and give us a modern industrial age GPU API, although still not as up to date as what game programmers writing native code have access to. There are no restrictions on while loops in WebGPU, but it doesn't support really old GPUs.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578365016.456200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578365016.456200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-01-06 18:43</span><br/>
The Apple Core animation library is pretty good, and offers much of what Conal did in 1998. It uses the GPU behind the scenes to do the animations, and if orbiting things around and changing them as they fly is your objective, Core Animation is a very clean system. Apple merged it into OSX/IOS so that one could avoid directly programming the GPU. It is one of Apple's notable advantages over Windows OS, along with the Sound APIs which are also baked into the kernel for real-time audio work. No other OS to my knowledge has audio stuff built in (probably invented by Amiga though).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578367217.456700"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578367217.456700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-06 19:20</span><br/>
I haven't programmed against CoreAnimation yet. What is the API like? Is it focused on function composition? If not, then what about it makes it comparable to FRP? How about something like Greensock or the Web Animation API?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578375302.459400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578375302.459400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-06 21:35</span><br/>
Core Animation is a low level imperative API for programming the kinds of animations that appear in MacOS and iOS GUIs. Apple GUIs uses the Model/View/Controller paradigm. Every window has one or more Views, and every view has one or more Layers, which are Core Animation objects. A Layer has a draw() function supplied by the application that draws the contents using Core Graphics. The drawn contents are cached in a bitmap in the GPU. Looks like you can composite layers together using transparency, apply affine transformations and perform simple animations, and CA orchestrates this on the GPU. It's not FRP because it's not Functional and it isn't Reactive (no input handling). I'd say that GreenSock is higher level.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578381718.000100"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578381718.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-01-06 23:21</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> gave a nice sketch of core animation, however he is vastly understating its power. It is what is powering all the built-in controls of IOS; the buttery smooth kinetic scrolling is all animated using core animation, and the fact that the frame rate can stay so high even under heavy CPU load is a very clever feat of the OS Kernel, which  has more of a real-time flavor than anyone gives it credit for. Android took many years to catch up to the buttery smooth animation tricks that Apple used. Of course nowadays phones are 10x what they were so these clever tricks aren't so necessary because of the horsepower. I don't know what you mean by functional. It is call scheduled via an animation queue which you can control slightly, and you can respond to inputs. Core Animation is a 2.5 dimensional system; you can put a rectangle into a perspective transformation, but it isn't a 3D world. For that people use Unreal Engine, Unity, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578384232.031100"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578384232.031100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2020-01-07 00:03</span><br/>
I’m also a little surprised that Core Animation popped up in a thread about FRP. It’s a very pragmatic imperative framework using some functional techniques. <br/><br/>It’s great trick is that you specify start and end states of an animation (which the UI framework could basically do for you implicitly, and you got default animations without specifying anything), commit it to the render server, and all the interpolation per frame is then done on the GPU. That cleared up the CPU to take care of other things, mostly shoving memory around to manage textures and create the raster image data for these from the UI framework. Apart from much slower chips, memory bandwidth was one of the biggest issues of the early iPhones. Core Animation worked around that very effectively. (A design that fell out of constraints of the time — in case you’re following other threads about creativity. ;-)<br/><br/>Sharing the work between CPU and GPU made the first iPhone possible, or rather its smooth kinetic scrolling capabilities which separated generating the textures from moving and scaling or otherwise transforming them. If you ever used an early iPhone, you might remember the checkerboard pattern that showed up whenever you were scrolling into areas that hadn’t texture memory loaded yet — still it always felt responsive because you could see the inertia of the scrolling thanks to the checkerboard. That was a design decision realizing that it’s more important to have the animation be absolutely smooth than to see the actual content.<br/><br/>Its greatest benefit is also its greatest weakness: once you commit an animation it just runs and you have little control over it. For animations that might be exactly what you want, but as Apple moved on to interruptible animation and gestures and now that chips are much more capable, Core Animation is likely on the way out to be replaced with something much more resembling FRP, although I wouldn’t count on Apple to deliver a pure functional approach. <br/><br/>You can get a glimpse of what it will look like with SwiftUI, which includes — apart from classic UI components still built on top the classic frameworks (but for how long?) — a simple graphics API for shapes and animations that is likely to eventually succeed Core Graphics (Quartz) and Core Animation and will be a more efficient implementation directly leveraging Metal. That might be what you may want to look at for inspiration: <br/><br/><a href="https://developer.apple.com/tutorials/swiftui/drawing-paths-and-shapes">https://developer.apple.com/tutorials/swiftui/drawing-paths-and-shapes</a><br/><br/><a href="https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions">https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578431001.001800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578431001.001800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-07 13:03</span><br/>
My vision for state-of-the-art functional reactive animation (FRAN):<br/>• Provide a rich set of 2D and 3D operators for constructing graphical values (shapes and colour patterns). For example, instead of just the endlessly recycled 2D vector graphics operators of Postscript/SVG, support the full power of resolution-independent implicit function representation, where anything that can be described using mathematics can be expressed: algebraic surfaces, set union intersection difference, fractals, non-affine transformations, noise based procedural modelling, and so on.<br/>• A pure functional program, which uses these primitives, is evaluated to yield a graphical value, which may be time varying and reactive. A graphical value is represented by tree of graphics operators (call this the CSG tree).<br/>• An optimizing graphics compiler walks the CSG tree, compiling it into code that runs partly on the CPU and partly on the GPU.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578439937.002900"></a>
      <img src="https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578439937.002900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ivan Reese</b>
<span style="margin:2em; color:#606060">2020-01-07 15:32</span><br/>
Not to pile on, but Edward also said..<br/>&gt; I don't know what you mean by functional.<br/>FRP is "functional" in the sense of Functional Programming — it's an approach to specifying animations using function composition, where each function describes how to transform some input graphic according to some input time. <em>What the animation does</em> is captured by the combination of functions and their return values as you vary the time input.<br/><br/>It sounds like CA works a bit like Greensock or Web Animations and other OO animation tools, where you create some state object to represent the animation, specify properties and values on the object, and then submit that object to some engine. <em>What the animation does</em> is captured by the data in that object and what the engine does based on it.<br/><br/>Then there are the procedural animation tools, like Processing or the HTML Canvas, where you write code that is executed every frame. <em>What the animation does</em> is a side effect of your code directly manipulating or generating the graphic.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578469305.013100"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578469305.013100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-01-07 23:41</span><br/>
In the case of Core Animation, there are various properties that you can specify for beginning and ending value, and it does the tricky job of interpolating. You can also chain animations, and run sequences of them in parallel, with triggers. It is a very complete and capable animation system, and far ahead of Windows at the time as MS was lagging in graphics except in DirectX ,which was basically a rogue team inside MS that wanted to make 3D games fast, and realized the only way was to bypass the normal Windows graphical kernel, so they built they own drivers for the hardware. Now we see Apple trying to beat MS's DirectX with their own 3D interface they call Metal.  There are also capabilities if i recall correctly to have a callback function called to generate parameters. The most unusual aspect of Core Animation is the it has a 4x4 matrix, but you are pinned down in some of the parameters so you can only put a plane in perspective. They stopped short of 3D. I call it 2 and 1/2 dimensions. Anyway supporting some animation is a very important aspect of building modern interfaces, if you want to go past simple 2D dragging of say images onto a flat surface. I would imagine some of the efforts in the FoC group are using WebGL and just going full bore into 3D. 3D comes with a lot of baggage, and it sure isn't friendly for beginners. There was an add-on library for Adobe AIR called Starling, the work of one really great german programmer, and it gives you the GPU for 2D sprite sheets, and many other accelerated things. A really great compromise, and many popular Mobile games are using Starling, because it leverages the machine independent virtual GPU that underlies Adobe AIR. I know it is a fading technology, but getting great accelerate 2D rendering is a terrific thing, and it takes a huge amount of work to build.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578469309.013300"></a>
      <img src="https://avatars.slack-edge.com/2019-09-09/753296041488_3447742b735b104a7ff2_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578469309.013300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Don Abrams</b>
<span style="margin:2em; color:#606060">2020-01-07 23:41</span><br/>
Honestly animation via code feels really strange to me-- hard to write and harder to read. I worked on an animation prototyping tool for a design tool and it felt so much better to use than direct code. We leveraged Greensock, had start/end states constrained by the design (or current page state), and provided tooling to visually modify the transition (basically just leveraging interpolation over the merged tree during playback).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578469886.014000"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578469886.014000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-01-07 23:51</span><br/>
Most of the classic 3D animation tools, like Autocat 3D studio max, and the Maya product, had graphical interactive interfaces, which automatically generated commands in their command line language, which you could then tweak. Or use as inspiration for generating code by computers. Animation has always existed, even back in Macromind Director which spawned the whole CDROM revolution, in concert with the ability to tweak the animation. In hollywood they do motion capture, and then tweak it a little bit by hand to make it just right. The human eye and hand can get you very close, but there is inevitably some massaging, and generating sequences by computer of course is done all the time by the masters at Pixar, which use every technique possible to get things to look good. Classic Disney style cel animation is the "hard way", and it is pretty much extinct due to its cost.  It took over 1200 people to draw Snow White.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578470103.014200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578470103.014200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-01-07 23:55</span><br/>
If you want to see hard core animation, here is a brief documentary on Snow White.  <a href="https://www.youtube.com/watch?v=OebUzEhSLBI">https://www.youtube.com/watch?v=OebUzEhSLBI</a><br/>The most expensive cartoon of its time by more than a factor of 10. You have to hand it to Walt Disney he didn't think small.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578797809.134400"></a>
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578797809.134400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-11 18:56</span><br/>
Wow there's a lot of stuff to respond to here, but here's a summary of what I'm thinking. My hypothesis is that the barrier to entry for generative art / creative coding / reactive animations is very high because the medium is naturally difficult to map onto imperative code. FRP (or more specifically DCTP) was originally invented to solve this exact problem but hasn't taken off for many reasons: meta-level thinking required for higher order streams, lack of interfaces (text or otherwise) that allow one to manipulate streams in an easily-digestible way, and performance to name a few challenges. None of these seem insurmountable and I think that a tool like this has the potential to blur the line between programmer and artist like Processing intended nearly two decades ago
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578798292.134600"></a>
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578798292.134600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-11 19:04</span><br/>
Tools like Core Animation and Greensock are the exact opposite of what I'm looking for. I'm thinking about animation as a pure function from user interaction to pixels on a screen—inherently interrupt-able. frameworks like these seem like solutions created for interfaces where the language didn't have the expressive power to model continuous time
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578798831.135100"></a>
      <img src="https://avatars.slack-edge.com/2019-11-20/845138028391_2825557305c27a8f158e_72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578798831.135100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jonas Luebbers</b>
<span style="margin:2em; color:#606060">2020-01-11 19:13</span><br/>
Doug's thoughts above about FRAN I think are spot on though I'm biased toward artistic expression over mathematical purity
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578856902.144400"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578856902.144400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-12 11:21</span><br/>
My main goals for Curv are:<br/>• Artistic expressiveness. You can make any kind of 2D or 3D art, using a wide variety of techniques.<br/>• Ease of use. This covers a lot of ground, including the IDE and the language itself.<br/>Mathematical purity is not a goal, but there are lots of areas in the design where mathematical purity makes important contributions to artistic expressiveness, ease of use, and ease of engineering. So I use mathematical purity as a tool, not as an end in itself:<br/>• Pure functional programming. This contributes greatly to ease of use, and simplifies the engineering (generating data-parallel rendering code). The semantics of the language are much simpler. A pure functional API for constructing shapes by composing functions is <b>so much nicer</b> than a 1990's style API where graphical primitives paint directly onto a canvas and you have to manage a set of global variables containing the current colour, the current line width, the current transformation matrix, etc.<br/>• Abstract algebra, what Haskell calls "equational reasoning". Unlike most programming languages, the equality operator <tt>a==b</tt> is an equivalence relation: <tt>a==a</tt>; <tt>a==b</tt> implies <tt>b==a</tt>; <tt>a==b</tt> and <tt>b==c</tt> implies <tt>a==c</tt>. Unlike most dynamic languages, the boolean operations obey all the axioms of a boolean algebra. For example, unlike in Python Javascript Lisp, the boolean and operator is commutative. This all falls under ease of use: simple language semantics, no surprises.<br/>However, there are some kinds of mathematical purity in Haskell culture that are detrimental to my goals.<br/>• Lazy function calls are a net loss; Curv uses strict argument evaluation in function calls.<br/>• Static typing is a big barrier to learning a language, and is incompatible with live programming, so Curv is dynamically typed.<br/>• I haven't built a Turing complete reactive API yet, but DCTP looks really hard to understand. The Elm language transitioned from "mathematically pure" FRP to "the Elm architecture", which is much easier to understand, and it is still "pure functional" and "reactive". So I'll probably take my lead from Elm, begin with the Elm architecture, and iterate from there.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578876791.145200"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578876791.145200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2020-01-12 16:53</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> to defend Haskell culture — a bit of it and not to be confused with Haskell itself.  To make types consistent with liveness, you need holes: this part isn't filled in yet or these two parts are at odds because I'm reconciling them.  Now laziness strike me as nearly as important as purity: being able to ignore the timing of when a function gets evaluated.  Then treat change over time as a first class entity rather than a side effect function evaluation order.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1578882161.145600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1578882161.145600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2020-01-12 18:22</span><br/>
Hazel has holes, and it is dynamically typed for this reason. It's a terminology issue. "Dynamic typing" is not academically respectable, so they had to use different terminology in the paper. But it's dynamic typing because they store type information in the data and check the type information at runtime, which Haskell doesn't do.<br/><br/>I make a distinction between Haskell's lazy evaluation of function calls, and lazy data structures. No other languages I know have copied Haskell's lazy function calls, due to ease of use issues for the programmer (unpredictable performance and memory consumption), and due to high cost and complexity of implementation. Even Idris, which is even purer than Haskell, with its dependent types and total functions, uses strict evaluation order. Lazy function calls would be disastrous for Curv, but other forms of laziness will be necessary.<br/><br/>Curv is a pure functional language. All functions are pure (have no side effects). The language guarantees that you can't use side effects to determine the order of evaluation of function calls within an expression. So yes, I do want to treat change over time as a first class entity. Curv totally works this way right now. However, the Haskell virtual machine (the way it implements laziness) is totally incompatible with running code on a GPU, so I may need to find new ways to model change over time in a pure functional language as Curv becomes more powerful. I feel that I cannot simply follow in Haskell's footsteps. Haskell just is not designed for GPUs. Haskell's model of laziness is intimately tied to a single-threaded execution model, while GPUs are data-parallel : that is part of the problem.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579068858.195300"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1579068858.195300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2020-01-14 22:14</span><br/>
I'll readily agree that in practice laziness has many drawbacks.  As for GPU programming, I don't know how to accomplish more than a basic shader, so no idea how do something serious.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579077514.195700"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1579077514.195700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2020-01-15 00:38</span><br/>
GPU programming is extremely difficult and weird. They typically have very limited instructions sets with all sorts of irregularities, and the fact that they often cannot access regular RAM but instead have their own very fast memory makes it the specialty of game programmers and ML number crunchers. Thankfully core counts on regular CPU's are coming up fast due to AMD finally giving Intel some competition again after languishing for so many years. Perhaps some day it will be just one processor type again.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1579087879.196800"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1578272464.418200.html#1579087879.196800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2020-01-15 03:31</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> every few years I do stick my nose in to check whether it still stinks.  :fire::scream::fire:
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
