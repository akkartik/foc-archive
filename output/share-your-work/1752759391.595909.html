<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-07-17 06:36</span><br/>
I've stated that CPUs don't implement "functions". In this [article](On Options For Programming <a href="https://open.substack.com/pub/programmingsimplicity/p/on-options-for-programming?r=1egdky&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true">https://open.substack.com/pub/programmingsimplicity/p/on-opt&hellip;</a>), I say this again, hopefully in a better way.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1752769935.157609"></a>
      <img src="https://avatars.slack-edge.com/2023-09-30/5997119242352_87f45e326f3a692ca55c_72.png" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1752769935.157609" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jasmine Otto</b>
<span style="margin:2em; color:#606060">2025-07-17 09:32</span><br/>
I noticed Arawjo 2020 and was reminded to read through, thank you. His vision of coding-as-inscription reminds me a lot of Sengers's anti-boxology, and her notes on critical technical practice, which you seem to be working with here.<br/><br/>You might enjoy p.13 - 20 of Sengers 1998 (digitally numbered p.25 - 32), which pulls Winograd &amp; Flores / Suchman / Chapman / Agre / Varela et al. into a delightful five-way synthesis. These are all researchers who have applied rigorous ontological discipline to subjective experiences. When you describe 'bending [computing machines] to fit paradigms of thought', that's what I think of<br/><br/><a href="http://reports-archive.adm.cs.cmu.edu/anon/anon/usr/ftp/usr0/ftp/1998/CMU-CS-98-151.pdf">http://reports-archive.adm.cs.cmu.edu/anon/anon/usr/ftp/usr0&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1752770084.464749"></a>
      <img src="https://avatars.slack-edge.com/2023-09-30/5997119242352_87f45e326f3a692ca55c_72.png" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1752770084.464749" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jasmine Otto</b>
<span style="margin:2em; color:#606060">2025-07-17 09:34</span><br/>
e.g. depending on your formulation of the action space,<br/>> In an unexpected move, after trying to understand AI in a Heideggerian sense Winograd chose to jettison AI altogether as impossible. [...]  AI <em>can</em> solve problems that are formally specified and circumscribed, but will always fail to attain true intelligence because “[t]he essence of intelligence is to act appropriately when there is no simple pre-definition of the problem or the space of states in which to search for a solution” (98).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1752830622.520429"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1752830622.520429" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-07-18 02:23</span><br/>
&gt; Today, we focus on only <em>one</em> engine - the FP-machine engine.<br/>Is that true? Academic CS research is very much focused on FP, but my impression is that the software industry doesn't.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1752875974.418189"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1752875974.418189" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-07-18 14:59</span><br/>
It is my impression that software industry programmers use the word "function" even when they mean "procedure", and, programmers tend to shy away from side-effects and state, and programmers tend to rely on the existence of preemptive operating systems (Windows, Linux, MacOS), etc. It is my impression that most popular CPUs today are enbaubled with <a href="https://programmingsimplicity.substack.com/p/pusm-programming-using-the-sicp-method?r=1egdky">scaffolding</a> that supports the function-based meme (e.g. virtual memory, MMUs, caches, etc. (stuff that is needed to handle larger and larger data, but, not actually necessary for code itself)). It is my impression that programmers tend to think that "concurrency" and "asynchrony" are difficult concepts. These are all "tells" of too much emphasis on function-based thinking. It is, thus, my conclusion that the software industry is heavily influenced by the FP / function-based meme. (I blame "C").
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1752939930.744589"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1752939930.744589" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-07-19 08:45</span><br/>
And yet, most software I have personally looked at and worked with does not adopt FP as its dominant style. But scientific software is probably a special case.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1752977103.082229"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1752977103.082229" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-07-19 19:05</span><br/>
Yes. I'm struggling to find words  to express my observation. If I use the phrase "function-based", no one understands what I mean, if I switch to using "FP", everyone understands what they <b>think</b> I mean, but, miss my point). Before C, programming languages talked about "subroutines" (or, "procedures") and "functions", where "function" meant pure function in a mathematical-y sense. C conflated the two terms and just called everything a "function". This - psychologically - seemed to infer that CPUs were supposed to be used as function-machines. Early languages, like Prolog, Forth, etc. were invented before this mindset took over - the inventors allowed themselves to build little engines using opcodes. The engines supported various - very different - paradigms for thought. It is my belief that, today, programmers try to solve every problem using only one paradigm for thought (the function-based paradigm) and push themselves into unseemly corners in cases where the function-based paradigm is an unsuitable choice. Stuff like "concurrency", "asynchrony", "robotics" should be solved, IMO, in paradigms other than than the function-based one (and, without the attendant "operating system" that is needed by the function-based paradigm).<br/><br/>Smalltalk was infected with this cognitive dissonance and began misusing the phrase "message passing" when in fact it only implemented function-calling (blocking) with named parameters {correction: functions (aka "methods") named by inclusion of parameter keywords}. IMO, an "object" should be a whole CPU and a "message" is a blob of data sent along a wire from one CPU to another CPU. There is a deep difference between the idea of synchronous machines / objects and free-running, asynchronous, distributed machines. We couldn't afford to build this properly in the early days, but, we could afford to do this, properly, today (using cheapo CPUs, Arduinos, RPis, etc.) if we wanted.<br/><br/>IMO, if you're using Python, Javascript, Smalltalk, CLOS, C++, etc. then you are implicitly using the function-based paradigm.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1753013533.753119"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1753013533.753119" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2025-07-20 05:12</span><br/>
If no one understands what you are trying to say, especially after years of trying to say it, you might consider that you are not communicating your point well. I would further suggest that the reason for this external communication failure is internal: you haven’t gotten your ideas in good order yet.<br/><br/>For example, how would moving from <tt>function</tt> to <tt>procedure</tt> make any difference for specifying async or concurrent tasks? What difference are you drawing between the two things? How is one not just a special case of the other? I have suspicions about what you mean here based on my understanding of these things, but you haven’t really clarified these distinctions within your communications.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1753103822.931919"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1753103822.931919" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-07-21 06:17</span><br/>
&gt; This - psychologically - seemed to infer that CPUs were supposed to be used as function-machines.<br/>I doubt it. C goes back to a time when FP was considered impractical. I see the reasoning behind the term "function" in C (as in Lisp) as procedures being a generalization of the concept "function" in the context of code (as opposed to math).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1753104939.045359"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1753104939.045359" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-07-21 06:35</span><br/>
Yes, FP was considered impractical in the days of C. (In fact, I studied Denotational Semantics due to my interest in compilers, and rolled my eyes). Yet, I think that there was a <b>psychological</b> effect just in the use of the word "function" instead of the then-used words like "procedure" and "subroutine". The word "function" gave free reign to thoughts like "mutation is bad", "state is bad", functions must return a value, no side-effects (what is a "server", then?), etc., etc. All of that led to bloat such as MMUs, caches, preemption, excessive amounts of memory, ignoring of coroutines, etc., etc. When I listen to Muratori's talk, I "hear" this. He actually flip-flops between using the words "subroutine" and "function" while decrying bloatware. Functions require stacks, everything-is-a-function-ideology requires "infinite" stacks which leads to virtual memory and excessive amounts of memory (we <b>need</b> more memory for fatter and better media, but, that does not directly imply that our code needs to become bloated, too). Functions create ad-hoc blocking which leads to heavy-weight operating systems needing to use preemption. Early games had the right idea, IMO, you slipped in a cartridge and the software took over the whole machine, without 55,000,000 LOC of operating system getting in the way.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1753125430.812489"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1753125430.812489" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-07-21 12:17</span><br/>
The term "function" is actually pre-C. Fortran used it as well, in pretty much the same sense, with the possibility of mutable state as well.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1753126938.288759"></a>
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1753126938.288759" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2025-07-21 12:42</span><br/>
I haven't used Fortran in ages, but I remember that a "function" was different from a "subroutine". Do you know what the difference is/was?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1753174013.139989"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1753174013.139989" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2025-07-22 01:46</span><br/>
Starting in FORTRAN II in 1958, <tt>FUNCTION</tt>s returned a value and <tt>SUBROUTINE</tt>s did not. So if you wanted some result from a subroutine you would pass (usually) an array into the subroutine to be modified in place. However, you could also pass such a datum into a function to be modified, so the real difference is that a subroutine is a special case of a function that never returns anything. Algol and early Lisp made a similar distinction, which is unsurprising given that McCarthy worked on all of them.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1753276990.914979"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1752759391.595909.html#1753276990.914979" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2025-07-23 06:23</span><br/>
The one big reason to use FUNCTION rather than SUBROUTINE is that you can use function calls inside compound expressions (e.g. <tt>2.0 * SQRT(X)</tt> ), whereas subroutines must be called with a CALL statement, i.e. one line per call.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
