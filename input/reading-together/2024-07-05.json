[
    {
        "user": "U07BWTYKJQG",
        "type": "message",
        "ts": "1720203029.699949",
        "client_msg_id": "eba4129f-3758-45a8-b1d0-3881ba993e2d",
        "text": "I've been kinda obsessed with this paper, \"Weird Machines, Exploitability, and Provable Unexploitability\" since October last year.\n<https:\/\/ieeexplore.ieee.org\/stamp\/stamp.jsp?tp=&amp;arnumber=8226852>\n<https:\/\/www.youtube.com\/watch?v=1ynkWcfiwOk>\n(I think starting with the talk is a good idea)\n\nAfter hearing about robust first computing I've been pondering the connection for a bit. I'm not really sure what to make of it, but there has to be some connection. In <https:\/\/www.youtube.com\/watch?v=Dmlm6mtnSZs|this talk> by Dave Ackley he specifically mentions that \"flipping one bit\" (paraphrasing) can be enough to destroy a lot of software, which is the exact attack model that Dullien uses. It would be nice if software could maintain security invariants despite memory corruption (which Dullien proves for a small piece of software that he writes) so in that sense the two concepts allign. But I find that \"continuing despite an error\" or \"return a best-effort answer\" is the source of many security vulnerabilities, (mid example: database lookup fails, code is written in a way that forgot to handle that case, code continues anyway and returns admin data that shouldn't be shown). I wonder if any of y'all have read this or have thoughts about it. :))",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gab6480f198d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ab6480f198d285d8f1c8d27be7c7ad13.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png",
            "first_name": "Polly",
            "real_name": "Polly",
            "display_name": "Polly",
            "team": "T5TCAFTA9",
            "name": "pollyboutet",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1720203029.699949",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1720360934.437349",
        "reply_users": [
            "UCUSW7WVD",
            "U07BWTYKJQG",
            "U07AR9MFUUF"
        ],
        "replies": [
            {
                "user": "UCUSW7WVD",
                "ts": "1720221975.552169"
            },
            {
                "user": "U07BWTYKJQG",
                "ts": "1720254838.939829"
            },
            {
                "user": "U07AR9MFUUF",
                "ts": "1720360934.437349"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ItZ\/+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been kinda obsessed with this paper, \"Weird Machines, Exploitability, and Provable Unexploitability\" since October last year.\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/ieeexplore.ieee.org\/stamp\/stamp.jsp?tp=&arnumber=8226852"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=1ynkWcfiwOk"
                            },
                            {
                                "type": "text",
                                "text": "\n(I think starting with the talk is a good idea)\n\nAfter hearing about robust first computing I've been pondering the connection for a bit. I'm not really sure what to make of it, but there has to be some connection. In "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=Dmlm6mtnSZs",
                                "text": "this talk"
                            },
                            {
                                "type": "text",
                                "text": " by Dave Ackley he specifically mentions that \"flipping one bit\" (paraphrasing) can be enough to destroy a lot of software, which is the exact attack model that Dullien uses. It would be nice if software could maintain security invariants despite memory corruption (which Dullien proves for a small piece of software that he writes) so in that sense the two concepts allign. But I find that \"continuing despite an error\" or \"return a best-effort answer\" is the source of many security vulnerabilities, (mid example: database lookup fails, code is written in a way that forgot to handle that case, code continues anyway and returns admin data that shouldn't be shown). I wonder if any of y'all have read this or have thoughts about it. :))"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heartbeat",
                "users": [
                    "UCUSW7WVD",
                    "U05UK5T7LPP",
                    "U06DZDM8C93"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1720221975.552169",
        "client_msg_id": "97dc8732-14e0-4244-a7ee-77bc71e3a0c6",
        "text": "I'm still thinking about this one, but want to share something I wrote a few years that starts out from a similar framing: <https:\/\/akkartik.name\/post\/modularity>\n\nOP is much cleaner. What I refer to fuzzily as \"territories of programs\", OP makes precise as the distinction between the intended finite state machine and its _emulation_ on a (fixed-memory, so you end up padding a bunch of don't-care bits in the address space) real computer.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1720203029.699949",
        "parent_user_id": "U07BWTYKJQG",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eQO1w",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm still thinking about this one, but want to share something I wrote a few years that starts out from a similar framing: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/akkartik.name\/post\/modularity"
                            },
                            {
                                "type": "text",
                                "text": "\n\nOP is much cleaner. What I refer to fuzzily as \"territories of programs\", OP makes precise as the distinction between the intended finite state machine and its "
                            },
                            {
                                "type": "text",
                                "text": "emulation",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " on a (fixed-memory, so you end up padding a bunch of don't-care bits in the address space) real computer."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]