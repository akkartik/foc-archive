<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2023-02-06/4754627914258_41a8bada781281751d07_72.jpg" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Paul Tarvydas</b>
<span style="margin:2em; color:#606060">2022-08-15 20:55</span><br/>
For discussion: I am thinking that FoC should be done with “dynamic languages” (Lisp (pre-CL), JavaScript, REBOL, Self, technical diagrams, etc.).  PoC (Present of Coding) languages, e.g. “static languages” like Haskell, Rust, C++, etc., and, compiler-appeasement dynamic languages like Python, Racket, Scheme, Smalltalk, Common Lisp, etc., are used to optimize and to structure FoC ideas, but, they inhibit out-of-the-box-thinking.  Writing the program twice (or more times) is more efficient than writing the code once only in a PoC language.  What is “efficient”?  At one extreme: all Design and no optimization, at the other extreme: all Production Engineering (optimization) and no Design.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660622623.501149"></a>
      <img src="https://secure.gravatar.com/avatar/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660622623.501149" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Personal Dynamic Media</b>
<span style="margin:2em; color:#606060">2022-08-15 21:03</span><br/>
I'm not sure I fully understand how you classified each of those languages, especially Scheme and Smalltalk, but I love the phrase "compiler-appeasement." It really captures the concept of limitations that arise from the accidental complexity of implementation, and not the effort to make a usable and useful design.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660630995.060499"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660630995.060499" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2022-08-15 23:23</span><br/>
For me the language is irrelevant; it is the idea that is important. Use the tool that will get the job done.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660632208.011949"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660632208.011949" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2022-08-15 23:43</span><br/>
<span style="background-color:#ccf">@Paul Tarvydas</span> The two lists of languages don't make any sense to me. Can you expand on how you think Smalltalk is more of a compiler appeasement language relative to Self?<br/><br/><span style="background-color:#ccf">@Chris Maughan</span> I don't mean to be rude, so please try to take this in the collegial spirit with which I ask it: what do you think that comment adds to this conversation?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660634899.008229"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660634899.008229" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-08-16 00:28</span><br/>
I used to be a scala programmer and types enthusiast but I have totally moved to dynamic languages because they are so much faster to develop with. I used to create rube-goldberg type frameworks that would enforce various constraints via metarpogramming, but then I read this article that showed compile type checking could be reduced to runtime checking and we just keep moving the same undecidability problem a level outwards... and it clicked, that all this type stuff was almost pointless, I was trying to do runtime computation at compile time, but with worse debugging tools. It was silly.<br/><br/>Consider this:<br/><pre style="white-space:pre-wrap">I write a bug, I try to compile it, and the computer refuses to, and highlights a line with an error</pre><br/>vs<br/><pre style="white-space:pre-wrap">I write a bug and I run it, and the computer crashes and highlights the the line with a stack trace</pre><br/>Anyway, I shifted my focus to visibility at runtime and I think it's a better tradeoff for than types for smaller programs. VERY large software spans the network and database and those are untypes so everything becomes dynamically typed  eventually at the other end of the scale too.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660636636.794179"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660636636.794179" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-08-16 00:57</span><br/>
My dream environment is yet a bit different: a live-coding system inside which I can define subsystems that subject to static verifications, but using type systems (plural!) that I can define myself. Details: <a href="https://science-in-the-digital-era.khinsen.net/#Static%20type%20systems">https://science-in-the-digital-era.khinsen.net/#Static%20type%20systems</a> and <a href="https://science-in-the-digital-era.khinsen.net/#Formalization">https://science-in-the-digital-era.khinsen.net/#Formalization</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660636709.836379"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660636709.836379" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-08-16 00:58</span><br/>
I don't want to switch languages, and in particular I don't want to change run-time systems and have to deal with data conversion, when I move from free-style to formally verified code.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660639693.737089"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660639693.737089" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2022-08-16 01:48</span><br/>
Hi <span style="background-color:#ccf">@Jack Rusher</span> , apologies if I came across as flippant; not my intention. I merely wanted to suggest that speed of execution might be faster if you use the tools you know best. I've found that, while fun to try different languages, there is a knowledge wall which eventually inhibits progress. Sonic Pi comes to mind. I've been a core contributor to that for a while. It is implemented in no less than 4 languages; C++, Elixir, Ruby &amp; Erlang; with significant code in each one.  While a great project, progress is inevitably slow because Sam is really the only one that comes close to understanding how everything works. One thing I've heard Sam say is that ‘Elixir gives me this nice real time scheduling which is great for music’. My personal opinion is that you can achieve that just as easily with most languages. They are all just deep stacks sitting on your CPU.  The down side of the approach is, as I say, speed of implementation. The barrier to entry for Sonic Pi development is huge; it requires technical abilities in many areas to make significant contributions.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660640256.059179"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660640256.059179" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2022-08-16 01:57</span><br/>
… mostly I'm addressing <span style="background-color:#ccf">@Paul Tarvydas</span> point ‘what is efficient’? To be fair, he is also asking about how languages change ‘thinking’; that is certainly true.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660655176.538259"></a>
      <img src="https://avatars.slack-edge.com/2022-06-22/3731055996048_754abc97c5ce87f6c99f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660655176.538259" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tony Worm</b>
<span style="margin:2em; color:#606060">2022-08-16 06:06</span><br/>
I'll just add, that in my opinion, Go is a master class in language and tooling design. It may be the last great work of some computing legends (Pike, Thompson)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660661847.663969"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660661847.663969" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2022-08-16 07:57</span><br/>
<span style="background-color:#ccf">@Chris Maughan</span> No big thing! My reaction came from:<br/>1. Programming languages themselves contain ideas, and ideas about how to make better programming languages are very much in scope for FoC efforts. This is especially true when we consider the environment in which a language is embedded, rather than reducing it to syntax + denotational semantics. <br/>2. It was phrased in such a way that it seemed like it was trying to shut down <span style="background-color:#ccf">@Paul Tarvydas</span>'s thread. (Probably not your intention!)<br/>A question about "you can achieve that just as easily with most languages" — do you think it would be "just as easy" to build Erlang's OTP or write a real-time scheduler in Ruby?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660661906.641459"></a>
      <img src="https://avatars.slack-edge.com/2022-06-22/3731055996048_754abc97c5ce87f6c99f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660661906.641459" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tony Worm</b>
<span style="margin:2em; color:#606060">2022-08-16 07:58</span><br/>
&gt;  how to make better programming languages<br/>How does one define better?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1660734784.784359"></a>
      <img src="https://secure.gravatar.com/avatar/2266cacc8f3c9964e7bfb1c357bf6873.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../thinking-together/1660622143.650149.html#1660734784.784359" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Chris Maughan</b>
<span style="margin:2em; color:#606060">2022-08-17 04:13</span><br/>
&gt; 1. Programming languages themselves contain ideas, and ideas about how to make better programming languages are very much in scope for FoC efforts. This is especially true when we consider the environment in which a language is embedded, rather than reducing it to syntax + denotational semantics.<br/>Yes, I was thinking more about how to 'implement' those new things; languages or otherwise, to be efficient.<br/><br/>&gt; 2. It was phrased in such a way that it seemed like it was trying to shut down <span style="background-color:#ccf">@Paul Tarvydas</span>'s thread. (Probably not your intention!)<br/>Certainly not; just a too-brief reaction to the post!<br/><br/>&gt; A question about "you can achieve that just as easily with most languages" — do you think it would be "just as easy" to build Erlang's OTP or write a real-time scheduler in Ruby?<br/>That is a very fair point; maybe using a C extension :wink: Perhaps 'you can achieve the most in the quickest time using a language you know'.  i.e. I could probably build a scheduler the fastest in C++; and you (speculating) might build one faster in Lisp than Ruby.... etc.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
