[
    {
        "user": "UDQBTJ211",
        "type": "message",
        "ts": "1649508703.704979",
        "edited": {
            "user": "UDQBTJ211",
            "ts": "1649508782.000000"
        },
        "client_msg_id": "520683c1-1f55-4fa4-8ed1-b637b57e6337",
        "text": "People admire Lisp's \"elegance\" in that it only has a single built-in datastructure - lists `(a b c)`. Clojure, on the other hand is generally admired for being more \"practical\". One of the main things Clojure introduced is vectors `[a b c]`, and maps `{:a b, :c d}` as first class syntax. I was reading <https:\/\/git.eta.st\/eta\/intertube\/src\/branch\/master\/trackernet.lisp#L93|some Lisp> this week and my brain kept grating\/complaining because I was seeing what are conceptually hashmaps written as what I was interpreting as a lists of pairs, something which I \"know\" to be different.\n\nConversely, I have always thought it was annoying that C++ has three different operators (`::`, `.`, `-&gt;`) that all essentially mean \"member of\". Would C# be better if you had to say `System::Console.Print()` instead of `System.Console.Print()`? No, I think most people would rarely feel the need to conceptually distinguish between these things, the C++ syntax is just annoying noise to me.\n\n*What is it that distinguishes Clojure's brilliant decision to expand the syntax, from C# brilliant decision to compress the syntax?*\n\nIt implies to me that if there is a scale of simplicity-to-expressiveness, then humans just happen to sit at particular point on it. There's no particular \"reason\" for why these changes were right other than \"they'd gone too far that way, go back this way\". There's a local maximum somewhere in the middle.\n\nI have been thinking about this simplicity-to-expressiveness scale recently as it irrationally annoys me that on WikiData, \"instance of\" is \"just another relationship\" (it's <https:\/\/www.wikidata.org\/wiki\/Property:P31|P31> - <https:\/\/www.wikidata.org\/wiki\/Property:P27|\"citizen of\" is P27>!).\n\nI think that RDF is far too far towards the \"elegance\" end of the spectrum and would greatly benefit from a Clojure-style acknowledgement that some things are more different, and should be more differentiated. Yeah, it's mildly interesting that Node-Rel-Node triples is all you need to describe an ontology, but that's not actually how people think about the world...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "2624b1e78c0a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-14\/551655871797_2624b1e78c0a9eaed529_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Knott",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "chrisknott",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1649508703.704979",
        "reply_count": 8,
        "reply_users_count": 6,
        "latest_reply": "1649787628.056239",
        "reply_users": [
            "UEBG0NPDK",
            "U02U0AS3J49",
            "UGWUJUZHT",
            "U016VUZGUUQ",
            "UBKNXPBAB",
            "U03B14DUZSA"
        ],
        "replies": [
            {
                "user": "UEBG0NPDK",
                "ts": "1649517032.800189"
            },
            {
                "user": "UEBG0NPDK",
                "ts": "1649517079.681229"
            },
            {
                "user": "UEBG0NPDK",
                "ts": "1649517126.837289"
            },
            {
                "user": "U02U0AS3J49",
                "ts": "1649518479.374759"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1649522470.505519"
            },
            {
                "user": "U016VUZGUUQ",
                "ts": "1649523349.579689"
            },
            {
                "user": "UBKNXPBAB",
                "ts": "1649562377.640379"
            },
            {
                "user": "U03B14DUZSA",
                "ts": "1649787628.056239"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LSN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "People admire Lisp's \"elegance\" in that it only has a single built-in datastructure - lists "
                            },
                            {
                                "type": "text",
                                "text": "(a b c)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Clojure, on the other hand is generally admired for being more \"practical\". One of the main things Clojure introduced is vectors "
                            },
                            {
                                "type": "text",
                                "text": "[a b c]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", and maps "
                            },
                            {
                                "type": "text",
                                "text": "{:a b, :c d}",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as first class syntax. I was reading "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/git.eta.st\/eta\/intertube\/src\/branch\/master\/trackernet.lisp#L93",
                                "text": "some Lisp"
                            },
                            {
                                "type": "text",
                                "text": " this week and my brain kept grating\/complaining because I was seeing what are conceptually hashmaps written as what I was interpreting as a lists of pairs, something which I \"know\" to be different.\n\nConversely, I have always thought it was annoying that C++ has three different operators ("
                            },
                            {
                                "type": "text",
                                "text": "::",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": ".",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "->",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ") that all essentially mean \"member of\". Would C# be better if you had to say "
                            },
                            {
                                "type": "text",
                                "text": "System::Console.Print()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " instead of "
                            },
                            {
                                "type": "text",
                                "text": "System.Console.Print()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? No, I think most people would rarely feel the need to conceptually distinguish between these things, the C++ syntax is just annoying noise to me.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "What is it that distinguishes Clojure's brilliant decision to expand the syntax, from C# brilliant decision to compress the syntax?",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nIt implies to me that if there is a scale of simplicity-to-expressiveness, then humans just happen to sit at particular point on it. There's no particular \"reason\" for why these changes were right other than \"they'd gone too far that way, go back this way\". There's a local maximum somewhere in the middle.\n\nI have been thinking about this simplicity-to-expressiveness scale recently as it irrationally annoys me that on WikiData, \"instance of\" is \"just another relationship\" (it's "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.wikidata.org\/wiki\/Property:P31",
                                "text": "P31"
                            },
                            {
                                "type": "text",
                                "text": " - "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.wikidata.org\/wiki\/Property:P27",
                                "text": "\"citizen of\" is P27"
                            },
                            {
                                "type": "text",
                                "text": "!).\n\nI think that RDF is far too far towards the \"elegance\" end of the spectrum and would greatly benefit from a Clojure-style acknowledgement that some things are more different, and should be more differentiated. Yeah, it's mildly interesting that Node-Rel-Node triples is all you need to describe an ontology, but that's not actually how people think about the world..."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "fireworks",
                "users": [
                    "U02M6PM725T"
                ],
                "count": 1
            },
            {
                "name": "point_up_2",
                "users": [
                    "UJFN50C00"
                ],
                "count": 1
            },
            {
                "name": "thinking_face",
                "users": [
                    "UJFN50C00"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UEBG0NPDK",
        "type": "message",
        "ts": "1649517032.800189",
        "client_msg_id": "90353AA0-49CA-47F8-8612-5B4A8936FCBE",
        "text": "In the C++ case it's a distinction without a difference. In the lisp case it's a difference without a distinction.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "9e85c7bdd45b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-11-25\/487455880658_9e85c7bdd45b1d2d4721_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Granger",
            "display_name": "ibdknox",
            "team": "T5TCAFTA9",
            "name": "ibdknox",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M0P",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the C++ case it's a distinction without a difference. In the lisp case it's a difference without a distinction."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U016VUZGUUQ",
                    "UJBAJNFLK",
                    "U013ZLJARC7",
                    "UQ706GB9U",
                    "U0245E9RB2B"
                ],
                "count": 5
            },
            {
                "name": "point_up",
                "users": [
                    "UDQBTJ211",
                    "ULM3U6275"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UEBG0NPDK",
        "type": "message",
        "ts": "1649517079.681229",
        "client_msg_id": "7011B221-432D-44FF-BBC7-3D4C674C2C15",
        "text": "Differences and distinctions should match 1:1",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "9e85c7bdd45b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-11-25\/487455880658_9e85c7bdd45b1d2d4721_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Granger",
            "display_name": "ibdknox",
            "team": "T5TCAFTA9",
            "name": "ibdknox",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eyC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Differences and distinctions should match 1:1"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UEBG0NPDK",
        "type": "message",
        "ts": "1649517126.837289",
        "client_msg_id": "0E9344D8-94B0-465C-AA39-1BD49F3E4A05",
        "text": "Daniel Jackson's concept modeling work does a good job of giving a framework for why",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "9e85c7bdd45b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-11-25\/487455880658_9e85c7bdd45b1d2d4721_72.jpg",
            "first_name": "Chris",
            "real_name": "Chris Granger",
            "display_name": "ibdknox",
            "team": "T5TCAFTA9",
            "name": "ibdknox",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4Rg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Daniel Jackson's concept modeling work does a good job of giving a framework for why"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD",
                    "UDQBTJ211"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "UHZUS56SV"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1649518479.374759",
        "client_msg_id": "146911ef-03b5-4767-8144-d6ca51d30e1e",
        "text": "Tools, tasks, and people are a triple. If you keep two the same you can find a local maximum for the third. But what you learn doing that isn't transferrable to different tasks, tools, and people. And maximizing only one would have to be justified by expecting the other two never to change. It's never just one spectrum, like \"elegance\". With Clojure and C#, it might be that they were opposite sides of the same local maximum, because the task and people are similar. Maybe not. RDF has a completely different triple, so the lessons aren't transferable, I would expect. I would also say that if a tool doesn't reflect how people think about the world that doesn't necessarily mean there is anything wrong with the tool. It might suggest the utility of another, different tool, aimed at different (or just more) people.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BO7I",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Tools, tasks, and people are a triple. If you keep two the same you can find a local maximum for the third. But what you learn doing that isn't transferrable to different tasks, tools, and people. And maximizing only one would have to be justified by expecting the other two never to change. It's never just one spectrum, like \"elegance\". With Clojure and C#, it might be that they were opposite sides of the same local maximum, because the task and people are similar. Maybe not. RDF has a completely different triple, so the lessons aren't transferable, I would expect. I would also say that if a tool doesn't reflect how people think about the world that doesn't necessarily mean there is anything wrong with the tool. It might suggest the utility of another, different tool, aimed at different (or just more) people."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UDQBTJ211"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1649522470.505519",
        "client_msg_id": "566d63c5-2030-4513-9827-d829205c9721",
        "text": "IMO...\n\nThe beauty of assembler, lisp, lambda calculus, triples, etc. is that they have “no syntax” and *don’t restrict* what you can do.\n\nThe beauty of C++, Smalltalk, Clojure, etc. is that they “have syntax” and *restrict* what you can do.\n\n“Local maximum” is just that - local.  There are many local maxima.  Schmooing all possible notations into “one language to rule them all” results in complexity, poor UX, epicycles, watered-down unions of features, etc., etc.\n\nDisclaimer: I am a Lisper and a PEGer (Ohm-JS).  Syntax is cheap.  Deprecate programming languages.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TJ+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "IMO...\n\nThe beauty of assembler, lisp, lambda calculus, triples, etc. is that they have “no syntax” and"
                            },
                            {
                                "type": "text",
                                "text": " don’t restrict ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "what you can do.\n\nThe beauty of C++, Smalltalk, Clojure, etc. is that they “have syntax” and "
                            },
                            {
                                "type": "text",
                                "text": "restrict",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " what you can do.\n\n“Local maximum” is just that - local.  There are many local maxima.  Schmooing all possible notations into “one language to rule them all” results in complexity, poor UX, epicycles, watered-down unions of features, etc., etc.\n\nDisclaimer: I am a Lisper and a PEGer (Ohm-JS).  Syntax is cheap.  Deprecate programming languages."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U016VUZGUUQ",
        "type": "message",
        "ts": "1649523349.579689",
        "client_msg_id": "116233d1-0403-4d3c-91b9-30d0b9ef8f2d",
        "text": "Expanding on <@UEBG0NPDK>'s point a bit, C++'s various member\/scope operators all have basically the same signature of `(group, selector) -&gt; thing`. So it doesn't hide or obscure any semantics to use the same syntax. Lists and hash maps do not have the same signature; a list is flat, but there are internal relationships in the arguments to a hashmap. So it helps to have different syntax to remind you of that.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gaee3c99144d",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/aee3c99144dfc6644c6c1f1303683140.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "Andrew F",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "andrewflnr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rDg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Expanding on "
                            },
                            {
                                "type": "user",
                                "user_id": "UEBG0NPDK"
                            },
                            {
                                "type": "text",
                                "text": "'s point a bit, C++'s various member\/scope operators all have basically the same signature of "
                            },
                            {
                                "type": "text",
                                "text": "(group, selector) -> thing",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". So it doesn't hide or obscure any semantics to use the same syntax. Lists and hash maps do not have the same signature; a list is flat, but there are internal relationships in the arguments to a hashmap. So it helps to have different syntax to remind you of that."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "It's important to ask whether the geometric representations you use actually contribute to understanding.\n\nTake your Fibonacci example. I don't think representing addition as the half-perimeter of a rectangle provides me with any intuition or insight here. To me, this particular diagram would be better off if you just stacked the input segments to form the output segment.\n\nBetter still might be a Fibonacci spiral construction, as shown below. No clue (offhand) how to represent this construction in a programming system, but it says a lot more, geometrically, than half-perimeters of rectangles \/or\/ stacked segments.",
        "files": [
            {
                "id": "F03AF4MU1JB",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "UBKNXPBAB",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ntW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's important to ask whether the geometric representations you use actually contribute to understanding.\n\nTake your Fibonacci example. I don't think representing addition as the half-perimeter of a rectangle provides me with any intuition or insight here. To me, this particular diagram would be better off if you just stacked the input segments to form the output segment.\n\nBetter still might be a Fibonacci spiral construction, as shown below. No clue (offhand) how to represent this construction in a programming system, but it says a lot more, geometrically, than half-perimeters of rectangles \/or\/ stacked segments."
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1649561633.377979",
        "client_msg_id": "37f7cb1a-44b6-4489-a024-643ac368ee26",
        "thread_ts": "1649362262.813219",
        "parent_user_id": "U035QJ14NN9",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U035QJ14NN9",
                    "UC2A2ARPT"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UBKNXPBAB",
        "type": "message",
        "ts": "1649562377.640379",
        "client_msg_id": "30159ddb-e49f-4702-a856-4cb53e186849",
        "text": "<@UEBG0NPDK>’s take, absolutely. C++ adds complexity that doesn't provide any (useful) expressiveness. So it isn't even on the Pareto frontier of the simplicity\/expressiveness tradeoff space.\n\nI personally take Lisp vs Clojure as a better example of a legitimate tradeoff close to the frontier.\n\nI also think it's bonkers that the smallest Wikidata property, P6, is \"head of government\". Shows you what Wikidata thinks is most important. :stuck_out_tongue:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7b3bc9e878d6",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-03-28\/6866700980471_7b3bc9e878d663396caf_72.jpg",
            "first_name": "",
            "real_name": "Joshua Horowitz",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "joshuah",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ps1N2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEBG0NPDK"
                            },
                            {
                                "type": "text",
                                "text": "’s take, absolutely. C++ adds complexity that doesn't provide any (useful) expressiveness. So it isn't even on the Pareto frontier of the simplicity\/expressiveness tradeoff space.\n\nI personally take Lisp vs Clojure as a better example of a legitimate tradeoff close to the frontier.\n\nI also think it's bonkers that the smallest Wikidata property, P6, is \"head of government\". Shows you what Wikidata thinks is most important. "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue",
                                "unicode": "1f61b"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]