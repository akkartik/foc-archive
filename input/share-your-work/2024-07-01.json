[
    {
        "user": "UBN9AFS0N",
        "type": "message",
        "ts": "1719827238.988589",
        "edited": {
            "user": "UBN9AFS0N",
            "ts": "1719827274.000000"
        },
        "client_msg_id": "1e32acaa-7de0-48b7-abb8-7ecd82c847d1",
        "text": ":writing_hand::skin-tone-4: <https:\/\/marianoguerra.org\/posts\/the-proof-is-in-the-meta-tracing-jit-interpreter\/|The proof is in the meta-tracing JIT interpreter>\n\nThe one where I implement a native JIT interpreter for my minimal oop language using pypy's meta-tracing compiler toolchain",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7f0f1c0238ec",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-09\/395086754178_7f0f1c0238ec02befdab_72.jpg",
            "first_name": "Mariano",
            "real_name": "Mariano Guerra",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "mariano",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/marianoguerra.org\/posts\/the-proof-is-in-the-meta-tracing-jit-interpreter\/",
                "ts": 1719765099,
                "id": 1,
                "original_url": "https:\/\/marianoguerra.org\/posts\/the-proof-is-in-the-meta-tracing-jit-interpreter\/",
                "fallback": "Mariano Guerra's Log: The proof is in the meta-tracing JIT interpreter",
                "text": "In the previous posts: Make Your Self and Macros and optimizations: it's just a phase I described the design and implementation of a minimal object oriented language with the implementation done in Ja",
                "title": "The proof is in the meta-tracing JIT interpreter",
                "title_link": "https:\/\/marianoguerra.org\/posts\/the-proof-is-in-the-meta-tracing-jit-interpreter\/",
                "service_name": "Mariano Guerra's Log"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hauXG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "emoji",
                                "name": "writing_hand",
                                "unicode": "270d-1f3fd",
                                "skin_tone": 4
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/marianoguerra.org\/posts\/the-proof-is-in-the-meta-tracing-jit-interpreter\/",
                                "text": "The proof is in the meta-tracing JIT interpreter"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThe one where I implement a native JIT interpreter for my minimal oop language using pypy's meta-tracing compiler toolchain"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719827402.834429",
        "client_msg_id": "e59f8cd0-b980-4547-8148-52580bbd9a1d",
        "text": "<@UJBAJNFLK> Interesting arguments. Still mulling… Observation: I’m not sure that electronic hardware followed a more mature growth than software.  Electronics took off somewhere roughly around 1900 with Tesla, Steinmetz, Heaviside, et al. Electronics “culminated” around 1950\/1960 with the invention of chips and CPUs (hardware progress continues). By this reckoning, electronics was about 1 century old when it created a spin-off. At the moment, software is about the same age. Maybe the difference is something to do with grounding in reality? Electronics is constrained by physical principles (electrons obey the speed of light, the “9 inches in one nanosecond” thing), whereas software is based on written math which is basically FTL (faster than light) - you can perform a referential transparency replacement operation on paper instantaneously. In fact, I wonder if FTL-think isn’t the cause of a great many workarounds\/epicycles in software. On paper, operations are instantaneous, whereas in a physical CPU, operations take a finite amount of realtime - it’s not a 1:1 mapping. Hmmm.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fwSry",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " Interesting arguments. Still mulling… Observation: I’m not sure that electronic hardware followed a more mature growth than software.  Electronics took off somewhere roughly around 1900 with Tesla, Steinmetz, Heaviside, et al. Electronics “culminated” around 1950\/1960 with the invention of chips and CPUs (hardware progress continues). By this reckoning, electronics was about 1 century old when it created a spin-off. At the moment, software is about the same age. Maybe the difference is something to do with grounding in reality? Electronics is constrained by physical principles (electrons obey the speed of light, the “9 inches in one nanosecond” thing), whereas software is based on written math which is basically FTL (faster than light) - you can perform a referential transparency replacement operation on paper instantaneously. In fact, I wonder if FTL-think isn’t the cause of a great many workarounds\/epicycles in software. On paper, operations are instantaneous, whereas in a physical CPU, operations take a finite amount of realtime - it’s not a 1:1 mapping. Hmmm."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1719829778.158839",
        "client_msg_id": "5ff2431a-90f6-43ca-b89f-316fc83f26df",
        "text": "<@UJBAJNFLK> another data-point: I do not believe that Functional Programming IS programming. It’s only a KIND of programming. Programming is something larger than FP. Programming is about making electronic reprogrammable machines DO something. If all you want to DO is to use the hardware as a calculator, where only the results of the computation matter, then FP is appropriate. If you want to use the machine as a sequencer or to network machines together or to run robots (ie. to make physical actions?), then FP is not as appropriate and some other notation(s) should be used to program machines for those kinds of actions. [Unfortunately, for me, FP is currently considered to be the *only* way to program machines, and, I continue to flail at trying to express what I think the differences are].",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2vD+c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " another data-point: I do not believe that Functional Programming IS programming. It’s only a KIND of programming. Programming is something larger than FP. Programming is about making electronic reprogrammable machines DO something. If all you want to DO is to use the hardware as a calculator, where only the results of the computation matter, then FP is appropriate. If you want to use the machine as a sequencer or to network machines together or to run robots (ie. to make physical actions?), then FP is not as appropriate and some other notation(s) should be used to program machines for those kinds of actions. [Unfortunately, for me, FP is currently considered to be the "
                            },
                            {
                                "type": "text",
                                "text": "only",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " way to program machines, and, I continue to flail at trying to express what I think the differences are]."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1719843583.211389",
        "client_msg_id": "415f5253-b0e6-448d-9874-d344959ea145",
        "text": "Hi <@U0112C10V4Y> I understand you've been collaborating with Folk Computer? And a quick search reveals that you may not have told us all about it here! If both are true - over to you! (Else I'll delete this post before I get embarrassed :flushed: )",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qB4k8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi "
                            },
                            {
                                "type": "user",
                                "user_id": "U0112C10V4Y"
                            },
                            {
                                "type": "text",
                                "text": " I understand you've been collaborating with Folk Computer? And a quick search reveals that you may not have told us all about it here! If both are true - over to you! (Else I'll delete this post before I get embarrassed "
                            },
                            {
                                "type": "emoji",
                                "name": "flushed",
                                "unicode": "1f633"
                            },
                            {
                                "type": "text",
                                "text": " )"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02QC0PPER3",
        "type": "message",
        "ts": "1719856171.606639",
        "edited": {
            "user": "U02QC0PPER3",
            "ts": "1719861022.000000"
        },
        "client_msg_id": "78c109c3-3bad-4ee3-84bb-04daa69be693",
        "text": "Been a while since I touched it but I've been <https:\/\/github.com\/cben\/animation-stack-language|building> a toy postfix stack-based language to inflict upon my kids.  My theory is:\n• postfix may have benefits for early teaching (linear evaluation order, lack of \"syntax\", trivial notional machine)\n• the obvious drawbacks can be somewhat mitigated if instead of destructively changing the stack, you can navigate all previous stack states.  (I'm not the first to try the latter; in particular Kartik did it in Mu, including descending into function calls. I don't even have user-defined functions yet.)\n• I wanted to explore \"replacing\" some uses of control structures with composition of a bigger data type, like a whole picture or animation.  \nI'm resigned to the thing not being turing-complete.\n\nInitial implementation's data type was 1D \"animation\" of color change (I wanted them to program an RGB lamp): <https:\/\/asciinema.org\/a\/zObMq9ZLJQNA99X3EhdEDllhA>\n=> My kids liked typing and mixing colors, but the idea of a single value representing change over time went entirely over their heads :disappointed:\nAnyway terminal REPL was a dead end, because you can't go back and edit past code.  => I got a prototype web editor — you can move cursor, edit freely, and see stack state before each word: <https:\/\/animation-stack-language.netlify.app\/>\nTODO: rendering still uses styled block characters :technologist:, I need to learn canvas...\n\nTODO: Next big step will be to replace the data type from 1D \"time\" to 2D \"picture\", taking inspiration from <http:\/\/forthsalon.appspot.com|forthsalon.appspot.com> and <https:\/\/code.world\/|code.world >.\nI'm thinking to make do with some 2D rather than RGB colorspace, so that every pixel can also be interpreted as a vector.  That way any picture doubles as a limited representation of function-as-data (not turing-complete! but very visual :thinking_face:).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "90c9108c61f5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-12-12\/2854686602576_90c9108c61f5d809eb8a_72.jpg",
            "first_name": "Beni",
            "real_name": "Beni Cherniavsky-Paskin",
            "display_name": "Beni Cherniavsky-Paskin",
            "team": "T5TCAFTA9",
            "name": "beni.cherniavsky",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mIGfk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Been a while since I touched it but I've been "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/cben\/animation-stack-language",
                                "text": "building"
                            },
                            {
                                "type": "text",
                                "text": " a toy postfix stack-based language to inflict upon my kids.  My theory is:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "postfix may have benefits for early teaching (linear evaluation order, lack of \"syntax\", trivial notional machine)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "the obvious drawbacks can be somewhat mitigated if instead of destructively changing the stack, you can navigate all previous stack states.  (I'm not the first to try the latter; in particular Kartik did it in Mu, including descending into function calls. I don't even have user-defined functions yet.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I wanted to explore \"replacing\" some uses of control structures with composition of a bigger data type, like a whole picture or animation.  "
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI'm resigned to the thing not being turing-complete.\n\nInitial implementation's data type was 1D \"animation\" of color change (I wanted them to program an RGB lamp): "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/asciinema.org\/a\/zObMq9ZLJQNA99X3EhdEDllhA"
                            },
                            {
                                "type": "text",
                                "text": "\n=> My kids liked typing and mixing colors, but the idea of a single value representing change over time went entirely over their heads "
                            },
                            {
                                "type": "emoji",
                                "name": "disappointed",
                                "unicode": "1f61e"
                            },
                            {
                                "type": "text",
                                "text": "\nAnyway terminal REPL was a dead end, because you can't go back and edit past code.  => I got a prototype web editor — you can move cursor, edit freely, and see stack state before each word: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/animation-stack-language.netlify.app\/"
                            },
                            {
                                "type": "text",
                                "text": "\nTODO: rendering still uses styled block characters "
                            },
                            {
                                "type": "emoji",
                                "name": "technologist",
                                "unicode": "1f9d1-200d-1f4bb"
                            },
                            {
                                "type": "text",
                                "text": ", I need to learn canvas...\n\nTODO: Next big step will be to replace the data type from 1D \"time\" to 2D \"picture\", taking inspiration from "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/forthsalon.appspot.com",
                                "text": "forthsalon.appspot.com"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/code.world\/",
                                "text": "code.world "
                            },
                            {
                                "type": "text",
                                "text": ".\nI'm thinking to make do with some 2D rather than RGB colorspace, so that every pixel can also be interpreted as a vector.  That way any picture doubles as a limited representation of function-as-data (not turing-complete! but very visual "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            },
                            {
                                "type": "text",
                                "text": ")."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UFEQUBNNT",
                    "U06SAHYT80L",
                    "UA14TGLTC"
                ],
                "count": 4
            }
        ]
    },
    {
        "user": "U03LMRE6MQE",
        "type": "message",
        "ts": "1719860900.286079",
        "client_msg_id": "2b6b9ab3-4b1b-4f10-a231-0ee7d5a22af7",
        "text": "Hash reference to every function and limiting effects at the top level to allow code to execute even after a failure. This is a bit longer as I try to explain in more detail what these features are in EYG <https:\/\/vimeo.com\/973314611?share=copy>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ea29e26e919b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-06-23\/3708469439522_ea29e26e919bc202feb6_72.png",
            "first_name": "Peter",
            "real_name": "Peter Saxton",
            "display_name": "Peter Saxton",
            "team": "T5TCAFTA9",
            "name": "peterhsaxton",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "from_url": "https:\/\/vimeo.com\/973314611?share=copy",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/vimeo.png",
                "thumb_url": "https:\/\/i.vimeocdn.com\/video\/1887438430-1ad5b565b17f24df0112fa86e8d2590d6dd98c2a109df670fcf8d6bc2c9bceb4-d_295x166",
                "thumb_width": 295,
                "thumb_height": 166,
                "video_html": "<iframe src=\"https:\/\/player.vimeo.com\/video\/973314611?autoplay=1&amp;app_id=122963\" width=\"400\" height=\"225\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture; clipboard-write\" title=\"7\/1\/2024, hash references to functions, effects and transpilation in EYG\"><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "id": 1,
                "original_url": "https:\/\/vimeo.com\/973314611?share=copy",
                "fallback": "Vimeo Video: 7\/1\/2024, hash references to functions, effects and transpilation in EYG",
                "title": "7\/1\/2024, hash references to functions, effects and transpilation in EYG",
                "title_link": "https:\/\/vimeo.com\/973314611?share=copy",
                "author_name": "crowdhailer",
                "author_link": "https:\/\/vimeo.com\/crowdhailer",
                "service_name": "Vimeo",
                "service_url": "https:\/\/vimeo.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PmXN8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hash reference to every function and limiting effects at the top level to allow code to execute even after a failure. This is a bit longer as I try to explain in more detail what these features are in EYG "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/vimeo.com\/973314611?share=copy"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U06MCTWJKSR",
        "type": "message",
        "ts": "1719868360.256359",
        "edited": {
            "user": "U06MCTWJKSR",
            "ts": "1719869342.000000"
        },
        "client_msg_id": "85f893d8-d239-4f0f-b183-e27eb223db22",
        "text": "I made a blog post about visualizing risk. <https:\/\/calcwithdec.dev\/posts\/viz-risk\/>\nIt's a scrollable explanation that develops up a visualization - a bit going on in it, a problem I have with a lot of things, so was really glad to spend time learning a few things about making this kind of scrollable interaction to more carefully introduce things.\n\nBehind the scenes, the numbers are from a calculang model doing monte carlo simulations on a pension calculator calculang model. This composability (or what I call flexibility) is something I decided not to make _this_ post about, but it's an important part of why calculang exists.\nI plan to do a few similar separate exercises, and then spin back to this on it's own. (e.g. next: benchmarking actual results to their older estimates)\n\nSo, this blog post isn't really technical, but I hope it's interesting or at least easy to follow, and it fits into a longer piece about calculang. Happy if you have any feedback about the post or questions about this longer piece!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "5b4c95c70d98",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-04-10\/6931478324918_5b4c95c70d98784a05cc_72.jpg",
            "first_name": "Declan",
            "real_name": "Declan",
            "display_name": "Declan Naughton",
            "team": "T5TCAFTA9",
            "name": "declann1990",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "image_url": "https:\/\/calcwithdec.dev\/posts\/viz-risk\/viz-risk.png",
                "image_width": 1044,
                "image_height": 676,
                "image_bytes": 118885,
                "from_url": "https:\/\/calcwithdec.dev\/posts\/viz-risk\/",
                "id": 1,
                "original_url": "https:\/\/calcwithdec.dev\/posts\/viz-risk\/",
                "fallback": "Visualizing Risk – Calc with Dec :abacus: :nerd_face:",
                "text": "Visualizing Risk: feat. a pension savings calculation, Monte Carlo simulation, and ‘scrollytelling’",
                "title": "Visualizing Risk – Calc with Dec :abacus: :nerd_face:",
                "title_link": "https:\/\/calcwithdec.dev\/posts\/viz-risk\/",
                "service_name": "calcwithdec.dev"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wL7PW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I made a blog post about visualizing risk. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/calcwithdec.dev\/posts\/viz-risk\/"
                            },
                            {
                                "type": "text",
                                "text": "\nIt's a scrollable explanation that develops up a visualization - a bit going on in it, a problem I have with a lot of things, so was really glad to spend time learning a few things about making this kind of scrollable interaction to more carefully introduce things.\n\nBehind the scenes, the numbers are from a calculang model doing monte carlo simulations on a pension calculator calculang model. This composability (or what I call flexibility) is something I decided not to make "
                            },
                            {
                                "type": "text",
                                "text": "this",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " post about, but it's an important part of why calculang exists.\nI plan to do a few similar separate exercises, and then spin back to this on it's own. (e.g. next: benchmarking actual results to their older estimates)\n\nSo, this blog post isn't really technical, but I hope it's interesting or at least easy to follow, and it fits into a longer piece about calculang. Happy if you have any feedback about the post or questions about this longer piece!"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U02QC0PPER3",
                    "U0123H7JRDM",
                    "UA14TGLTC"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "UJBAJNFLK",
        "type": "message",
        "ts": "1719900930.713749",
        "client_msg_id": "49cd2d04-fcca-450b-800d-9d882e163489",
        "text": "<@UGWUJUZHT> There are indeed arguments to add to my list. Physical constraints is a good one! And it makes me think of Chuck Moore, who made a career out of staying close to the metal with Forth, and occasionally crossing over into the hardware domain. Is his software more robust? I can't say. His software is also small, in terms of functionality, which may be the more important factor in robustness.\nFTL-think is a nice term. Definitely a problem in the branch of computer science that leans towards mathematics. There's also the issue of losing sight of the physical devices, as in data centers and cloud computing.\nI certainly agree that the distinction between abstract data transformation and actions in the physical world matters, but I doubt there's a consensus on \"programming\" referring only to the latter. Even FP people know about the distinction, which is why they invented monads and effects as FP concepts. Historical data point: Ken Iverson's 1962 book \"A Programming Language\" uses \"programming\" for describing the development of algorithms with pencil and paper.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e169f54bbaf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-03-12\/1859691333940_e169f54bbaf8b9b36b12_72.png",
            "first_name": "Konrad",
            "real_name": "Konrad Hinsen",
            "display_name": "Konrad Hinsen",
            "team": "T5TCAFTA9",
            "name": "konrad.hinsen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1719438405.632489",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+BQje",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " There are indeed arguments to add to my list. Physical constraints is a good one! And it makes me think of Chuck Moore, who made a career out of staying close to the metal with Forth, and occasionally crossing over into the hardware domain. Is his software more robust? I can't say. His software is also small, in terms of functionality, which may be the more important factor in robustness.\nFTL-think is a nice term. Definitely a problem in the branch of computer science that leans towards mathematics. There's also the issue of losing sight of the physical devices, as in data centers and cloud computing.\nI certainly agree that the distinction between abstract data transformation and actions in the physical world matters, but I doubt there's a consensus on \"programming\" referring only to the latter. Even FP people know about the distinction, which is why they invented monads and effects as FP concepts. Historical data point: Ken Iverson's 1962 book \"A Programming Language\" uses \"programming\" for describing the development of algorithms with pencil and paper."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]