[
    {
        "user": "UEQ7QL15F",
        "type": "message",
        "ts": "1553243935.113900",
        "edited": {
            "user": "UEQ7QL15F",
            "ts": "1553243960.000000"
        },
        "client_msg_id": "be58f9b0-fb3a-4d36-bdd6-d68bbb24ba19",
        "text": "One thing to note is that on a Finnish keyboard, both “\/” and “#” are equally difficult to type. Probably true for other non-English keyboards as well.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g52d221ae708",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/a52d221ae708f36674644a348005633a.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-72.png",
            "first_name": "Janne",
            "real_name": "Janne Aukia",
            "display_name": "jaukia",
            "team": "T5TCAFTA9",
            "name": "janne.aukia",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EdfK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One thing to note is that on a Finnish keyboard, both “\/” and “#” are equally difficult to type. Probably true for other non-English keyboards as well."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UF5PAGQQ4",
        "type": "message",
        "ts": "1553244149.114200",
        "client_msg_id": "834ccd14-f91b-4c65-b091-53ece001c809",
        "text": "`;` :smile:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g99a3fab7a1a",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/299a3fab7a1a2d6644455dedae9fce0a.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png",
            "first_name": "",
            "real_name": "Stathis Sideris",
            "display_name": "Stathis",
            "team": "T5TCAFTA9",
            "name": "sideris",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lXKg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": ";",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UAL7940NM",
        "type": "message",
        "ts": "1553244303.114400",
        "client_msg_id": "c54cb2ff-0033-4fa7-a556-42a5289b373a",
        "text": "On the german keyboard, `#` is actually easier to type than `\/` IMO. Apart from that, I find multi-line comments `\/*` and `*\/` convenient. I don't know a lot of languages that use `#`, but how do they handle multi-line comments? Python's approach of using multi-line strings `'''` doesn't seem right...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43873346f949",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-13\/399377633206_43873346f949174e340e_72.jpg",
            "first_name": "Felix",
            "real_name": "Felix Kohlgrüber",
            "display_name": "Felix Kohlgrüber",
            "team": "T5TCAFTA9",
            "name": "felix.kohlgrueber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "923B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On the german keyboard, "
                            },
                            {
                                "type": "text",
                                "text": "#",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is actually easier to type than "
                            },
                            {
                                "type": "text",
                                "text": "\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " IMO. Apart from that, I find multi-line comments "
                            },
                            {
                                "type": "text",
                                "text": "\/*",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "*\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " convenient. I don't know a lot of languages that use "
                            },
                            {
                                "type": "text",
                                "text": "#",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but how do they handle multi-line comments? Python's approach of using multi-line strings "
                            },
                            {
                                "type": "text",
                                "text": "'''",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " doesn't seem right..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAL7940NM",
        "type": "message",
        "ts": "1553245396.114600",
        "client_msg_id": "6e08f110-2179-4088-8a5b-4c7e901498db",
        "text": "I agree with <@UCUSW7WVD> that consistency is probably the most important aspect. When using a keyboard shortcut for toggling comments, entering comments becomes consistent among many languages (just tried it with Rust, Python and TS in vscode, works out of the box). Additionally, syntax highlighting makes it easy to recognize comments and differentiate them from other code. I'd argue that when using an editor that provides both, the actual PL's choice of comment syntax doesn't matter. You could probably show Python code using C-style comments to me and as long as the comment would still be highlighted as comments, I wouldn't even recognize the difference.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43873346f949",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-13\/399377633206_43873346f949174e340e_72.jpg",
            "first_name": "Felix",
            "real_name": "Felix Kohlgrüber",
            "display_name": "Felix Kohlgrüber",
            "team": "T5TCAFTA9",
            "name": "felix.kohlgrueber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XwnC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree with "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " that consistency is probably the most important aspect. When using a keyboard shortcut for toggling comments, entering comments becomes consistent among many languages (just tried it with Rust, Python and TS in vscode, works out of the box). Additionally, syntax highlighting makes it easy to recognize comments and differentiate them from other code. I'd argue that when using an editor that provides both, the actual PL's choice of comment syntax doesn't matter. You could probably show Python code using C-style comments to me and as long as the comment would still be highlighted as comments, I wouldn't even recognize the difference."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGJ9KAZM3",
        "type": "message",
        "ts": "1553255844.114800",
        "edited": {
            "user": "UGJ9KAZM3",
            "ts": "1553255889.000000"
        },
        "client_msg_id": "5ec6d221-b11c-4342-986a-559b41223a2b",
        "text": "Minor preference for `\/\/` + `\/*` + `*\/`.  If the choice is strictly between `\/\/` and `#`, then minor preference for `#`.\n\nIf you gotta block-comment larger sections using random\/sucky\/unfamiliar editor then `\/\/` is annoying: repeat sequence `shift-7-7 down left left` means non-trivial number of keystrokes per finger. The repeat sequence for `#` is 'qualitatively' different as `shift-3 down left` is exactly one press per finger and thus more hammerable. :stuck_out_tongue:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a9ca5b79893e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-05\/567982344725_a9ca5b79893ede5381e5_72.jpg",
            "first_name": "Iridian",
            "real_name": "Iridian Kiiskinen",
            "display_name": "Iridian",
            "team": "T5TCAFTA9",
            "name": "iridian",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NmON",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Minor preference for "
                            },
                            {
                                "type": "text",
                                "text": "\/\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " + "
                            },
                            {
                                "type": "text",
                                "text": "\/*",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " + "
                            },
                            {
                                "type": "text",
                                "text": "*\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  If the choice is strictly between "
                            },
                            {
                                "type": "text",
                                "text": "\/\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "#",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", then minor preference for "
                            },
                            {
                                "type": "text",
                                "text": "#",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nIf you gotta block-comment larger sections using random\/sucky\/unfamiliar editor then "
                            },
                            {
                                "type": "text",
                                "text": "\/\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is annoying: repeat sequence "
                            },
                            {
                                "type": "text",
                                "text": "shift-7-7 down left left",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " means non-trivial number of keystrokes per finger. The repeat sequence for "
                            },
                            {
                                "type": "text",
                                "text": "#",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is 'qualitatively' different as "
                            },
                            {
                                "type": "text",
                                "text": "shift-3 down left",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is exactly one press per finger and thus more hammerable. "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue",
                                "unicode": "1f61b"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UC2A2ARPT",
        "type": "message",
        "ts": "1553266379.115400",
        "client_msg_id": "fccd7270-70ef-4585-85e0-685727085dcf",
        "text": "1 char is nicer than 2, but which char you pick should be decided by the other syntax in your language and which other languages you want to align yourself with. So I also vote `;`",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gf94d2ed5e18",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/6f94d2ed5e188be9865a531021b0afcd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-72.png",
            "first_name": "Ivan",
            "real_name": "Ivan Reese",
            "display_name": "Ivan Reese",
            "team": "T5TCAFTA9",
            "name": "ivanreese",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oPAj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "1 char is nicer than 2, but which char you pick should be decided by the other syntax in your language and which other languages you want to align yourself with. So I also vote "
                            },
                            {
                                "type": "text",
                                "text": ";",
                                "style": {
                                    "code": true
                                }
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553269129.115600",
        "client_msg_id": "7f530b7a-e60e-40f5-812f-9520d98ed695",
        "text": "Oh, another thing is, if you have a bunch of parsers and printers for Loyc trees for different languages, you can run language-agnostic algorithms on the syntax trees. Here are three examples:\n\n1. LeMP: the lexical macro processor is language-agnostic and since it works at the level of syntax, not semantics, it can be used to transform code of any language.\n2. Tree-structured find \/ find and replace: I wrote basic pattern-matching and find-and-replace algorithms for Loyc trees, so again, given the necessary parsers, the same algorithms can be used with any language.\n3. Gathering comments. Typical lexers throw comments away since the parser can't easily handle comments in arbitrary locations. But if you gather the comments and newlines into a list, I've written a language-independent algorithm to recombine the comments with the Loyc tree produced by the parser. (It requires a small amount of custom code per-language, and in order for the algorithm to work reliably, there are some reasonable constraints on the relationship between the Loyc tree and the original text. But it's a lot less hassle than reimplementing the algorithm from scratch for every language.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "y3Pq\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh, another thing is, if you have a bunch of parsers and printers for Loyc trees for different languages, you can run language-agnostic algorithms on the syntax trees. Here are three examples:\n\n1. LeMP: the lexical macro processor is language-agnostic and since it works at the level of syntax, not semantics, it can be used to transform code of any language.\n2. Tree-structured find \/ find and replace: I wrote basic pattern-matching and find-and-replace algorithms for Loyc trees, so again, given the necessary parsers, the same algorithms can be used with any language.\n3. Gathering comments. Typical lexers throw comments away since the parser can't easily handle comments in arbitrary locations. But if you gather the comments and newlines into a list, I've written a language-independent algorithm to recombine the comments with the Loyc tree produced by the parser. (It requires a small amount of custom code per-language, and in order for the algorithm to work reliably, there are some reasonable constraints on the relationship between the Loyc tree and the original text. But it's a lot less hassle than reimplementing the algorithm from scratch for every language.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553269624.115800",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1553269702.000000"
        },
        "client_msg_id": "8a08a66a-f6bb-4c6a-b194-046e9c2cd1a3",
        "text": "There's no obvious winner as both comment types are very popular. +1 Ivan, it depends on other factors - for instance in my LES language I used `\/\/` because (1) it's styled after the C family of languages and (2) for unusual reasons specific to LES, it was useful to treat `#` as an identifier character (similar to underscore).",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1nIdR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's no obvious winner as both comment types are very popular. +1 Ivan, it depends on other factors - for instance in my LES language I used "
                            },
                            {
                                "type": "text",
                                "text": "\/\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " because (1) it's styled after the C family of languages and (2) for unusual reasons specific to LES, it was useful to treat "
                            },
                            {
                                "type": "text",
                                "text": "#",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as an identifier character (similar to underscore)."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553270092.116200",
        "client_msg_id": "f219ae6e-fc4f-4d57-bf34-857ba35b040d",
        "text": "<@UGJ9KAZM3> should experience in a random\/sucky\/unfamiliar editor really be a consideration in designing a programming language?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0b6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGJ9KAZM3"
                            },
                            {
                                "type": "text",
                                "text": " should experience in a random\/sucky\/unfamiliar editor really be a consideration in designing a programming language?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGK6P07UP",
        "type": "message",
        "ts": "1553270659.116400",
        "client_msg_id": "932d66dd-25dc-4632-a785-153c1c8edd60",
        "text": "Hmm, at least I do think it's a bad idea to rely on assumptions about the editing environment. I think that's a significant part of language design, actually - otherwise it's about designing the editor, not the language. Of course, the issue is not black&amp;white. But I mean, if I could make assumptions about the editor, I could do things like define something horrid like `{type: def: Contsruction{\/- -\/}}` (or god forbid, xml :stuck_out_tongue: ) as the enclosure for some thing, and just leave it for the editor to display it with nice iconography and whatnot.\n\nThat said, I'm not a language designer, and will readily admit others are likely to be more informed about this than me.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "87bd62a4d028",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-27\/562509014037_87bd62a4d028d26ec0d4_72.jpg",
            "first_name": "Ilari",
            "real_name": "Ilari Kajaste",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ilari",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zm5w8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hmm, at least I do think it's a bad idea to rely on assumptions about the editing environment. I think that's a significant part of language design, actually - otherwise it's about designing the editor, not the language. Of course, the issue is not black&white. But I mean, if I could make assumptions about the editor, I could do things like define something horrid like "
                            },
                            {
                                "type": "text",
                                "text": "{type: def: Contsruction{\/- -\/}}",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (or god forbid, xml "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue",
                                "unicode": "1f61b"
                            },
                            {
                                "type": "text",
                                "text": " ) as the enclosure for some thing, and just leave it for the editor to display it with nice iconography and whatnot.\n\nThat said, I'm not a language designer, and will readily admit others are likely to be more informed about this than me."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553271649.116600",
        "client_msg_id": "37280f1f-1566-456d-9e8d-c28308d13da9",
        "text": "Responding a couple of comments back, <@UCGAK10LS> I don't think a closed decision-making process can _ever_ yield a hackable result. And if ever there was a project that needs the result to be hackable, it's WebAssembly. \"Good people\" is irrelevant.\n\nAlternative phrasing: if you don't have a (potential) say in how it's implemented you aren't who it's designed for. Not really. Programming is fundamentally a political act. So yes, WebAssembly may well have a bright future. But it's a bright future for Mozilla and Google, not for the rest of us.\n\nI've been citing Conway's Law a lot lately (<https:\/\/en.wikipedia.org\/wiki\/Conway's_law>). If your process for creating it is closed, the result will be closed also.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "attachments": [
            {
                "title": "Conway's law",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/Conway's_law",
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/Conway's_law",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/",
                "text": "Conway's law is an adage named after computer programmer Melvin Conway, who introduced the idea in 1967. It states that\n\norganizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations.\n\nThe law is based on the reasoning that in order for a software module to function, multiple authors must communicate frequently with each other. Therefore, the software interface structure of a system will reflect the social boundaries of the organization(s) that produced it, across which communication is more difficult. Conway's law was intended as a valid sociological observation, although sometimes it's used in a humorous context. It was dubbed Conway's law by participants at the 1968 National Symposium on Modular Programming.",
                "fallback": "wikipedia: Conway's law",
                "service_icon": "https:\/\/a.slack-edge.com\/bfaba\/img\/unfurl_icons\/wikipedia.png",
                "id": 1,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/Conway's_law"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QF4HA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Responding a couple of comments back, "
                            },
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " I don't think a closed decision-making process can "
                            },
                            {
                                "type": "text",
                                "text": "ever",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " yield a hackable result. And if ever there was a project that needs the result to be hackable, it's WebAssembly. \"Good people\" is irrelevant.\n\nAlternative phrasing: if you don't have a (potential) say in how it's implemented you aren't who it's designed for. Not really. Programming is fundamentally a political act. So yes, WebAssembly may well have a bright future. But it's a bright future for Mozilla and Google, not for the rest of us.\n\nI've been citing Conway's Law a lot lately ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Conway's_law"
                            },
                            {
                                "type": "text",
                                "text": "). If your process for creating it is closed, the result will be closed also."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553271805.117000",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1553272265.000000"
        },
        "client_msg_id": "cc074b00-4358-41cd-9464-845955cd34a3",
        "text": "<@UD6EXQVM0> Does supporting Loyc trees require parsing comments? Most (all?) languages filter out comments during lexing. Actually including comments in the parse tree massively complicates the grammar, because every non-terminal may turn into 2, or 3.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nz5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UD6EXQVM0"
                            },
                            {
                                "type": "text",
                                "text": " Does supporting Loyc trees require parsing comments? Most (all?) languages filter out comments during lexing. Actually including comments in the parse tree massively complicates the grammar, because every non-terminal may turn into 2, or 3."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UE6EFEPTQ",
        "type": "message",
        "ts": "1553272320.117300",
        "client_msg_id": "8b2119fb-f4a7-4e4b-be15-aeb5d8f8bdf1",
        "text": "`--` every time :smile:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "8073c43d5d8d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-12-18\/508431502471_8073c43d5d8dd3d3b4b2_72.jpg",
            "first_name": "Duncan",
            "real_name": "Duncan Cragg",
            "display_name": "Duncan Cragg",
            "team": "T5TCAFTA9",
            "name": "fp",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dnJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "--",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " every time "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "smile",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGJ9KAZM3",
        "type": "message",
        "ts": "1553272653.117600",
        "edited": {
            "user": "UGJ9KAZM3",
            "ts": "1553272759.000000"
        },
        "client_msg_id": "b34b6437-b4fc-4ce8-877d-55ec33d9b4c5",
        "text": "<@UCUSW7WVD> depends on the numbers, of course. Lemme define:\n`random` = user is using an editor in random context (like a web editor)\n`unfamiliar` = user has chosen an editor but has not become an expert and is unaware of functionality\n`sucky` = user has chosen editor which outright doesn't implement the functionality\n\nLet's look at mass-indent-macro which has a de facto implementation of (&lt;shift&gt;-)&lt;tab&gt; and the feature penetration is high.\nHere there are very few sucky editors, users become familiar with the editors quickly, and as a result, expect even random editors to support the functionality. So a language designer in this case could very well rely on such a macro.\n\nBut auto-block-comment-macro (which I was somewhat obscurely referring to here) does not have a de-facto implementation (or at least I don't know of one. Maybe I learn more today? :D)\nSo for this situation all three groups are considerably larger and language designers... 'can' be justified in taking even such minor details into account.\n\nI'm not proposing this as even the most important of the minor details of course, just brought it up as something that came to mind...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a9ca5b79893e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-05\/567982344725_a9ca5b79893ede5381e5_72.jpg",
            "first_name": "Iridian",
            "real_name": "Iridian Kiiskinen",
            "display_name": "Iridian",
            "team": "T5TCAFTA9",
            "name": "iridian",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D5x0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " depends on the numbers, of course. Lemme define:\n"
                            },
                            {
                                "type": "text",
                                "text": "random",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " = user is using an editor in random context (like a web editor)\n"
                            },
                            {
                                "type": "text",
                                "text": "unfamiliar",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " = user has chosen an editor but has not become an expert and is unaware of functionality\n"
                            },
                            {
                                "type": "text",
                                "text": "sucky",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " = user has chosen editor which outright doesn't implement the functionality\n\nLet's look at mass-indent-macro which has a de facto implementation of (<shift>-)<tab> and the feature penetration is high.\nHere there are very few sucky editors, users become familiar with the editors quickly, and as a result, expect even random editors to support the functionality. So a language designer in this case could very well rely on such a macro.\n\nBut auto-block-comment-macro (which I was somewhat obscurely referring to here) does not have a de-facto implementation (or at least I don't know of one. Maybe I learn more today? :D)\nSo for this situation all three groups are considerably larger and language designers... 'can' be justified in taking even such minor details into account.\n\nI'm not proposing this as even the most important of the minor details of course, just brought it up as something that came to mind..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553272710.117800",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1553278017.000000"
        },
        "client_msg_id": "d0170ebe-d809-4fe6-9354-b50de12030bb",
        "text": "<@UGK6P07UP> It's not cut and dried. I think certain things should be in the 'jurisdiction' of the tools rather than the language. Block commenting several lines at once feels like such a thing (<https:\/\/www.reddit.com\/r\/vim\/comments\/4ootmz\/what_is_your_little_known_secret_vim_shortcut_or\/d4ehmql>).\n\nSituations like this contribute to my skepticism of structured editors. It's _really_ nice that our tools are often oblivious of grammatical structure. It's just so much _simpler_ to just comment out lines rather than statements.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NcCgJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGK6P07UP"
                            },
                            {
                                "type": "text",
                                "text": " It's not cut and dried. I think certain things should be in the 'jurisdiction' of the tools rather than the language. Block commenting several lines at once feels like such a thing ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.reddit.com\/r\/vim\/comments\/4ootmz\/what_is_your_little_known_secret_vim_shortcut_or\/d4ehmql"
                            },
                            {
                                "type": "text",
                                "text": ").\n\nSituations like this contribute to my skepticism of structured editors. It's "
                            },
                            {
                                "type": "text",
                                "text": "really",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " nice that our tools are often oblivious of grammatical structure. It's just so much "
                            },
                            {
                                "type": "text",
                                "text": "simpler",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to just comment out lines rather than statements."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UGJ9KAZM3"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553273018.118500",
        "client_msg_id": "8f6b7f6f-bafd-47f2-8d05-bd111b068f39",
        "text": "<@UGJ9KAZM3> what does `auto-block-comment-macro` do? I think that's the part I'm missing.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dZ3a",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGJ9KAZM3"
                            },
                            {
                                "type": "text",
                                "text": " what does "
                            },
                            {
                                "type": "text",
                                "text": "auto-block-comment-macro",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " do? I think that's the part I'm missing."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGJ9KAZM3",
        "type": "message",
        "ts": "1553273237.118700",
        "client_msg_id": "01181b92-ea22-49d5-9f45-df569f6b2747",
        "text": "eh, sorry, my mental context was elsewhere. I just used that as keyword for the \"select shit and press key and have it all be auto-commented\". But we already shared that context and were already talking about the same thing.\n\nAnyway: core point was more on that what can be assumed to be 'de facto standard' and what can't is a slowly moving target. And I don't think a language designer can try to be somehow 'timeless' here. A language designed now with modern tools is allowed and can be expected to look different to a language of tools 20 years past... even if it is semantically the same language.\nAnd knowing and caring about what is de-facto-editor-functionality on one hand and what is state-of-the-art editor functionality on the other hand are things that can and should influence this.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a9ca5b79893e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-05\/567982344725_a9ca5b79893ede5381e5_72.jpg",
            "first_name": "Iridian",
            "real_name": "Iridian Kiiskinen",
            "display_name": "Iridian",
            "team": "T5TCAFTA9",
            "name": "iridian",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+IZJU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "eh, sorry, my mental context was elsewhere. I just used that as keyword for the \"select shit and press key and have it all be auto-commented\". But we already shared that context and were already talking about the same thing.\n\nAnyway: core point was more on that what can be assumed to be 'de facto standard' and what can't is a slowly moving target. And I don't think a language designer can try to be somehow 'timeless' here. A language designed now with modern tools is allowed and can be expected to look different to a language of tools 20 years past... even if it is semantically the same language.\nAnd knowing and caring about what is de-facto-editor-functionality on one hand and what is state-of-the-art editor functionality on the other hand are things that can and should influence this."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGJ9KAZM3",
        "type": "message",
        "ts": "1553273504.118900",
        "client_msg_id": "ad6bf2b8-4f74-484f-8acb-b80ab4b9d9d8",
        "text": "I agree with the suspicion on structured editors at least on intuitive level. :smile:\nIt's not just commenting, but copy-pasting, refactoring, drafting syntactically incorrect pseudocode-stuff and then only fixing it later, etc.\nSometimes the code comes together only after going through something that objectively was a huge mess all the time, and I end up feeling that it was correct all throughout.\nBut I don't know. Maybe even tightly structured editors would allow for the same thing, even enhance it, if one got used to them?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a9ca5b79893e",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-05\/567982344725_a9ca5b79893ede5381e5_72.jpg",
            "first_name": "Iridian",
            "real_name": "Iridian Kiiskinen",
            "display_name": "Iridian",
            "team": "T5TCAFTA9",
            "name": "iridian",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dxg0H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree with the suspicion on structured editors at least on intuitive level. "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            },
                            {
                                "type": "text",
                                "text": "\nIt's not just commenting, but copy-pasting, refactoring, drafting syntactically incorrect pseudocode-stuff and then only fixing it later, etc.\nSometimes the code comes together only after going through something that objectively was a huge mess all the time, and I end up feeling that it was correct all throughout.\nBut I don't know. Maybe even tightly structured editors would allow for the same thing, even enhance it, if one got used to them?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UD6EXQVM0"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553274575.119400",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1553274733.000000"
        },
        "client_msg_id": "bb9eb794-729a-46c0-949b-0e8c8420a5d0",
        "text": "No, what I'm saying is that the parser never sees the comments, the lexer throws them \"out\" - into a list of comment tokens - before they reach the parser. Then you use `StandardTriviaInjector` to recombine the comments with the syntax tree.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Wkl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "No, what I'm saying is that the parser never sees the comments, the lexer throws them \"out\" - into a list of comment tokens - before they reach the parser. Then you use "
                            },
                            {
                                "type": "text",
                                "text": "StandardTriviaInjector",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to recombine the comments with the syntax tree."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553275197.119900",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1553275276.000000"
        },
        "client_msg_id": "b4846011-903e-4b7f-841c-584736d3a7ca",
        "text": "So with Loyc trees you get this feature almost for free, and you can use it to build other tools (e.g. documentation generator, documentation detector in IDEs) more easily. You could also build refactoring tools, although other designs like Roslyn are better for refactoring since they preserve the parse tree, whereas all my code so far has only been designed to preserve the AST (this approach saves memory and since my goal was conversion between languages, the complete parse tree was not relevant for my purposes.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+2VY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So with Loyc trees you get this feature almost for free, and you can use it to build other tools (e.g. documentation generator, documentation detector in IDEs) more easily. You could also build refactoring tools, although other designs like Roslyn are better for refactoring since they preserve the parse tree, whereas all my code so far has only been designed to preserve the AST (this approach saves memory and since my goal was conversion between languages, the complete parse tree was not relevant for my purposes.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553275635.120300",
        "client_msg_id": "58c60aa2-2c37-4468-9dbe-43af3b3963af",
        "text": "Note that WebAssembly's decision process is semi-open via the Community Group, though some key decisions were made more privately. I think it's fair to say that Mozilla and Google will end up with most of the power since they are the only ones funding people to work on Wasm full-time. If you live in the Bay Area you could probably attend in-person meetings and theoretically have as much say in Wasm as Mozilla and Google, but let's face it, if no one is paying you to do that, how can you work on it in the Bay Area where rent is crazy, or fly to Paris for some meetings?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Toh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Note that WebAssembly's decision process is semi-open via the Community Group, though some key decisions were made more privately. I think it's fair to say that Mozilla and Google will end up with most of the power since they are the only ones funding people to work on Wasm full-time. If you live in the Bay Area you could probably attend in-person meetings and theoretically have as much say in Wasm as Mozilla and Google, but let's face it, if no one is paying you to do that, how can you work on it in the Bay Area where rent is crazy, or fly to Paris for some meetings?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553275814.120500",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1553275991.000000"
        },
        "client_msg_id": "87651315-0f15-427a-9886-5d33adff86dc",
        "text": "But my main concern is their goals - the goal isn't to achieve the \"best\" solution that will support \"all\" programming languages, nor is interop a goal - I think the goal is to support _most_ programming languages _more-or-less_ with _reasonably short time to market_ and probably without spending too much money on it... which to me is aiming low. I'm worried that WebAssembly will become wildly popular and then features that could have been possible in new programming languages will be dropped because \"Wasm can't do that\" or \"We can do that but there would be a performance hit on Wasm so... let's not bother\".",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kxifr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But my main concern is their goals - the goal isn't to achieve the \"best\" solution that will support \"all\" programming languages, nor is interop a goal - I think the goal is to support "
                            },
                            {
                                "type": "text",
                                "text": "most",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " programming languages "
                            },
                            {
                                "type": "text",
                                "text": "more-or-less",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with "
                            },
                            {
                                "type": "text",
                                "text": "reasonably short time to market",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and probably without spending too much money on it... which to me is aiming low. I'm worried that WebAssembly will become wildly popular and then features that could have been possible in new programming languages will be dropped because \"Wasm can't do that\" or \"We can do that but there would be a performance hit on Wasm so... let's not bother\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_check_mark",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "expressionless",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553276264.121200",
        "client_msg_id": "bcc9171b-445c-4370-bddb-a6ce4833e89c",
        "text": "Ok, so I did understand you the first time. I think my reasoning is that anybody who wants the power-user ability to comment out a whole block is also going to be using a high-power editor that can provide a single shortcut for it. `shift-3 down left` seems pretty lame as well :stuck_out_tongue: (Among other issues, it requires you to think about empty lines.)\n\nThis is turning into a bit of a tangent, but I think language syntax for block comments is deservedly an obsolete idea:\n\na) Non-nesting block comments (the way C and Java implement them) is obviously bad. I can't block-select twice to comment out.\n\nb) Even if you have nestable block comments, you now have to be careful to only select well-contained blocks.\n\nAll this is unnecessarily complex. Just select blocks and hit `C-\/`, and it'll always do what you want. Use my recommendation above and have the shortcut insert an extra leader character, and you'll also be able to undo such block comments really easily, while leaving real comments untouched. It works really well, and as I said in my reddit comment above, I don't really understand why editors and IDEs don't support it out of the box.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "u7C4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ok, so I did understand you the first time. I think my reasoning is that anybody who wants the power-user ability to comment out a whole block is also going to be using a high-power editor that can provide a single shortcut for it. "
                            },
                            {
                                "type": "text",
                                "text": "shift-3 down left",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " seems pretty lame as well "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue",
                                "unicode": "1f61b"
                            },
                            {
                                "type": "text",
                                "text": " (Among other issues, it requires you to think about empty lines.)\n\nThis is turning into a bit of a tangent, but I think language syntax for block comments is deservedly an obsolete idea:\n\na) Non-nesting block comments (the way C and Java implement them) is obviously bad. I can't block-select twice to comment out.\n\nb) Even if you have nestable block comments, you now have to be careful to only select well-contained blocks.\n\nAll this is unnecessarily complex. Just select blocks and hit "
                            },
                            {
                                "type": "text",
                                "text": "C-\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", and it'll always do what you want. Use my recommendation above and have the shortcut insert an extra leader character, and you'll also be able to undo such block comments really easily, while leaving real comments untouched. It works really well, and as I said in my reddit comment above, I don't really understand why editors and IDEs don't support it out of the box."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UGJ9KAZM3",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553276521.121700",
        "client_msg_id": "432374ed-aa7d-4dce-907c-d7111d43a0af",
        "text": "How does `StandardTriviaInjector` know where to add each comment? Do you include source code location information when funneling them out? (At that point the lexer only has row\/column co-ordinates; does the grammar have to carry that information along to permit recombination downstream?)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tFt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How does "
                            },
                            {
                                "type": "text",
                                "text": "StandardTriviaInjector",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " know where to add each comment? Do you include source code location information when funneling them out? (At that point the lexer only has row\/column co-ordinates; does the grammar have to carry that information along to permit recombination downstream?)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553276765.121900",
        "client_msg_id": "0facbe79-bf98-40f5-ae19-5d7c04af4bcb",
        "text": "Loyc trees include a source range per-node and the tokens, of course, should also have that. (Source ranges use half the memory compared to pairs of row\/column and are often easier for algorithms to work with.) IIRC, the syntax tree from the parser needs to _mostly_ follow the constraint that for each node X, the range of all children of X is a subrange of X's range, and ranges of siblings must not overlap. The children are not required to be in order but it's slower if they are out-of-order.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3y0A",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Loyc trees include a source range per-node and the tokens, of course, should also have that. (Source ranges use half the memory compared to pairs of row\/column and are often easier for algorithms to work with.) IIRC, the syntax tree from the parser needs to "
                            },
                            {
                                "type": "text",
                                "text": "mostly",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " follow the constraint that for each node X, the range of all children of X is a subrange of X's range, and ranges of siblings must not overlap. The children are not required to be in order but it's slower if they are out-of-order."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553276912.122200",
        "client_msg_id": "e4c00250-d34d-46e5-8845-cd429fc337af",
        "text": "See documentation: <http:\/\/ecsharp.net\/doc\/code\/classLoyc_1_1Syntax_1_1AbstractTriviaInjector.html>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Nvh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "See documentation: "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/ecsharp.net\/doc\/code\/classLoyc_1_1Syntax_1_1AbstractTriviaInjector.html"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553276984.122400",
        "client_msg_id": "67eecc55-48ca-4584-9775-e8e2002794b7",
        "text": "Do existing languages need to change to plumb source ranges through?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vRCG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Do existing languages need to change to plumb source ranges through?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553277228.122600",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1553277880.000000"
        },
        "client_msg_id": "ec003bae-79a0-48bb-876f-eab923d15c5f",
        "text": "Most parsers already do this in order to be able to report warnings\/errors long after parsing is done. (The hard part is converting an existing parser's output to a Loyc tree. And I haven't quite worked out how I'll port my existing code to the language in which most parsers are written - C++. I plan to work on surface syntax conversion first.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gEVO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Most parsers already do this in order to be able to report warnings\/errors long after parsing is done. (The hard part is converting an existing parser's output to a Loyc tree. And I haven't quite worked out how I'll port my existing code to the language in which most parsers are written - C++. I plan to work on surface syntax conversion first.)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553278715.123700",
        "client_msg_id": "1318376b-4b70-431d-b2d5-7fe3026cb0d5",
        "text": "They're tracking _something_ but is it source ranges? Do the units interoperate?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RIUS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "They're tracking "
                            },
                            {
                                "type": "text",
                                "text": "something",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " but is it source ranges? Do the units interoperate?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553279392.123900",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1553279854.000000"
        },
        "client_msg_id": "a0631025-77b2-4826-a363-98586ac4cd1a",
        "text": "6 sounds like a reasonable teaching tool, except that people won't be used to it, so they might be like \"what. the. fsk. is this\". Personally I think that high-level documentation is really important, moreso than function-level documentation - explain the core concepts and how the code is organized, and people should be able to figure out the rest. (that's what I'd recommend to others - I have perhaps a unique bad habit of writing what is probably too much documentation!)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552725903.098900",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "q4A1u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "6 sounds like a reasonable teaching tool, except that people won't be used to it, so they might be like \"what. the. fsk. is this\". Personally I think that high-level documentation is really important, moreso than function-level documentation - explain the core concepts and how the code is organized, and people should be able to figure out the rest. (that's what I'd recommend to others - I have perhaps a unique bad habit of writing what is probably too much documentation!)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553279847.124200",
        "client_msg_id": "1be64d00-defa-43b3-9cb5-55c4a2496ac2",
        "text": "There's already lots that people aren't used to. When they're in a strange codebase, that's going to be the norm. Some number of people will poke at something and withdraw after realizing it requires a larger investment than they expected. Nothing one can do about that. (And indeed those two categories are often the same people, just shifted in time. I have to recoil a few times from a codebase before I internalize what I need to do and why and make a larger commitment.)\n\nThe metric for learning new things is often \"how familiar is it?\" when I think it should be \"how parsimonious is it?\" I think a codebase that relies consistently on 5 unfamiliar mechanisms\/concepts\/names\/whatever is superior to one that relies on 100 familiar whatevers.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552725903.098900",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zQDA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's already lots that people aren't used to. When they're in a strange codebase, that's going to be the norm. Some number of people will poke at something and withdraw after realizing it requires a larger investment than they expected. Nothing one can do about that. (And indeed those two categories are often the same people, just shifted in time. I have to recoil a few times from a codebase before I internalize what I need to do and why and make a larger commitment.)\n\nThe metric for learning new things is often \"how familiar is it?\" when I think it should be \"how parsimonious is it?\" I think a codebase that relies consistently on 5 unfamiliar mechanisms\/concepts\/names\/whatever is superior to one that relies on 100 familiar whatevers."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553280343.124500",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1553280467.000000"
        },
        "client_msg_id": "f3f08072-4280-4c3b-8eec-8c57e21991fe",
        "text": "I predict it'll usually be ranges but the lowest-common-denominator is row\/col pairs, as all parsers need to be able to produce those for error messages. As a hack the algorithm ought to still generally work if you combine row\/cols into an integer (like, top 16 bits for row, 15 bits for col). A bit less hacky, one could use `IndexPositionMapper` to go from row\/cols back to indexes. The main thing some parsers might be missing is an end index (in compilers that can only report start indexes in errors, not ranges) in which case, yeah, you'd have to retrofit the parser. And some parsers (including my own) might occasionally have a bug in their range assignments, which tends to cause comments to be assigned to the wrong place in the AST.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552413977.047500",
        "parent_user_id": "UD6EXQVM0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "max",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I predict it'll usually be ranges but the lowest-common-denominator is row\/col pairs, as all parsers need to be able to produce those for error messages. As a hack the algorithm ought to still generally work if you combine row\/cols into an integer (like, top 16 bits for row, 15 bits for col). A bit less hacky, one could use "
                            },
                            {
                                "type": "text",
                                "text": "IndexPositionMapper",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to go from row\/cols back to indexes. The main thing some parsers might be missing is an end index (in compilers that can only report start indexes in errors, not ranges) in which case, yeah, you'd have to retrofit the parser. And some parsers (including my own) might occasionally have a bug in their range assignments, which tends to cause comments to be assigned to the wrong place in the AST."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553281546.124800",
        "client_msg_id": "42aceb9e-c4e5-4cb6-b9ef-7838c5869819",
        "text": "Yeah... but I guess you'll want to have some explanation of the unfamiliar things in a prominent place lest people run away screaming (well, silently screaming, because you'll probably never hear from them). I recently had a thought: although my Loyc projects are easy to build, maybe users won't realize that because so many other projects are complicated? So I added a dedicated section to my readme that says \"### How to build: ### Open Loyc.sln in Visual Studio, set the build configuration to Debug.NET45, and build it!\" [note to self: figure out how to build it on Linux\/Mac]",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552725903.098900",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "g+X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah... but I guess you'll want to have some explanation of the unfamiliar things in a prominent place lest people run away screaming (well, silently screaming, because you'll probably never hear from them). I recently had a thought: although my Loyc projects are easy to build, maybe users won't realize that because so many other projects are complicated? So I added a dedicated section to my readme that says \"### How to build: ### Open Loyc.sln in Visual Studio, set the build configuration to Debug.NET45, and build it!\" [note to self: figure out how to build it on Linux\/Mac]"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UD6EXQVM0",
        "type": "message",
        "ts": "1553281694.125000",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1553282255.000000"
        },
        "client_msg_id": "579cdccc-b0ef-4bfa-9ebd-6671bff192a0",
        "text": "I guess what I'm saying is, anything goes on the internet so it's important to show that your practices aren't just unusual\/confusing, they're actually good\/helpful.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g4a9957508aa",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "",
            "real_name": "David Piepgrass",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "qwertie256",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552725903.098900",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WiJ4d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess what I'm saying is, anything goes on the internet so it's important to show that your practices aren't just unusual\/confusing, they're actually good\/helpful."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1553291162.125800",
        "client_msg_id": "4457751f-9eb7-48df-9d52-f0daaecd927f",
        "text": "(Answering original question). My preference is `#` between the two. Likely because I've been using Python a lot. I also feel a single character is better, doesn't look like an operator (`\/` by itself is usually an operator in most languages). I assume most folks just use editor shortcuts to 'comment block' anyway (I surely do). In any case, there's already a lot of shift_ characters used when programming.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BnZo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(Answering original question). My preference is "
                            },
                            {
                                "type": "text",
                                "text": "#",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " between the two. Likely because I've been using Python a lot. I also feel a single character is better, doesn't look like an operator ("
                            },
                            {
                                "type": "text",
                                "text": "\/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " by itself is usually an operator in most languages). I assume most folks just use editor shortcuts to 'comment block' anyway (I surely do). In any case, there's already a lot of shift_ characters used when programming."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553293385.126000",
        "client_msg_id": "01c39035-44e9-45ec-93fc-16f52c5ff527",
        "text": "Yup! I definitely think about this a lot. See the example runs at the top of <https:\/\/github.com\/akkartik\/mu\/blob\/master\/subx\/Readme.md>.\n\nThe point of the example repos is also precisely to help make the unfamiliar more familiar. I'm not trying to convince random projects to use my build system. (That's kinda terrifying.) This post is a link that'll go to a few strategic places where I hope people trying out my other projects will encounter it.\n\nI figure since nobody ever has example repos for playing with their build systems, I'm signaling that I care. I was assuming that an example repo would seem obviously likely to be easy to build and run. But now that I think about it, I'm not actually sure if that's a deduction everyone will make..",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1552725903.098900",
        "parent_user_id": "UCUSW7WVD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T8W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yup! I definitely think about this a lot. See the example runs at the top of "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/akkartik\/mu\/blob\/master\/subx\/Readme.md"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nThe point of the example repos is also precisely to help make the unfamiliar more familiar. I'm not trying to convince random projects to use my build system. (That's kinda terrifying.) This post is a link that'll go to a few strategic places where I hope people trying out my other projects will encounter it.\n\nI figure since nobody ever has example repos for playing with their build systems, I'm signaling that I care. I was assuming that an example repo would seem obviously likely to be easy to build and run. But now that I think about it, I'm not actually sure if that's a deduction everyone will make.."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U6KQ2S410",
        "type": "message",
        "ts": "1553309427.126400",
        "client_msg_id": "12C3FEC6-F2BA-4C51-A5B8-01A2E48C8517",
        "text": "See <https:\/\/wiki.haskell.org\/Wadler%27s_Law>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e8f4c2151d2b",
            "image_72": "https:\/\/avatars.slack-edge.com\/2017-08-09\/225308926294_e8f4c2151d2b70ebfae3_72.jpg",
            "first_name": "Jonathan",
            "real_name": "Jonathan Edwards",
            "display_name": "jonathoda",
            "team": "T5TCAFTA9",
            "name": "jonathoda",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "StlCU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "See "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/wiki.haskell.org\/Wadler%27s_Law"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "joy",
                "users": [
                    "U8A5MS6R1",
                    "U5STGTB3J"
                ],
                "count": 2
            },
            {
                "name": "face_with_rolling_eyes",
                "users": [
                    "UE6EFEPTQ"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1553312698.126800",
        "client_msg_id": "b907bda2-f316-41ed-b57e-364835bb9445",
        "text": "And the highest ratio belongs to... <@U6KQ2S410>!",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SnSv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And the highest ratio belongs to... "
                            },
                            {
                                "type": "user",
                                "user_id": "U6KQ2S410"
                            },
                            {
                                "type": "text",
                                "text": "!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1553323014.127300",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1553323046.000000"
        },
        "client_msg_id": "9a6363f4-6922-46ae-b2a5-3af1d37c01b5",
        "text": "Interesting results. It appears that no matter what delimiter you pick for line comments it will be inconvenient or ugly for someone. -- is definitely prettier, and more consonant with prose typographical traditions. \/\/ is easy to type on a US keyboard. # is the python\/julia convention. Personally i feel that anything a language does to encourage commenting is a positive thing. Code is for computers, comments are for the humans reading the code. I detest Knuth's literate programming concepts, and i am often dismayed by the almost total lack of comments from the younger programmers who have yet to taste the bitter fruit of debugging someone else's uncommented monster codebase. When you have been tortured your entire career by the laziness of others, you learn good practices.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1553216451.112800",
        "parent_user_id": "UEQ6M68H0",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=8U",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Interesting results. It appears that no matter what delimiter you pick for line comments it will be inconvenient or ugly for someone. -- is definitely prettier, and more consonant with prose typographical traditions. \/\/ is easy to type on a US keyboard. # is the python\/julia convention. Personally i feel that anything a language does to encourage commenting is a positive thing. Code is for computers, comments are for the humans reading the code. I detest Knuth's literate programming concepts, and i am often dismayed by the almost total lack of comments from the younger programmers who have yet to taste the bitter fruit of debugging someone else's uncommented monster codebase. When you have been tortured your entire career by the laziness of others, you learn good practices."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]