<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robin Allison</b>
<span style="margin:2em; color:#606060">2020-09-10 23:25</span><br/>
Broad question here.<br/>Do people here know of any tools that separates the complexity component of a program from the underlying behavior it would eventually produce, and then let you manipulate code so the behavior is fixed? By behavior I mean something like the user-facing behavior of a program, or its effect on some data. Its a flexible concept in my mind. A large portion of programming seems to be rewriting code so it maintains the same behavior, but is then also extensible in some way. Factoring code is an example of this activity, but you could also rewrite code to produce the same behavior which is not a factorization of the original code. To be concrete, you could factor in two different ways, so each factorization would produce the same behavior but neither is a factorization of one another. Moving back to the unfactored code and factoring in the other way is then a means of transforming the code to produce the same behavior that isn't mere factoring.<br/>(picture: code&lt;--factoring&lt;--code--&gt;factoring--&gt;code)<br/>(this is very reminiscent of factoring in abstract algebra and you could imagine an algebra about manipulating the code in this way, and going down this road you can ask whether two programs will produce the same behavior implies there is a common factorization but this might be another conversation).<br/><br/>I'm curious about this question mostly as a proxy for a related question in math: How can you transform one proof into an equivalent proof? This is a slippery concept because nobody knows how to make precise the idea of "equivalence of proofs". If you know about Hilbert and his 23 problems you might find it interesting that he originally had a 24th problem on the equivalence of proofs! Even though the idea is notoriously difficult to pin down, I think it is intuitive enough to take a pragmatic stance and ask how you could go about implementing technology to carry out these transformations. This is important to me because in math we "factor" proofs all the time and often compare proofs to determine the essential and incidental aspects of each. So what I'm really looking for is any techniques or perspectives in the domain of programming that could be taken back into mathematics. I've seen some approaches down at the level of the lambda calculus but I haven't found them useful. I think a pragmatic/experimental approach is better than a theoretical approach at this point.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1599808252.266700"></a>
      <img src="https://avatars.slack-edge.com/2023-10-13/6057269405632_8ea58fc41bd6baa7dda6_72.png" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html#1599808252.266700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jack Rusher</b>
<span style="margin:2em; color:#606060">2020-09-11 00:10</span><br/>
The closest thing to what I think you're asking about is using Logic Programming to do program synthesis. Here's a video demoing a system of this kind:<br/><a href="https://www.youtube.com/watch?v=5vtC7WEN76w">https://www.youtube.com/watch?v=5vtC7WEN76w</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1599808898.267200"></a>
      <img src="https://avatars.slack-edge.com/2020-02-26/971836171367_2fdcf29b225b02e66825_72.png" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html#1599808898.267200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Martin Sosic</b>
<span style="margin:2em; color:#606060">2020-09-11 00:21</span><br/>
At risk of coming up as very naive: what about tests on the practical side and formal verification on the other side? Since those are allowing us to refactor code while ensuring (to varying degree) its correctnes and behaviour, how do those fit into what you are looking for?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1599813645.268000"></a>
      <img src="https://avatars.slack-edge.com/2020-09-10/1362285586740_cbf2c32d7d6b8886a1b2_72.png" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html#1599813645.268000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Henning Dieterichs</b>
<span style="margin:2em; color:#606060">2020-09-11 01:40</span><br/>
I wonder how different proofs for the same theorem compare after resolving all abstractions and breaking them down to ZF. But I guess even proofs using the minimal amount of axioms aren't unambiguous, as two different axioms could share a common idea.<br/>However, it is undecidable whether a set of axioms contains redundant axioms. <br/><br/>In general, deciding whether two programs are semantically equivalent is undecidable too. So there cannot be a universal tool that enumerates all alternative function bodys with the same behavior.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1599816204.268200"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html#1599816204.268200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2020-09-11 02:23</span><br/>
When dealing with undecidability, it's best to say, "well, we'll just handle the easy cases," and see how far you go.  Compiler optimizations are certainly an exercise in factoring as is partial evaluation, which is a good deal more fun.  Come to think of it, conventional refactoring is sort of the opposite transformation.  Instead of removing indirection, add it so that the rest is more regular.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1599844798.273600"></a>
      <img src="https://secure.gravatar.com/avatar/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html#1599844798.273600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robin Allison</b>
<span style="margin:2em; color:#606060">2020-09-11 10:19</span><br/>
<span style="background-color:#ccf">@Martin Sosic</span> I appreciate the answer. Talking about testing is more concrete than talking about an abstract idea of behavior, and as you said the practice of testing is about manipulating code so the same tests (at least) still pass. I guess the picture I have in my mind is that when you are coding you are moving around a space of strings of symbols, and in that huge space is a space of valid programs, and once you write tests, then there is an even smaller space of programs that pass those tests. Is there any means of restricting code rewrites to discrete steps that take place entirely in the space of programs that pass the tests? Rewriting for-loops as while-loops wouldn't change any tests. Changing some variable names. Refactoring. These wouldn't change the tests at all, and in a specific context you could possibly have more. If you have various pieces of code that are interchangeable then you have something like an algebra where you can substitute equivalent expressions. Tests tell you when code is interchangeable so it gives you some algebra-like thing and how can you manipulate code at this level?<br/><br/>So tests are relevant for what I'm looking for because they let you say when two programs are equivalent. I don't think proof verification does the same in math.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1599846324.273800"></a>
      <img src="https://secure.gravatar.com/avatar/f5f4ac5375e539e50ceedb08f65e9dd3.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html#1599846324.273800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robin Allison</b>
<span style="margin:2em; color:#606060">2020-09-11 10:45</span><br/>
<span style="background-color:#ccf">@Henning Dieterichs</span> "In general, deciding whether two programs are semantically equivalent is undecidable too. So there cannot be a universal tool that enumerates all alternative function bodys with the same behavior."<br/><br/>Neat! Good to know there isn't a universal tool.<br/><br/><span style="background-color:#ccf">@William Taysom</span> Easy cases is right! I haven't seen compiler optimizations before. I might take a peek into that area, but I have a feeling I might get scarred.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1599850934.278400"></a>
      <img src="https://avatars.slack-edge.com/2020-06-28/1196019819111_19925410efa8da86ae13_72.jpg" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html#1599850934.278400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Ray Imber</b>
<span style="margin:2em; color:#606060">2020-09-11 12:02</span><br/>
I agree with <span style="background-color:#ccf">@William Taysom</span>. This very much reminds me of compiler optimization.<br/><br/>Classical compiler optimization makes use of many transformations that maintain equivalence such as <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> form. These sorts of transformations combined with heuristic based analysis are the bread and butter of compiler optimization. The GHC Haskell compiler is probably the epitome of the classical compiler optimization approach.<br/><br/>Then there are the recent results in applying Machine Learning and Genetic algorithms to compiler optimization. These compilers often produce extremely novel, unexpected, even bizarre, machine code, and yet the results have been shown to be "equivalent", and yet much more efficient in some dimension than known state of the art classical approaches (often either better runtime or less resulting machine code.) AFAIK, the way the ML compilers seems to work today is essentially unit testing and manual inspection against programs compiled with classical compilers.<br/><a href="https://arxiv.org/pdf/1805.03441.pdf">https://arxiv.org/pdf/1805.03441.pdf</a><br/><a href="https://www.semanticscholar.org/paper/Compiler-Optimization%3A-A-Genetic-Algorithm-Approach-Ballal-Sarojadevi/6676a5489ced5412fa2ba3ecb76ca3e5ca2723e0">https://www.semanticscholar.org/paper/Compiler-Optimization%&hellip;</a><br/><br/>A key idea is that all these algorithms must have some notion of equivalence of programs. An optimization is only useful if the resulting behavior is equivalent.<br/>The real heart of this is the Church-Turing thesis. Program optimization is essentially saying one program is equivalent to another program, but just computed in a different way. The fact that such equivalent programs can even exist is a direct result the Church-Turing thesis.<br/><br/>Your line of reasoning is related to some of the inspiration of the creators of logic programming and proof assistants like Coq and Agda. If you can encode a proof in a programming language, you have essentially shown that the proof is computable. If it's computable, then there are infinite equivalent programs (via Church-Turing). You can then apply all the known computable transformations like SSA, or graph pruning analysis, etc...
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1599895801.289600"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html#1599895801.289600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2020-09-12 00:30</span><br/>
Wow, GCC flags <span style="background-color:#ccf">@Ray Imber</span>?  I do like the idea of ML being applied at high level "moves" than it often is.  I mean, for instance, allow for only valid application of inference rules rather than random term rewrites.  Let the system play over that space.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1600241417.465000"></a>
      <img src="https://secure.gravatar.com/avatar/e4a9957508aa1bdb16018793cfc1bb40.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png" style="float:left"/>
      <a href="../thinking-together/1599805535.266400.html#1600241417.465000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>David Piepgrass</b>
<span style="margin:2em; color:#606060">2020-09-16 00:30</span><br/>
"tools that separates the complexity component of a program from the underlying behavior it would eventually produce, and then let you manipulate code so the behavior is fixed"<br/>I'm not sure if optimization is on your mind here, but look up the Halide "language" (a C++ DSL), which allows the behavior to be specified separately from the execution plan. Also I heard TVM is related, as well as a new pair of languages called Rise &amp; Elevate for algorithm optimization.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
