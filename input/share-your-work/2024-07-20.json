[
    {
        "user": "U0296ACR13M",
        "type": "message",
        "ts": "1721480504.606179",
        "client_msg_id": "0186cd15-b014-42c6-ab8c-648d3299270b",
        "text": "Personally not a fan of node or blocks based programming, but good job coming up with something novel in the domain! I think it has potential, although would probably suffer quite a bit from the same understandability issues that other node and block based approaches suffer when the complexity grows.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "59de929720a2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2022-09-08\/4075674207584_59de929720a2fe0a13d8_72.jpg",
            "first_name": "",
            "real_name": "Jarno Montonen",
            "display_name": "Jarno Montonen",
            "team": "T5TCAFTA9",
            "name": "jarno.montonen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1720889347.004269",
        "parent_user_id": "U013GB24BD4",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iCOj\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Personally not a fan of node or blocks based programming, but good job coming up with something novel in the domain! I think it has potential, although would probably suffer quite a bit from the same understandability issues that other node and block based approaches suffer when the complexity grows."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U013GB24BD4",
        "type": "message",
        "ts": "1721506929.399589",
        "client_msg_id": "dbb167fb-7051-433e-abc3-38e801e173ab",
        "text": "Thank you so much for your feedback <@U0296ACR13M>. It's really interesting to think about the strengths and weaknesses of these different paradigms.\n\nI would say that with any sufficiently complex application, it comes down to what tooling is available and whether the codebase has consistent standards. I spend much of my day job in more standard code, in complex distributed codebases.\n\nIt's invaluable to be able to use an IDE, navigate through definitions, search across the full codebase, seamless debugging and lately even having the ability to analyze and explain larger parts of the codebase with AI in tools such as Cursor. This all can help understand new code. Using common or at least consistent patterns, good naming and all that stuff will make it easier. It can still involve learning new paradigms, libraries and so on.\n\nI would say that a lot of the same applies to working in node based environments. With the added complexity of usually having to lay out things yourself, which can absolutely make or break readability - whereas formatters are absolutely standard for text code nowadays. Also, given the lack of standardization in node based tools (yes, it's often nodes, but with so many flavors), each language requires its own IDE, putting a lot of strain on developers to match the mature tooling for text code.\n\nStill, I find that some types of flows, especially data piping, and some types of use-cases, such as realtime multimedia applications, generally work better for me in visual environments. vvvv gamma (<https:\/\/visualprogramming.net\/>), which all of Schema is created with, seems to be the closest to a full featured IDE I've come across in visual programming. I've also found that Reactive programming is incredibly intuitive in this environment, compared to C# for instance. Though  it still has some way to go, such as improved tooling for git or multiwindow.\n\nDuring development I've certainly had moments where the realtime code update and amazing protocol abstractions made it a joy, while there were others where the tooling and constant tidying needed made me wish for more standard lands.\n\nGoing back to the original point with complexity, In Schema, while theoretically possible, I do not encourage there to be a huge amount of complexity at the same time. First of all, there is a big focus on fairly high level nodes aimed mainly at animation and a good amount of things happening implicitly, such as referencing extents of objects in space. Of course, all this interconnected machinery is its own complexity, even when there may be less \"code\" to see at a time.\n\nSecondly, there are a number of ways of switching up parts of the stacks using assigning via Director, layers, groupings, referencing other objects and modifying slightly. With the general idea that you can get a lot of variety by combining and switching around small-ish stacks of blocks.\n\nAdditionally, when you look at a Block based code, which may seem visual, it's actually no more than nested functions, not far from Lisp or any code AST in general.\n\nBlockly, for instance, is often used to build out regular text code. Though I agree drag and dropping everything is a pretty obnoxious way if you know your way around code.\n\nAs a matter of fact, all of Schema Block stacks can actually be represented as a very succinct YAML (<https:\/\/docs.scenic.tools\/future-concepts\/scenicscript>), which allows for a human readable transfer format, text editing (helpful on terminal devices also), LLM completions and more.\n\nWhat the UI in Schema helps with is interfacing with the parameters and providing immediate in-place feedback of the individual data processing steps (similar to TouchDesigner which does this very well). It also providing domain specific overlays such as MIDI mapping or DMX channel output visualization.\n\nOverall I am trying to strike a balance between the two worlds while finding new ways to interact with code.\n\nThis new Cursor work aims to make the block programming feel as efficient, if not more than, writing textual code, while also making it more accessible and fun with the goal of enabling full game controller support.\n\nI really appreciate that you find some of these approaches novel :heart:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "65426aae1dc7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-05-16\/1127224771285_65426aae1dc71e1ba6d6_72.jpg",
            "first_name": "",
            "real_name": "Dominik Jančík",
            "display_name": "Dominik Jančík",
            "team": "T5TCAFTA9",
            "name": "hi565",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1720889347.004269",
        "parent_user_id": "U013GB24BD4",
        "attachments": [
            {
                "image_url": "https:\/\/visualprogramming.net\/img\/ogVVVV_gray.jpg",
                "image_width": 610,
                "image_height": 320,
                "image_bytes": 14213,
                "from_url": "https:\/\/visualprogramming.net\/",
                "service_icon": "https:\/\/visualprogramming.net\/.\/favicon.ico",
                "id": 1,
                "original_url": "https:\/\/visualprogramming.net\/",
                "fallback": "vvvv - visual live-progamming for .NET",
                "text": "A visual live-programming environment that takes you from rapid prototyping to final production.",
                "title": "vvvv - visual live-progamming for .NET",
                "title_link": "https:\/\/visualprogramming.net\/",
                "service_name": "visualprogramming.net"
            },
            {
                "image_url": "https:\/\/docs.scenic.tools\/~gitbook\/ogimage\/-M7M0xgS4lTiR2B8B-92",
                "image_width": 1200,
                "image_height": 630,
                "image_bytes": 21142,
                "from_url": "https:\/\/docs.scenic.tools\/future-concepts\/scenicscript",
                "id": 2,
                "original_url": "https:\/\/docs.scenic.tools\/future-concepts\/scenicscript",
                "fallback": "ScenicScript \/ YAMLStacks | Schéma",
                "text": "(Working Title)",
                "title": "ScenicScript \/ YAMLStacks | Schéma",
                "title_link": "https:\/\/docs.scenic.tools\/future-concepts\/scenicscript",
                "service_name": "docs.scenic.tools"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pWkPi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thank you so much for your feedback "
                            },
                            {
                                "type": "user",
                                "user_id": "U0296ACR13M"
                            },
                            {
                                "type": "text",
                                "text": ". It's really interesting to think about the strengths and weaknesses of these different paradigms.\n\nI would say that with any sufficiently complex application, it comes down to what tooling is available and whether the codebase has consistent standards. I spend much of my day job in more standard code, in complex distributed codebases.\n\nIt's invaluable to be able to use an IDE, navigate through definitions, search across the full codebase, seamless debugging and lately even having the ability to analyze and explain larger parts of the codebase with AI in tools such as Cursor. This all can help understand new code. Using common or at least consistent patterns, good naming and all that stuff will make it easier. It can still involve learning new paradigms, libraries and so on.\n\nI would say that a lot of the same applies to working in node based environments. With the added complexity of usually having to lay out things yourself, which can absolutely make or break readability - whereas formatters are absolutely standard for text code nowadays. Also, given the lack of standardization in node based tools (yes, it's often nodes, but with so many flavors), each language requires its own IDE, putting a lot of strain on developers to match the mature tooling for text code.\n\nStill, I find that some types of flows, especially data piping, and some types of use-cases, such as realtime multimedia applications, generally work better for me in visual environments. vvvv gamma ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/visualprogramming.net\/"
                            },
                            {
                                "type": "text",
                                "text": "), which all of Schema is created with, seems to be the closest to a full featured IDE I've come across in visual programming. I've also found that Reactive programming is incredibly intuitive in this environment, compared to C# for instance. Though  it still has some way to go, such as improved tooling for git or multiwindow.\n\nDuring development I've certainly had moments where the realtime code update and amazing protocol abstractions made it a joy, while there were others where the tooling and constant tidying needed made me wish for more standard lands.\n\nGoing back to the original point with complexity, In Schema, while theoretically possible, I do not encourage there to be a huge amount of complexity at the same time. First of all, there is a big focus on fairly high level nodes aimed mainly at animation and a good amount of things happening implicitly, such as referencing extents of objects in space. Of course, all this interconnected machinery is its own complexity, even when there may be less \"code\" to see at a time.\n\nSecondly, there are a number of ways of switching up parts of the stacks using assigning via Director, layers, groupings, referencing other objects and modifying slightly. With the general idea that you can get a lot of variety by combining and switching around small-ish stacks of blocks.\n\nAdditionally, when you look at a Block based code, which may seem visual, it's actually no more than nested functions, not far from Lisp or any code AST in general.\n\nBlockly, for instance, is often used to build out regular text code. Though I agree drag and dropping everything is a pretty obnoxious way if you know your way around code.\n\nAs a matter of fact, all of Schema Block stacks can actually be represented as a very succinct YAML ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/docs.scenic.tools\/future-concepts\/scenicscript"
                            },
                            {
                                "type": "text",
                                "text": "), which allows for a human readable transfer format, text editing (helpful on terminal devices also), LLM completions and more.\n\nWhat the UI in Schema helps with is interfacing with the parameters and providing immediate in-place feedback of the individual data processing steps (similar to TouchDesigner which does this very well). It also providing domain specific overlays such as MIDI mapping or DMX channel output visualization.\n\nOverall I am trying to strike a balance between the two worlds while finding new ways to interact with code.\n\nThis new Cursor work aims to make the block programming feel as efficient, if not more than, writing textual code, while also making it more accessible and fun with the goal of enabling full game controller support.\n\nI really appreciate that you find some of these approaches novel "
                            },
                            {
                                "type": "emoji",
                                "name": "heart",
                                "unicode": "2764-fe0f"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U0296ACR13M"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U013GB24BD4",
        "type": "message",
        "ts": "1721507225.649639",
        "client_msg_id": "90d93e7a-f4d8-4da0-8ca7-e307f4e2662a",
        "text": "I have less need for this now after ending my tenure at a company that partially focused on code analysis, but...\n\nI am really glad there are now more options for JS analysis outside of the JS ecosystem for efficiency and sanity's sake. :pray:\n\nBest of luck with the engine work :crossed_fingers: I wonder, is there a specific niche you're aiming to fill compared to the super optimized behemoths or is it more of a learning exercise?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "65426aae1dc7",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-05-16\/1127224771285_65426aae1dc71e1ba6d6_72.jpg",
            "first_name": "",
            "real_name": "Dominik Jančík",
            "display_name": "Dominik Jančík",
            "team": "T5TCAFTA9",
            "name": "hi565",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721316761.909239",
        "parent_user_id": "U05CF6KLESV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7u4j3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have less need for this now after ending my tenure at a company that partially focused on code analysis, but...\n\nI am really glad there are now more options for JS analysis outside of the JS ecosystem for efficiency and sanity's sake. "
                            },
                            {
                                "type": "emoji",
                                "name": "pray",
                                "unicode": "1f64f"
                            },
                            {
                                "type": "text",
                                "text": "\n\nBest of luck with the engine work "
                            },
                            {
                                "type": "emoji",
                                "name": "crossed_fingers",
                                "unicode": "1f91e"
                            },
                            {
                                "type": "text",
                                "text": " I wonder, is there a specific niche you're aiming to fill compared to the super optimized behemoths or is it more of a learning exercise?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U05CF6KLESV"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U05CF6KLESV",
        "type": "message",
        "ts": "1721515235.786939",
        "client_msg_id": "f7166502-ca6f-4751-bd67-5945eee2e993",
        "text": "<@U013GB24BD4> Definitely more of a learning experience atm, but I think there is a potential niche to build something similar to Quick.js, which only supports a subset of the spec and doesn't have a JIT, but is great for embedded or serverless usecases where fast start up times are a top priority.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "25ed978f2a92",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-06-12\/5403931675222_25ed978f2a92f81ad513_72.jpg",
            "first_name": "John",
            "real_name": "John Flockton",
            "display_name": "John Flockton",
            "team": "T5TCAFTA9",
            "name": "j.r.flockton",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1721316761.909239",
        "parent_user_id": "U05CF6KLESV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "p4dfg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U013GB24BD4"
                            },
                            {
                                "type": "text",
                                "text": " Definitely more of a learning experience atm, but I think there is a potential niche to build something similar to Quick.js, which only supports a subset of the spec and doesn't have a JIT, but is great for embedded or serverless usecases where fast start up times are a top priority."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]