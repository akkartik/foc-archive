<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-03-13 00:55</span><br/>
Swift has some really crazy complex super subtle syntax features that i can't even imagine why they bothered because they take more effort to learn than they must save. All part of the committee approach that Swift has adopted, which is the PL/1 or ADA of our time. A gigantic language that just couldn't say "no" to any feature anyone could think of. PL/1 was great, and so is Swift, but it isn't easy for other people to make a Swift compiler, so it is more or less locked-in to Apple.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552478992.065500"></a>
      <img src="https://secure.gravatar.com/avatar/42bcec88b9653a5c34e35a2be102e115.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552478992.065500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Max Desiatov</b>
<span style="margin:2em; color:#606060">2019-03-13 05:09</span><br/>
I personally find Swift very minimalistic, elegant, practical and powerful compared to a lot of other languages, e.g. Rust and C++. I enjoy using Swift, especially after having some substantial experience with Python, JavaScript, TypeScript and Objective-C. Managing any complexity in Python and JavaScript (and Objective-C especially due to its verbosity) is a nightmare, while in Swift it's easy peasy due to advanced type system and nice syntax. This is also what I hear from a lot of other people and see in practice while working on large projects. So I think the bottom line is that our opinions about its complexity are subjective and we won't be able to make any definitive statements until we gather any quantitative data about this.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552515471.068100"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552515471.068100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-03-13 15:17</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> Can you elaborate on what you consider “really crazy complex super subtle syntax features” in Swift? Would love to better understand that with a few examples.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552517018.070200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552517018.070200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-03-13 15:43</span><br/>
Don't get me wrong. Swift is overwhelmingly preferred by the Apple dev community, because the standard for Objective C was "whatever the compiler does", hardly a sensible situation. To my knowledge, the original designer of Swift has left Apple, so they have lost their benevolent dictator for life whose typical job it is to hold back the tide of unnecessary feature elaboration. As a consequence you have things like adding iterability to enumerated types, with the kicker that now there is some subtle pragma statement you have to add.  Take this example from a swift 4.2 feature explanation from <a href="https://www.hackingwithswift.com/articles/77/whats-new-in-swift-4-2">https://www.hackingwithswift.com/articles/77/whats-new-in-swift-4-2</a><br/><br/>enum Direction: CaseIterable {<br/>    static var allCases: [Direction] {<br/>        return [.north, .south, .east, .west]<br/>    }<br/><br/>    case north, south, east, west<br/><br/>    @available(*, unavailable)<br/>    case all<br/>}<br/><br/>Someone reading that code above, has to now understand the @available keyword, and the deep meaning of @available(*, unavailable). That is clear as mud. And this took me all of 10 seconds to find on the internet, just by looking at "new swift features" you can see the complexification that inevitably occurs once a committee can start adding their so-called contributions. If a committee had taken over Michelangelo's statue of David, he would have a hat, a cane, and all sorts of accessories added by now. There is a great virtue to simplicity, and whether you study the latest ADA, Java, or C++, etc., you see significant additions to the original core language, and the net result is a massive cognitive burden on the learner.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552518093.077900"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552518093.077900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-03-13 16:01</span><br/>
You can indeed measure complexity. You can look at the total number of pages of documentation you have to read to cover the features of the language. you can examine how many tokens the EBNF grammar has. How many API's you have to call to implement a reference program. It is extremely critical when comparing languages to give the same exact clear specifications for each of the reference programs, so the comparison is valid. That was one of the first things i did was make a small sequence of graphical interactive programs, a clock, a wristwatch, snake, tictactoe, minesweeper, chess, and then give that same task to some of the various competing next-gen language efforts. When you start doing a fair amount of drawing, if you are basing your language on HTML/CSS for drawing you hit a wall quickly, because my specifications call for responding to the size, orientation, and DPI of the device you are on. This is why people are so wedded to frameworks in the JS world, because raw DOM manipulation is pretty tricky. To a great extent, the HTML/CSS world is just a botched implementation of Display Postscript, which was one of Steve Job's favorite things, but overruled by his technical staff as unworkable.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552518198.078700"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552518198.078700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-03-13 16:03</span><br/>
And i assert is the API load that is the major problem today. You can learn a language pretty easily, it is the investment in the API's that dominates now, because many OS's have thousands of API's to learn, and you not only have to learn what each one does, but the exact sequence they must be used in, which is where some of the hardest bugs there are arise; improper sequencing of computation is i believe 50% of all debugging.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552518825.086800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552518825.086800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-03-13 16:13</span><br/>
I was very impressed with Swift 1. I read the manual the day it came out, all 600 pages, and i think Apple did the best they could given the constraint that they couldn't change any of the underlying operating system, with the thousands of API's and object-oriented model they selected back in the day when Next computer and the NextStep OS started that generation of product. But i don't consider Swift simple, and that is what i am after. A new language that drastically simplifies programming.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552519293.087100"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552519293.087100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-03-13 16:21</span><br/>
You have to understand my history to grasp why it is i hate all these modern things. I was influenced by Prof. Niklaus Wirth of ETH, and used first the Pascal language, then Modula-2 for 20 years. The core of the Modula-2 language can be covered in around 100 pages. The language is clean as a whistle, and programs written it are 1/2 the length of C, due to achieving a higher degree of code sharing. I used it for 20 years and made macintosh/windows desktop software products. Yes, it was work to write my own graphical layer, because the language has no drawing primitives. But the many run-time checks it offered compared to C made it a safer language to program in.  The windows compiler i used is now released as freeware, formerly known as the stony brook compiler, it is miraculously fast, with the ability to compile and link programs super fast. I think my 100k line code base for Discus was just a few seconds.<br/><br/><a href="https://www.modula2.org/adwm2/">https://www.modula2.org/adwm2/</a><br/><br/>Prof. Wirth later made his own computer (the Lilith machine), and his own OS, which i don't think many other small teams ever accomplished. He spent some time at Xerox Palo Alto Research center, and was inspired. When you dig deep enough Xerox invented most of the modern computer technologies, but was poorly run and the management never capitalized on any of its many breakthroughs.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552529001.087800"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552529001.087800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-03-13 19:03</span><br/>
It seems that this topic has too many facets to agree on. In many respects, complexity is objective (e.g. go watch Rich Hickey's "Simple Made Easy"). But there's a big difference between complexity of a language and complexity of code, complexity of frameworks, etc. There's also complexity of all features vs a practical subset.<br/><br/>JavaScript is a perfect example of this: On the one hand it has a lot of bad parts; on the other, the so called "good parts" form a subset that's one of the purest, simplest, and most powerful and practical languages ever; but on the other other hand, it's also been the target of some of the most bloated and over-tooled software practices ever.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552529276.088000"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552529276.088000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-03-13 19:07</span><br/>
<span style="background-color:#ccf">@Dan Cook</span> One lovely thing about Lua is that it's basically "Dynamic Language: the Good Parts Edition" – or if that's too bold, we could say it was designed by committee but by taking the intersection of the committee's opinions.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552529360.088200"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552529360.088200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-03-13 19:09</span><br/>
Back to the original question, I think it's really a social / personal matter.<br/><br/>For example, I don't see potential for finding one common representation that would be used everywhere; there's just too many people and opinions and options that are not going to coalesce. But if you (or a growing community) wanted to use it for a set of tools that you'd expand to support multiple (and perhaps any) language, then sure I think it can work just fine.<br/><br/>The idea of being able to create tools or features or whatever that is implemented in terms of a generic representation that can target any language ... that's pretty cool!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552529707.088600"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552529707.088600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-03-13 19:15</span><br/>
... That being said though, I personally would find it simpler to just use a dynamic/generic data structure, like dictionaries and lists; or a dynamic language where that's the norm to begin with. That's a major part of why I'm using JavaScript for my universal-software-tool project. I find that highly preferable to creating a generalizable representation in a statically typed language -- but that's also my general language preference speaking :)<br/><br/>If you put the structure choice aside though (e.g. Loyc versus JSON), the idea of finding a general representation of code is definitely something that relates to what I'm doing, and for that matter, I think Loyc had identified the right components (identifiers, values, nested structure, attributes / meta, and all operations represented as "calls") ... And that's a topic/space that might actually be worth it's own focus / collaboration, because I'm sure it's something that multiple of us are exploring
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552530012.088800"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552530012.088800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-03-13 19:20</span><br/>
Anyway, If the goal is a common representation that can match the syntax of any language (from a source code standpoint), then Loyc makes a lot of sense.<br/><br/>But (perhaps depending on what I've intends to do with it) I also think a better approach would be to identify since general semantics for a program and pick a representation for that, and then (if desired) be able to generate serve code in other languages for that. Some things like variables, functions, and expressions are universal; but other things like classes, attributes, namespaces, access-modifiers (e.g. public / private) are not, and I'd personally argue that (from a language agnostic view) those things don't add much value, especially since most of what they "do" can be achieved through other techniques (e.g. with closures). And then it's a matter of how do you generate the equivalent in any given language.<br/><br/>... That's perhaps getting into "different goals" territory (and perhaps specific to what my reasons would be for cross-language code), but I suspect the main differences are whether you want to generate a common parse from multiple languages, or compile one representation <b>to</b> multiple languages; and whether you want the output to be ideal for each language, or just for the common representation to be ideal just so long as compiling to other languages "works".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552530319.089300"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552530319.089300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-03-13 19:25</span><br/>
Ironically, I was just listening to Barry Jay talk about the Pattern Calculus <a href="https://youtu.be/4i4SNvlWnmM?t=800">https://youtu.be/4i4SNvlWnmM?t=800</a>, which is a somewhat pleasing general semantics.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552533642.090700"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552533642.090700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-03-13 20:20</span><br/>
I'll take a look!<br/><br/>Also, anyone interested in universal language / semantics / syntax should really take a look at Ian Piumarta's "Open Reuseable Object Models" -- It's amazing, and makes the typical "meta object protocol" look weak. It used to be a document on <a href="http://VPRI.org">VPRI.org</a> (if it's not anymore)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552559435.091300"></a>
      <img src="https://secure.gravatar.com/avatar/42bcec88b9653a5c34e35a2be102e115.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552559435.091300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Max Desiatov</b>
<span style="margin:2em; color:#606060">2019-03-14 03:30</span><br/>
&gt; Someone reading that code above, has to now understand the @available keyword, and the deep meaning of @available(*, unavailable).<br/><span style="background-color:#ccf">@magicmouse94937</span> Please allow me to disagree with this, you've picked a contrived example that uses an advanced feature. Do I understand correctly that your point is that this feature shouldn't exist in Swift because anyone would need to learn what this feature is about before using it? In my opinion this could applied to any language, including those that are for some reasons unknown to me are considered "simple". Let's take Python for example, which many people claim is "easy to learn". I can list an example in Python that uses metaclasses and then claim that Python is broken because people now have to learn metaclasses to use Python. Which probably wouldn't make any argument of this kind valid
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552559589.091500"></a>
      <img src="https://secure.gravatar.com/avatar/42bcec88b9653a5c34e35a2be102e115.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552559589.091500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Max Desiatov</b>
<span style="margin:2em; color:#606060">2019-03-14 03:33</span><br/>
As for complexity, most of the features recently added to Swift reduce complexity in my opinion. Thanks to <tt>@available</tt> attribute I can mark almost any term as available in a specific version of the language without worrying about users stumbling upon it with an unsupported version of the compiler. I don't have to maintain multiple versions of my libraries to allow my users to pick any version of Swift compiler they choose. Compare this with a world of pain caused by Python 2 to Python 3 transition
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552559804.091700"></a>
      <img src="https://secure.gravatar.com/avatar/42bcec88b9653a5c34e35a2be102e115.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552559804.091700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Max Desiatov</b>
<span style="margin:2em; color:#606060">2019-03-14 03:36</span><br/>
And I never stumbled upon any beginner learning Swift complaining about <tt>@available</tt> attribute making anything complex for them. In fact, this is still an advanced feature that you have to search hard to see it used anywhere. Beginners are never concerned with it when they don't need it due to the progressive disclosure principle, which is fundamental to Swift. You can use as many features of Swift as you like and only when you're ready. That's what makes Swift Playgrounds so great by the way: people can be introduced to this language gradually step by step as they see fit. They can go through first tutorials without knowing what generics are how error handling works. And can proceed to more advanced features only when they need them.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1552559940.091900"></a>
      <img src="https://secure.gravatar.com/avatar/42bcec88b9653a5c34e35a2be102e115.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png" style="float:left"/>
      <a href="../share-your-work/1552463735.064500.html#1552559940.091900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Max Desiatov</b>
<span style="margin:2em; color:#606060">2019-03-14 03:39</span><br/>
Also, compare this with Objective-C, which right out of the gate forced you to understand what a pointer is and what's the difference between stack vs heap allocation.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
