[
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717108290.114059",
        "client_msg_id": "f93e816c-fbea-4e5d-9529-be43cf3c58fb",
        "text": "The reason the relational model forbids this — the reason it is restricted to first order logic — is that this runs into the halting problem.\n\nRoughly, once relations can refer to other relations, they can form arbitrarily complex structures where queries never finish. The relational model is, almost mathematically so, the richest model you can have where queries always finish.\n\nNote that in the above suggestions where you refer to other relations by a code, you have to go into your external, Turing-complete language to use this.\n\nNot a reason a database should not have this feature, of course, but this might be a useful nuance to be aware of.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3ecb3076c7b0",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-08-29\/5820723719363_3ecb3076c7b047d665ea_72.jpg",
            "first_name": "Guyren",
            "real_name": "Guyren Howe",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "guyren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8Cepu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The reason the relational model forbids this — the reason it is restricted to first order logic — is that this runs into the halting problem.\n\nRoughly, once relations can refer to other relations, they can form arbitrarily complex structures where queries never finish. The relational model is, almost mathematically so, the richest model you can have where queries always finish.\n\nNote that in the above suggestions where you refer to other relations by a code, you have to go into your external, Turing-complete language to use this.\n\nNot a reason a database should not have this feature, of course, but this might be a useful nuance to be aware of."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717111273.665189",
        "client_msg_id": "8be235dd-9872-4c08-af59-1acff9fc410f",
        "text": "That helps explain it, thanks.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "foO19",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That helps explain it, thanks."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AD80KMLK",
        "type": "message",
        "ts": "1717116852.043579",
        "client_msg_id": "1b0e057b-5a9f-4967-a84b-9785a9ab57fa",
        "text": "Every programming language runs into the halting problem, and yet, we don't care. Why do we care for a knowledge language?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "a07cdcb6d037",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-09\/1376906509376_a07cdcb6d037bf7b6a5e_72.jpg",
            "first_name": "",
            "real_name": "Denny Vrandečić",
            "display_name": "Denny Vrandečić",
            "team": "T5TCAFTA9",
            "name": "dvrandecic",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LmMnC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Every programming language runs into the halting problem, and yet, we don't care. Why do we care for a knowledge language?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717117230.601369",
        "client_msg_id": "52068BF3-4651-4BD3-9AA5-CDA492836FBE",
        "text": "SQL has poisoned the entire industry. So you’re used to thinking of a relational database as this heavyweight, fixed sort of thing with a terrible query language.\n\nThe correct way to understand the relational model is that it lets you separate your first order logic (FOL) computation from the stuff that should be (either logically or pragmatically) done in a Turing complete language.\n\nThe vast majority of the logic in just about any program can be written in FOL. Folks don’t even think about doing that because SQL is terrible.\n\nOne of the great features of the relational model is that precisely because of its limits, optimisation is a relatively simple problem. We should be able to use relations freely across all of our programming tasks. The result would be that you can just declaratively specify what comes from what, and the query optimiser will make it work efficiently.\n\nThese considerations still apply to SQL databases. If you execute a query, it will eventually finish and when it does, you’re guaranteed that if some data satisfies your query, it will be retrieved.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3ecb3076c7b0",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-08-29\/5820723719363_3ecb3076c7b047d665ea_72.jpg",
            "first_name": "Guyren",
            "real_name": "Guyren Howe",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "guyren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "j0FMM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "SQL has poisoned the entire industry. So you’re used to thinking of a relational database as this heavyweight, fixed sort of thing with a terrible query language.\n\nThe correct way to understand the relational model is that it lets you separate your first order logic (FOL) computation from the stuff that should be (either logically or pragmatically) done in a Turing complete language.\n\nThe vast majority of the logic in just about any program can be written in FOL. Folks don’t even think about doing that because SQL is terrible.\n\nOne of the great features of the relational model is that precisely because of its limits, optimisation is a relatively simple problem. We should be able to use relations freely across all of our programming tasks. The result would be that you can just declaratively specify what comes from what, and the query optimiser will make it work efficiently.\n\nThese considerations still apply to SQL databases. If you execute a query, it will eventually finish and when it does, you’re guaranteed that if some data satisfies your query, it will be retrieved."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UFEQUBNNT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717117346.144229",
        "client_msg_id": "757F84F6-DCAB-4ED4-A515-A6ACF1E9514D",
        "text": "If we use a database that is Turing complete, you can write something that is logically correct, but the query engine might not be able to determine that. It is a great virtue that if something is true of your data, if you can express it in FOL, your database can find it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3ecb3076c7b0",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-08-29\/5820723719363_3ecb3076c7b047d665ea_72.jpg",
            "first_name": "Guyren",
            "real_name": "Guyren Howe",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "guyren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RrWPf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If we use a database that is Turing complete, you can write something that is logically correct, but the query engine might not be able to determine that. It is a great virtue that if something is true of your data, if you can express it in FOL, your database can find it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717124646.864589",
        "client_msg_id": "02e576a1-0169-4a2d-b189-cc4694c644f3",
        "text": "I have difficulty gauging how practical a virtue the guarantee of termination really is. I can end up with non-terminating code elsewhere, and I just fix it. Is the benefit perhaps that someone cannot add data that makes a query stop terminating that used to terminate? Because not a lot of people are letting users run arbitrary untested queries against their data. So it feels like you would know in advance it will terminate unless the data can stop that from happening, maybe?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0k73i",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have difficulty gauging how practical a virtue the guarantee of termination really is. I can end up with non-terminating code elsewhere, and I just fix it. Is the benefit perhaps that someone cannot add data that makes a query stop terminating that used to terminate? Because not a lot of people are letting users run arbitrary untested queries against their data. So it feels like you would know in advance it will terminate unless the data can stop that from happening, maybe?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U01AD80KMLK",
                    "UFEQUBNNT"
                ],
                "count": 2
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717125096.775079",
        "client_msg_id": "CE6701D9-1564-4E9B-99DD-28FE638C4270",
        "text": "The relational model is, basically, “essence of declarative programming”. 2nd order logic, subject to halting problems, currently mostly needs to be written by humans. But the rest of it can be declarative — most of most programs, in fact. The part you can express in FOL benefits from this essence of declarative stuff insofar as you can just declare the rules of what facts follow from what other facts, and then the computer writes an efficient algorithm to implement the logic for you.\n\nThe relational model provides a theory for generating code from declarations about what is true and what follows from what.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3ecb3076c7b0",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-08-29\/5820723719363_3ecb3076c7b047d665ea_72.jpg",
            "first_name": "Guyren",
            "real_name": "Guyren Howe",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "guyren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KHRb0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The relational model is, basically, “essence of declarative programming”. 2nd order logic, subject to halting problems, currently mostly needs to be written by humans. But the rest of it can be declarative — most of most programs, in fact. The part you can express in FOL benefits from this essence of declarative stuff insofar as you can just declare the rules of what facts follow from what other facts, and then the computer writes an efficient algorithm to implement the logic for you.\n\nThe relational model provides a theory for generating code from declarations about what is true and what follows from what."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717125948.693559",
        "client_msg_id": "911216cf-2058-4962-b424-3ea26d1f4167",
        "text": "Don't get me wrong. I'm sold on declarative  logic code. Love it, terminating issues and all. Big fan. I just am not sold on the FOL limitation, and I'm having difficulty believing that anyone without a comp sci degree really cares about guaranteed termination that much, unless it is guaranteed against changes in the data.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uAi3f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Don't get me wrong. I'm sold on declarative  logic code. Love it, terminating issues and all. Big fan. I just am not sold on the FOL limitation, and I'm having difficulty believing that anyone without a comp sci degree really cares about guaranteed termination that much, unless it is guaranteed against changes in the data."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717126060.338729",
        "client_msg_id": "EA67D097-C8F5-41BA-BE7E-1FB0659625AF",
        "text": "But that right there is one reason for the design. If you have a language in which someone *can’t express* a non-terminating query, they don’t have to understand any of that, but they know they have a completely reliable system that always answers their questions.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3ecb3076c7b0",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-08-29\/5820723719363_3ecb3076c7b047d665ea_72.jpg",
            "first_name": "Guyren",
            "real_name": "Guyren Howe",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "guyren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1PzCv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But that right there is one reason for the design. If you have a language in which someone "
                            },
                            {
                                "type": "text",
                                "text": "can’t express",
                                "style": {
                                    "bold": true,
                                    "italic": false,
                                    "strike": false
                                }
                            },
                            {
                                "type": "text",
                                "text": " a non-terminating query, they don’t have to understand any of that, but they know they have a completely reliable system that always answers their questions."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02U0AS3J49",
        "type": "message",
        "ts": "1717127206.613369",
        "client_msg_id": "e48a6607-4fc3-4637-bc8f-8cb81941e244",
        "text": "Regardless of the data, or just regardless of the query?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5247a9c6cbb",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5247a9c6cbb943683c9e2e2cef6eba79.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Jason",
            "real_name": "Jason Morris",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "jason",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uUEW\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Regardless of the data, or just regardless of the query?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFEQUBNNT",
        "type": "message",
        "ts": "1717128658.159119",
        "client_msg_id": "39553A76-CEEC-4B19-A047-84DAE83D01A3",
        "text": "I’m curious too. If every query has a 60-second deadline, valid FOL and SOL queries will both sometimes fail. How much does it matter why? Are the performance problems harder to diagnose and fix with the more complicated languages? Are they more common?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "565c54a4fa91",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2508698086192_565c54a4fa91a0c8c75a_72.png",
            "first_name": "Tom",
            "real_name": "Tom Lieber",
            "display_name": "alltom",
            "team": "T5TCAFTA9",
            "name": "tom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FdUcu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I’m curious too. If every query has a 60-second deadline, valid FOL and SOL queries will both sometimes fail. How much does it matter why? Are the performance problems harder to diagnose and fix with the more complicated languages? Are they more common?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFEQUBNNT",
        "type": "message",
        "ts": "1717128727.979669",
        "client_msg_id": "E3A7EBF8-8E1D-4AA0-8012-B53FE46DDA30",
        "text": "I was playing with the idea of a query language the other day and realized that I was limiting myself to FOL. So I questioned the choice.\n\nI came to realize that apps will need additional flexibility in how they process data before it can be presented, and limiting the query language wasn’t going to make that requirement go away. All I was doing was forcing algorithms to be split across database and client, instead of allowing the entire algorithm to be done in one language. Worse, if the seam is in the middle of an algorithm, I might be forcing multiple network calls, with all the de\/serialization that entails, to satisfy one semantic query. For what? So that I can say that every operation my database supports is fast? Wouldn’t I rather say that my database is easy to use?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "565c54a4fa91",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2508698086192_565c54a4fa91a0c8c75a_72.png",
            "first_name": "Tom",
            "real_name": "Tom Lieber",
            "display_name": "alltom",
            "team": "T5TCAFTA9",
            "name": "tom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wX+gG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was playing with the idea of a query language the other day and realized that I was limiting myself to FOL. "
                            },
                            {
                                "type": "text",
                                "text": "So "
                            },
                            {
                                "type": "text",
                                "text": "I questioned the choice."
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "I came to realize that apps will need "
                            },
                            {
                                "type": "text",
                                "text": "additional"
                            },
                            {
                                "type": "text",
                                "text": " flexibility in how they process data before it can be presented, and limiting the query language wasn’t going to make that requirement go away. All I was doing was forcing algorithms to be split across database and client, instead of allowing the entire algorithm to be done in one language. Worse, if the seam is in the middle of an algorithm, I might be forcing multiple network calls"
                            },
                            {
                                "type": "text",
                                "text": ", with all the de\/serialization that entails,"
                            },
                            {
                                "type": "text",
                                "text": " to satisfy one semantic query. For what? So that I can say that every operation my database supports is fast? Wouldn’t I rather say that my database is easy to use?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UFEQUBNNT",
        "type": "message",
        "ts": "1717128855.513579",
        "client_msg_id": "4BFE35BA-15B8-42A1-A8FF-49250A62E1FF",
        "text": "I decided that I’d rather bring relational operations to a more complex language, and just isolate them enough that they can be plucked out by an optimizer.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "565c54a4fa91",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-09-13\/2508698086192_565c54a4fa91a0c8c75a_72.png",
            "first_name": "Tom",
            "real_name": "Tom Lieber",
            "display_name": "alltom",
            "team": "T5TCAFTA9",
            "name": "tom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HBmAH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I decided that I’d rather bring relational operations to a more complex language, and just isolate them enough that they can be plucked out by an optimizer."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717129027.057379",
        "client_msg_id": "1E310FAD-B045-4581-B6E3-AA7425DEB6EC",
        "text": "Aha! You discovered the weakness in my cunning ruse!\n\nNot really. You can certainly write SQL queries that will time out. But in practice, those are rare, and if you had to solve the same problem in a Turing-complete language, there’s a good chance you have no other way to fix it.\n\nComputation complexity is always with us, either way.\n\nAnd in practice, there might be some things that are easier to write in a TC language. But I’d have to struggle with some quite unusual sort of data for a while to produce an example.\n\nSo: a relational database can represent most of most programs more cleanly and simply than any mainstream TC language can, and it does a lot of the programming for you, particularly in terms of working out what order it should process each part of your logic in. And, because it can do that dynamically and automatically, it can retain efficiencies even as you change the model, whereas the typical TC solution might need substantial re-engineering to retain efficiency.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3ecb3076c7b0",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-08-29\/5820723719363_3ecb3076c7b047d665ea_72.jpg",
            "first_name": "Guyren",
            "real_name": "Guyren Howe",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "guyren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xFOvz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Aha! You discovered the weakness in my cunning ruse!\n\nNot really. You can certainly write SQL queries that will time out. But in practice, those are rare, and if you had to solve the same problem in a Turing-complete language, there’s a good chance you have no other way to fix it.\n\nComputation complexity is always with us, either way.\n\nAnd in practice, there might be some things that are easier to write in a TC language. But I’d have to struggle with some quite unusual sort of data for a while to produce an example.\n\nSo: a relational database can represent most of most programs more cleanly and simply than any mainstream TC language can, and it does a lot of the programming for you, particularly in terms of working out what order it should process each part of your logic in. And, because it can do that dynamically and automatically, it can retain efficiencies even as you change the model, whereas the typical TC solution might need substantial re-engineering to retain efficiency."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717129104.148369",
        "client_msg_id": "EA216CE1-EAB6-4B9B-85F5-A1600E664745",
        "text": "There is absolutely nothing wrong with a higher-order\/TC query\/logic language. Prolog is one such, is very useful for some types of problems, and is I believe easier for non-developers to learn than most TC languages. Mercury is another such, not so beginner friendly but very expressive and flexible.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3ecb3076c7b0",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-08-29\/5820723719363_3ecb3076c7b047d665ea_72.jpg",
            "first_name": "Guyren",
            "real_name": "Guyren Howe",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "guyren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pg0jX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is absolutely nothing wrong with a higher-order\/TC query\/logic language. Prolog is one such, is very useful for some types of problems, and is I believe easier for non-developers to learn than most TC languages. Mercury is another such, not so beginner friendly but very expressive and flexible."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717129245.444489",
        "client_msg_id": "E1EE9408-AAC0-4C7C-8997-07C50DF58137",
        "text": "Codd’s original conception was that the relational database engine would be used in combination with a TC language. Predicates for filters, for example, are not part of the relational theory but are just supplied from a TC language.\n\nSo your idea for a language that contains both but separates them is not terrible. Although even with SQL, you can see the advantage of separating the relational side. One of the most underappreciated advantage of a separate relational storage engine is that you can use the same data store from multiple programs, written in different languages.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3ecb3076c7b0",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-08-29\/5820723719363_3ecb3076c7b047d665ea_72.jpg",
            "first_name": "Guyren",
            "real_name": "Guyren Howe",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "guyren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XbmCk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Codd’s original conception was that the relational database engine would be used in combination with a TC language. Predicates for filters, for example, are not part of the relational theory but are just supplied from a TC language.\n\nSo your idea for a language that contains both but separates them is not terrible. Although even with SQL, you can see the advantage of separating the relational side. One of the most underappreciated advantage of a separate relational storage engine is that you can use the same data store from multiple programs, written in different languages."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U05PY5AQCA2",
        "type": "message",
        "ts": "1717132374.515389",
        "client_msg_id": "3943CBFB-B006-471E-9C45-C837A3901C48",
        "text": "SQLite is interesting, in that actually leans a fair way into injecting the TC language. The features are not as well known as they should be, and depend on whether the language embedding supports it, but in SQLite, the host application\/language can potentially define:\n• regular functions;\n• aggregate functions; and;\n• (what most folks don’t know) custom type deserialisers.\nPostgres has close similar features also.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "3ecb3076c7b0",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-08-29\/5820723719363_3ecb3076c7b047d665ea_72.jpg",
            "first_name": "Guyren",
            "real_name": "Guyren Howe",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "guyren",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1716832997.950009",
        "parent_user_id": "U02U0AS3J49",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "F0WaF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "SQLite is interesting, in that actually leans a fair way into injecting the TC language. The features are not as well known as they should be, and depend on whether the language embedding supports it, but in SQLite, the host application\/language can potentially define:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "regular functions;"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "aggregate functions; and;"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "(what most folks don’t know)"
                                    },
                                    {
                                        "type": "text",
                                        "text": " custom type deserialisers."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "offset": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nPostgres has close similar features also."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]