<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <a href="../share-your-work/1565111628.102100.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-06 10:13</span><br/>
Programming is hard because the brain, formalism, and hardware are all dissimilar but must reconcile with each other. These three conflicting entities might be called the <em>incongruous triumvirate of programming</em>.<br/><br/>Is this correct?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565112139.102400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565112139.102400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-06 10:22</span><br/>
I would say no. Since one of the 3, the brain, is invariably going to adapt itself the best it can to the other two. You can do this from 2 perspectives.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565112304.102600"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565112304.102600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-06 10:25</span><br/>
You can try and understand hardware deeply, then try to understand formal computation in terms of that.. this will give you a 2-step line, not a triangle. This is what I've done, and I feel it really simplifies the picture. Of the 3, the formal computation is the most artificial one as it is purely a man made construct, so it is fine to be understood in terms lower level hardware. Generally, understanding higher level concepts in terms of lower level ones seems easier, since it requires fewer concepts to be understood by the brain.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565112422.102800"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565112422.102800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-06 10:27</span><br/>
Or, you can try to make your brain think in terms of formal computation, and then later understand hardware in terms of it. This to me seems extremely painful, as you can never make a clean mapping for this. It is trying to understand the house before the bricks, and put your brain forever on shaky ground
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565112540.103000"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565112540.103000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-06 10:29</span><br/>
There are many different ways to understand computation at a more high level, and only one at a lower level. Should be easy for your brain to know where to start :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565115370.103300"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565115370.103300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-06 11:16</span><br/>
I'm aiming to bring programming straight to the brain bit of your diagram.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565115465.103500"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565115465.103500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-06 11:17</span><br/>
My search for the essence of programming is a search for a cognitively-satisfying programming model.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565115544.103700"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565115544.103700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-06 11:19</span><br/>
Finding a theoretical foundation or an efficient implementation is a lower priority
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565115573.103900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565115573.103900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-06 11:19</span><br/>
That means you're still in the bottom left corner of that diagram, and since you're still needing to run on actual hardware, you're still causing a lot of inescapable pain to the brain
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565115633.104100"></a>
      <img src="https://secure.gravatar.com/avatar/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565115633.104100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Will Crichton</b>
<span style="margin:2em; color:#606060">2019-08-06 11:20</span><br/>
I like the diagram. I think about it as: formal computation embodies the way you <em>want</em> to think about a problem. You build precise mathematical models at just the right level of abstraction. Physical hardware embodies the way you <em>have</em> to think about a problem. If you want your program to run on a computer, you can’t ignore the hardware. Both of those are far from the brain for different reasons. Hardware is <em>arbitrary</em>, meaning the laws of physics dictated a particular (unintuitive) programming model. Math is… well, math. Thinking in formal languages is not an innate skill, it must be learned.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565115697.104300"></a>
      <img src="https://secure.gravatar.com/avatar/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565115697.104300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Will Crichton</b>
<span style="margin:2em; color:#606060">2019-08-06 11:21</span><br/>
This is why I teach programming languages as a bridge between theory and systems :slightly_smiling_face: <a href="http://cs242.stanford.edu">cs242.stanford.edu</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565115788.104600"></a>
      <img src="https://secure.gravatar.com/avatar/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565115788.104600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Will Crichton</b>
<span style="margin:2em; color:#606060">2019-08-06 11:23</span><br/>
I would highly recommend reading “On the cruelty of really teaching computing science” (Dijkstra) because I think it does a good job conveying part of why computing is hard for our animal brains. <a href="http://www.cs.utexas.edu/~EWD/transcriptions/EWD10xx/EWD1036.html">http://www.cs.utexas.edu/~EWD/transcriptions/EWD10xx/EWD1036.html</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565115850.104900"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565115850.104900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-06 11:24</span><br/>
I've found that designing for the cognitive essence of programming is surprisingly close to the formal computation vertex anyway. Probably because they're both declarative.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565115850.105100"></a>
      <img src="https://secure.gravatar.com/avatar/ce240a8e5a8fdc65e86bbb869975ccfe.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565115850.105100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Will Crichton</b>
<span style="margin:2em; color:#606060">2019-08-06 11:24</span><br/>
“From a bit to a few hundred megabytes, from a microsecond to a half an hour of computing confronts us with completely baffling ratio of 10^9! The programmer is in the unique position that his is the only discipline and profession in which such a gigantic ratio, which totally baffles our imagination, has to be bridged by a single technology. He has to be able to think in terms of conceptual hierarchies that are much deeper than a single mind ever needed to face before. Compared to that number of semantic levels, the average mathematical theory is almost flat. By evoking the need for deep conceptual hierarchies, the automatic computer confronts us with a radically new intellectual challenge that has no precedent in our history.”
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565116533.105500"></a>
      <a href="../share-your-work/1565111628.102100.html#1565116533.105500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-06 11:35</span><br/>
I should note that I’m most concerned about fundamental limitations.  The brain and formalisms are “incommensurate” not only because the brain is neurons while the lambda calculus is not but also because the brain is only good at communicating with actors who also understand human motivations and goals—it’s much easier to train an employee than it is to train a computer. Strong AI might let us cheat. So, <span style="background-color:#ccf">@Duncan Cragg</span>, I’m curious if your formalism encodes knowledge about the human world.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565117011.105900"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565117011.105900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-06 11:43</span><br/>
Humans have evolved their cognition in a physical world so it's possible to let them model and manifest in that world (i.e. "program") in an intuitive way. Computer theoreticians can do the hard work of formalising all that stuff, but normal people don't need all that. Don't forget in this whole discussion that all of us here are crawling around on the bottom of your diagram like a bunch of weirdos!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565117340.106100"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565117340.106100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-06 11:49</span><br/>
So no, "encoding knowledge about the human world" isn't part of that,  or at least no more than helpful additions after the fact, like Excel's £ and % formatting, types that are the fun bit, the I/O or reality interface on top of a type free "formalism" (which we wouldn't tell our users is a"formalism").
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565120081.109400"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565120081.109400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-06 12:34</span><br/>
Really enjoyed reading the Dijkstra paper, thanks <span style="background-color:#ccf">@Will Crichton</span>). Totally disagree with half of it (the radical novelty bit) but the other half (the importance of balancing the bottom left and right of <span style="background-color:#ccf">@Brian Hempel</span>'s diagram) resonated with me as one of us who live their lives down there!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565121299.109700"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565121299.109700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-06 12:54</span><br/>
The bottom of the above diagram is really a declarative---imperative split, and I believe the top of the diagram, the cognitive, should be declarative, too. So some of Dijkstra's pro declarative arguments also apply to that.  Maybe an Excel user's Leibniz's Dream!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565122242.109900"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565122242.109900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-08-06 13:10</span><br/>
I think the original diagram is 100% accurate, based on the way things currently / typically work. However, that does not mean that it is <b>ideal</b>. Many of us are trying to make programming more tractable by reducing the gap between those 3 areas. For example, there's no reason that notation or hardware <b>has</b> to be so different. Or that code (languages, structure, or interface for it) <b>has</b> to be different from human mental models. They're not fundamentally different, they're incidentally different.<br/><br/>As for the bricks before house thing, you can have the most durable solid cost-effective heat-efficient house, but still have it fail to be a good house. A good house is about what a house is for, what happens in it. That's about people and patterns of events, and those events are about patterns of life, etc. So you've <b>got</b> to understand what makes a good house <b>for people</b> first, and*then* understand how to do that in a solid, effective, etc. way.<br/><br/>References:<br/><li> BV's Learnable Programming (a human is not a machine, and should not be made to think like one)<br/><li> Christopher Alexander - (Todo: look up this quote ... I'll edit this later. Gist is about finding a structure that will fit that patterns of events of the ones inhabiting it)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565125750.110400"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565125750.110400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-06 14:09</span><br/>
&gt; there’s no reason that notation or hardware <b>has</b> to be so different. Or that code (languages, structure, or interface for it) <b>has</b> to be different from human mental models. They’re not fundamentally different, they’re incidentally different<br/>I agree that we are trying to reduce the mismatch between the three, and I agree that accidental complexity dominates many if not most uses of computers. However, the differences between the brain, math, and hardware are fundamental: brains are designed for socialization and survival, not math, and hardware always has physical limits that need to be managed in practice (out of memory, computation won’t finish before the universe ends). We will always be stuck with finite hardware, so that part of the diagram isn’t going away, and until we can control our computers with Strong AI instead of with something mathy, we’re stuck with formal computation as well. (Unless you can think of something other than Strong AI that can sufficiently interface with human motivations—but don’t forget the failure of the original AI movement!)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565125915.110600"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565125915.110600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-08-06 14:11</span><br/>
Interesting topic. 'Why X is hard' is a very difficult if not impossible question to answer. E.g. did folks realize 'why arithmetic is hard' when working with roman numerals? Did they say 'actually arithmetic is hard because the <b>notation</b> we use doesn't make some operations easy'? I doubt it. The very notion of <b>notation</b> was likely not present in the mental model of people - otherwise they might have set out for a better notation sooner. What about building larger huts and houses? Did folks realize they needed architecture? Perhaps when the only things they saw is material strength, they might have thought that the only thing they need are stronger materials to build larger structures.<br/><br/>So we might not know why programming is hard until (and if) we find mental models that makes some things significantly easier. I look at the above diagram above as a specific mental model. One thing that seems missing is cognition - where does that fit in? Isn't the entire model inside our brains (so there should be a larger brain surrounding the entire diagram?). We have a mental model of all three things in there (even if they are hard to simulate, we do have the capacity to model them). A tangential question I would ask based on the above diagram is: in a world where programming is significantly easier, what is the mental model of human computer interaction? Is it still the above diagram?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565127948.110900"></a>
      <a href="../share-your-work/1565111628.102100.html#1565127948.110900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-06 14:45</span><br/>
<span style="background-color:#ccf">@Shalabh</span> Fascinating challenge. There will always be mediation between humans and the machines—we know that’s fundamental at least—but can we confidently say the mediating mechanism, the models, will always be harder than necessary for our brains to manage? I answer, “Perhaps so.” Because, absent strong AI, saying that the brain has a model means that it will be the brain’s job to perform activities within the model, without help from the computer. You might replace the “formalism” bit of the diagram with “mental model of computation”.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565128982.111300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565128982.111300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-08-06 15:03</span><br/>
Ok this new diagram is much more interesting (to me :smile:). I think the red labels hit some important problems. Maybe the mediating mechanism should be place on the line between brain and hardware?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565129512.111500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565129512.111500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-08-06 15:11</span><br/>
The reason we have mediating mechanisms is because hardware is far away from direct human capacity (mental or physical). Even our model of hardware is a mediating mechanism I think. It's just further away from the other concepts we deal with (domain models?) and so we the other mediation mechanisms.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565129832.111700"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565129832.111700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-06 15:17</span><br/>
Yeah I thought about drawing the whole diagram on a line :brain: &lt;---&gt; λ &lt;---&gt; :desktop_computer:  but that didn’t feel as nice :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565130502.112000"></a>
      <a href="../share-your-work/1565111628.102100.html#1565130502.112000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-06 15:28</span><br/>
The machine just doesn’t care.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565131360.112500"></a>
      <img src="https://secure.gravatar.com/avatar/e52a48f76fc911d40711f788d74773a0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565131360.112500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brendan Zabarauskas</b>
<span style="margin:2em; color:#606060">2019-08-06 15:42</span><br/>
I do think that often the brain doesn’t know what it actually wants, or what it wants is ill-formed/problematic/broken
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565131427.112700"></a>
      <img src="https://secure.gravatar.com/avatar/e52a48f76fc911d40711f788d74773a0.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565131427.112700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brendan Zabarauskas</b>
<span style="margin:2em; color:#606060">2019-08-06 15:43</span><br/>
the job of a good UI/formal system is to guide one through the process of clarifying what the brain <em>actually</em> wants to do
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565139603.113100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565139603.113100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-08-06 18:00</span><br/>
The purple box is the interesting bit because there are relationships between the objects in there. E.g. how is lambda calculus related to the hardware model? How is it related to the real world domains that we simulate or compute for? Certain models may have more 'cognitive sympathy'.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565139691.113300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565139691.113300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-08-06 18:01</span><br/>
I like the direction this diagram is taking :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565139867.113600"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565139867.113600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-08-06 18:04</span><br/>
I like this diagram because it highlights there is a gap between formal computation and the hardware. In my own Beads project, i have effectively created a virtual hardware platform that makes the two bottom items identical from the programmer's perspective. For example, formal computation is a lot easier to debug when your computer is reversible. That is something that no current hardware can do, and in fact current hardware makes it incredibly difficult to offer omniscient debugging.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565162545.116500"></a>
      <img src="https://avatars.slack-edge.com/2021-11-13/2722434855730_0c210ee2df74838f8683_72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565162545.116500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>nicolas decoster</b>
<span style="margin:2em; color:#606060">2019-08-07 00:22</span><br/>
Very interesting discussion, thanks! :slightly_smiling_face:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565163062.116700"></a>
      <img src="https://avatars.slack-edge.com/2021-11-13/2722434855730_0c210ee2df74838f8683_72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565163062.116700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>nicolas decoster</b>
<span style="margin:2em; color:#606060">2019-08-07 00:31</span><br/>
Maybe there is something interesting to add (sorry for adding complexity!). It is the social aspect of programming. It adds a new "dissimilarity" to the brain/formal/hardware ones (to use the diagram vocabulary), the dissimilarity between people. Different people with different mental view, different way of thinking and different capacity in grasping all this. This has an impact on the formal part. Different "formal computations" take this "people dissimilarity" differently (two examples: Brainfuck and Scratch).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565168817.116900"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565168817.116900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-07 02:06</span><br/>
<span style="background-color:#ccf">@Brian Hempel</span> I believe that you don't need any AI to help us talk to computers if you create a cognitively intuitive programming model (which I guess is then the corresponding "formalism").<br/><br/>Just checking though - what's the relationship between programming models (languages) and formalisms in your diagram?<br/><br/>So I believe that, in your original diagram, we could reduce the "incommensurate with" arrow's size. Then Programming Isn't Hard any more.. :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565174289.146600"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565174289.146600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2019-08-07 03:38</span><br/>
This is an exciting discussion! At the risk of taking this a little too meta, and because I am currently thinking a lot about thinking, I can’t help but add a few random thoughts:<br/><br/>(A) I don’t think the three objects in the original diagram are conceptually on the same layer. Trying to analyze differences between them, I see manifestations in the real world (both brain and electrical circuits) and abstract models (do both lambda calculus and Turing machine fall into Formal Computation?). Our brain copes with all of them, and likely has its own abstract model which is different from the ones in Formal Computation.<br/><br/>(B) That, however, could also lead to the conclusion that maybe all three objects are in fact on the same conceptual level and just represent three different mental models optimizing for different goals by abstracting (removing) certain limiting properties: the machine model optimizing for physical implementation giving up formal simplicity (beauty) for pragmatism, the formal model(s) optimizing for a simple logic representation giving up real-world constraints (e.g. computation time), and our own mental model optimizing for understanding and applicability giving up clear deterministic rules and algorithms and replacing them with meta-cognitive constructs we don’t understand (yet).<br/><br/>(C) When I try to put things in a visual diagram, I usually think a lot about patterns in the relationships between the objects I want to combine. As already discussed above, I also immediately thought, “are we looking at a continuum here, with objects marking certain points on that spectrum?” The extremes could be something like <em>physical manifestation</em> and <em>logical manifestation</em>, or perhaps even bolder <em>concrete</em> vs. <em>abstract</em>? But then what insights would this perspective really offer on top of what we already know?<br/><br/>(D) The next thing I’d try is to look for a fourth object — are we possibly looking at a 2-by-2 with two distinct dimensions, and are just missing one element? That often works surprisingly well (and gave us a whole industry called “consulting” ;-)<br/>If we keep the <em>physical</em> vs. <em>logical</em> dimension from (C) and try to add another one, what could be it? If we want to take the route towards adding “Worldly Goals” as the 4th object, then there is something about both the brain and the world that’s much less specific/defined/known than computation and hardware. I think that is partly what <span style="background-color:#ccf">@Brian Hempel</span> expressed with “The machine just doesn’t care.” So maybe a <em>care</em> vs. <em>don’t care</em> dimension, where our brains and the world look for purpose to apply hardware and computation to?<br/><br/>(E) Riffing off of (D) maybe it’s about mind vs. machine? A mind driven by purpose trying to understand and control a machine that just executes computations? Then a possible answer to the initial question “Why is programming hard?” could perhaps be “because we are having a hard time encoding purpose into a system that has defined away any purpose”. Which also makes me suddenly realize that I have to re-think my stance on AI…<br/><br/>Just thinking out loud here… maybe it inspires some new paths.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565187701.147900"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565187701.147900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-07 07:21</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span> teleology strikes again!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565192903.148300"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565192903.148300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-08-07 08:48</span><br/>
Without purpose, there's no meaning or value, and the components of a software system may as well be modeled to shaking a bag of rocks. Incidental complexity is somewhat like that, I suppose: you learn to see the parts of the code or system that are relevant, and the rest is just noise (boilerplate, wiring, syntax)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565208052.150800"></a>
      <img src="https://secure.gravatar.com/avatar/a212b1b5a546c274ae1b67f380cc922e.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565208052.150800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joel Holdbrooks</b>
<span style="margin:2em; color:#606060">2019-08-07 13:00</span><br/>
Something about this strikes me as uncomfortably assumptive and speculative. What evidence is guiding the construction of the graph?<br/><br/>“Why Programming is Hard” makes the assumption that programming, in general, is hard. However, we know that for all instances of “programming is hard” this is not true. The valuation of difficulty is context dependent with, likely, many more variables than what appear in any of these diagrams.<br/><br/>Rather than start from “programming is hard” as an axiom, we should start from the question “Is programming hard?” and, if so, “For who?” and “Why?“.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565208548.151000"></a>
      <img src="https://secure.gravatar.com/avatar/a212b1b5a546c274ae1b67f380cc922e.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565208548.151000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joel Holdbrooks</b>
<span style="margin:2em; color:#606060">2019-08-07 13:09</span><br/>
“When is programming hard?” is another question we might ask.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565212393.151200"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565212393.151200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-08-07 14:13</span><br/>
Also, what does 'hard' mean?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565212415.151400"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565212415.151400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-08-07 14:13</span><br/>
Is maths hard?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565239317.151700"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565239317.151700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-08-07 21:41</span><br/>
Programming is observably difficult. Currently, it requires a personality that has a great deal of patience. If it was only as hard as crossword puzzles, it would have a more diverse set of practitioners. Besides being time consuming and frustrating, it is also observably not a very repeatable field, where one can accurately estimate the completion time for various tasks. So i think the evidence is overwhelming that programming is a demanding field. And yes there are people that have a knack for it, just like any other tricky skill like juggling, it isn't broadly distributed.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565241569.151900"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565241569.151900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-08-07 22:19</span><br/>
The very existence of this community is due to the fact that programming is harder than it should be.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565241827.152300"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565241827.152300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-08-07 22:23</span><br/>
Shalabh makes a good point though: Maybe programming (or math(s)) in its pure form is not hard, and is maybe even something intuitive that everyone does without realizing it. But at the very least, the way it's currently represented and taught and perhaps even understood, etc., is certainly very hard.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565242477.152500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565242477.152500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2019-08-07 22:34</span><br/>
Yeah I was trying to see if we can qualify what we mean by hard and what it would mean to be not hard. E.g. <span style="background-color:#ccf">@magicmouse94937</span> brings up good points wrt repeatability, predictability etc. So we could say if we improve the situation, basic programming would be predictably learnable, mostly estimate-able and not generally frustrating after you learn it. Kinda like learning-to-drive hard, not WTF hard.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565277534.155700"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565277534.155700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-08 08:18</span><br/>
&gt; Maybe programming (or math(s)) in its pure form is not hard, and is maybe even something intuitive that everyone does without realizing it.<br/>Having tutored math, I would say the evidence points against mathematical thinking being innate. Particularly if “pure math” == “abstract math”. If math was fundamentally “something intuitive that everyone does without realizing it” I think we would have discovered that by now. And from a theoretical angle rather than an empirical angle, evolutionary theory suggests the brain is not primarily adapted for abstraction—why would it be? My understanding is that the ability to handle abstraction is largely a byproduct of our language facilities, which is a late arrival on the evolutionary tree and thus likely underdeveloped. Even the ability to work with metaphors (the more practical form of abstraction, and the form of abstraction more widely exercised in human history) doesn’t really develop in children until ~12 years of age.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565279332.156900"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565279332.156900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-08-08 08:48</span><br/>
<span style="background-color:#ccf">@Brian Hempel</span> do you know many five year olds?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565279962.163600"></a>
      <img src="https://secure.gravatar.com/avatar/a212b1b5a546c274ae1b67f380cc922e.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565279962.163600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joel Holdbrooks</b>
<span style="margin:2em; color:#606060">2019-08-08 08:59</span><br/>
The <b>when</b> and <b>what</b> are important. You could pick another topic with a perceived difficulty and you would need to qualify it’s difficulty much the same way.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565280329.168300"></a>
      <img src="https://secure.gravatar.com/avatar/a212b1b5a546c274ae1b67f380cc922e.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565280329.168300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Joel Holdbrooks</b>
<span style="margin:2em; color:#606060">2019-08-08 09:05</span><br/>
Also – and maybe I missed it – how is programming being defined?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565280671.168600"></a>
      <img src="https://avatars.slack-edge.com/2021-11-13/2722434855730_0c210ee2df74838f8683_72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565280671.168600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>nicolas decoster</b>
<span style="margin:2em; color:#606060">2019-08-08 09:11</span><br/>
Here is my guess: programming is the act to specify a desired behaviour for something else.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565282326.168900"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565282326.168900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-08 09:38</span><br/>
- what is programming? (Excel or C?)<br/> - who is programming? (demographic)<br/> - hard at first or hard always?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565282329.169100"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565282329.169100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-08 09:38</span><br/>
<span style="background-color:#ccf">@William Taysom</span> The kids were usually a bit older than that.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565282400.169600"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565282400.169600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-08 09:40</span><br/>
I think some of us may hold the opinion that abstraction is something 5 year olds can indeed do, so now we need to define abstraction as well.. :smile:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565283353.170100"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565283353.170100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2019-08-08 09:55</span><br/>
In fairness, the Animal Brain is mighty good at some things, and it's definitely different from conventional formal computation and physical hardware.  Nailing down what exactly is an interesting business.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565291890.170600"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565291890.170600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-08 12:18</span><br/>
So just checking, where do programming languages fit in the diagram?<br/>I mean, C seems over to the physical right, Haskel over to the formal left.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565291907.170800"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565291907.170800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-08 12:18</span><br/>
So are Excel, etc up at the cognitive top?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565726398.175600"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565726398.175600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-08-13 12:59</span><br/>
Excel is not magical; it too is a formal computation that creates a virtual computer that consists of an array (sheets) of 2D cells, each of which has simple addressing nomenclature (sheet1:B3), coupled with protected arithmetic, and automatic dependency calculations, plus a ton of pre-designed graphing and charting modules, and an escape hatch to use conventional programming (the visual basic scripting language inside). The fact that you rarely draw anything explicitly in Excel means you save 70% of the code. But Excel only works well if your data to code ratio is high. The more code you have the more cumbersome Excel becomes. The truth is that much of business relates to summing numbers, and clumping them into groups for the purposes of tracking sales. This requires so little logic, that Excel is the natural tool for such a thing. A genius invention by Frankston &amp; Bricklin, one of the fundamental tools of computers.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565726502.175800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565726502.175800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-08-13 13:01</span><br/>
Excel is terrible at handling business logic, because by default all the code is hidden in Excel, and the data is shown instead. In a commonly used language like Java the opposite happens: the data is invisible to the reader, but you see all the business logic in plain view.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1565814597.177200"></a>
      <img src="https://secure.gravatar.com/avatar/fbf9758a8150cef0eea447876cd48346.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0014-72.png" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1565814597.177200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Robert Hall</b>
<span style="margin:2em; color:#606060">2019-08-14 13:29</span><br/>
I’ve often thought that gamification is one right way to close the gap between formal computation and the brain. Not gamification in the typical way we think about it, but mostly in terms of the alignment of nonlinear thought processes and (quite frankly) fun.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566372487.180600"></a>
      <img src="https://avatars.slack-edge.com/2018-12-18/508431502471_8073c43d5d8dd3d3b4b2_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566372487.180600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Duncan Cragg</b>
<span style="margin:2em; color:#606060">2019-08-21 00:28</span><br/>
<a href="https://twitter.com/brianhempel/status/1163807830031425536">https://twitter.com/brianhempel/status/1163807830031425536</a> <span style="background-color:#ccf">@Brian Hempel</span> via <span style="background-color:#ccf">@Jonathan Edwards</span>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566376698.181400"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566376698.181400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-08-21 01:38</span><br/>
The Clayton Lewis paper is very interesting. There are some people in the programming language community that swear that programming is an unmeasurable activity, and that we cannot give a numerical score to a language in some dimension, like ease of use, or mean time to repair by someone other than the author which is the number i am optimizing for in my designs. I disagree with this attitude. We can indeed measure it classrooms and industry projects pretty directly. Once your sample size gets large enough, and you get past toy problems, the virtues or flaws of a language become glaringly apparent. I worked on a project for IBM at the very tail end of the Thomas J. Watson, Jr. era, and under Watson's regime, every important project at IBM had 3 different teams working on it, as a form of internal contest. This is obviously quite expensive, but it kept the teams in a competitive mindset. The winner of the contest who came in first and best was rewarded with extra funding, and losing teams like sports teams transferred staff around. Unfortunately by the time i worked on this project, IBM's management had deteriorated into what is now very common in children's sports where "everyone is a winner". They lacked guts to declare a winner, and IBM although is still a very company has almost no impact any more on the computer industry. They are a mere shadow of their former selves. When you have three different teams, and they use different languages for the same detailed specification, we saw Modula-2 outperform C by more than 2:1 on man-hours (which translates to cost), and 12 months instead of 18. Half the people in 3/4 the time translates to a 3:1 advantage of Modula-2 over C. The third project never even finished in time so one could argue it was even better than 3:1.<br/><br/>I believe that for a specified task, for each different language, you can rank and estimate the time it will take to implement, and also estimate how hard it will be to repair and update the project. No question that animating cats is easy in Scratch, and very easy to maintain, and it would be cumbersome to that task in Java. The reason we have so many languages to choose from is because we are making such a wide variety of software. I know of many projects which are impossible to do in anything but Mathematica, because it symbolic solving language, and unlike any other conventional language.<br/><br/>I fought unsuccessfully to get other companies and teams to adopt Modula-2. They did not care if it offered consistent, significant advantages, because it wasn't what everyone else is using. Human beings are herd animals, and the glacial pace of improvement in software is due in part to the stubbornness and herd instinct of humans. Here we are more than 30 years after Modula-2, and Javascript a little while ago added to their syntax a slightly botched subset of the Modula2 module system, and that's considered an exciting feature that is taking years to roll out into the browsers. As of today, you can only run local modules in Safari, because Chrome considers it a security risk. It is so frustrating to see things from decades, slowly rolling out drip by drip.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566400523.181600"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566400523.181600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-08-21 08:15</span><br/>
Thanks for the story, <span style="background-color:#ccf">@magicmouse94937</span>. It’s so rare to hear actual head-to-head stories between languages! Maybe quantitative measurement isn’t impossible, but in practice it probably is for basically everyone. IBM had money to hire multiple teams for multiple months, but academics and people on this Slack do not. (And even in your story, a scientific purist could complain that it wasn’t a <em>real</em> randomized controlled trial (RCT): the purist would want to control for different managers and team dynamics. Find 20 managers, randomly assign engineers to managers, assign 10  teams to C, 10 to Modula-2, and task them all with the same project. Does the lack of an RCT nullify your 3:1 productivity result? Only to an RCT-statistical purist! But in practice I’m sure you have reason to believe your 3:1 result because you saw the day-to-day details of actually building the project. Measuring only project duration doesn’t capture those details. So I guess that’s what qualitative methods like the “Cognitive Dimensions of Notation” help you do: they help you observe those details, so you get finer resolution sampling, and that’s what Lewis argues for.)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566409163.182100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566409163.182100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-21 10:39</span><br/>
<span style="background-color:#ccf">@magicmouse94937</span> we may be herd animals, but we additionally slow down progress by not agreeing what progress looks like, so we stay with the status quo because it is the only thing that has momentum
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566409240.182300"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566409240.182300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-21 10:40</span><br/>
yes, the whole world getting excited about small improvements in JS sometimes feels like everyone getting excited about slightly rounder wooden wheels on horse carts :wink:
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566409352.182500"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566409352.182500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-21 10:42</span><br/>
And yes, you can measure, particularly these large quantities of students implementing the same medium size problem seems interesting. The problem is with the conclusions, they may hold for some small subset of that above diagram and not all
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566409464.182700"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566409464.182700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-21 10:44</span><br/>
I think for every "obvious" progress you can conclude from a study, there are always legitimate reasons why it would be the opposite of progress for some part of that graph
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566409654.182900"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566409654.182900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-21 10:47</span><br/>
for example, there's a lot of people that think that everyone switching to GC languages would be progress, and I would personally strongly disagree (&lt;- don't take this as the start of a GC debate, it is just an example). Same with static typing, functional programming, some testing or SE methodology, etc etc
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566410048.183100"></a>
      <img src="https://avatars.slack-edge.com/2019-03-27/582042668721_465336060ae83dc74288_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566410048.183100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wouter van Oortmerssen</b>
<span style="margin:2em; color:#606060">2019-08-21 10:54</span><br/>
It's funny, programming is such a huge field now (both in terms of breath of subject matter and the amount of people involved) and has a decent length cultural history, that we're running into similar issues as other fields in terms of making progress. I guess the advantage we have is that often sub-groups can make progress without needing the whole world to follow along (you can have type safety in your own project mostly even if the rest of the world doesn't want it, which is easier than say, solving pollution in the real world). But the price we pay for that is crazy levels of fragmentation, duplication, and interfacing pains.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566413355.183300"></a>
      <a href="../share-your-work/1565111628.102100.html#1566413355.183300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>magicmouse94937</b>
<span style="margin:2em; color:#606060">2019-08-21 11:49</span><br/>
In the large project i was working on (approx. 100 man years), we had the choice of C or Modula-2. Modula-2 has an almost exact mapping 1:1 with C. C has arithmetic, logical operations, records, arrays, function calls, and the classic control flow statements like loops, if, switch. So from a feature point of view Modula-2 only offered a few additional features. So people ignored it. But what they failed to realize at the time, and still continue to fail to realize, is that from a practical standpoint programming is all about avoiding human error. You can write 1000 lines of code in a certain number of hours, but how long until all the errors are removed? This is where the majority of time is spent, and when you have a whole bunch of people changing the same code base at the same time, that multiplies the possibility for errors. Modula-2 offered more protection for the programmer. It caught errors that C at the time did not catch
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1566414676.183700"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1565111628.102100.html#1566414676.183700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-08-21 12:11</span><br/>
Here is the screenshot of the runtime checks that Modula2 offered. this is from the ADW compiler for windows, which is now freeware. Notice how it is going to check for subscript range, so an array that goes from 0..9 will be checked if the subscript is outside the range. It also checks assignments to make sure your int32 being copied into an int16 doesn't overflow, it checks the switch cases, it also checks for null pointers, it looks at arithmetic overflow, and some other things. These runtime checks inflate the code by 30%; its very expensive to have all these IF statements, which are among the slowest statements in the CPU. But during development i gladly pay this toll, because its going to catch small errors quickly. C did not offer these at the time. The other advantage Modula-2 had was it used precompiled definition files, and if the definition file didn't change one could change the implementation and no other code would need to be recompiled. Built into the system was a dependency analyzer, that on large programs sped up compile times by 10:1 because you didn't waste time recompiling code that is not going to change. People really love interactive tools that compile as you type, but for 1980 this was a lightning fast system, and as interactive as you could get. I couldn't get people to even try Modula-2, because C was "the standard". The larger the program the more time you spend on cross-module concerns and bugs, and Module system designed by Prof. Wirth was brilliant and effective.  There is an old joke that programmers are too busy digging with dessert spoons to see the bulldozer demonstration.<br/><br/>The evolution of programming is fairly linear when you look at the last 50 years. People are slowly realizing that human error is the real obstacle to getting things built, and the reason there is so much interest in graphical interfaces in this group is that in a graphical product you can constrain the system so that fewer errors can be created in the first place. If something can't be put into a box you don't let it happen. This is in contrast with textual systems, where one can give crazy instructions. Any toolchain which helps prevent user frustration is beneficial and forward progress. Assembler was abandoned because it was too easy to overwrite a register, and create phantom bugs. C was phased out in favor of Java because in C it was too easy to double-free memory or reference deallocated memory, with phantom bugs resulting. Java should be abandoned because it is too easy to refer to an object before it is instantiated, causing innumerable nil pointer errors, and the OOP model is now discredited IMHO.<br/><br/>Human beings get up in the morning and make tons of mistakes. We have a sloppy biocomputer that is not that reliable, and our tools need to protect against omnipresent human errors. We can certainly make things prettier and easier to work with, but at the core we must build reliable systems.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
