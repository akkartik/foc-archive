<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #reading-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../reading-together/1660888406.320979.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Personal Dynamic Media</b>
<span style="margin:2em; color:#606060">2022-08-18 22:53</span><br/>
On the criteria to be used in decomposing systems into modules by D. L. Parnas<br/><a href="https://dl.acm.org/doi/10.1145/361598.361623">https://dl.acm.org/doi/10.1145/361598.361623</a><br/><br/>This is one of my favorite papers, and the basic concept that each design decision should be hidden within a module of some sort, where "module" can mean anything from a collection of procedures to a language specific feature, has served me well for many years.<br/><br/>Also, the principle that programs should be broken up by concern and not by the order in which things happen has informed my design decisions for a long time.<br/><br/>Has this paper's approach informed anyone else's design over the years? If so, how?<br/><br/>What principles do the rest of you use to make your programs more resilient against changes in the specifications?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1661818878.451259"></a>
      <img src="https://secure.gravatar.com/avatar/15651704a60f7ef1539f9b1fa2506188.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0003-72.png" style="float:left"/>
      <a href="../reading-together/1660888406.320979.html#1661818878.451259" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>taowen</b>
<span style="margin:2em; color:#606060">2022-08-29 17:21</span><br/>
Parnas theory is based on "information hiding". The bottleneck of collaboration is communication and share understanding. To modularize (or to collaborate) based on minimal information sharing is economic. This also means, to save the cost of end user programming, we need to find the boundary what can be customize, what can not be. If everything is changable, the cost of understanding to tweak will go up.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1661819090.670089"></a>
      <img src="https://secure.gravatar.com/avatar/7fd1bd5c53681452a80086a54ebb2ad1.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-72.png" style="float:left"/>
      <a href="../reading-together/1660888406.320979.html#1661819090.670089" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Personal Dynamic Media</b>
<span style="margin:2em; color:#606060">2022-08-29 17:24</span><br/>
<span style="background-color:#ccf">@taowen</span> that reminds me of a joke we used to make many years ago when a customer would ask for endless amounts of customizability. "Maybe we should just give them a Perl interpreter."
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1661995221.570889"></a>
      <img src="https://avatars.slack-edge.com/2022-03-23/3286745266387_1092a4f970985ebc8d2b_72.png" style="float:left"/>
      <a href="../reading-together/1660888406.320979.html#1661995221.570889" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Christopher Shank</b>
<span style="margin:2em; color:#606060">2022-08-31 18:20</span><br/>
Maybe a little stereotypical, but I have found pace layers a really useful tool for decomposing systems into a layers that move at different speeds. It helps tease out boundaries between layers and provides guidance about how different layers should change. <br/><br/>&gt; Fast learns, slow remembers.  Fast proposes, slow disposes.  Fast is discontinuous, slow is continuous.  Fast and small instructs slow and big by accrued innovation and by occasional revolution.  Slow and big controls small and fast by constraint and constancy.  Fast gets all our attention, slow has all the power.<br/><a href="https://jods.mitpress.mit.edu/pub/issue3-brand/release/2">https://jods.mitpress.mit.edu/pub/issue3-brand/release/2</a><br/><br/>What’s interesting is that this mental model makes you really think about the qualities you want at different layers. The slowest layers should be small, simple, tightly-scoped, and extensible to let other layers innovate at the edges.<br/><br/>A detailed example is how web technologies were designed to enable progressive enhancement via pace layers. <a href="https://speaking.adactio.com/ZCJ61M">https://speaking.adactio.com/ZCJ61M</a><br/>
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
