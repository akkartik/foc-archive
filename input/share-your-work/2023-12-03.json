[
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1701592770.486569",
        "client_msg_id": "2c32df88-0b0c-49e1-9199-420793eed53e",
        "text": "This episode also reminded me of this essay about two view on computation: the theory of computation (machine oriented) and the theory of programming (language\/logic oriented). <https:\/\/pron.github.io\/posts\/what-we-talk-about-when-we-talk-about-computation>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1700373745.504449",
        "parent_user_id": "UC2A2ARPT",
        "attachments": [
            {
                "from_url": "https:\/\/pron.github.io\/posts\/what-we-talk-about-when-we-talk-about-computation",
                "service_icon": "https:\/\/pron.github.io\/fav\/favicon-152.png",
                "thumb_url": "http:\/\/www.gravatar.com\/avatar\/c69557151e2f8331f6b1865469b694dd?s=200",
                "thumb_width": 200,
                "thumb_height": 200,
                "ts": 1472495400,
                "id": 1,
                "original_url": "https:\/\/pron.github.io\/posts\/what-we-talk-about-when-we-talk-about-computation",
                "fallback": "Ron Pressler: What We Talk About When We Talk About Computation",
                "text": "Machine and language models of computation differ so greatly in the computational complexity properties of their representation that they form two distinct classes that cannot be directly compared in a meaningful way. While machine models are self-contained, the properties of the language models indicate that they require a computationally powerful collaborator, and are better called models of programming.",
                "title": "What We Talk About When We Talk About Computation",
                "title_link": "https:\/\/pron.github.io\/posts\/what-we-talk-about-when-we-talk-about-computation",
                "service_name": "Ron Pressler"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9FpUP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This episode also reminded me of this essay about two view on computation: the theory of computation (machine oriented) and the theory of programming (language\/logic oriented). "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/pron.github.io\/posts\/what-we-talk-about-when-we-talk-about-computation"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1701592831.096209",
        "client_msg_id": "b618993a-6246-4f64-bc85-f884d5276fdf",
        "text": "&gt;  We can summarize the two positions in the following way: The TOP people say, “computations are programs, and programs are mathematical objects whose structure is captured by their types; the two models of computations are equivalent when asked to represent first-order functions, but diverge when asked to represent higher-order functions”. The TOC response is, put simply, “what the hell is a function?” Just as a falling apple doesn’t compute integrals — it just falls — so too Turing machines and any other machine model compute neither higher-order nor first-order functions; they compute bits. What imaginary mathematical concepts we then choose to describe those computations is a different matter altogether, one that does not affect the nature of the computation just as calculus has had no impact on the behavior of falling apples.\nI’m definitely in team computation.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1700373745.504449",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "se+h1",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " We can summarize the two positions in the following way: The TOP people say, “computations are programs, and programs are mathematical objects whose structure is captured by their types; the two models of computations are equivalent when asked to represent first-order functions, but diverge when asked to represent higher-order functions”. The TOC response is, put simply, “what the hell is a function?” Just as a falling apple doesn’t compute integrals — it just falls — so too Turing machines and any other machine model compute neither higher-order nor first-order functions; they compute bits. What imaginary mathematical concepts we then choose to describe those computations is a different matter altogether, one that does not affect the nature of the computation just as calculus has had no impact on the behavior of falling apples."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I’m definitely in team computation."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U017TE5R09M"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1701595880.738719",
        "edited": {
            "user": "U017TE5R09M",
            "ts": "1701596272.000000"
        },
        "client_msg_id": "684b559f-933b-43ec-9a0c-072fbb223112",
        "text": "Yeah, also very much on team computation.  Or actually, team running programs on a computer.\n\nI also find Wadler’s idea of universality+ fun to contemplate, but he actually misses a rather significant problem with that idea:  it doesn’t even cover computing, never mind the multiverse.\n\n“Reducing terms to produce an answer” describes only a small and ever-diminishing portion of what we program our computers to do.  They store data, retrieve data previously stored, communicate, have effects in the world, interpret stuff that happens in the world etc.\n\nAnd that is not the incidental stuff, that is the main task of programs.  Algorithmic work does occur, but it is more and more incidental.\n\nBut that’s just the practical view, apparently there’s theory to back it up as well:\n\n<https:\/\/cs.brown.edu\/people\/pw\/strong-cct.pdf>\n\nI am not sure how relevant those theoretical objections are, but the practical ones seem pretty strong to me.\n\n(And yes, you can obviously implement many of these other concerns using term-reduction\/substitution.  But you can also do that using NAND gates…)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1700373745.504449",
        "parent_user_id": "UC2A2ARPT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VfBlj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, also very much on team computation.  Or actually, team running programs on a computer.\n\nI also find Wadler’s idea of universality+ fun to contemplate, but he actually misses a rather significant problem with that idea:  it doesn’t even cover computing, never mind the multiverse.\n\n“Reducing terms to produce an answer” describes only a small and ever-diminishing portion of what we program our computers to do.  They store data, retrieve data previously stored, communicate, have effects in the world, interpret stuff that happens in the world etc.\n\nAnd that is not the incidental stuff, that is the main task of programs.  Algorithmic work does occur, but it is more and more incidental.\n\nBut that’s just the practical view, apparently there’s theory to back it up as well:\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/cs.brown.edu\/people\/pw\/strong-cct.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI am not sure how relevant those theoretical objections are, but the practical ones seem pretty strong to me.\n\n(And yes, you can obviously implement many of these other concerns using term-reduction\/substitution.  But you can also do that using NAND gates…)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    }
]