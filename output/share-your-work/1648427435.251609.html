<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2025-02-28/8529753983250_8f365fd896e9c8f573b5_72.jpg" style="float:left"/>
      <a href="../share-your-work/1648427435.251609.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>xyzzy</b>
<span style="margin:2em; color:#606060">2022-03-27 17:30</span><br/>
I have been dogfooding my literate programming tool wheel. So far I have been able to develop multiple webapps, a game and even a C++ based desktop app with it. I also think LP can be invaluable in managing your programming notes and system admin commands, not to mention writing html based books. You can checkout all the project links <a href="https://xyzzyapps.link/literate-programming.html">here</a>.<br/><br/>I dub my approach to LP as procedural literate programming. Instead of developing new syntax, I use string substitution based approaches common in web development which is more flexible than all the other approaches to literate programming so far, including the original cweb.<br/><br/>I think the fundamental mistake that people seem to be making with LP is using it to describe algorithms rather than code history, code inspirations, bug stories, features and any other context surrounding code like tests / security. This means that git commit messages can be skipped with LP in some sense. While complex algorithms definitely can use lengthy descriptions, you can assume your reader is a programmer and just show code as is for everyday code. I suppose if you want to keep existing ways of  working with code you can copy paste the diffs manually back into the literate source code, but a well integrated IDE could perhaps avoid this step and allow you to use both workflows simultaneously.<br/><br/>Last year I participated in a few jams which allowed me to explore different approaches to LP. I have developed a comment based code extraction and animation approach to LP called Loom and I was able to develop a very basic IDE using PyQt.  It turns out that LP has a lot in common with Xanadu and Web because fundamentally they all are hypertext systems. Talk about a wild coincidence! Like Xanadu, LP is heavily dependent on two-way links called transclusions. If anyone knows Ted Nelson here I would love to tell him about my findings about how a transclusion based browser can act as an IDE to LP.<br/><br/>I also found that LP can act a glue tool for generative programming. You can create multiple DSLs and pipe them through external scripts, while presenting just the DSL to the reader. This is something I am exploring in a compiler project where I am trying to generate C code from YAML.<br/><br/>As of now I think LP is a huge plus  for solo developers juggling multiple projects. Reading code in an understandable order allows you to pick up code where you left off. No wonder Knuth was so productive with it. You can checkout demos for wheel, PyQt IDE and Loom on youtube. I have also created a screencast recently to showcase my workflow with sublime<br/><br/><a href="https://www.youtube.com/watch?v=9Bcaif2h1lE&amp;list=PLbyPZ-v56IPnTDISg3pFUYl7374q7jqsq">https://www.youtube.com/watch?v=9Bcaif2h1lE&amp;list=PLbyPZ-&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1648451245.723489"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1648427435.251609.html#1648451245.723489" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-03-28 00:07</span><br/>
&gt; I think the fundamental mistake that people seem to be making with LP is using it to describe algorithms rather than code history, code inspirations, bug stories, features and any other context surrounding code like tests / security.<br/>This sounds a bit strange to me. The original goal of literate programming, as introduced by Donald Knuth, was to formulate algorithms in a pedagogical way. I wouldn't call that goal a mistake. Maybe literate programming is not the best way to achieve it, but then... what is?<br/><br/>That said, I am perfectly fine with your approach, which is more in line with the various notebooks that have appeared over the last years. From my perspective as a long-time user of Emacs-plus-org-mode, I'd say you are doing org-mode with Web technology.<br/><br/>But I think this approach misses something essential: the algorithms on which all the high-level stuff ultimately depends. I want those algorithms to be just as accessible to readers as the high-level outline. With notebooks and friends, they disappear in a black box instead.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1648457223.694159"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1648427435.251609.html#1648457223.694159" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-03-28 01:47</span><br/>
I am super into LP too, I use Observablehq, and I love mixing in tweets into my notebooks. You can tell a whole story, so you can connect a LP story to internet media (or in my opinion you should do). I also dogfooding my experience here <a href="1647859090.612199.html">1647859090.612199.html</a><br/>I also think git is less needed in LP situation, you just need the rollback safety features, and merging for team workflow. Funny enough we discussed that organically last week!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1648468147.577299"></a>
      <img src="https://avatars.slack-edge.com/2025-02-28/8529753983250_8f365fd896e9c8f573b5_72.jpg" style="float:left"/>
      <a href="../share-your-work/1648427435.251609.html#1648468147.577299" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>xyzzy</b>
<span style="margin:2em; color:#606060">2022-03-28 04:49</span><br/>
<span style="background-color:#ccf">@Tom Larkworthy</span><br/><br/>Yes its about the story! Does Observablehq allow you to embed content from other blocks, like noweb ? Jupyternotebook can't really do that and it is just linear. It is crucial to have that so that  you can explain code in any order.<br/><br/><span style="background-color:#ccf">@Konrad Hinsen</span><br/><br/>To take <a href="https://www.literateprograms.org/quicksort_<em>c</em>.html">quick sort</a> as an example, I would<br/><br/>1. show the video of quick sort first<br/>2. show the unit test second<br/>3. explain the history of the algorithm<br/>4. explain any trivia<br/>5. give a brief explanation of the algorithm along with common bugs<br/>6. put  up personal anecdotes<br/>7. put the complete quick sort code rather than go into details like declarations, loops, recursion ... <br/>I find examples going into too much details  while completely missing 1-6<br/><br/>In the LP <a href="https://www.literateprograms.org/quicksort_<em>c</em>.html">wiki</a> quick sort is described as<br/><br/><pre style="white-space:pre-wrap"><br/>*&lt;&lt;public declarations&gt;&gt;=*<br/>*void* quicksort(*void* * base, size_t num_elements, size_t element_size,<br/>        *int* (*comparer)(*const* *void* *, *const* *void* *));<br/>*&lt;&lt;quicksort&gt;&gt;=*<br/>*void* quicksort(*void* * base, size_t num_elements, size_t element_size,<br/>        *int* (*comparer)(*const* *void* *, *const* *void* *))<br/>*{*<br/>  &lt;&lt;quicksort declarations&gt;&gt;<br/> &lt;&lt;check termination condition&gt;&gt;<br/>  &lt;&lt;select a pivot&gt;&gt;<br/>  &lt;&lt;partition the array&gt;&gt;<br/>  &lt;&lt;recursively sort each subpartition&gt;&gt;<br/>*}*<br/></pre><br/><br/>I would basically avoid declaration chunks like the above snippet ... unless its really a complex algorithm. Most everyday code in apps is  far too simple to warrant such detail.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1648471910.573339"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1648427435.251609.html#1648471910.573339" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-03-28 05:51</span><br/>
yes, observable is dataflow driven and features non-linear (topological) execution order <a href="https://observablehq.com/@observablehq/observables-not-javascript">https://observablehq.com/@observablehq/observables-not-javascript</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1648485206.503189"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../share-your-work/1648427435.251609.html#1648485206.503189" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2022-03-28 09:33</span><br/>
<span style="background-color:#ccf">@xyzzy</span> I think the challenge is to link all that together.<br/><br/>Example: I have a notebook that calls a function called <tt>quicksort</tt>. As a reader, I want to figure out what it does.<br/><br/>First step: look up the code that is actually called. That's your step 7, and should be trivial, which it is in a good IDE but (so far) it is not in notebook-like environments. The only other piece that a code analysis could lead to is unit tests (your step 2).<br/><br/>Everything else would be annotations added by the developer, so now we are in the "documentation" category. Donald Knuth's prose gets complemented by other media, links to Wikipedia, etc. All the niceties that didn't exist at Knuth's time. But that's just a technology update, not a fundamental improvement compared to the LP of the past.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1648490096.210129"></a>
      <img src="https://avatars.slack-edge.com/2025-02-28/8529753983250_8f365fd896e9c8f573b5_72.jpg" style="float:left"/>
      <a href="../share-your-work/1648427435.251609.html#1648490096.210129" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>xyzzy</b>
<span style="margin:2em; color:#606060">2022-03-28 10:54</span><br/>
Roughly speaking what I propose is not an update on LP, anything that implements tangle and mangle is LP,  but an update on the code  documentation genre / style. The final LP document should read like a history book as opposed to technical description of the code. My goal is to capture the evolution of all technical decisions made in a project, algorithms unless they are critical ... like say complex signal processing are of secondary importance.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1648540486.202029"></a>
      <img src="https://avatars.slack-edge.com/2021-09-13/2483463922595_27dffd0e73bd6f709927_72.gif" style="float:left"/>
      <a href="../share-your-work/1648427435.251609.html#1648540486.202029" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Tom Larkworthy</b>
<span style="margin:2em; color:#606060">2022-03-29 00:54</span><br/>
This one was a style I liked <a href="https://observablehq.com/@tomlarkworthy/mip">https://observablehq.com/@tomlarkworthy/mip</a>. BIG intro to topic, executable tests, actual implementation was really done elsewhere. Sorta looks more like a text book in the end. I have a change log for the history, though I tend to be quite terse on on that bit. I don't think history is very interesting if you end up reading about doing something that 3 months later is deleted and replaced with a different way. I use history to answer... did anything change since I last looked?<br/><br/>If you want an overview of how a whole community is using LP (which is different to how I do it) I have a 100 of the best here:- <a href="https://observablehq.com/@tomlarkworthy/notebooks2021">https://observablehq.com/@tomlarkworthy/notebooks2021</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1648552569.034009"></a>
      <img src="https://avatars.slack-edge.com/2025-02-28/8529753983250_8f365fd896e9c8f573b5_72.jpg" style="float:left"/>
      <a href="../share-your-work/1648427435.251609.html#1648552569.034009" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>xyzzy</b>
<span style="margin:2em; color:#606060">2022-03-29 04:16</span><br/>
I like obervablehq's style! What a difference it makes to show examples and tests first. In many ways blogs are literate programs too.<br/><br/>While a history approach may not seem useful for discussing math heavy topics, it becomes very useful for showcasing project evolution.<br/><br/>Right now I am evaluating DuctapeJS and Lua. Instead of throwing the final code away, I will just add a section on  scripting engine under early prototypes chapter for example.<br/><br/>Let us say a project is changing from apache to Nginx or from REST to Graphql, all these can be discussed in github issues and then the code changes can be documented. Heck, you can even have a toggle button to show old code - as I am using web stuff for doing LP, this is entirely possible. I right now use a "DEV" flag to hide stripe API keys.<br/><br/>Many decisions like framework choice, architecture choice, requirements can go into LP. Why are you building the damn thing in the first place ? When a function is deprecated I would like that to be documented too. Right now this is scattered in pm tools, github issues, mails, ad-hoc documents and commit messages. Apart from examples and tests, add a tutorial and user guide if you are building a reusable library. I am using wheel to build everyday polyglot webapps, where most decisions are  actually related to UI, so I am also documenting colorschemes :slightly_smiling_face:
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
