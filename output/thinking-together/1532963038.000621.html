<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2018-07-30 08:03</span><br/>
What are the best ways for programmers that prefer different platforms, programming languages, and runtime environments to work together on the same software system? Let's say a C, a Python, a JavaScript, and a Haskell programmer walk into a bar, and — after the joke is finished — they decide to work together on a piece of software but all want to keep using their preferred language (let's ignore how useful or stubborn or realistic that is for a moment) — how could they technically do it with contemporary methods?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1532963656.000227"></a>
      <img src="https://secure.gravatar.com/avatar/9a9441ae87afd96151f1fdcaec0df0fd.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1532963656.000227" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jacob Haip</b>
<span style="margin:2em; color:#606060">2018-07-30 08:14</span><br/>
They might use a message passing tools like ZeroMQ, gRPC, DBUS, etc.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1532964503.000617"></a>
      <img src="https://avatars.slack-edge.com/2018-09-11/433781465829_7c31dc735c6c1257fe1f_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1532964503.000617" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Krouse</b>
<span style="margin:2em; color:#606060">2018-07-30 08:28</span><br/>
Compile them all to JavaScript/WASM via Emscripten, Jython, ghc-JS, etc!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1532965421.000149"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1532965421.000149" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-07-30 08:43</span><br/>
I don't know what the OS people have been up to, but there were moments when it seemed like this would be straightforward <a href="https://dl.acm.org/citation.cfm?id=806544">https://dl.acm.org/citation.cfm?id=806544</a>.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1532965557.000094"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1532965557.000094" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-07-30 08:45</span><br/>
For us Redis has given us nothing but success,
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1532969567.000402"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1532969567.000402" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-07-30 09:52</span><br/>
I don't think contemporary technologies have a great solution here. The integration can only happen at the lowest levels - one option is messaging, another is C API based.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1532969573.000420"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1532969573.000420" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2018-07-30 09:52</span><br/>
ZeroMQ, gRPC, HTTP, sockets and JSON/edn/transit/avro
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1532971071.000279"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1532971071.000279" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-07-30 10:17</span><br/>
Yes - all decent messaging options. One question that comes to mind is: how do you share code (or do you reimplement stuff, or only access stuff via messaging - what about low level stuff?). Second, more importantly, how do you specify system wide behavior or patterns? We often design 'whithin an OS process' using the chosen language paradigm, but then glue together these processes (each implemented in a different paradigm) into a system. Is there is 'system paradigm'?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1532971084.000254"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1532971084.000254" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-07-30 10:18</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span> - what's the motivation behind asking this question?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1532975925.000183"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1532975925.000183" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2018-07-30 11:38</span><br/>
<span style="background-color:#ccf">@Shalabh</span> I wanted to see if I'm unaware of any solutions to that problem. Reading about the <em>Rule of Composition</em> from <em>The Art of Unix Programming</em> triggered my thought process (<a href="http://www.faqs.org/docs/artu/ch01s06.html#id2877684">http://www.faqs.org/docs/artu/ch01s06.html#id2877684</a>).<br/><br/>This is a bigger issue that prevents us from making progress because we're all so busy reinventing wheels for our preferred stack and convincing others why our technology choice is better than theirs.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533023000.000117"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533023000.000117" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2018-07-31 00:43</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span> this is the closest I've seen <a href="https://twitter.com/mfikes/status/1019233164273881088">https://twitter.com/mfikes/status/1019233164273881088</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533023021.000165"></a>
      <img src="https://avatars.slack-edge.com/2018-07-09/395086754178_7f0f1c0238ec02befdab_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533023021.000165" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Mariano Guerra</b>
<span style="margin:2em; color:#606060">2018-07-31 00:43</span><br/>
<a href="https://www.graalvm.org/">https://www.graalvm.org/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533055703.000415"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533055703.000415" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-07-31 09:48</span><br/>
Ah yes graal is pretty interesting. Transpiling/compiling to the same lower level virtual machine - i.e. grall - might be another way to interop. But you may have to leave the ecosystem behind (may not port easily).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533056141.000523"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533056141.000523" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-07-31 09:55</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span> yes we have an incredible amount of reinvention - of the ecosystem and also of the ideas themselves. This is a strong 'system smell'. The prevalent ways of composition <b>require</b> a lot of reimplementation. Consider I can't just implement and share a simple idea - such as a sorter - and have everyone just reuse it. There is some generic programming within each language world, but why no system-wide generic programming? The more I think about this I feel the problem is the substrate - our current model of composition is poor and requires this kind of reimplementation. I think it has to do with pervasive early binding but still chewing on it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533078727.000152"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533078727.000152" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-07-31 16:12</span><br/>
I am somewhat anti-text-streams/files (see more here if interested: <a href="https://shalabh.com/programmable-systems/files-and-file-formats.html">https://shalabh.com/programmable-systems/files-and-file-formats.html</a>), so while I agree with the general sentiment of 'programs should easily talk to each other', I think text streams/files are a poor way of doing that. Firstly, the format is transmitted out-of-band. Secondly there's no way to bind/compose two programs connected via stream into a larger program for isolation or performance The Unix way seems to conflate the implemetation mechanims (stream of text vs function call vs in memory message passing vs inlining) with the semantics (one object sending a logical message to another).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533107724.000096"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533107724.000096" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2018-08-01 00:15</span><br/>
<span style="background-color:#ccf">@Shalabh</span> I share your sentiment about files or byte streams somewhat. Constantly I wonder “Really, that is the best we could come up with in half a century?” However, there must be something to it that made the Unix way a successful design. It certainly is simple, yet powerful, and it does have some composition properties with the filter and pipes mechanisms.<br/><br/>What I’m most intrigued by though, and what you don’t really talk about in your (otherwise excellent) linked article, is that the amazingly pervasive files metaphor in Unix also enables designing for the future: because you cannot assume anything about a byte stream, you’re encouraged to build your filter or command line utility with the least amount of assumptions on what you will receive, thus avoiding the specific design for a specific data format which will immediately couple your program to a more specific aka limited use case and make many unanticipated use cases impossible.<br/><br/>Therefore I’m not sure I agree that “minimizing pre-shared knowledge [should] be an essential goal of our system design” — I know what you mean and it sure sounds obvious and logical, but I’m just not sure about that anymore.<br/><br/>There is some clever magic here that I’m still trying to understand and I’m not sure I’m capable of expressing yet, and what Unix does with files, streams, and byte arrays is a beautiful incarnation of that magic for us to look at and figure out the principles behind. It only works well for cases where other important Unix principles are also respected, like files with easy to understand, human-readable formats that have been designed with extensibility in mind.<br/><br/>I do hope that this magic can be lifted from the domain of files and streams to something better… I also think we are ready to leave files behind. I just don’t know exactly what that other, better domain is, yet.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533145287.000408"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533145287.000408" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-08-01 10:41</span><br/>
The composition of processes via pipes is something I really appreciate. It's got nice properties of encapsulation of each process and as you mention - easy composition. In fact I wish it was easy to do more configurations than a uni-directional pipeline.<br/><br/>&gt; the amazingly pervasive files metaphor in Unix also enables designing for the future: because you cannot assume anything about a byte stream, you’re encouraged to build your filter or command line utility with the least amount of assumptions on what you will receive, thus avoiding the specific design for a specific data format which will immediately couple your program to a more specific aka limited use case and make many unanticipated use cases impossible.<br/><br/>Interesting point. Quite likely there is something you are saying here that I am missing because I would say the opposite :slightly_smiling_face:. Here's my line of thought: dealing directly with byte streams makes you more coupled with the formats where any minor syntax change will break you. Two exceptions I can think of are <tt>tee</tt> (programs that treat the stream as opaque, just pass the bytes uninspected) and <tt>wc</tt> (programs that inspect well known 'standardized' byte markers). Any script that uses <tt>grep</tt> or <tt>awk</tt> is very closely bound to the syntax of the data. If the file format is changed (but semantically identical) all the scripts would have to be rewritten. Ideally it should be possible for the file itself to tell the script how to get the the same information from the new contents and the script should only have to be modified if the same information is not available. One way to do this is to shift the boundary between the tool and the file so the interaction is not 'give me your bytes' but instead 'give me your tokens/records/etc' - i.e. concepts at a higher level than 'bytes'. Hmm.. doing this makes it no longer a file, but an encapsulated object. Still early in the process of thinking along these lines.<br/><br/>It seems 'files with human readable formats' becomes important if 'give my your bytes' is the level of discourse we intend to have. In the encapsulated object scenario, each object has embedded within it an introspectable 'API' and perhaps visual inspector tailored to its purpose.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533149318.000569"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533149318.000569" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2018-08-01 11:48</span><br/>
<span style="background-color:#ccf">@Shalabh</span> Sounds like you just described what XML wanted to be. :-)<br/><br/>What I meant is that the design encourages you to write programs that try to be more forgiving precisely because — as a good Unix programmer — you don’t want it to break with every format change, and many conventions have formed over time to help with that in how you format those byte streams (like the different configuration file formats).<br/><br/>It’s interesting that you jump to “encapsulated objects with introspectable API” directly, which seems to me like the other extreme on a spectrum. Unix shows that you can get quite far with simple (and human-readable, feeling almost natural) conventions like a line is a record, simple chars acting as delimiters, etc. That is all very fuzzy, and can break easily just as you describe, but if you can design your program to rely on as few of these conventions as possible, you can use it in many ways, some of them likely unforeseen. That’s a quality I feel is part of that magic.<br/><br/>An encapsulated object with schema encourages to just throw an error that the data has a different format now. That’s a “cleaner” design of sorts, as it prevents potentially weird stuff from happening. But it also kills any unintended use cases from appearing.<br/><br/>I’m still not good at making my point here, and it’s just a hunch that there is a quality there we are missing when we try to make everything fail-safe from the beginning, but maybe the idea shines through?<br/><br/>A similar debate that smells like it’s rooted in the same concept is early vs. late binding. Interestingly, I used to be quite strongly on the side of early binding and strong type systems, which corresponds to the “other” side in our conversation, so one could say I’m inconsistent.<br/><br/>As you can tell, I’m in the middle of forming my opinion about this, and so far I can only conclude that there are good reasons to have both, just not at the same time.<br/><br/>When I’m prototyping and don’t really know what the system I’m building should look like, I want flexibility and I don’t want to specify schemas for instance; I want to explore the design space and run into unintended use cases. When the system is finally fleshed out, I want to nail everything down and optimize, so early binding and well-defined schemas and APIs are very useful if not even required.<br/><br/>Am I making any sense at all?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533157568.000394"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533157568.000394" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-08-01 14:06</span><br/>
&gt; Sounds like you just described what XML wanted to be. :-)<br/>Haha.. oops, not my intention at all. XML provides nothing that different from byte arrays. I jumped to objects because they seems to be the first shift that is qualitatively different. I think the difference comes from considering the boundary between the two entities as a <b>conversation</b>. Each entity is dependent on only the messages it sends and receives - it is free to reorganize its internals in any way. One implication is that each entity has an 'inside' and an 'outside' - encapsulation. So in theory you reduce the coupling itself to the bare essential by talking in messages with 'high level' meaning within the domain at hand. Only the meaning of the messages needs to be agreed upon. From this POV, reading an XML file is the conversation between 'tool' and 'file' that goes as follows:<br/><br/> -&gt; read_bytes<br/> &lt;- here_you_go(bytes)<br/><br/>While the meaning of those bytes is then extracted on the 'wrong' side of the boundary. The tool is still tightly coupled to the irrelevant details of mapping bytes to the higher constructs it really wants - say inventory data or user preferences or whatever. A better boundary actually does exists within the implementation of the tool itself - likely as a function or class boundary provided by an embedded parser. This makes it easy to 'change only the one part' of the tool when the format changes - but you still have to recompile and push out this tool everywhere, so where's the win? (edit: hit enter too soon, follow up coming..)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533158438.000130"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533158438.000130" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-08-01 14:20</span><br/>
&gt; That is all very fuzzy, and can break easily just as you describe, but if you can design your program to rely on as few of these conventions as possible, you can use it in many ways, some of them likely unforeseen. That’s a quality I feel is part of that magic.<br/><br/>Ah right - I think I get what you are saying. There is flexibility and tolerance within the interacting entities in the system? Yes this is a good thing, and I think will transfer to an 'object oriented' OS as well. I'm not really trying to make all interactions fail-safe - you may still have unexpected situations of two objects that try but can't talk to each other - but that failure will be clearer and (speculating here) easier to patch. The main win at the system level is that the mapping between higher level concepts and lower level bytes is hidden within some object, which gives you a bit more flexibility than spreading this mapping around across all the readers.<br/><br/>&gt; I want to explore the design space and run into unintended use cases. When the system is finally fleshed out, I want to nail everything down and optimize<br/><br/>Yes this makes complete sense. It's like the strictness should be a knob on different objects within a program - initially we keep stuff loose but as things get clearer we make some/many of them tighter.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533164161.000253"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533164161.000253" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-08-01 15:56</span><br/>
<span style="background-color:#ccf">@Stefan Lesser</span> so I read your reply again and now I think I didn't really get it. Do you have an example of an 'unintended use case'?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533223332.000294"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533223332.000294" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2018-08-02 08:22</span><br/>
Ok, here's some context on why I'm after "unintended/unforseen use cases": We talk about <em>expressiveness</em> a lot, or how powerful these new tools we want are going to be. And then there's <em>composition</em>, which seems to be an accepted way to enable expressiveness through combining simple building blocks to form more complex behavior. And then there's <em>hacking</em> in the positive sense of taking something that has been built for one thing and creatively repurposing it for another.<br/><br/>These are all things that we can try to design into the systems we build. But there's just no way to anticipate all the possibilities in the problem space upfront. We might even have a totally limited view on what that problem space is. A more pragmatic (and possibly more successful, as demonstrated by Unix) approach is to let go of specifying everything and just rely on a minimal subset of assumptions to make things useful.<br/><br/>I often use music production or video editing tools as examples: in electronic music sound designers (aka people who <em>play</em> with synthesizers and effect modules) created many iconic sounds because they were just aimlessly exploring the possibility landscape (aka fiddling with the knobs until it sounds great). Their tools had relatively few parameters but an endless range of combinations to explore and often you would just accidentally land on a great set of parameters, likely while looking for something completely different. We need to build that into our systems! But today we're more focused on preventing unintended things to happen, because we usually consider them exceptions to be avoided.<br/><br/>There are also many stories from science, where great inventions started as happy accidents, like the "superglue" that turned out to be totally disappointing, but then 3M turned it into their best known product, because as it turns out people wanted glue that doesn't really stick to things.<br/><br/>We need more happy accidents in computing, more hackers that repurpose things with their creativity and discover new use cases for things that weren't supposed to be used that way, and more non-hackers who explore the systems we build in seemingly stupid ways, just to end up on something that we would've never put together in that way, but turns out to be useful.<br/><br/>To bring it back to our original example of byte streams vs. encapsulated objects: the latter seems to discourage tinkering to prevent unwanted effects — and this is a very reasonable demand for architecting a robust system. The former encourages you to plug weird things together to see what happens just because you can or "to poke the power socket with a screwdriver" which is, yes, dangerous, but can sometimes also be… enlightening…?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533229102.000346"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533229102.000346" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-08-02 09:58</span><br/>
Ah.. this resonated with me - I agree this spirit of exploration, 'just playing around', 'connecting things and seeing what happens' should be kept alive. I see one downside of objects (which I think you've been saying all along): if we have name based messages the name-symbols have to match exactly for two things to connect. Whereas I can connect any file with any 'input stream'. Also, we'd have to 'pre-share' the names so we agree on their meaning - this may not scale well either. This relates to another idea - use something other than nominal (or even structural) binding. <br/><br/>At one point I was thinking about how to connect two objects that weren't designed with each other in mind (i.e. don't share types/message names) - e.g. display an object that exposes two numbers onto another object that's a 2D plane. One way is to manually specify the precise mapping - but this is least preferable. We 'know' there are a few natural ways for these to connect - one object has two values on a scale and the other side has two 'scales' ~axes. Can we have the user just 'mush' the objects together and have the system discover reasonable bindings? More impressive would be if we can take an object from very different domains and mush them together and have something reasonable happen or at least be presented with good binding options. Anyway I didn't get very far thinking about this. I started thinking of this as cross-ontological mapping. Maybe introspecting objects should reveal more than message names. Perhaps we need a different system for defining the interfaces where deeper characteristics of the messages can be inferred.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533229285.000223"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533229285.000223" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-08-02 10:01</span><br/>
So I do agree with you. We don't want gear-like fitting of these entities (but we don't want liquid like mixing either).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533263074.000050"></a>
      <img src="https://secure.gravatar.com/avatar/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533263074.000050" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>William Taysom</b>
<span style="margin:2em; color:#606060">2018-08-02 19:24</span><br/>
I feel this kind of "mushing" awkwardness often in Haskell.  Every algebraic data type is pretty similar (a combination of sums, products, and function arrows) and of course converting between these is what functional programs do.  Still, shifting between similar representations often feels awkward: you end up with either conversion boilerplate or type class indirection or monad stacks or experimental type extensions.  Impedance mismatch is by no means a Haskell specific problem.  <span style="background-color:#ccf">@Shalabh</span> noted that OO systems end up with a lot of wrapping and unwrapping.  I think a real solution is tool support for basic mushing, "I want to combine this and this."  "Okay," says the system.  "They naturally mush this way or that way and any other way is too tricky to guess."
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533313497.000005"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533313497.000005" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-08-03 09:24</span><br/>
&gt; I think a real solution is tool support for basic mushing, "I want to combine this and this."  "Okay," says the system.  "They naturally mush this way or that way and any other way is too tricky to guess."<br/><br/>Yes! Though I would perhaps call it system support - it's something that would subsume/replace a type system.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533314190.000086"></a>
      <img src="https://avatars.slack-edge.com/2017-08-20/228447816352_649181907e06ec450c64_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533314190.000086" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Stefan Lesser</b>
<span style="margin:2em; color:#606060">2018-08-03 09:36</span><br/>
I'm half-way through <em>The Art of Unix Programming</em> (<a href="http://www.faqs.org/docs/artu/index.html">http://www.faqs.org/docs/artu/index.html</a>) and I find chapters 4, 5, and 6 very insightful and relevant to this discussion. I mean it's not describing a perfect system design, it just provides all the context to understand the pretty solid and somewhat proven design decisions in Unix, and I'm shocked how much we had figured out back then and then collectively forgot.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1533318061.000142"></a>
      <img src="https://avatars.slack-edge.com/2019-03-21/584465935395_b7c63cc07373326ec6ea_72.jpg" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1533318061.000142" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Shalabh</b>
<span style="margin:2em; color:#606060">2018-08-03 10:41</span><br/>
Ha.. 'The Importance of Being Textual' <a href="http://www.faqs.org/docs/artu/ch05s01.html">http://www.faqs.org/docs/artu/ch05s01.html</a> - kind of the opposite of what I was saying in my essay :smile:. It's a good read though (even if I don't agree with all the points).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1536959125.000100"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1532963038.000621.html#1536959125.000100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2018-09-14 14:05</span><br/>
My rant on this is that we programmers need to replace our obsession with programming languages with an obsession for runtimes[1]. The runtime is the car, the language is the color of the bumper.<br/><br/>For me the big problem boils down to making it easy to copy code from one codebase to another, and have confidence when you're done that you didn't cause any regressions.<br/><br/>If you can do this, working with multiple runtimes becomes a lot more tractable.<br/><br/>(Avoiding bugs is a separate problem. As is coming up with the ideal architecture for a codebase. Both these seem about as solvable as world peace. But making codebases more malleable seems like the most ambitious problem we can work on that actually may admit a solution.)<br/><br/>[1] This may not be the best thing I've written on the subject, but it's something: <a href="https://news.ycombinator.com/item?id=10397026#10397931">https://news.ycombinator.com/item?id=10397026#10397931</a>
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
