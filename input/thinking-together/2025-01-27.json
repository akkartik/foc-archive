[
    {
        "user": "UDRF3ALP4",
        "type": "message",
        "ts": "1737974838.613369",
        "client_msg_id": "6355dc9d-8a88-4509-9335-7b465b6efa86",
        "text": "In the last startup I worked at we built an email inbox meets browser kind of thing, specifically for team collab apps (<https:\/\/acapela.com>). It was not a general solution to the need you're identifying, instead we hardcoded the hell out of it (e.g. re-using users' Notion session cookie to poll their internal API to fetch the notification count)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "cc11a4b410bd",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-01-16\/527084657030_cc11a4b410bd932425de_72.jpg",
            "first_name": "Gregor",
            "real_name": "Gregor",
            "display_name": "Gregor",
            "team": "T5TCAFTA9",
            "name": "gregorwbr",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737760488.011559",
        "parent_user_id": "U08A3DJ5VKM",
        "attachments": [
            {
                "image_url": "https:\/\/framerusercontent.com\/images\/KZEeKicdOsPIkIdgl3TX0SMD5Y.jpg",
                "image_width": 1200,
                "image_height": 630,
                "image_bytes": 64595,
                "from_url": "https:\/\/acapela.com\/",
                "service_icon": "https:\/\/framerusercontent.com\/modules\/ZyNehIFCsbFwWN26oExD\/oafg9rpO08fTbWLrCMxS\/assets\/oNECeDYDL36gyIEsv3UvihD9k.png",
                "id": 1,
                "original_url": "https:\/\/acapela.com",
                "fallback": "Acapela | All work notifications in one inbox",
                "text": "Acapela lets you take control of your notifications. Capture, filter and action them all from one place. Unblock your team twice as fast.",
                "title": "Acapela | All work notifications in one inbox",
                "title_link": "https:\/\/acapela.com\/",
                "service_name": "acapela.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bv+Ae",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the last startup I worked at we built an email inbox meets browser kind of thing, specifically for team collab apps ("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/acapela.com"
                            },
                            {
                                "type": "text",
                                "text": "). It was not a general solution to the need you're identifying, instead we hardcoded the hell out of it (e.g. re-using users' Notion session cookie to poll their internal API to fetch the notification count)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "clap",
                "users": [
                    "U08A3DJ5VKM"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UHNEKU7J7",
        "type": "message",
        "ts": "1737983128.161789",
        "client_msg_id": "873ae7dd-084b-4f71-8e17-54694006e9f2",
        "text": "I've been thinking about what libs and pkg indexes might look like as coding assistants become the norm. What if instead of packages providing a post_install.sh script (to regex config, add symlinks), they had a post_install.md prompt to help integrate the code into your app.\n\nLibraries and packages indexes (especially language specific ones) have been a boon for code reuse. But they can only be used for code that can be cleanly abstracted. I often encounter chunks of code I wish could reuse as a lib, but I can't because I can't abstract it well enough\n\nBut if you wanted to package up a partial table schema and some prompt about how it could be rendered in a UI, then the package manager+coding assistant could auto merge the partial schema into the user's existing schema and even make the right UI updates to show the new fields\n\nThis might really help when building apps using coding assistants. Having assistants write so much code from scratch still feels unpredictable. What I really want is to be able to suggest from an index of code fragments and prompts which things to glue into my app.\n\nSuch a package index would encourage open source contribution of prompts plus pre-made code fragments. I'm interested in others thoughts.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1e87ddc396c8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-05\/8244024349030_1e87ddc396c8973263cb_72.png",
            "first_name": "Matt",
            "real_name": "Matt Rasmussen",
            "display_name": "rasmus",
            "team": "T5TCAFTA9",
            "name": "matt.rasmus",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737983128.161789",
        "reply_count": 6,
        "reply_users_count": 5,
        "latest_reply": "1738617405.133929",
        "reply_users": [
            "U089J8FNGB1",
            "UHNEKU7J7",
            "UQ706GB9U",
            "U088999PF62",
            "U0887QU9G2V"
        ],
        "replies": [
            {
                "user": "U089J8FNGB1",
                "ts": "1737985852.547739"
            },
            {
                "user": "UHNEKU7J7",
                "ts": "1737987033.121109"
            },
            {
                "user": "UQ706GB9U",
                "ts": "1738000204.990409"
            },
            {
                "user": "UHNEKU7J7",
                "ts": "1738001417.652779"
            },
            {
                "user": "U088999PF62",
                "ts": "1738012882.424319"
            },
            {
                "user": "U0887QU9G2V",
                "ts": "1738617405.133929"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bBKN2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been thinking about what libs and pkg indexes might look like as coding assistants become the norm. What if instead of packages providing a post_install.sh script (to regex config, add symlinks), they had a post_install.md prompt to help integrate the code into your app.\n\nLibraries and packages indexes (especially language specific ones) have been a boon for code reuse. But they can only be used for code that can be cleanly abstracted. I often encounter chunks of code I wish could reuse as a lib, but I can't because I can't abstract it well enough\n\nBut if you wanted to package up a partial table schema and some prompt about how it could be rendered in a UI, then the package manager+coding assistant could auto merge the partial schema into the user's existing schema and even make the right UI updates to show the new fields\n\nThis might really help when building apps using coding assistants. Having assistants write so much code from scratch still feels unpredictable. What I really want is to be able to suggest from an index of code fragments and prompts which things to glue into my app.\n\nSuch a package index would encourage open source contribution of prompts plus pre-made code fragments. I'm interested in others thoughts."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U089J8FNGB1",
        "type": "message",
        "ts": "1737985852.547739",
        "client_msg_id": "edc6f13d-e82f-4898-85ea-cbd77b216eda",
        "text": "David Crawshaw’s [article](<https:\/\/crawshaw.io\/blog\/programming-with-llms>) might be relevant to your interests; he says that he uses more local packages because it’s easier to keep context smaller to work with LLMs:\n&gt;  As LLMs do better with exam-style questions, more and smaller packages make it easier to give a complete and yet isolated context for a piece of work. This is true for humans too, which is why we use packages at all, but we trade off package size against the extra typing\/plumbing\/filing to make more readable code. With an LLM both doing and benefiting from a big chunk of that extra work, the tradeoff shifts. (As a bonus, we humans get more readable code!)\nwhich I think meshes well with your idea about having small chunks that are integrated directly into the program, rather than isolated in a `node_modules` or `site_packages` or whatever",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g5caead19f58",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/5caead19f5842ccdc759880c60e7c699.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0005-72.png",
            "first_name": "Bill",
            "real_name": "Bill Mill",
            "display_name": "Bill Mill",
            "team": "T5TCAFTA9",
            "name": "bill",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737983128.161789",
        "parent_user_id": "UHNEKU7J7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JNwFx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "David Crawshaw’s [article]("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/crawshaw.io\/blog\/programming-with-llms"
                            },
                            {
                                "type": "text",
                                "text": ") might be relevant to your interests; he says that he uses more local packages because it’s easier to keep context smaller to work with LLMs:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " As LLMs do better with exam-style questions, more and smaller packages make it easier to give a complete and yet isolated context for a piece of work. This is true for humans too, which is why we use packages at all, but we trade off package size against the extra typing\/plumbing\/filing to make more readable code. With an LLM both doing and benefiting from a big chunk of that extra work, the tradeoff shifts. (As a bonus, we humans get more readable code!)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nwhich I think meshes well with your idea about having small chunks that are integrated directly into the program, rather than isolated in a "
                            },
                            {
                                "type": "text",
                                "text": "node_modules",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or "
                            },
                            {
                                "type": "text",
                                "text": "site_packages",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or whatever"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHNEKU7J7",
        "type": "message",
        "ts": "1737987033.121109",
        "edited": {
            "user": "UHNEKU7J7",
            "ts": "1737987049.000000"
        },
        "client_msg_id": "85406d50-ae8b-4ac4-a569-f14ea0c82db8",
        "text": "Ah, thanks for the reference! That's a cool observation that this trend would encourage smaller packages since writing the extra glue code between them isn't a burden for LLMs. That's a nice way to put it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1e87ddc396c8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-05\/8244024349030_1e87ddc396c8973263cb_72.png",
            "first_name": "Matt",
            "real_name": "Matt Rasmussen",
            "display_name": "rasmus",
            "team": "T5TCAFTA9",
            "name": "matt.rasmus",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737983128.161789",
        "parent_user_id": "UHNEKU7J7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RCc30",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah, thanks for the reference! That's a cool observation that this trend would encourage smaller packages since writing the extra glue code between them isn't a burden for LLMs. That's a nice way to put it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UQ706GB9U",
        "type": "message",
        "ts": "1738000204.990409",
        "client_msg_id": "7ac46b25-5eed-4e53-8702-3399c93a9e6a",
        "text": "Also, LLMs, please save us from incompatible dependencies. I had a situation where external dependency A, which I was already using, depended on X-v1.0, and I couldn't add a library B that depended on X-v2.0.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g80bf3c31da6",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/80bf3c31da6a1f3f44e68bfe227fd35d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0025-72.png",
            "first_name": "George",
            "real_name": "George Campbell",
            "display_name": "George",
            "team": "T5TCAFTA9",
            "name": "abersnaze",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737983128.161789",
        "parent_user_id": "UHNEKU7J7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iQFHm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, LLMs, please save us from incompatible dependencies. I had a situation where external dependency A, which I was already using, depended on X-v1.0, and I couldn't add a library B that depended on X-v2.0."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UHNEKU7J7",
        "type": "message",
        "ts": "1738001417.652779",
        "edited": {
            "user": "UHNEKU7J7",
            "ts": "1738001436.000000"
        },
        "client_msg_id": "e46e9b17-cbb2-4e27-847b-d6ccde94b99a",
        "text": "I would love that. Just have the llm solve the dep incompatibility either by finding the right versions or doing the refactorings in the main app to make it work",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "1e87ddc396c8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-05\/8244024349030_1e87ddc396c8973263cb_72.png",
            "first_name": "Matt",
            "real_name": "Matt Rasmussen",
            "display_name": "rasmus",
            "team": "T5TCAFTA9",
            "name": "matt.rasmus",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737983128.161789",
        "parent_user_id": "UHNEKU7J7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ez\/YJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would love that. Just have the llm solve the dep incompatibility either by finding the right versions or doing the refactorings in the main app to make it work"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U088999PF62",
        "type": "message",
        "ts": "1738012882.424319",
        "client_msg_id": "3ca0206b-71ea-4bc0-86a2-de0329772ed4",
        "text": "What if there were just a way to auto-import based on you using function calls from so-and-so library? The agent could suggest imports and handle everything by preprocessing your code.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "ee4ab31ddf7a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2025-01-13\/8273414548951_ee4ab31ddf7a86143d34_72.jpg",
            "first_name": "Karl",
            "real_name": "Karl Toby Rosenberg",
            "display_name": "Karl Toby Rosenberg",
            "team": "T5TCAFTA9",
            "name": "karltobyrosenberg",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1737983128.161789",
        "parent_user_id": "UHNEKU7J7",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LsIfh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What if there were just a way to auto-import based on you using function calls from so-and-so library? The agent could suggest imports and handle everything by preprocessing your code."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]