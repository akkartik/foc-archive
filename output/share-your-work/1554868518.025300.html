<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #share-your-work</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1554868518.025300.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-04-09 20:55</span><br/>
You mention some of the tools/techniques that have been used, but it would have been more complete and accurate if you started with the first debugging tool after tracing was the crash dump, then checkpoint/restart appeared, then breakpoint debugging, then postmortem debugging (Modula-2, via the Logitech Multiscope debugger was the first commercial tool to offer this, where you could see all the data structures and stack trace on a crashed program from a customer), then omniscient debugging which is creeping into tools, which has been popping in and out of view for the last 15 years with greater frequency.<br/><br/>The exact origin of each of these tools and techniques can always be debated, but there is a clearly in our history a progression towards greater information, and omniscient debugging, (which includes time traveling features, plus data structure visualizations) are definitely going to be common in the future.<br/><br/>I disagree that Docker is some kind of progress. It is merely a patch over the atrocious lack of integrity checking in the archaic dynamic linking methodology of Unix, which is 50 years old, and long past expiration date. Because you can break things terribly with a new version of a shared library, Docker creates a half-assed virtual machine that lets two program needing different versions of shared libraries run at the same time on a machine. The fact that the version conflicts exist, and that old versions of a library are not updated (leaving security holes galore) cannot be considered an acceptable long term solution.<br/><br/>And if i can put on my grump-meister helmet, i frankly think that API's are the main evil of today's programming world, and must be eliminated. The future is a  world of interchangeable parts, not tens of thousands of API's, which have to be called in some specific order, and have mysterious interactions.<br/><br/>And version control systems which lets people break stuff constantly as they do in many open source projects have to evolve so that breakage is less common. The sad truth is that all the open source projects don't seem to have any external or built-in QA, so the code oscillates badly, with a good vintage of a project hard to pin down.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1554869279.033000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-08/681438296241_88eacb7e65edebc579ab_72.jpg" style="float:left"/>
      <a href="../share-your-work/1554868518.025300.html#1554869279.033000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Aidan Cunniffe</b>
<span style="margin:2em; color:#606060">2019-04-09 21:07</span><br/>
Nice <span style="background-color:#ccf">@magicmouse94937</span> I appreciate the feedback! I definitely could have gone into much more detail about each tool / the history of them. If I were braver and had more time I’d probably write something even longer form exploring the journey in the terms you described “progression towards greater information” <br/><br/>Re: APIs — I agree there ought to be a better way to share functionality between programmers, but the economics of breaking services up across multiple companies does make a lot of sense. It’s less clear to me how you could build something as immensely valuable to developers as Stripe is if their main delivery method was shipping an executable. APIs as they stand today aren’t technically elegant, but the decentralization allows companies to employ value based pricing and fund the development of awesome software. <br/><br/>Totally with you on version control though :+1:. <br/><br/>Thanks again for the feedback. Have any good books or papers you’d recommend? 
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1554900377.038400"></a>
      <img src="https://avatars.slack-edge.com/2018-08-03/410049852848_d79ba47b2952e74a99d9_72.jpg" style="float:left"/>
      <a href="../share-your-work/1554868518.025300.html#1554900377.038400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Brian Hempel</b>
<span style="margin:2em; color:#606060">2019-04-10 05:46</span><br/>
A “world of interchangeable parts” is only possible with standardized interfaces between the parts (hence the ability to interchange). Not sure how to get there. My current belief (which I realized watching the Google demo of the computer calling a human on the phone to make a restaurant reservation) is that these “standardized” interfaces are not actually going to be standardized—our computers are just going to be smarter about making sense of unknown APIs. Automatic adapters or something like that. In the worst case, you’ll have one computer talking to another computer <em>over the phone using audio</em>. It’s a flexible interface.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1554974699.041800"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1554868518.025300.html#1554974699.041800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-04-11 02:24</span><br/>
Audio is a flexible interface, but can be quite ambiguous. In order to support Siri, Apple had to inject quite a bit of knowledge about the world, and in a recent talk by Stephen Wolfram, who arguably has the best track record in history for interchangeable parts, he talked about how when he started Wolfram Alpha only had a few heuristics, and now the thing is mostly heuristics. Unlike most of the other prior work, the Wolfram language has not changed hardly at all in 25 years. He's either a very stubborn person, or he did a superb job in the beginning, or perhaps a mixture of both.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1555196473.000400"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../share-your-work/1554868518.025300.html#1555196473.000400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-04-13 16:01</span><br/>
If we had a language with interchangeable parts, then Stripe could give you a code module that presented and validated a credit card form, with all the best practices, and saving tens of thousands of programmers from having to roll their own. Merchant gateways from credit cards are pretty trivial, but interestingly many people store the credit card data which they are not supposed to do at all. Stripe is an example where if you had modular code it would help a lot. In the case of Google Maps however, the magic is all on the server side, and in that situation you will have a lot of API's. But you could reduce the API's by a huge factor if you hypothesize a better connection between the two computers than merely JSON. I find the lowest common denominator approach of JSON strings as the interchange between computers to be very crude. Surely we can do a lot better.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
