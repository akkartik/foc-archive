<html>
<head><meta charset="UTF-8"></head><h2>Archives, <a href="https://futureofcoding.org/community">Future of Coding Community</a>, #thinking-together</h2>
  <table>
  <tr>
    <td style="width:72px; vertical-align:top; padding-bottom:1em">
      <img src="https://secure.gravatar.com/avatar/915aac3dfde2fb502ce415d77643a72d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0004-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Wil Chung</b>
<span style="margin:2em; color:#606060">2019-10-12 08:08</span><br/>
PG announced his second Lisp variant: Bel. <a href="http://paulgraham.com/bel.html">http://paulgraham.com/bel.html</a> He’s taking an axiomatic approach to Lisp, as described here: <a href="https://sep.yimg.com/ty/cdn/paulgraham/bellanguage.txt?t=1570888282&amp;">https://sep.yimg.com/ty/cdn/paulgraham/bellanguage.txt?t=1570888282&amp;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570894342.240700"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570894342.240700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-10-12 08:32</span><br/>
Very nice!
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570903753.242800"></a>
      <img src="https://avatars.slack-edge.com/2019-12-15/861537614034_222a2870915d24ec10cc_72.jpg" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570903753.242800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Vladimir Gordeev</b>
<span style="margin:2em; color:#606060">2019-10-12 11:09</span><br/>
I skimmed through it, still didn't understand is there any novelty
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570906198.243200"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570906198.243200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-12 11:49</span><br/>
From my reading it is a back to basics Lisp.  A very clever language from a great mathematician, but its over-reliance on recursion as the main power tool makes Lisp unsuitable for the future.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570906768.243800"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570906768.243800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-10-12 11:59</span><br/>
The power of Lisp has everything to do with the kind of underlying model it can be (and on that sense, it's inescapable).<br/><br/>But it's not necessarily a good top-level model (aka "language" or "interface") for most things. But that's also true of programming language + code in general
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570910690.245000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570910690.245000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-12 13:04</span><br/>
I really like the idea of building up a full featured programming language from a small core. It's elegant. In theory, it means that creating a new from-scratch implementation of the language can be done quickly, with a small amount of code, since you only need to reimplement the core. I mostly associate this idea with Lisp and Forth: having a small, simple syntax makes it easier to have a small core.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570913339.249600"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570913339.249600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-12 13:48</span><br/>
I love seeing ambitious projects like this where the author is making the tool they’d like to use.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570913423.249900"></a>
      <img src="https://avatars.slack-edge.com/2021-03-22/1871363334903_cbd558604a21b23211c3_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570913423.249900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Breck Yunits</b>
<span style="margin:2em; color:#606060">2019-10-12 13:50</span><br/>
Very cool! Also cool to see the shoutout to  <span style="background-color:#ccf">@Kartik Agaram</span> !  Any thoughts you could share about Bel? "The code I wrote to generate and test the Bel source is written in Arc," So he was not writing Bel directly?
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570913863.250500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570913863.250500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-10-12 13:57</span><br/>
I actually asked the same question but didn't get an answer. I haven't seen Bel running either, just given feedback on early drafts of what you see.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570913994.250800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570913994.250800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-10-12 13:59</span><br/>
I'd like to implement something like Bel in my machine code. With its emphasis on using little of the underlying platform it feels like a good fit for Mu. But I'm not sure when I'll get to that. I'm currently designing the C-ish level of the Mu stack.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570914101.251000"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570914101.251000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-10-12 14:01</span><br/>
The minimalistic approach I use is like a Lisp/Scheme evaluator, but all operations are stored as functions (native if necessary), and the evaluator simply looks them up from a dictionary and invokes them. No operations are "built in" to the language
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570914107.251200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570914107.251200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-10-12 14:01</span><br/>
While the Bel interpreter shown here is built in itself, it only needs a subset of Bel. One suggestion I had was to show two interpreters, one for Bel0 and one for the full Bel. Implement both in Bel0. That would improve the exposition, I think.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570914235.251500"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570914235.251500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-10-12 14:03</span><br/>
<span style="background-color:#ccf">@Dan Cook</span> Does your language have primitives that are not functions? Other languages have keywords. Lisp has special forms. Smalltalk has blocks. I suspect you can't avoid something like that.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570915304.252000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570915304.252000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-12 14:21</span><br/>
Smalltalk is a bit different: the entire Smalltalk system is written in Smalltalk, all the way down. It's similar in this sense to C and Unix, where the C compiler and the operating system are written in C. I gather that the Smalltalk bootstrapping process involves a small, statically typed subset of Smalltalk with semantics similar to C, but I'm not familiar with the details. C was originally bootstrapped using a C compiler written in assembly language, but I bet nobody has bootstrapped C in that way since the 1970's.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570916231.252400"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570916231.252400" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-10-12 14:37</span><br/>
It's not clear to me that Smalltalk is different. Since the substrate (machine code) isn't Smalltalk or C, it is by definition impossible that the entire system is written in Smalltalk all the way down. Even if nobody works on the bootstrap any more it's still worth spreading the knowledge about how the bootstrap works, precisely what subset of the language it uses, and how the semantics differ from the full language. Until we understand this we can't actually say how parsimonious Smalltalk's bootstrap is compared to other languages.<br/><br/>(This may seem pedantic, but I think it's hugely important for the health of society: <a href="https://app.slack.com/client/T5TCAFTA9/C5T9GPWFL">https://app.slack.com/client/T5TCAFTA9/C5T9GPWFL</a>)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570916932.252600"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570916932.252600" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-12 14:48</span><br/>
In a system like Bel, I gather that most Bel functions are written in Bel, but some Bel functions are 'primitive': they do not have source code written in Bel. In Smalltalk, nothing is primitive. The entire interpreter and virtual machine are written in Smalltalk. You can inspect the source code, you can debug it, you can change the way it works, using live coding within a running Smalltalk image. That's what's different, and that's what I meant by "written in Smalltalk all the way down".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570917721.252800"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570917721.252800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-10-12 15:02</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> I see, you're right. It may be worth distinguishing between "built in Smalltalk" and "could be modified using Smalltalk". The latter property is indeed universal, and that's pretty rare. Maybe Self and Io share it, besides Smalltalk? My Wart had it as well. What I learned from it was that while it's cool to be able to modify plumbing all the way down, there are extremely subtle implications for correctness and performance that the environment as a whole isn't equipped to support debugging. And arguably <em>couldn't possibly</em> support. So it doesn't seem worth chasing or bragging about. Just stick to 5% or 1% that isn't introspectable. To do otherwise is status signalling at best.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570917864.253000"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570917864.253000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-10-12 15:04</span><br/>
Common Lisp supports replacing <tt>if</tt> with your own version. You have to crack open a package lock and whatnot, but you <em>can</em> do it. But trust me, you don't want to. The package lock is there for a reason.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570918261.253200"></a>
      <img src="https://avatars.slack-edge.com/2018-05-22/369438371830_ec35ac5b251f37e26aca_72.jpg" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570918261.253200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Dan Cook</b>
<span style="margin:2em; color:#606060">2019-10-12 15:11</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> There are primitive values, lists, key-value objects, and native functions. The base operations are native, and other "functions" are just objects with "code", "args", and "context" properties.<br/><br/>When an object-function is invoked, a new context (i.e. a lexical scope object) is created with the function's context as its parent, the arguments are set into that context, and then that context and the function's "code" are fed into the evaluator.<br/><br/>However, when a function-object does not contain any "context" property, then the context of the caller is used as the parent context (aka dynamic scope). The practice is to embed such functions in calls to things like "if" -- which is very much like how SmallTalk blocks work.<br/><br/>["if", condition, {code:[...]}]<br/><br/>So instead of macros, functions are used for code that might or might not be invoked.<br/><br/>It's interesting to note that arrow-functions in JavaScript work similarly (i.e. they don't override "this" or "arguments", like other functions do)
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570920327.253500"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570920327.253500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-12 15:45</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> Io didn’t support rewriting the interpreter from within itself, but as it had no keywords and has code-as-data with a single AST node type, you can easily do a lot of dynamic things that may be difficult even in languages written in themselves (such as control structures).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570920799.253700"></a>
      <img src="https://secure.gravatar.com/avatar/7588e3d3aa94ba40f57f495ec8c3206b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0017-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570920799.253700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Steve Dekorte</b>
<span style="margin:2em; color:#606060">2019-10-12 15:53</span><br/>
Taking on the responsibility of dealing with varied current and future machine architectures and OS conventions (calling, dynamic libraries, etc) seems like a lot of (never ending) effort that may not have much to do with what makes a language useful/interesting unless it’s goal is to be a systems language.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570921230.254200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570921230.254200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-12 16:00</span><br/>
<span style="background-color:#ccf">@Kartik Agaram</span> I think we can separate the problematic "self brain surgery" method of changing the internals of a Smalltalk image, from the benefits of a language and environment that is able to fully self-represent and self-introspect itself. I think that your "status signalling" criticism applies only to the former. Here's a paper, "Bootstrapping Reflective Systems: The Case of Pharo", describing how Pharo solves the "self brain surgery" problem in Smalltalk while retaining the ability to fully describe itself and evolve itself. <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.452.6952&amp;rep=rep1&amp;type=pdf">https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570922910.255200"></a>
      <img src="https://avatars.slack-edge.com/2019-07-14/687915485201_6e649a383cf8f9e366e3_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570922910.255200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Kartik Agaram</b>
<span style="margin:2em; color:#606060">2019-10-12 16:28</span><br/>
<span style="background-color:#ccf">@Doug Moen</span> I don't understand the distinction you're making. How can you change the lowest-level internals of a system without it being like brain surgery, whether self- or otherwise? There seems to be some border around what you mean by "fully self-represent" and "entire system is written", but I can't see where it is. But maybe this needs a separate thread in  #linking-together. It's not a huge disagreement that I feel a need to explore.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570925495.256100"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570925495.256100" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-12 17:11</span><br/>
In Smalltalk, if you try to refactor critical low-level parts of the system, you can easily crash the system, because the code you are refactoring is running while you are performing the refactor. In Pharo, you accomplish this by making a copy of the system, and modifying the copy. It's described in the 2014 paper I linked. This paper mentions some limitations (eg, on making changes to how SmallInteger and the boolean values work), due to the original system and the copy sharing the same VM data structures and byte code format, but there's been a lot of new work on the Pharo bootstrapping system since then that I haven't read about yet. Maybe some of these limitations have been removed. It seems plausible that there is some boundary, but I don't know where the theoretical limits are.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570926777.256800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570926777.256800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-12 17:32</span><br/>
I now see that one of the problems being researched here is how to upgrade a running software system without rebooting it. The 2014 "hazelnut" bootstrapping system for Pharo that I cited above has been replaced by the "espell" system, which is described as "a language runtime virtualization infrastructure".
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1570983127.264700"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1570983127.264700" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-10-13 09:12</span><br/>
Smalltalk definitely has a virtual machine, so it's not Smalltalk all the way down. That virtual machine was initially implemented manually for each machine. Squeak introduced a virtual machine written mostly in Smalltalk and generating C code. But in all cases, the VM is not part of the image and the running VM cannot be modified on the fly, unlike the Smalltalk classes built on top of it.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571066056.280800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571066056.280800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-14 08:14</span><br/>
<span style="background-color:#ccf">@Konrad Hinsen</span> Thanks for the clarification. I guess that the definition of a language primitive is: if you implement a primitive in the source language itself, you induce a meta-circular dependency on the language implementation. Non-primitives can be implemented in terms of primitives without creating this kind of circularity. Meta-circular definitions of language primitives are not just a party trick. They are necessary if you want to implement an operating system that runs on top of the bare metal, and if you also want to use that same language &amp; operating system to develop newer versions of itself. The C compiler is written in C. <span style="background-color:#ccf">@Steve Dekorte</span> I agree with your sentiment. Implementing a language in itself, all the way down to the bare metal, is possible, but then you take on the job of supporting all modern hardware, which is a huge commitment.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571067844.281000"></a>
      <img src="https://avatars.slack-edge.com/2023-12-09/6320751143555_acf65c259768ce3a90a4_72.jpg" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571067844.281000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Jamie Brandon</b>
<span style="margin:2em; color:#606060">2019-10-14 08:44</span><br/>
Nada Amin's "collapsing towers of meta-circular interpreters" might be of interest- <a href="https://www.cs.purdue.edu/homes/rompf/papers/amin-popl18.pdf">https://www.cs.purdue.edu/homes/rompf/papers/amin-popl18.pdf</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571080124.283300"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571080124.283300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-14 12:08</span><br/>
<span style="background-color:#ccf">@Jamie Brandon</span> Thanks for the link, it's quite relevant to my project.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571081059.283500"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571081059.283500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2019-10-14 12:24</span><br/>
Can anyone explain the appeal of saying things like numbers are just a certain type of list? (Btw: I’ve done set theory and such, so the idea of such an encoding is very familiar, it just leaves me cold, in both mathematical and programming contexts).
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571084651.284200"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571084651.284200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-14 13:24</span><br/>
This entertaining presentation of the paper "What about the natural numbers?" makes a case for treating natural numbers more like lists, in a programming context. It even provides a practical motivation for "lazy natural numbers". <a href="https://www.youtube.com/watch?v=jFk1qpr1ytk">https://www.youtube.com/watch?v=jFk1qpr1ytk</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571084967.284500"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571084967.284500" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2019-10-14 13:29</span><br/>
Thanks, I can’t watch a video right now, but I’ll try to have a look when I can.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571085451.284800"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571085451.284800" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-14 13:37</span><br/>
<span style="background-color:#ccf">@Justin Blank</span> Here's the original paper, it's quite readable: <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.3442&amp;rep=rep1&amp;type=pdf">https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56&hellip;</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571086489.285000"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571086489.285000" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-14 13:54</span><br/>
Also, the Idris language works this way. The natural numbers are defined in the standard library as <tt>data Nat = Z | S Nat</tt>. <a href="https://www.idris-lang.org/example/">https://www.idris-lang.org/example/</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571121111.285900"></a>
      <img src="https://avatars.slack-edge.com/2019-02-05/542651515888_326328f75c3f2a08544c_72.jpg" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571121111.285900" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Edward de Jong</b>
<span style="margin:2em; color:#606060">2019-10-14 23:31</span><br/>
Mathematica being the only commonly used symbolic system, has arbitrary precision available. Excel, the most commonly used programming tool offers protected arithmetic. COBOL, the most derided tool still in use, offers BCD arithmetic, where 0.1 + 0.2 does equal 0.3, (which it does not in IEEE floating point). There are a lot of choices for arithmetic, and it is a very interesting, and fundamentally very important design decision for any language. In my Beads language i offer physical units of measurement which stores the exponents of the fundamental units along with the magnitude of a number, so that when you multiply  kg times meters you have a quantity with mass^1 • length^1, and this is maintained at runtime, so as to support catching mistakes in units both at compile time and more importantly at runtime, which per Van Snyder of JPL is the 3rd most common error in engineering and scientific software. I recently announced this feature to the scientist subgroup of Reddit and got heaps of abuse from scientists who claimed that they never make units mistakes, and couldn't possibly tolerate the additional overhead of storing such things. I was quite surprised by the negative reaction to this very clever implementation of a desired feature from the 70's, and it has taught me that violent opposition to any fundamental change is going to happen. Offering too many kinds of numbers in languages (like INT8 INT16, INT32, INT64) is a hangover from the 70's when you spent a lot of time figuring out how many bytes each field should take, and carefully trimmed field sizes so as to take minimum space. Those days are long gone, and in the JS world, you only have FLOAT64. Too bad IEEE floating point is so stupid, as pointed out in the wonderful talks by Douglas Crockford on its many intrinsic flaws.  It is very hard to fix this nasty problem because of interchange issues, where really we need to change all at once to a better format. That might not happen for another 20 years at the rate we are going.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571122053.286200"></a>
      <img src="https://avatars.slack-edge.com/2021-03-12/1859691333940_e169f54bbaf8b9b36b12_72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571122053.286200" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Konrad Hinsen</b>
<span style="margin:2em; color:#606060">2019-10-14 23:47</span><br/>
Here's a scientist who openly admits having had to deal with unit problems many times, in my own code and in the code of others. In fact, the problem mostly comes from different people tacitly assuming different conventions, so people who use only code they wrote themselves are perhaps in a better situation.<br/>Calling IEEE FP stupid is a sign of... stupidity. A lot of careful thought has gone into that specification, which is a good fit for what it was designed for (scientific computing). People who barely understand it and use it for accounting get the punishment they deserve. The real problem with IEEE FP is that it is commonly presented (in programming tutorials) as "real numbers" making people believe in properties that IEEE FP doesn't have.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571155697.334300"></a>
      <img src="https://secure.gravatar.com/avatar/34185a5422416f82b3e4a62964f2866b.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571155697.334300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Doug Moen</b>
<span style="margin:2em; color:#606060">2019-10-15 09:08</span><br/>
Douglas Crockford's issue is that you can't safely use binary floating point for financial calculations, you should use decimal FP instead. See &lt;http://dec64.com/&gt;. Crockford claims that his DEC64 format is more efficient than IEEE Decimal floating point. He also proposes that DEC64 should be "the only number type in the next generation of application programming languages". That makes sense for spreadsheets, and languages used for financial calculations, but not for everything. No need to wait 20 years, DEC64 is available now on github.<br/><br/>DEC64 is a terrible idea for things like Machine Learning, and 3D graphics (both of which use GPUs). DEC64 would be a bad choice for my project, Curv, which is an end-user programming language for 3D graphics. For these applications, you need efficient binary floating point. IEEE binary floating point is an improvement over the non-IEEE floats found in some older GPU hardware: it has better numerical properties. What might be even better than IEEE FP, for ML and 3D, is "posit" floating point. For a given number of bits, it uses those bits more efficiently and represents a larger range of numbers which are distributed in a more effective way along the number line. Also, IMO, posit arithmetic has better numeric properties than IEEE. &lt;https://posithub.org/docs/BeatingFloatingPoint.pdf&gt;. Posits are <b>not</b> a drop in replacement for IEEE float (your code may need to change), and they aren't competitive unless implemented in hardware (unlike DEC64), so we may be waiting a while. They make the most sense for new ML hardware being built.<br/><br/>For a language like Idris, where you use dependent types to prove programs correct, you need a natural number type, Nat, which implements the Peano axioms directly. You need this so that you can perform inductive proofs over the natural numbers. You need other numeric types as well (Nat doesn't include negative numbers or fractions).<br/><br/>In systems languages like C, C++ and Rust, you need multiple numeric types like int8, int16, int32 and int64, so that you can write high performance code that optimizes memory consumption and memory access patterns and uses the L1 cache efficiently. Systems programming is not "a hangover from the 70's".<br/><br/>If you want to design a programming language that has only a single numeric type, and is competitive in all of these niches, then I have bad news for you.
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top; padding-bottom:1em">
      <a name="1571335071.468300"></a>
      <img src="https://secure.gravatar.com/avatar/6fceba60ff0c90dc32cbff29054b02c2.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png" style="float:left"/>
      <a href="../thinking-together/1570892929.240300.html#1571335071.468300" style="color:#aaa">#</a>
    </td>
    <td style="vertical-align:top; padding-bottom:1em; padding-left:1em">
<b>Justin Blank</b>
<span style="margin:2em; color:#606060">2019-10-17 10:57</span><br/>
Thanks for the link. I don’t find it particularly convincing, but it is interesting.
    </td>
  </tr>
  </table>
<hr>
<a href="https://akkartik.name/foc-archive.zip">download this site</a> (~25MB)<br/>
<a href="https://github.com/akkartik/foc-archive">Git repo</a>
</html>
