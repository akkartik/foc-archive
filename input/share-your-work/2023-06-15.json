[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1686822821.603449",
        "client_msg_id": "be74c44e-df83-4914-9864-96454e0b2cc8",
        "text": "“… longer. Did you reorganize or something?…”  Not intentionally, but operator error is certainly a possibility.  I’ll see if I can access backups from around then.  Is it safe to say that you saw this essay around Apr. 18 (the date of the original post in this thread)?",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1681811012.388819",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yTfDd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "“… longer. Did you reorganize or something?…”  Not intentionally, but operator error is certainly a possibility.  I’ll see if I can access backups from around then.  Is it safe to say that you saw this essay around Apr. 18 (the date of the original post in this thread)?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1686823760.818089",
        "client_msg_id": "5e8b951e-36db-4dfb-acd1-1e8eb74c0a15",
        "text": "“Inlining … Increasing rather than decreasing code size.”  True.  I guess that I’m thinking about how this is done, i.e. if you can do inlining, then deduplication is just around the corner.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1681811012.388819",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FnJD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "“Inlining … Increasing rather than decreasing code size.”  True.  I guess that I’m thinking about how this is done, i.e. if you can do inlining, then deduplication is just around the corner."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1686824613.393479",
        "client_msg_id": "6b939a90-0544-4c30-994c-5ea1c2bbdd30",
        "text": "“It’s a lot easier to create a …”\nSpecialization instead of generalization.  Fork-ing is specialization.  I argue that there is a huge gap in Simplicity between the two approaches.  I argue that Generalization does not make programming better and leads to bloatware.  We, finally, have tools that allow us to Specialize easily (e.g. Ohm-JS, PEG, PROLOG, github, etc.) and should be working out ways to Specialize on a per-project basis.  That’s the flavour I get from your talk, too. [None of the above-mentioned tools \/ techniques are “new”, but we now have the freedom to use them in earnest, instead of doing things the way we’ve always done them (envisioned in the 1950s, based on biases from the 1950s)].",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1681811012.388819",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QVqjV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "“It’s a lot easier to create a …”\nSpecialization instead of generalization.  Fork-ing is specialization.  I argue that there is a huge gap in Simplicity between the two approaches.  I argue that Generalization does not make programming better and leads to bloatware.  We, finally, have tools that allow us to Specialize easily (e.g. Ohm-JS, PEG, PROLOG, github, etc.) and should be working out ways to Specialize on a per-project basis.  That’s the flavour I get from your talk, too. [None of the above-mentioned tools \/ techniques are “new”, but we now have the freedom to use them in earnest, instead of doing things the way we’ve always done them (envisioned in the 1950s, based on biases from the 1950s)]."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1686825262.038799",
        "client_msg_id": "7f212333-881f-4304-974a-f26cf446e67c",
        "text": "The ground truth has changed.\n\nCPUs are cheap and abundant.  Memory is cheap and abundant.  None of this was true in the 1950s.\n\nFor example, we don’t need to waste our time figuring out how to time-share CPUs and we don’t need to waste our time dealing with the consequences of doing so.  A whole swath of problems simply dissolve, starting with “thread safety”.  If you need more than one process, you use more than one CPU, instead of forcing code to share a single CPU.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1681811012.388819",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O3g=E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The ground truth has changed.\n\nCPUs are cheap and abundant.  Memory is cheap and abundant.  None of this was true in the 1950s.\n\nFor example, we don’t need to waste our time figuring out how to time-share CPUs and we don’t need to waste our time dealing with the consequences of doing so.  A whole swath of problems simply dissolve, starting with “thread safety”.  If you need more than one process, you use more than one CPU, instead of forcing code to share a single CPU."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1686838608.896329",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1686838676.000000"
        },
        "client_msg_id": "32265436-4058-4fe2-a34b-72f6c1d2938f",
        "text": "&gt; ..if you can do inlining, then deduplication is just around the corner.\n&gt; \nIf you can do multiplication, factoring is around the corner? :slightly_smiling_face:\n\nYou don't need thread safety to access more than one CPU. You only need it for threads _that share data_. Keep the data disjoint, and life is much better.\n\n&gt; Is it safe to say that you saw this essay around Apr. 18 (the date of the original post in this thread)?\n&gt; \nDefinitely. Could be an incorrect link on my part as well, or I might not be quoting you exactly..\n\nYou're absolutely right that compilers may not be needed for many tasks. Maybe just don't mention them.\n\nIt would be _very_ interesting to come up with a framework of some sort that lets people tag duplicate sections in their own code. Like a structured editor that allows transclusion.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1681811012.388819",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fVE",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "..if you can do inlining, then deduplication is just around the corner.\n"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIf you can do multiplication, factoring is around the corner? "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": "\n\nYou don't need thread safety to access more than one CPU. You only need it for threads "
                            },
                            {
                                "type": "text",
                                "text": "that share data",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Keep the data disjoint, and life is much better.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is it safe to say that you saw this essay around Apr. 18 (the date of the original post in this thread)?\n"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nDefinitely. Could be an incorrect link on my part as well, or I might not be quoting you exactly..\n\nYou're absolutely right that compilers may not be needed for many tasks. Maybe just don't mention them.\n\nIt would be "
                            },
                            {
                                "type": "text",
                                "text": "very",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " interesting to come up with a framework of some sort that lets people tag duplicate sections in their own code. Like a structured editor that allows transclusion."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1686840885.073689",
        "client_msg_id": "b4471616-349e-40e6-8375-fd56fd894c82",
        "text": "“It would be very interesting … that lets people tag duplicate sections in their own code. …” It would be even more interesting if the machine could do it, instead of wasting peoples’ time.  To me, things like git, diff, NiCaD seem related.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1681811012.388819",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QSLw7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "“It would be very interesting … that lets people tag duplicate sections in their own code. …” It would be even more interesting if the machine could do it, instead of wasting peoples’ time.  To me, things like git, diff, NiCaD seem related."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1686841304.324429",
        "client_msg_id": "a2306633-71ea-4a7b-9f19-7bf162822f9e",
        "text": "To summarize this sub-thread of the conversation: you might have (apocryphal) once said \"just let the compiler handle all deduplication\" [without ever slowing things down] or words to that effect. It seems you still believe this :slightly_smiling_face: My strong claim is this is impossible (akin to proving P=NP) in the general case. So your options are to manage it manually either by creating techniques in the context of specific codebases, or having programmers juggle function boundaries, or having programmers juggle function boundaries while looking like some cool transclusion effect. There may be other choices, but this is the picture as I can best see it right now. Not trying to score debating points or anything, trying to be as balanced as possible.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1681811012.388819",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5ni",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To summarize this sub-thread of the conversation: you might have (apocryphal) once said \"just let the compiler handle all deduplication\" [without ever slowing things down] or words to that effect. It seems you still believe this "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " My strong claim is this is impossible (akin to proving P=NP) in the general case. So your options are to manage it manually either by creating techniques in the context of specific codebases, or having programmers juggle function boundaries, or having programmers juggle function boundaries while looking like some cool transclusion effect. There may be other choices, but this is the picture as I can best see it right now. Not trying to score debating points or anything, trying to be as balanced as possible."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "white_check_mark",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1686841617.934989",
        "client_msg_id": "a89c3a1c-0948-46c6-9659-4acf780debb0",
        "text": "Zooming out to the argument as a whole, this is more evidence that you need more examples. Hand-create more example programs, spend some time hand-compiling them. I think you'll quickly run into situations where two code paths look very similar but slow things down when deduplicated. But the only way to confirm this is to create more examples.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1681811012.388819",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S4O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Zooming out to the argument as a whole, this is more evidence that you need more examples. Hand-create more example programs, spend some time hand-compiling them. I think you'll quickly run into situations where two code paths look very similar but slow things down when deduplicated. But the only way to confirm this is to create more examples."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "white_check_mark",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1686855709.386279",
        "client_msg_id": "d34be81f-982c-458a-b424-065db6c587e8",
        "text": "Fun stuff. l’art pour l’art.  Mostly.  The bit about emotions in programming hit the mark, IMHO.  I wrote about emotions in the context of the always rational and level-headed static\/dynamic typing debate:\n\n[The Safyness of Static Typing](<https:\/\/blog.metaobject.com\/2014\/06\/the-safyness-of-static-typing.html>)\n\nI think there’s a lot more there, if we dig.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1685590624.584419",
        "parent_user_id": "UC2A2ARPT",
        "attachments": [
            {
                "from_url": "https:\/\/blog.metaobject.com\/2014\/06\/the-safyness-of-static-typing.html",
                "service_icon": "https:\/\/blog.metaobject.com\/favicon.ico",
                "id": 1,
                "original_url": "https:\/\/blog.metaobject.com\/2014\/06\/the-safyness-of-static-typing.html",
                "fallback": "The Safyness of Static Typing",
                "text": "I like static (manifest) typing. This may come as a shock to those who have read other posts of mine, but it is true. I certainly am mor...",
                "title": "The Safyness of Static Typing",
                "title_link": "https:\/\/blog.metaobject.com\/2014\/06\/the-safyness-of-static-typing.html",
                "service_name": "blog.metaobject.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AsIz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Fun stuff. l’art pour l’art.  Mostly.  The bit about emotions in programming hit the mark, IMHO.  I wrote about emotions in the context of the always rational and level-headed static\/dynamic typing debate:\n\n[The Safyness of Static Typing]("
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/blog.metaobject.com\/2014\/06\/the-safyness-of-static-typing.html"
                            },
                            {
                                "type": "text",
                                "text": ")\n\nI think there’s a lot more there, if we dig."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U03R0B9U1GD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1686856133.139529",
        "client_msg_id": "89fb134a-2300-407a-b0ec-9ddd52a53cd1",
        "text": "I think BASIC is underappreciated these days.\n\nApart from memory safety (with the concept really not even surfacing), BASIC also has some advantages in being very straightforward and linear, rather than hierarchical. Which is not just easy to understand. but actually also a close analogue to how the CPU executes instructions, at least conceptually.\n\nThat also enables a very direct transition from immediate mode execution to stored program:  just add a line number in front.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1686591251.099979",
        "parent_user_id": "U01U19ECZTJ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EubJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think BASIC is underappreciated these days.\n\nApart from memory safety (with the concept really not even surfacing), BASIC also has some advantages in being very straightforward and linear, rather than hierarchical. Which is not just easy to understand. but actually also a close analogue to how the CPU executes instructions, at least conceptually.\n\nThat also enables a very direct transition from immediate mode execution to stored program:  just add a line number in front."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "with encouragement from <@U055QFU92JK>, down to share what I’m doing…\n\nI make <http:\/\/lintrule.com|lintrule.com>, a little CLI for having a language model do your code review.\n\nYou write rules in plain text, and then it checks them against your code, like a test framework. Here’s an example rule that runs on SQL migrations:\n\n```---\ninclude: [\"migrations\/*.sql\"]\n---\n\nMake sure our postgres migrations follow these rules:\n\n1. ensure new tables are at least 3NF (third normal form). If they're not, fail and give an example of what's wrong, assuming the reader does not know terms like \"BNCF\", \"3NF\", \"BCNF\", and so on.\n2. make sure that all tables have a created_at and updated_at\n3. make sure migrations don't have breaking changes. For example, removing a table, removing column, and so on.\n   3.1 It's okay to have a breaking change if there's a comment on the migration that explains why it's safe to have that change.\n4. prefer 'uuid' over 'serial' or 'int' for primary keys. Ignore this check if it's primary key made up of two columns.```\n",
        "files": [
            {
                "id": "F05CLMDLLRL",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "U05BY4YJ9QU",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4J7G",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "with encouragement from "
                            },
                            {
                                "type": "user",
                                "user_id": "U055QFU92JK"
                            },
                            {
                                "type": "text",
                                "text": ", down to share what I’m doing…\n\nI make "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/lintrule.com",
                                "text": "lintrule.com"
                            },
                            {
                                "type": "text",
                                "text": ", a little CLI for having a language model do your code review.\n\nYou write rules in plain text, and then it checks them against your code, like a test framework. Here’s an example rule that runs on SQL migrations:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "---\ninclude: [\"migrations\/*.sql\"]\n---\n\nMake sure our postgres migrations follow these rules:\n\n1. ensure new tables are at least 3NF (third normal form). If they're not, fail and give an example of what's wrong, assuming the reader does not know terms like \"BNCF\", \"3NF\", \"BCNF\", and so on.\n2. make sure that all tables have a created_at and updated_at\n3. make sure migrations don't have breaking changes. For example, removing a table, removing column, and so on.\n   3.1 It's okay to have a breaking change if there's a comment on the migration that explains why it's safe to have that change.\n4. prefer 'uuid' over 'serial' or 'int' for primary keys. Ignore this check if it's primary key made up of two columns."
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1686867634.503979",
        "client_msg_id": "5a01fdbd-4580-430b-bdc1-0537f59ed114",
        "thread_ts": "1686867634.503979",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1686943227.089319",
        "reply_users": [
            "U02U0AS3J49"
        ],
        "replies": [
            {
                "user": "U02U0AS3J49",
                "ts": "1686943227.089319"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "cool",
                "users": [
                    "U055QFU92JK",
                    "UMQ6LR9NZ",
                    "U0245E9RB2B",
                    "UPVBV34EL",
                    "U79HM6726",
                    "U036DC03FE1"
                ],
                "count": 6
            },
            {
                "name": "eyes",
                "users": [
                    "UMQ6LR9NZ"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "U02U0AS3J49",
                    "U05CF6KLESV"
                ],
                "count": 2
            }
        ]
    }
]