[
    {
        "user": "U04E5QAD6DD",
        "type": "message",
        "ts": "1696952062.537249",
        "client_msg_id": "e8e10fae-e376-4d12-bccf-f6fc18ce0923",
        "text": "I was curious this morning: my naïve view of compiler history is that they used to be very small (due to performance constraints) and have gotten very complicated over the years in order to support multiple platforms and in order to employ more and more optimizations. Is that generally a fair take? What are the big changes to compiler architectures from the early days? Does something like LLVM produce enough better code to justify its complexity? Are there any blog post- or paper-length history of compilers articles out there? (I'm not quite so curious as to be ready to read a whole book, but if you've got a good recommendation…)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "e3e6bba2ae45",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-06\/5085861186081_e3e6bba2ae4575d17358_72.jpg",
            "first_name": "David",
            "real_name": "David Alan Hjelle",
            "display_name": "David Alan Hjelle",
            "team": "T5TCAFTA9",
            "name": "dahjelle_futureofcodi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1696952062.537249",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1697015559.901719",
        "reply_users": [
            "UNS7QDKFV",
            "UKJGU23KP"
        ],
        "replies": [
            {
                "user": "UNS7QDKFV",
                "ts": "1696971900.506849"
            },
            {
                "user": "UKJGU23KP",
                "ts": "1697015559.901719"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0xnQD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was curious this morning: my naïve view of compiler history is that they used to be very small (due to performance constraints) and have gotten very complicated over the years in order to support multiple platforms and in order to employ more and more optimizations. Is that generally a fair take? What are the big changes to compiler architectures from the early days? Does something like LLVM produce enough better code to justify its complexity? Are there any blog post- or paper-length history of compilers articles out there? (I'm not quite so curious as to be ready to read a whole book, but if you've got a good recommendation…)"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UNS7QDKFV",
        "type": "message",
        "ts": "1696971900.506849",
        "client_msg_id": "adda9d85-e48e-4742-bfa4-52a0cde66ae0",
        "text": "One change is that companies don't need to build their own complete compiler anymore.  Previously, each company might buy a front end (e.g. EDG) for parsing, but the rest of the compiler they had to build in-house (or go complete open and extend gcc).  In addition to hardware performance constraints, the compiler size (and complexity) was limited to what size compiler team a company was willing to fund.  With LLVM, companies can focus on the pieces specific to their needs.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gbc993d98fe7",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/bc993d98fe7bf26c048ac0818a598d4d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0001-72.png",
            "first_name": "",
            "real_name": "Mark Dewing",
            "display_name": "Mark Dewing",
            "team": "T5TCAFTA9",
            "name": "markdewing",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1696952062.537249",
        "parent_user_id": "U04E5QAD6DD",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xkRFX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One change is that companies don't need to build their own complete compiler anymore.  Previously, each company might buy a front end (e.g. EDG) for parsing, but the rest of the compiler they had to build in-house (or go complete open and extend gcc).  In addition to hardware performance constraints, the compiler size (and complexity) was limited to what size compiler team a company was willing to fund.  With LLVM, companies can focus on the pieces specific to their needs."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "U04E5QAD6DD",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    }
]