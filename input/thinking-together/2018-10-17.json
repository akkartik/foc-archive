[
    {
        "subtype": "thread_broadcast",
        "user": "U5STGTB3J",
        "thread_ts": "1539532046.000100",
        "root": {
            "user": "UCUSW7WVD",
            "type": "message",
            "ts": "1539532046.000100",
            "client_msg_id": "750b09dc-88b5-4207-a261-36d8bb3be788",
            "text": "While I disagree with <@UA14TGLTC>'s comment about the monetization angle being unimportant, the observation of relative scale of YouTube and GitHub is extremely relevant here, and also to the side thread on business models and supply chains (<https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1539470382000100;> thanks <@U5STGTB3J> for engaging with me). As non-monetary concerns grow in importance, it becomes harder to reason about those concerns. I think that imposes a limit on how complex business models can get if you also care about the quality of creation (particularly for 'soft' products like videos or software), or about things like ethical sourcing and CO2 emissions.\n\nModern supply chains are incredibly complex: <https:\/\/logicmag.io\/04-see-no-evil>. Hard to imagine they come out unscathed if we start caring about more than money. The recent fracas about SoftMicro and hardware security is another example here.",
            "team": "T5TCAFTA9",
            "thread_ts": "1539532046.000100",
            "reply_count": 3,
            "reply_users_count": 2,
            "latest_reply": "1540225253.000100",
            "reply_users": [
                "U5STGTB3J",
                "UCUSW7WVD"
            ],
            "replies": [
                {
                    "user": "U5STGTB3J",
                    "ts": "1539787587.000100"
                },
                {
                    "user": "UCUSW7WVD",
                    "ts": "1540005276.000100"
                },
                {
                    "user": "U5STGTB3J",
                    "ts": "1540225253.000100"
                }
            ],
            "is_locked": false,
            "subscribed": false,
            "attachments": [
                {
                    "from_url": "https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1539470382000100;",
                    "fallback": "[October 13th, 2018 3:39 PM] stefanlesser: <@UCUSW7WVD> Interesting. I’m trying to wrap my head around tasks where extrinsic incentives work well according to your definition — do you have an example for what you had in mind?\n\nAnd if I understand you correctly, you mean that writing software does not fall into that category?\nDoes that mean you are arguing software shouldn’t be sold (for money)?\n\nAnd I have to admit that you lost me at the end with passion and motivation… to me it sounds like the best word for what you describe is _trust_. But I’m not sure where that connects to the original thought about money.\n\nGoing back to <@UC6997THT>’s YouTube example: I think “YouTube would be 1000x better without money” triggered my response, because I think it’s very easy to make the mistake of only seeing the negative side of money, the corruption, the misguided incentives (based on making money over delivering value), and all the business-types who show up that we’d rather like to stay home. But that’s unfortunately how markets work. If there is value, people will come and try to exploit that. But it also paves the way and breaks down barriers of entry for everyone, making it possible for real value creators and those who just want to express themselves to contribute. The money amplifies or accelerates both the good and the bad parts. One comes with the other. Even if we’d only like to have the good parts.",
                    "ts": "1539470382.000100",
                    "author_id": "U5STGTB3J",
                    "author_subname": "Stefan Lesser",
                    "channel_id": "C5T9GPWFL",
                    "is_msg_unfurl": true,
                    "is_thread_root_unfurl": true,
                    "text": "<@UCUSW7WVD> Interesting. I’m trying to wrap my head around tasks where extrinsic incentives work well according to your definition — do you have an example for what you had in mind?\n\nAnd if I understand you correctly, you mean that writing software does not fall into that category?\nDoes that mean you are arguing software shouldn’t be sold (for money)?\n\nAnd I have to admit that you lost me at the end with passion and motivation… to me it sounds like the best word for what you describe is _trust_. But I’m not sure where that connects to the original thought about money.\n\nGoing back to <@UC6997THT>’s YouTube example: I think “YouTube would be 1000x better without money” triggered my response, because I think it’s very easy to make the mistake of only seeing the negative side of money, the corruption, the misguided incentives (based on making money over delivering value), and all the business-types who show up that we’d rather like to stay home. But that’s unfortunately how markets work. If there is value, people will come and try to exploit that. But it also paves the way and breaks down barriers of entry for everyone, making it possible for real value creators and those who just want to express themselves to contribute. The money amplifies or accelerates both the good and the bad parts. One comes with the other. Even if we’d only like to have the good parts.",
                    "author_name": "Stefan Lesser",
                    "author_link": "https:\/\/futureprogramming.slack.com\/team\/U5STGTB3J",
                    "author_icon": "https:\/\/avatars.slack-edge.com\/2017-08-20\/228447816352_649181907e06ec450c64_48.jpg",
                    "mrkdwn_in": [
                        "text"
                    ],
                    "id": 1,
                    "original_url": "https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1539470382000100;",
                    "footer": "Thread in Slack Conversation"
                },
                {
                    "service_name": "Logic Magazine",
                    "title": "See No Evil",
                    "title_link": "https:\/\/logicmag.io\/04-see-no-evil",
                    "text": "Software helps companies coordinate the supply chains that sustain global capitalism. How does the code work—and what does it conceal?",
                    "fallback": "Logic Magazine: See No Evil",
                    "image_url": "https:\/\/logicmag.io\/content\/images\/2018\/08\/posner-2.jpg",
                    "image_width": 375,
                    "image_height": 250,
                    "ts": 1533682258,
                    "from_url": "https:\/\/logicmag.io\/04-see-no-evil",
                    "image_bytes": 287163,
                    "service_icon": "https:\/\/logicmag.io\/favicon.ico",
                    "id": 2,
                    "original_url": "https:\/\/logicmag.io\/04-see-no-evil"
                }
            ],
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "b56",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "While I disagree with "
                                },
                                {
                                    "type": "user",
                                    "user_id": "UA14TGLTC"
                                },
                                {
                                    "type": "text",
                                    "text": "'s comment about the monetization angle being unimportant, the observation of relative scale of YouTube and GitHub is extremely relevant here, and also to the side thread on business models and supply chains ("
                                },
                                {
                                    "type": "link",
                                    "url": "https:\/\/futureprogramming.slack.com\/archives\/C5T9GPWFL\/p1539470382000100;"
                                },
                                {
                                    "type": "text",
                                    "text": " thanks "
                                },
                                {
                                    "type": "user",
                                    "user_id": "U5STGTB3J"
                                },
                                {
                                    "type": "text",
                                    "text": " for engaging with me). As non-monetary concerns grow in importance, it becomes harder to reason about those concerns. I think that imposes a limit on how complex business models can get if you also care about the quality of creation (particularly for 'soft' products like videos or software), or about things like ethical sourcing and CO2 emissions.\n\nModern supply chains are incredibly complex: "
                                },
                                {
                                    "type": "link",
                                    "url": "https:\/\/logicmag.io\/04-see-no-evil"
                                },
                                {
                                    "type": "text",
                                    "text": ". Hard to imagine they come out unscathed if we start caring about more than money. The recent fracas about SoftMicro and hardware security is another example here."
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        "type": "message",
        "ts": "1539787587.000100",
        "client_msg_id": "7C875CFF-5582-43AD-8BE6-3288F722F9EF",
        "text": "This seems to be a relevant complement to this discussion: \n<https:\/\/vimeo.com\/294678123>",
        "attachments": [
            {
                "service_name": "Vimeo",
                "service_url": "https:\/\/vimeo.com\/",
                "title": "A Day in the Life of the Future: JP Parker at BlockConscious 2018",
                "title_link": "https:\/\/vimeo.com\/294678123",
                "author_name": "JP Parker",
                "author_link": "https:\/\/vimeo.com\/jpparker",
                "thumb_url": "https:\/\/i.vimeocdn.com\/video\/731643635_295x166.jpg",
                "thumb_width": 295,
                "thumb_height": 166,
                "text": "At this pivotal moment in our history as a species, what are the contours of the future we are shaping together? What could they be? It really is up to us, each and all.",
                "fallback": "Vimeo Video: A Day in the Life of the Future: JP Parker at BlockConscious 2018",
                "video_html": "<iframe src=\"https:\/\/player.vimeo.com\/video\/294678123?autoplay=1&app_id=122963\" width=\"400\" height=\"225\" frameborder=\"0\" title=\"A Day in the Life of the Future: JP Parker at BlockConscious 2018\" webkitallowfullscreen mozallowfullscreen allowfullscreen><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https:\/\/vimeo.com\/294678123",
                "service_icon": "https:\/\/a.slack-edge.com\/bfaba\/img\/unfurl_icons\/vimeo.png",
                "id": 1,
                "original_url": "https:\/\/vimeo.com\/294678123"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mhb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This seems to be a relevant complement to this discussion: \n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/vimeo.com\/294678123"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCKRZS3DZ",
        "type": "message",
        "ts": "1539804704.000100",
        "edited": {
            "user": "UCKRZS3DZ",
            "ts": "1539805400.000000"
        },
        "client_msg_id": "cd58f1d5-da55-4ad9-81af-b8ec37c82b08",
        "text": "<@U8A5MS6R1> and others. I was thinking about subject of your article.\nHere are some thoughts that I haven't yet enough time to prototype (recently even weekends are packed), yet I think you and others may find interesting.\n\nAssumption: actors with isolation (like in Erlang) might be really good abstraction to shape systems.\n\n1) Any applications is just bunch of actors that spawn children, send and receive messages from\/to each other.\n2) If actors depend only from their input (received messages), then we can have live time-travel code editing. We can record all IO for processes, select moment in the middle, change code of process and start execution again. Create a new branch of history.\n2.1) But this is not always possible. There must be actors which depend not only on their input: e.g. file handlers, sockets, OS timer. Similar to pure and dirty functions, we also have pure (processes) and dirty (ports) actors. Processes can go back in time and start new branch of exection (with different code). Ports cannot -- they terminate and supposed to be restarted by system.\n\nInteresting, but looks like code for process might be in any PL, as long as it fits into behavior of process.\n\n3) Supervisor config in Erlang and kubernetes config for services are awfully similar. Can we manage instances of applications the same way we manage little processes inside application? Probably there must be third kind of actors: a remote instance.\n\nRemote instances are similar enough to ports and processes to be managed by same supervisor code, yet they behave differently:\n\n * they may lose some of the messages in the middle of conversation\n * there is no way to learn that it died, in case of network split\n\nThis very fact that you can have everything in single system, is really powerful.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "222a2870915d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-15\/861537614034_222a2870915d24ec10cc_72.jpg",
            "first_name": "Vladimir",
            "real_name": "Vladimir Gordeev",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gordeev.vladimir.v",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1539804704.000100",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1539812270.000100",
        "reply_users": [
            "U8A5MS6R1"
        ],
        "replies": [
            {
                "user": "U8A5MS6R1",
                "ts": "1539812270.000100"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9l8d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " and others. I was thinking about subject of your article.\nHere are some thoughts that I haven't yet enough time to prototype (recently even weekends are packed), yet I think you and others may find interesting.\n\nAssumption: actors with isolation (like in Erlang) might be really good abstraction to shape systems.\n\n1) Any applications is just bunch of actors that spawn children, send and receive messages from\/to each other.\n2) If actors depend only from their input (received messages), then we can have live time-travel code editing. We can record all IO for processes, select moment in the middle, change code of process and start execution again. Create a new branch of history.\n2.1) But this is not always possible. There must be actors which depend not only on their input: e.g. file handlers, sockets, OS timer. Similar to pure and dirty functions, we also have pure (processes) and dirty (ports) actors. Processes can go back in time and start new branch of exection (with different code). Ports cannot -- they terminate and supposed to be restarted by system.\n\nInteresting, but looks like code for process might be in any PL, as long as it fits into behavior of process.\n\n3) Supervisor config in Erlang and kubernetes config for services are awfully similar. Can we manage instances of applications the same way we manage little processes inside application? Probably there must be third kind of actors: a remote instance.\n\nRemote instances are similar enough to ports and processes to be managed by same supervisor code, yet they behave differently:\n\n * they may lose some of the messages in the middle of conversation\n * there is no way to learn that it died, in case of network split\n\nThis very fact that you can have everything in single system, is really powerful."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U8A5MS6R1",
        "type": "message",
        "ts": "1539812270.000100",
        "client_msg_id": "81020ffd-438b-4a32-8260-de89836aaf84",
        "text": "Very interesting. This here is a key observation, I believe:\n\n&gt;  If actors depend only from their input (received messages), then we can have live time-travel code editing. We can record all IO for processes, select moment in the middle, change code of process and start execution again. Create a new branch of history.\n\nI'm going to dig into this aspect a bit, and ignore the others for now, because it is the part I find most interesting.\n\nBasically computation processes are modeled as this transform:\n\n`messageIn + objectX@v1 --&gt; objectX@v2 + messageOut`\n\nAnd this is reliable, repeatable transform - aka 'functional'. This is the start of managed time.. if you keep the object history, you can go back to the older version and then replay the inputs to get exactly the same subsequent state. An interesting write-up about these ideas is: <https:\/\/www.quora.com\/Why-is-functional-programming-seen-as-the-opposite-of-OOP-rather-than-an-addition-to-it>\n\nExcerpts:\n&gt; this would allow “real objects” to be world-lines of their stable states and they could get to their next stable state in a completely functional manner.\n\n&gt; You really only want views to be allowed on stable objects\n\nThe above point is important, while the object is 'processing' the message, it doesn't process other messages, so it is only visible in its stable, consistent states.\n\nNow how do these individual objects compose as peers? Some ideas are in Pseudo Time (David Reed) and Virtual Time (David Jefferson). The main idea is to embed a 'pseudo time' in each and every message. So each object transformation propagates monotonically increasing pseudo times to the emitted messages. Now perhaps we can revert entire clusters of objects to previous, consistent states and replay some messages. If messages leave our system into a different world (e.g. the 'file system world' - then we've already lost) -- but if the whole system consists of objects modeled and incorporates the pseudo time, you can basically roll back any object (in theory). The pseudo time tracks which 'timeline' objects are part of, globally. (In practice even if you can't roll back, you'll know exactly where the system becomes inconsistent.)\n\nIMO this is the essence of the idea behind MVCC, git and datomic too, but they limit the idea to a subset of the system - just a dead data structure, and operate on it from the outside.\n\nThere are lot of details that would need to be worked out, e.g. if and how objects compose to form larger encapsulated structures? How is the object state and functional transform actually represented? Etc.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "b7c63cc07373",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-03-21\/584465935395_b7c63cc07373326ec6ea_72.jpg",
            "first_name": "Shalabh",
            "real_name": "Shalabh",
            "display_name": "shalabh",
            "team": "T5TCAFTA9",
            "name": "shalabh.chaturvedi",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1539804704.000100",
        "parent_user_id": "UCKRZS3DZ",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "31V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Very interesting. This here is a key observation, I believe:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " If actors depend only from their input (received messages), then we can have live time-travel code editing. We can record all IO for processes, select moment in the middle, change code of process and start execution again. Create a new branch of history."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nI'm going to dig into this aspect a bit, and ignore the others for now, because it is the part I find most interesting.\n\nBasically computation processes are modeled as this transform:\n\n"
                            },
                            {
                                "type": "text",
                                "text": "messageIn + objectX@v1 --> objectX@v2 + messageOut",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nAnd this is reliable, repeatable transform - aka 'functional'. This is the start of managed time.. if you keep the object history, you can go back to the older version and then replay the inputs to get exactly the same subsequent state. An interesting write-up about these ideas is: "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.quora.com\/Why-is-functional-programming-seen-as-the-opposite-of-OOP-rather-than-an-addition-to-it"
                            },
                            {
                                "type": "text",
                                "text": "\n\nExcerpts:"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this would allow “real objects” to be world-lines of their stable states and they could get to their next stable state in a completely functional manner."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You really only want views to be allowed on stable objects"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nThe above point is important, while the object is 'processing' the message, it doesn't process other messages, so it is only visible in its stable, consistent states.\n\nNow how do these individual objects compose as peers? Some ideas are in Pseudo Time (David Reed) and Virtual Time (David Jefferson). The main idea is to embed a 'pseudo time' in each and every message. So each object transformation propagates monotonically increasing pseudo times to the emitted messages. Now perhaps we can revert entire clusters of objects to previous, consistent states and replay some messages. If messages leave our system into a different world (e.g. the 'file system world' - then we've already lost) -- but if the whole system consists of objects modeled and incorporates the pseudo time, you can basically roll back any object (in theory). The pseudo time tracks which 'timeline' objects are part of, globally. (In practice even if you can't roll back, you'll know exactly where the system becomes inconsistent.)\n\nIMO this is the essence of the idea behind MVCC, git and datomic too, but they limit the idea to a subset of the system - just a dead data structure, and operate on it from the outside.\n\nThere are lot of details that would need to be worked out, e.g. if and how objects compose to form larger encapsulated structures? How is the object state and functional transform actually represented? Etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UCKRZS3DZ"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UCKRZS3DZ"
                ],
                "count": 1
            }
        ]
    }
]