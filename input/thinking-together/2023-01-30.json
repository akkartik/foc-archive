[
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1675067890.920269",
        "client_msg_id": "dbf490f2-71f3-4622-b0d0-9c57c48742b8",
        "text": "<https:\/\/2019.splashcon.org\/details\/splash-2019-Onward-papers\/7\/Storage-Combinators|Storage Combinators> don’t have transactions built-in per-se, but allow for something that’s even better, IMHO:  you can build them yourself and then integrate the result into the <http:\/\/objective.st|language> in such a way that it is indistinguishable from being built in.\n\nAt least I am pretty sure it could be done, as I haven’t built that particular piece yet.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674241729.054749",
        "parent_user_id": "ULM3U6275",
        "attachments": [
            {
                "from_url": "https:\/\/2019.splashcon.org\/details\/splash-2019-Onward-papers\/7\/Storage-Combinators",
                "service_icon": "https:\/\/2019.splashcon.org\/favicon.ico",
                "id": 1,
                "original_url": "https:\/\/2019.splashcon.org\/details\/splash-2019-Onward-papers\/7\/Storage-Combinators",
                "fallback": "Storage Combinators (SPLASH 2019 - Onward! Papers) - SPLASH 2019",
                "text": "Onward! is a premier multidisciplinary conference focused on everything to do with programming and software: including processes, methods, languages, communities, applications and education. Onward! is more radical, more visionary, and more open than other conferences to ideas that are well-argued but not yet proven. We welcome different ways of thinking about, approaching, and reporting on programming language and software engineering research. \nThe Character of Onward! \nOnward! is looking for grand visions and new paradigms that could make a big difference in how we will one day build so ...",
                "title": "Storage Combinators (SPLASH 2019 - Onward! Papers) - SPLASH 2019",
                "title_link": "https:\/\/2019.splashcon.org\/details\/splash-2019-Onward-papers\/7\/Storage-Combinators",
                "service_name": "2019.splashcon.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TGo6X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/2019.splashcon.org\/details\/splash-2019-Onward-papers\/7\/Storage-Combinators",
                                "text": "Storage Combinators"
                            },
                            {
                                "type": "text",
                                "text": " don’t have transactions built-in per-se, but allow for something that’s even better, IMHO:  you can build them yourself and then integrate the result into the "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/objective.st",
                                "text": "language"
                            },
                            {
                                "type": "text",
                                "text": " in such a way that it is indistinguishable from being built in.\n\nAt least I am pretty sure it could be done, as I haven’t built that particular piece yet."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1675068378.006549",
        "client_msg_id": "eb562dbb-cd6a-4a79-acb5-6e7d53556d7a",
        "text": "While I don’t believe 0D is possible, it certainly is true that our current dominant architectural style, call\/return, couples way more than it should, and is largely <https:\/\/repository.upenn.edu\/cgi\/viewcontent.cgi?article=1074&amp;context=library_papers|mismatched> with the <https:\/\/dl.ifip.org\/db\/conf\/ehci\/ehci2007\/Chatty07.pdf|majority of systems> we build today.\n\nI talk about this in some detail in <https:\/\/dl.acm.org\/doi\/10.1145\/3397537.3397546|Can Programmers Escape the Gentle Tyranny of Call\/Return>.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HWfKt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "While I don’t believe 0D is possible, it certainly is true that our current dominant architectural style, call\/return, couples way more than it should, and is largely "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/repository.upenn.edu\/cgi\/viewcontent.cgi?article=1074&context=library_papers",
                                "text": "mismatched"
                            },
                            {
                                "type": "text",
                                "text": " with the "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/dl.ifip.org\/db\/conf\/ehci\/ehci2007\/Chatty07.pdf",
                                "text": "majority of systems"
                            },
                            {
                                "type": "text",
                                "text": " we build today.\n\nI talk about this in some detail in "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/dl.acm.org\/doi\/10.1145\/3397537.3397546",
                                "text": "Can Programmers Escape the Gentle Tyranny of Call\/Return"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U017TE5R09M",
        "type": "message",
        "ts": "1675068549.772679",
        "client_msg_id": "c738870f-388c-4f44-b2eb-8b0adcf6f618",
        "text": "As an example, it turns out that dataflow (in particular of the pipe\/filter kind) is actually the more flexible \/ more basic style, because you can easily and generically implement call\/return in terms of pipes\/filters but not the other way around, at least not without sacrificing important performance properties of dataflow.  Which was a bit of a surprising result to be honest.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "d0068f3c51a5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-07\/4763954018659_d0068f3c51a5a00a3b73_72.jpg",
            "first_name": "",
            "real_name": "Marcel Weiher",
            "display_name": "Marcel Weiher",
            "team": "T5TCAFTA9",
            "name": "marcel.weiher",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/xRUg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As an example, it turns out that dataflow (in particular of the pipe\/filter kind) is actually the more flexible \/ more basic style, because you can easily and generically implement call\/return in terms of pipes\/filters but not the other way around, at least not without sacrificing important performance properties of dataflow.  Which was a bit of a surprising result to be honest."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UA14TGLTC",
        "type": "message",
        "ts": "1675094970.899729",
        "client_msg_id": "76340656-975c-4ec6-bada-59f1a7274dcb",
        "text": "Curious to learn more, I listened to <@U017TE5R09M> over here <https:\/\/www.youtube.com\/watch?v=Gel8ffr4pqw>.  The Q&amp;A has a few familiar faces.\n\nThe idea, as I understand it, is that we often want to connect bits of data `y = f(x)` but call\/return unnecessarily couples how you enforce the relation, namely, by fixing `y` based on `f` of an precomputed `x`.  You may do it eagerly, you may do it lazily, but you're still committed.  With Prolog you can leave variables unbound.  With bidirectional transformations \/ lenses you can update `x` from changing `y`.  And there are more possibilities.\n\nI've long been curious about decoupling relations over state from evaluation\/update mechanisms.\n\nBy the way Common Lisp's resumable exception handling mechanism is called the \"Condition System.\"",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "gae6d55db9d1",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3ae6d55db9d15b79bc683a8031fc2588.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0009-72.png",
            "first_name": "",
            "real_name": "William Taysom",
            "display_name": "wtaysom",
            "team": "T5TCAFTA9",
            "name": "wtaysom",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "attachments": [
            {
                "from_url": "https:\/\/www.youtube.com\/watch?v=Gel8ffr4pqw",
                "thumb_url": "https:\/\/i.ytimg.com\/vi\/Gel8ffr4pqw\/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"300\" src=\"https:\/\/www.youtube.com\/embed\/Gel8ffr4pqw?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen title=\"Convivial Computing Salon #4: Can Programmers Escape the Gentle Tyranny of call\/return?\"><\/iframe>",
                "video_html_width": 400,
                "video_html_height": 300,
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/youtube.png",
                "id": 1,
                "original_url": "https:\/\/www.youtube.com\/watch?v=Gel8ffr4pqw",
                "fallback": "YouTube Video: Convivial Computing Salon #4: Can Programmers Escape the Gentle Tyranny of call\/return?",
                "title": "Convivial Computing Salon #4: Can Programmers Escape the Gentle Tyranny of call\/return?",
                "title_link": "https:\/\/www.youtube.com\/watch?v=Gel8ffr4pqw",
                "author_name": "FluidProject",
                "author_link": "https:\/\/www.youtube.com\/@FluidProject",
                "service_name": "YouTube",
                "service_url": "https:\/\/www.youtube.com\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KRj\/H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Curious to learn more, I listened to "
                            },
                            {
                                "type": "user",
                                "user_id": "U017TE5R09M"
                            },
                            {
                                "type": "text",
                                "text": " over here "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/www.youtube.com\/watch?v=Gel8ffr4pqw"
                            },
                            {
                                "type": "text",
                                "text": ".  The Q&A has a few familiar faces.\n\nThe idea, as I understand it, is that we often want to connect bits of data "
                            },
                            {
                                "type": "text",
                                "text": "y = f(x)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " but call\/return unnecessarily couples how you enforce the relation, namely, by fixing "
                            },
                            {
                                "type": "text",
                                "text": "y",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " based on "
                            },
                            {
                                "type": "text",
                                "text": "f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of an precomputed "
                            },
                            {
                                "type": "text",
                                "text": "x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  You may do it eagerly, you may do it lazily, but you're still committed.  With Prolog you can leave variables unbound.  With bidirectional transformations \/ lenses you can update "
                            },
                            {
                                "type": "text",
                                "text": "x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " from changing "
                            },
                            {
                                "type": "text",
                                "text": "y",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  And there are more possibilities.\n\nI've long been curious about decoupling relations over state from evaluation\/update mechanisms.\n\nBy the way Common Lisp's resumable exception handling mechanism is called the \"Condition System.\""
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1675097023.539569",
        "client_msg_id": "c61f7ba5-4bb6-42c5-8421-c8725a834f6d",
        "text": "I apologize if I’ve made this sound too complicated...\n\n0D has been around for a long time.\n\nI didn’t invent it, I just drew a sloppy red circle around it and gave it a name that I like.\n\nEvery “concurrent” program needs, first, to be 0D.  UNIX pipes were invented in 1973 <https:\/\/en.wikipedia.org\/wiki\/Pipeline_(Unix)>.  Morrison invented Flow-Based Programming even earlier.  Processes and IPCs have been around for a long time. All are 0D at the core.\n\nAnonymous functions (the precursors to closures) were invented around 1956 (Lisp 1.5).  If there hadn’t been such a deep allergy to Lisp, it might have become obvious that “operating system processes” were just closures.\n\nOne of the first CPUs that I programmed, didn’t have a callstack.  You had to choose to implement CALL manually, or, choose to implement co-routines manually.  (BALR instruction, IIRC). Or, to do something more ad-hoc and less-structured.\n\nBasic 0D consists of putting a queue at the front of a closure and another queue at the back of the same closure.  Then, writing a wrapper that shepherds messages between queues. Stating the obvious - lists and callstacks are not queues. Recursion is not 0D.\n\nI will try to whip up an example in some example language ...",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1674396396.762359",
        "parent_user_id": "UGWUJUZHT",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a9e45",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I apologize if I’ve made this sound too complicated...\n\n0D has been around for a long time.\n\nI didn’t invent it, I just drew a sloppy red circle around it and gave it a name that I like.\n\nEvery “concurrent” program needs, first, to be 0D.  UNIX pipes were invented in 1973 "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Pipeline_(Unix)"
                            },
                            {
                                "type": "text",
                                "text": ".  Morrison invented Flow-Based Programming even earlier.  Processes and IPCs have been around for a long time. All are 0D at the core.\n\nAnonymous functions (the precursors to closures) were invented around 1956 (Lisp 1.5).  If there hadn’t been such a deep allergy to Lisp, it might have become obvious that “operating system processes” were just closures.\n\nOne of the first CPUs that I programmed, didn’t have a callstack.  You had to choose to implement CALL manually, or, choose to implement co-routines manually.  (BALR instruction, IIRC). Or, to do something more ad-hoc and less-structured.\n\nBasic 0D consists of putting a queue at the front of a closure and another queue at the back of the same closure.  Then, writing a wrapper that shepherds messages between queues. Stating the obvious - lists and callstacks are not queues. Recursion is not 0D.\n\nI will try to whip up an example in some example language ..."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]