[
    {
        "user": "USJSL2NVB",
        "type": "message",
        "ts": "1580674741.033000",
        "client_msg_id": "6199b693-96ce-4423-923a-932634c8fdac",
        "text": "Hi! Operon 0.5.0 is out, find it from <https:\/\/operon.io|https:\/\/operon.io> (Java-binary and pdf-booklet). It is also the first public release and I'm hoping for feedback on the most rudimentary things; did you get the queries running (if you had a chance to try)? What was your initial impression on the language? Did you encounter anything illogical or that you could consider as possible design flaw? I have not yet documented everything, so there's more to come on later releases. Also none of the components were yet released, so it is just the core that is out now. Love to hear back from you! :grin:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "g05e50ce40a3",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/05e50ce40a353aa043e7846eaa6745df.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0007-72.png",
            "first_name": "OperonGuy",
            "real_name": "OperonGuy",
            "display_name": "OperonGuy",
            "team": "T5TCAFTA9",
            "name": "tuomas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "title": "operon.io - Build things faster",
                "title_link": "https:\/\/operon.io\/",
                "text": "Operon is the state of the art JSON query, transformation and integration language.",
                "fallback": "operon.io - Build things faster",
                "from_url": "https:\/\/operon.io\/",
                "service_name": "operon.io",
                "id": 1,
                "original_url": "https:\/\/operon.io"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X9N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi! Operon 0.5.0 is out, find it from "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/operon.io",
                                "text": "https:\/\/operon.io"
                            },
                            {
                                "type": "text",
                                "text": " (Java-binary and pdf-booklet). It is also the first public release and I'm hoping for feedback on the most rudimentary things; did you get the queries running (if you had a chance to try)? What was your initial impression on the language? Did you encounter anything illogical or that you could consider as possible design flaw? I have not yet documented everything, so there's more to come on later releases. Also none of the components were yet released, so it is just the core that is out now. Love to hear back from you! "
                            },
                            {
                                "type": "emoji",
                                "name": "grin",
                                "unicode": "1f601"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UP6G25H35",
        "type": "message",
        "ts": "1580691203.033400",
        "client_msg_id": "1d7b260b-028c-43e3-bbae-2cb21d98d795",
        "text": "<@UC21F8Q48> <@UEQ6M68H0> - The calculator example in <http:\/\/ppig.org\/sites\/ppig.org\/files\/2017-PPIG-28th-lewis.pdf> is good. It is a good example of assessing value add using your end uses current solution. The end users current solution was algebraic notation. Most users would have been using algebraic notation, very few end users would have been using  Polish notation. The calculator offered a value add the end users current solution.\n\nI understand that end users could have learned polish notation, but the size of the value add would have been very small. As we know the size of the value add impacts innovation adoption. Working from a current end user solutions give a useful way of comparing different value adds.\n\nMicrosoft used to spend a lot of time debating innovations. They did not have a good way to assess value adds. But when they started to use current user solutions as a way to  assess different ideas, most of the debate stopped. This suggests that, despite the difficulty of assessing value adds, the method does work,",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "57dceb337de9",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-12\/870368572213_57dceb337de9d471d315_72.jpg",
            "first_name": "Eddy",
            "real_name": "Eddy Parkinson",
            "display_name": "Eddy Parkinson",
            "team": "T5TCAFTA9",
            "name": "eddyparkinson",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EET",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC21F8Q48"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " - The calculator example in "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/ppig.org\/sites\/ppig.org\/files\/2017-PPIG-28th-lewis.pdf"
                            },
                            {
                                "type": "text",
                                "text": " is good. It is a good example of assessing value add using your end uses current solution. The end users current solution was algebraic notation. Most users would have been using algebraic notation, very few end users would have been using  Polish notation. The calculator offered a value add the end users current solution.\n\nI understand that end users could have learned polish notation, but the size of the value add would have been very small. As we know the size of the value add impacts innovation adoption. Working from a current end user solutions give a useful way of comparing different value adds.\n\nMicrosoft used to spend a lot of time debating innovations. They did not have a good way to assess value adds. But when they started to use current user solutions as a way to  assess different ideas, most of the debate stopped. This suggests that, despite the difficulty of assessing value adds, the method does work,"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1580709547.033600",
        "client_msg_id": "6a14b6e7-cb5a-4ae3-8c8b-14dfa5e99327",
        "text": "Microsoft had a very different philosophy than Apple. MS used Wizards extensively in both the OS and in their Apps. It is still true to this day. Apple would just dump you into a document and give you a tool palette, because they would try to simplify the process to fewer steps, and reduce the number of options. Sometimes Apple would strip away features that gave more customization, but MS would typically have more features, and organize the process into a multi-screen system. MS was shooting for a larger audience (appropriate given their 90%+ marketshare), and i think it worked pretty well. Interestingly, i don't see a lot of guided wizard programming tools in the FoC project lists. Almost all of the node and wire tools give you a blank screen, and don't walk you through it. I think there is an unconscious expectation that some kind of guiding wizard will appear for programming.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Om\/Pr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Microsoft had a very different philosophy than Apple. MS used Wizards extensively in both the OS and in their Apps. It is still true to this day. Apple would just dump you into a document and give you a tool palette, because they would try to simplify the process to fewer steps, and reduce the number of options. Sometimes Apple would strip away features that gave more customization, but MS would typically have more features, and organize the process into a multi-screen system. MS was shooting for a larger audience (appropriate given their 90%+ marketshare), and i think it worked pretty well. Interestingly, i don't see a lot of guided wizard programming tools in the FoC project lists. Almost all of the node and wire tools give you a blank screen, and don't walk you through it. I think there is an unconscious expectation that some kind of guiding wizard will appear for programming."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1580710310.033800",
        "client_msg_id": "ea102cb1-34a0-4b19-9427-83bc16358605",
        "text": "As for why RPN has all but disappeared from calculators, RPN was designed around the limitations of the HP calculator keyboard, which did not have sufficient keys to devote to parentheses characters. The HP calculator had a 4 level deep register stack, and operations like 2 3 4 + * would add 3 and 4 then multiply by 2. This chaining operation allows you to store intermediate results without having to name them, which would also require buttons to store\/retrieve temporary results. Basically RPN was a compromise caused by hardware limitations of the day, and a wish to use fewer keystrokes for the operations of entering programs, as stored programs was the \"power feature\" of the HP calculator that made it so revolutionary. Once you add an alphabetic keyboard and can name variables, you are way beyond HP's simplistic language.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pkYm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As for why RPN has all but disappeared from calculators, RPN was designed around the limitations of the HP calculator keyboard, which did not have sufficient keys to devote to parentheses characters. The HP calculator had a 4 level deep register stack, and operations like 2 3 4 + * would add 3 and 4 then multiply by 2. This chaining operation allows you to store intermediate results without having to name them, which would also require buttons to store\/retrieve temporary results. Basically RPN was a compromise caused by hardware limitations of the day, and a wish to use fewer keystrokes for the operations of entering programs, as stored programs was the \"power feature\" of the HP calculator that made it so revolutionary. Once you add an alphabetic keyboard and can name variables, you are way beyond HP's simplistic language."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UP6G25H35"
                ],
                "count": 1
            }
        ]
    },
    {
        "text": "HP keyboard",
        "files": [
            {
                "id": "FTEULT2MS",
                "mode": "tombstone"
            }
        ],
        "upload": true,
        "user": "UEQ6M68H0",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o5a",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "HP keyboard"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1580710322.034000",
        "client_msg_id": "6f584560-57bd-4d40-938e-32d756a57bbf",
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UP6G25H35"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UEQ6M68H0",
        "type": "message",
        "ts": "1580710779.034400",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1580711233.000000"
        },
        "client_msg_id": "b6d69e9b-b0cb-4c97-a2bb-2bd3d5447707",
        "text": "by adding twice as many buttons (and using each button 3 times via 2 different SHIFT keys), TI blew HP out of the market with easier programming, and larger feature set. RPN is like FORTH; once you know it, it is actually preferable as it is elegant, not needing parentheses; but it requires more mental gymnastics to be performed. So it isn't hard to imagine the unwashed masses loving TI.  Interestingly PostScript also uses RPN.  And one can see that PostScript is not used much as an explicit programming language today, so one could say that the public has voted with their feet, and rejected RPN as requiring too much short term memory, as one cannot read RPN code unless you mentally track what is on the stack. FORTRAN\/Algol wins again, because it more closely matches traditional algebraic notation.  One can also say that the programming public has rejected excessive parenthetical notations like LISP uses. I believe it is also rejecting syntaxes that require the reader to know how many arguments are used by a function. There are some languages where you say func x y z but you don't know how many are going to be absorbed by the function. This implies memorization of each functions argument list number; that is a burden for those in the audience that cannot easily remember arbitrary things like parameter lists.  How much one has to memorize to program in a language is a major factor in usability. In some languages like Java, there is a staggering burden related to the API's that are available. Just knowing which of the 10,000 API library routines you could call is probably the largest area sub-section in its learning curve.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "326328f75c3f",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-02-05\/542651515888_326328f75c3f2a08544c_72.jpg",
            "first_name": "Edward",
            "real_name": "Edward de Jong",
            "display_name": "Edward de Jong \/ Beads Project",
            "team": "T5TCAFTA9",
            "name": "magicmouse94937",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hrf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "by adding twice as many buttons (and using each button 3 times via 2 different SHIFT keys), TI blew HP out of the market with easier programming, and larger feature set. RPN is like FORTH; once you know it, it is actually preferable as it is elegant, not needing parentheses; but it requires more mental gymnastics to be performed. So it isn't hard to imagine the unwashed masses loving TI.  Interestingly PostScript also uses RPN.  And one can see that PostScript is not used much as an explicit programming language today, so one could say that the public has voted with their feet, and rejected RPN as requiring too much short term memory, as one cannot read RPN code unless you mentally track what is on the stack. FORTRAN\/Algol wins again, because it more closely matches traditional algebraic notation.  One can also say that the programming public has rejected excessive parenthetical notations like LISP uses. I believe it is also rejecting syntaxes that require the reader to know how many arguments are used by a function. There are some languages where you say func x y z but you don't know how many are going to be absorbed by the function. This implies memorization of each functions argument list number; that is a burden for those in the audience that cannot easily remember arbitrary things like parameter lists.  How much one has to memorize to program in a language is a major factor in usability. In some languages like Java, there is a staggering burden related to the API's that are available. Just knowing which of the 10,000 API library routines you could call is probably the largest area sub-section in its learning curve."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]