[
    {
        "user": "UGWUJUZHT",
        "type": "message",
        "ts": "1685573969.099099",
        "client_msg_id": "4adca6fc-1837-4a43-89d6-2404d4b9a556",
        "text": "I think we need many different little languages and a substrate “language” (kernel) to bolt them all together.\n\nNote that, in electronics, there is\/was something called “design rules” which is something more-than-type. In web-site design, one uses “input validation” which is like type-checking but on a very per-project basis. It would be nice to be able to bolt design-rule checkers together using a palette of existing components. Again, it seems that one should want a palette of components to help build up design rule checkers and completely different palette of components to build up actions. I would expect to use different “syntaxes” for each concern and would expect to use IDE layers to deal with each kind of issue separately then let the IDE automagically stitch them together. This is just another way of saying “I would like to use a different language (SCN in my words) to deal with each kind of issue”. Would I use text-based SCNs exclusively? No. But, for text-based SCNs, I would use Ohm-JS and for diagrammatic SCNs I would start by using <http:\/\/draw.io|draw.io>. Both kinds of syntaxes are “easy” now, so there is no reason not to build project-specific SCNs. We have been indoctrinated to believe that “one language to rule them all” GPLs is the way to go. I don’t agree.\n\nduplicated in <https:\/\/publish.obsidian.md\/programmingsimplicity\/2023-05-31-Bolting+Little+Languages+Together>",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "41a8bada7812",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-06\/4754627914258_41a8bada781281751d07_72.jpg",
            "first_name": "",
            "real_name": "Paul Tarvydas",
            "display_name": "guitarvydas",
            "team": "T5TCAFTA9",
            "name": "paultarvydas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1685573969.099099",
        "reply_count": 7,
        "reply_users_count": 4,
        "latest_reply": "1686644051.076979",
        "reply_users": [
            "U0378MDUG1Y",
            "UJBAJNFLK",
            "UGWUJUZHT",
            "U04E5QAD6DD"
        ],
        "replies": [
            {
                "user": "U0378MDUG1Y",
                "ts": "1685685323.229319"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1685705593.557489"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1685707055.622149"
            },
            {
                "user": "UJBAJNFLK",
                "ts": "1685714421.153329"
            },
            {
                "user": "U04E5QAD6DD",
                "ts": "1685793434.770809"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1686573995.019319"
            },
            {
                "user": "UGWUJUZHT",
                "ts": "1686644051.076979"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xOiE=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think we need many different little languages and a substrate “language” (kernel) to bolt them all together.\n\nNote that, in electronics, there is\/was something called “design rules” which is something more-than-type. In web-site design, one uses “input validation” which is like type-checking but on a very per-project basis. It would be nice to be able to bolt design-rule checkers together using a palette of existing components. Again, it seems that one should want a palette of components to help build up design rule checkers and completely different palette of components to build up actions. I would expect to use different “syntaxes” for each concern and would expect to use IDE layers to deal with each kind of issue separately then let the IDE automagically stitch them together. This is just another way of saying “I would like to use a different language (SCN in my words) to deal with each kind of issue”. Would I use text-based SCNs exclusively? No. But, for text-based SCNs, I would use Ohm-JS and for diagrammatic SCNs I would start by using "
                            },
                            {
                                "type": "link",
                                "url": "http:\/\/draw.io",
                                "text": "draw.io"
                            },
                            {
                                "type": "text",
                                "text": ". Both kinds of syntaxes are “easy” now, so there is no reason not to build project-specific SCNs. We have been indoctrinated to believe that “one language to rule them all” GPLs is the way to go. I don’t agree.\n\nduplicated in "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/publish.obsidian.md\/programmingsimplicity\/2023-05-31-Bolting+Little+Languages+Together"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "fire",
                "users": [
                    "U04KZ8A9WCT"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "U04KZ8A9WCT"
                ],
                "count": 1
            }
        ]
    }
]