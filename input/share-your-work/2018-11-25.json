[
    {
        "user": "UAL7940NM",
        "type": "message",
        "ts": "1543135401.071400",
        "client_msg_id": "f146aefd-258a-4530-8c8e-6532e52524a7",
        "text": "<@UCUSW7WVD> I agree. The problem I see with forking is that even if you want just a tiny change, you need to fork the whole project and then need to maintain it \/ update it yourself. What if forking could be done in a more fine-grained manner (e.g. on a per-function basis)? I think that this could make maintaining forks easier and prevent them drifting apart until they cannot be reunited anymore.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43873346f949",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-13\/399377633206_43873346f949174e340e_72.jpg",
            "first_name": "Felix",
            "real_name": "Felix Kohlgrüber",
            "display_name": "Felix Kohlgrüber",
            "team": "T5TCAFTA9",
            "name": "felix.kohlgrueber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543012054.056800",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qhF8l",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I agree. The problem I see with forking is that even if you want just a tiny change, you need to fork the whole project and then need to maintain it \/ update it yourself. What if forking could be done in a more fine-grained manner (e.g. on a per-function basis)? I think that this could make maintaining forks easier and prevent them drifting apart until they cannot be reunited anymore."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1543149344.071600",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1543149553.000000"
        },
        "client_msg_id": "0b6e1b37-70b9-420c-a3eb-a36f394d4949",
        "text": "Great question! I'm not sure here, and we need a lot more experimentation, but my current sense is that encouraging forking will tend to create larger units of deployment, not smaller ones. While it increases the effort of creating a fork and may be more inefficient in resource usage as you point out, it actually simplifies _selecting_ and _using_ forks. In the limit, putting together a system becomes a problem of just choosing from N forks of the whole system, rather than choosing from M^N combinations of forks (one per function). Because many combinations will be broken, some very subtly so. Treating the whole system as a unit of forking lets a group with shared usage patterns collaborate on a common system, ironing out issues for each other. Problems become internal rather than external, which seems the preferable kind of problem to have.\n\nBut perhaps I'm being insufficiently radical and just unwilling to make the larger conceptual leap :slightly_smiling_face: Maybe we should learn more about the theory for segmenting consumers into markets. Right now we have a handful of consumer segments when it comes to software, called _Linux_, _Windows_, etc. The small number isn't sufficiently addressing people's needs. The question is what's the sweet spot.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543012054.056800",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "caX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great question! I'm not sure here, and we need a lot more experimentation, but my current sense is that encouraging forking will tend to create larger units of deployment, not smaller ones. While it increases the effort of creating a fork and may be more inefficient in resource usage as you point out, it actually simplifies "
                            },
                            {
                                "type": "text",
                                "text": "selecting",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "using",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " forks. In the limit, putting together a system becomes a problem of just choosing from N forks of the whole system, rather than choosing from M^N combinations of forks (one per function). Because many combinations will be broken, some very subtly so. Treating the whole system as a unit of forking lets a group with shared usage patterns collaborate on a common system, ironing out issues for each other. Problems become internal rather than external, which seems the preferable kind of problem to have.\n\nBut perhaps I'm being insufficiently radical and just unwilling to make the larger conceptual leap "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " Maybe we should learn more about the theory for segmenting consumers into markets. Right now we have a handful of consumer segments when it comes to software, called "
                            },
                            {
                                "type": "text",
                                "text": "Linux",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "Windows",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", etc. The small number isn't sufficiently addressing people's needs. The question is what's the sweet spot."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAL7940NM",
        "type": "message",
        "ts": "1543161718.071900",
        "client_msg_id": "b2c27df4-e30e-42be-8bd9-4e976aaba94c",
        "text": "Ah I see where you're going. That's interesting and I didn't think in that direction. It might really depend on how similar usage patterns in a project \/ community are.\nIf you think about data visualization in Python for example, there are dozens of libraries that all create plots in slightly different ways. Most of them are incompatible to each other, and common features have to be implemented individually by each project. That's a waste of effort and I'm not sure whether it's necessary.\nYou're right that smaller projects might make forming communities more difficult \/ scattered. That's a human factor that might have a larger influence than I thought.\nThe most radical thing would be to not make any individual projects at all. I think I've said that before on this slack, but I find Wikipedia's approach interesting. It's just one large community that incrementally improves and extends the knowledge of the system. Because there are no individually-owned projects, it would be easy to identify and refactor duplications etc. Having one large community wouldn't mean that everyone has to understand everything, but it might encourage documenting knowledge about a system such that it's approachable and compatible.\nOne important difference is of course that other than text, code breaks easily by incompatible changes. I wonder if this could be improved by using tests to decide whether a change is breaking anything and then requiring a manual update. This could prevent non-popular code from breaking by accident.\nI don't know what's going to work out. I think that smaller projects \/ forks allow better reuse, and larger projects \/ forks might be easier to collaborate on. I'm looking forward to discuss this further :wink:",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43873346f949",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-13\/399377633206_43873346f949174e340e_72.jpg",
            "first_name": "Felix",
            "real_name": "Felix Kohlgrüber",
            "display_name": "Felix Kohlgrüber",
            "team": "T5TCAFTA9",
            "name": "felix.kohlgrueber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543012054.056800",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f8w",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah I see where you're going. That's interesting and I didn't think in that direction. It might really depend on how similar usage patterns in a project \/ community are.\nIf you think about data visualization in Python for example, there are dozens of libraries that all create plots in slightly different ways. Most of them are incompatible to each other, and common features have to be implemented individually by each project. That's a waste of effort and I'm not sure whether it's necessary.\nYou're right that smaller projects might make forming communities more difficult \/ scattered. That's a human factor that might have a larger influence than I thought.\nThe most radical thing would be to not make any individual projects at all. I think I've said that before on this slack, but I find Wikipedia's approach interesting. It's just one large community that incrementally improves and extends the knowledge of the system. Because there are no individually-owned projects, it would be easy to identify and refactor duplications etc. Having one large community wouldn't mean that everyone has to understand everything, but it might encourage documenting knowledge about a system such that it's approachable and compatible.\nOne important difference is of course that other than text, code breaks easily by incompatible changes. I wonder if this could be improved by using tests to decide whether a change is breaking anything and then requiring a manual update. This could prevent non-popular code from breaking by accident.\nI don't know what's going to work out. I think that smaller projects \/ forks allow better reuse, and larger projects \/ forks might be easier to collaborate on. I'm looking forward to discuss this further "
                            },
                            {
                                "type": "emoji",
                                "name": "wink",
                                "unicode": "1f609"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UDJ2TKB99",
        "type": "message",
        "ts": "1543183104.072100",
        "client_msg_id": "19ef40fe-f2c1-4328-822d-c067111e4c72",
        "text": "Just a quick comment to say that I enjoyed the discussion, especially Kartik's idea that failure of knowledge transfer is one of the big factors in making our systems worse as the individuals constituting an organization swap out. (And I also love Vinge's programmer-archeologists.)",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "7acd71947ea2",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-10-04\/2564854327154_7acd71947ea203e9a69b_72.jpg",
            "first_name": "Joe",
            "real_name": "Joe Trellick",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "joe",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543012054.056800",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RPO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Just a quick comment to say that I enjoyed the discussion, especially Kartik's idea that failure of knowledge transfer is one of the big factors in making our systems worse as the individuals constituting an organization swap out. (And I also love Vinge's programmer-archeologists.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UAL7940NM",
                    "U8A5MS6R1"
                ],
                "count": 3
            }
        ]
    },
    {
        "user": "UCUSW7WVD",
        "type": "message",
        "ts": "1543184201.072400",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1543184337.000000"
        },
        "client_msg_id": "8535f941-682f-43e3-8734-9409206d7af9",
        "text": "<@UDJ2TKB99> Yeah, I'm a lot less certain of my ideas for solutions (which I didn't get to in this episode), but I'd like people to think a lot harder about the entire life cycle of a software project, including what happens when new people start contributing.\n\n<@UBAP530VB> I'm still thinking about your comment. Basically I'm observing that while we think of interfaces as separating two people, they often have a single _user_ on both sides. And as users our laptops have not just one interface but a honeycomb of interfaces. One way to see my proposal is as a call for more Apple-like integration, where somebody takes charge of the entire stack and makes sure it works well together. However, this is even harder than Apple's case, because Apple focuses only on the exterior\/interface of things, whereas the goal here is hackability, for internals to be easy to understand as well. It's pretty much prohibitive to do in a centralized way. All my other ideas kinda stem from this constraint.\n\n<@UAL7940NM> Provocative thoughts. A couple of off-the-cuff reactions:\n\na) Different levels of the stack already work pretty differently. My old laptop has the same Ubuntu distro for six years now, and I can compile Vim from 1997 on it. On the other hand the Rails\/Node eco-systems and Chrome are constantly introducing breaking changes. Upper levels seem to have different trade-offs, and that will probably be the same in my ideal world as well.\n\nb) I'm not concerned so much with avoiding breakage as making breakage easy for end users to recover from.\n\nc) Larger projects can be just as easy to collaborate on. Are you seeing any particular areas where they're at a disadvantage? For example, our recent virtualization advances (VMs, jails, containers, etc.) make it easy to try out a new 'version' of one's laptop before committing to it.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "6e649a383cf8",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-07-14\/687915485201_6e649a383cf8f9e366e3_72.png",
            "first_name": "Kartik",
            "real_name": "Kartik Agaram",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "ak",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543012054.056800",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Agjq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDJ2TKB99"
                            },
                            {
                                "type": "text",
                                "text": " Yeah, I'm a lot less certain of my ideas for solutions (which I didn't get to in this episode), but I'd like people to think a lot harder about the entire life cycle of a software project, including what happens when new people start contributing.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UBAP530VB"
                            },
                            {
                                "type": "text",
                                "text": " I'm still thinking about your comment. Basically I'm observing that while we think of interfaces as separating two people, they often have a single "
                            },
                            {
                                "type": "text",
                                "text": "user",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " on both sides. And as users our laptops have not just one interface but a honeycomb of interfaces. One way to see my proposal is as a call for more Apple-like integration, where somebody takes charge of the entire stack and makes sure it works well together. However, this is even harder than Apple's case, because Apple focuses only on the exterior\/interface of things, whereas the goal here is hackability, for internals to be easy to understand as well. It's pretty much prohibitive to do in a centralized way. All my other ideas kinda stem from this constraint.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UAL7940NM"
                            },
                            {
                                "type": "text",
                                "text": " Provocative thoughts. A couple of off-the-cuff reactions:\n\na) Different levels of the stack already work pretty differently. My old laptop has the same Ubuntu distro for six years now, and I can compile Vim from 1997 on it. On the other hand the Rails\/Node eco-systems and Chrome are constantly introducing breaking changes. Upper levels seem to have different trade-offs, and that will probably be the same in my ideal world as well.\n\nb) I'm not concerned so much with avoiding breakage as making breakage easy for end users to recover from.\n\nc) Larger projects can be just as easy to collaborate on. Are you seeing any particular areas where they're at a disadvantage? For example, our recent virtualization advances (VMs, jails, containers, etc.) make it easy to try out a new 'version' of one's laptop before committing to it."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UAL7940NM",
        "type": "message",
        "ts": "1543185808.072900",
        "client_msg_id": "ed0e4a9a-d032-4dd3-86c9-8325b0e7ea2d",
        "text": "Not sure I understood b), could you elaborate?\nFor c), I actually wanted to say that larger projects are easier to collaborate on than really small ones, agreeing with what you've said before. Larger projects -&gt; Fewer projects -&gt; More people working on the same project.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "43873346f949",
            "image_72": "https:\/\/avatars.slack-edge.com\/2018-07-13\/399377633206_43873346f949174e340e_72.jpg",
            "first_name": "Felix",
            "real_name": "Felix Kohlgrüber",
            "display_name": "Felix Kohlgrüber",
            "team": "T5TCAFTA9",
            "name": "felix.kohlgrueber",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543012054.056800",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/Qwxa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not sure I understood b), could you elaborate?\nFor c), I actually wanted to say that larger projects are easier to collaborate on than really small ones, agreeing with what you've said before. Larger projects -> Fewer projects -> More people working on the same project."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "UCKRZS3DZ",
        "type": "message",
        "ts": "1543214939.073400",
        "client_msg_id": "c4a85ea2-4c63-46b3-8914-59e17cb5cbcc",
        "text": "&gt; especially Kartik's idea that failure of knowledge transfer is one of the big factors in making our systems worse as the individuals constituting an organization swap out\n\nSo when people develop a system they form an image of the system in their head, how it supposed to work. They leave bits of this knowledge in names of the variables and functions, in brief comments. But they don't dump this kind of knowledge into documentation -- for some reason it's very inconvenient and slow. Then they leave, and next people need to rebuild this image of the system again, from little leftover artifacts: names of variables and functions, brief comments, outdated documentation.\n\nWhat if there was a tool that provided convenient space to describe image of the system? From which parts it consists of, what parts should never communicate, what parts should never depend on each other. Something like knowledge system or structured documentation. Textual documentation is generated from this thing.\n\nCode can be checked against constraints described in this kind of structured documentation. This allows to keep it up to date.",
        "team": "T5TCAFTA9",
        "user_team": "T5TCAFTA9",
        "source_team": "T5TCAFTA9",
        "user_profile": {
            "avatar_hash": "222a2870915d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-12-15\/861537614034_222a2870915d24ec10cc_72.jpg",
            "first_name": "Vladimir",
            "real_name": "Vladimir Gordeev",
            "display_name": "",
            "team": "T5TCAFTA9",
            "name": "gordeev.vladimir.v",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1543012054.056800",
        "parent_user_id": "U5TCAFTD3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eqw",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "especially Kartik's idea that failure of knowledge transfer is one of the big factors in making our systems worse as the individuals constituting an organization swap out"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nSo when people develop a system they form an image of the system in their head, how it supposed to work. They leave bits of this knowledge in names of the variables and functions, in brief comments. But they don't dump this kind of knowledge into documentation -- for some reason it's very inconvenient and slow. Then they leave, and next people need to rebuild this image of the system again, from little leftover artifacts: names of variables and functions, brief comments, outdated documentation.\n\nWhat if there was a tool that provided convenient space to describe image of the system? From which parts it consists of, what parts should never communicate, what parts should never depend on each other. Something like knowledge system or structured documentation. Textual documentation is generated from this thing.\n\nCode can be checked against constraints described in this kind of structured documentation. This allows to keep it up to date."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]